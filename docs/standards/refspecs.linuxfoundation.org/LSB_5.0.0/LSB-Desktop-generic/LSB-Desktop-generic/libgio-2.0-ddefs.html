<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Data Definitions for libgio-2.0</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Linux Standard Base Desktop Specification, Generic Part"
HREF="book1.html"><LINK
REL="UP"
TITLE="Libraries"
HREF="gtk.html"><LINK
REL="PREVIOUS"
TITLE="Interfaces for libgio-2.0"
HREF="libgio-2.0.html"><LINK
REL="NEXT"
TITLE="Interface Definitions for libgio-2.0"
HREF="libgio-2.0man.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Standard Base Desktop Specification, Generic Part</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="libgio-2.0.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 17. Libraries</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="libgio-2.0man.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBGIO-2.0-DDEFS"
>17.12. Data Definitions for libgio-2.0</A
></H1
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libgio-2.0.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="normativerefs.html#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40879"
>17.12.1. gio-unix-2.0/gio/gdesktopappinfo.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DESKTOP_APP_INFO	(g_desktop_app_info_get_type ())
#define G_TYPE_DESKTOP_APP_INFO_LOOKUP	(g_desktop_app_info_lookup_get_type ())	/* DEPRECATED */
#define G_DESKTOP_APP_INFO_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfoClass))
#define G_IS_DESKTOP_APP_INFO_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DESKTOP_APP_INFO))
#define G_DESKTOP_APP_INFO(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfo))
#define G_DESKTOP_APP_INFO_LOOKUP(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP, GDesktopAppInfoLookup))	/* DEPRECATED */
#define G_IS_DESKTOP_APP_INFO(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DESKTOP_APP_INFO))
#define G_IS_DESKTOP_APP_INFO_LOOKUP(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP))	/* DEPRECATED */
#define G_DESKTOP_APP_INFO_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DESKTOP_APP_INFO, GDesktopAppInfoClass))
#define G_DESKTOP_APP_INFO_LOOKUP_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DESKTOP_APP_INFO_LOOKUP, GDesktopAppInfoLookupIface))	/* DEPRECATED */
#define G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME	"gio-desktop-app-info-lookup"	/* DEPRECATED */

typedef struct _GDesktopAppInfo GDesktopAppInfo;
typedef struct _GDesktopAppInfoClass {
    GObjectClass parent_class;
} GDesktopAppInfoClass;
typedef struct _GDesktopAppInfoLookup GDesktopAppInfoLookup;
typedef struct _GDesktopAppInfoLookupIface {
    GTypeInterface g_iface;
    GAppInfo *(*get_default_for_uri_scheme) (GDesktopAppInfoLookup *
					     lookup,
					     const char *uri_scheme);
} GDesktopAppInfoLookupIface;
typedef void (*GDesktopAppLaunchCallback) (GDesktopAppInfo * appinfo,
					   GPid pid, gpointer user_data);
extern const char *g_desktop_app_info_get_categories(GDesktopAppInfo *
						     info);
extern const char *g_desktop_app_info_get_filename(GDesktopAppInfo * info);
extern const char *g_desktop_app_info_get_generic_name(GDesktopAppInfo *
						       info);
extern gboolean g_desktop_app_info_get_is_hidden(GDesktopAppInfo * info);
extern const char *const *g_desktop_app_info_get_keywords(GDesktopAppInfo *
							  info);
extern gboolean g_desktop_app_info_get_nodisplay(GDesktopAppInfo * info);
extern gboolean g_desktop_app_info_get_show_in(GDesktopAppInfo * info,
					       const char *desktop_env);
extern GType g_desktop_app_info_get_type(void);
extern gboolean g_desktop_app_info_launch_uris_as_manager(GDesktopAppInfo *
							  appinfo,
							  GList * uris,
							  GAppLaunchContext
							  * launch_context,
							  GSpawnFlags
							  spawn_flags,
							  GSpawnChildSetupFunc
							  user_setup,
							  gpointer
							  user_setup_data,
							  GDesktopAppLaunchCallback
							  pid_callback,
							  gpointer
							  pid_callback_data,
							  GError * *error);
extern GAppInfo
    *g_desktop_app_info_lookup_get_default_for_uri_scheme
    (GDesktopAppInfoLookup * lookup, const char *uri_scheme);
extern GType g_desktop_app_info_lookup_get_type(void);
extern GDesktopAppInfo *g_desktop_app_info_new(const char *desktop_id);
extern GDesktopAppInfo *g_desktop_app_info_new_from_filename(const char
							     *filename);
extern GDesktopAppInfo *g_desktop_app_info_new_from_keyfile(GKeyFile *
							    key_file);
extern void g_desktop_app_info_set_desktop_env(const char *desktop_env);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40883"
>17.12.2. gio-unix-2.0/gio/gfiledescriptorbased.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_DESCRIPTOR_BASED	(g_file_descriptor_based_get_type ())
#define G_FILE_DESCRIPTOR_BASED(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_FILE_DESCRIPTOR_BASED, GFileDescriptorBased))
#define G_IS_FILE_DESCRIPTOR_BASED(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_FILE_DESCRIPTOR_BASED))
#define G_FILE_DESCRIPTOR_BASED_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_FILE_DESCRIPTOR_BASED, GFileDescriptorBasedIface))

typedef struct _GFileDescriptorBasedIface {
    GTypeInterface g_iface;
    int (*get_fd) (GFileDescriptorBased * fd_based);
} GFileDescriptorBasedIface;
extern int g_file_descriptor_based_get_fd(GFileDescriptorBased * fd_based);
extern GType g_file_descriptor_based_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40887"
>17.12.3. gio-unix-2.0/gio/gunixconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_UNIX_CONNECTION, GUnixConnectionClass))
#define G_IS_UNIX_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_UNIX_CONNECTION))
#define G_UNIX_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_UNIX_CONNECTION, GUnixConnection))
#define G_IS_UNIX_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_UNIX_CONNECTION))
#define G_UNIX_CONNECTION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_UNIX_CONNECTION, GUnixConnectionClass))
#define G_TYPE_UNIX_CONNECTION	(g_unix_connection_get_type ())

typedef struct _GUnixConnection {
    GSocketConnection parent_instance;
    GUnixConnectionPrivate *priv;
} GUnixConnection;
typedef struct _GUnixConnectionPrivate GUnixConnectionPrivate;
typedef struct _GUnixConnectionClass {
    GSocketConnectionClass parent_class;
} GUnixConnectionClass;
extern GType g_unix_connection_get_type(void);
extern GCredentials *g_unix_connection_receive_credentials(GUnixConnection
							   * connection,
							   GCancellable *
							   cancellable,
							   GError *
							   *error);
extern void g_unix_connection_receive_credentials_async(GUnixConnection *
							connection,
							GCancellable *
							cancellable,
							GAsyncReadyCallback
							callback,
							gpointer
							user_data);
extern GCredentials
    *g_unix_connection_receive_credentials_finish(GUnixConnection *
						  connection,
						  GAsyncResult * result,
						  GError * *error);
extern gint g_unix_connection_receive_fd(GUnixConnection * connection,
					 GCancellable * cancellable,
					 GError * *error);
extern gboolean g_unix_connection_send_credentials(GUnixConnection *
						   connection,
						   GCancellable *
						   cancellable,
						   GError * *error);
extern void g_unix_connection_send_credentials_async(GUnixConnection *
						     connection,
						     GCancellable *
						     cancellable,
						     GAsyncReadyCallback
						     callback,
						     gpointer user_data);
extern gboolean g_unix_connection_send_credentials_finish(GUnixConnection *
							  connection,
							  GAsyncResult *
							  result,
							  GError * *error);
extern gboolean g_unix_connection_send_fd(GUnixConnection * connection,
					  gint fd,
					  GCancellable * cancellable,
					  GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40891"
>17.12.4. gio-unix-2.0/gio/gunixcredentialsmessage.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_CREDENTIALS_MESSAGE_CLASS(c)	(G_TYPE_CHECK_CLASS_CAST ((c), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass))
#define G_IS_UNIX_CREDENTIALS_MESSAGE_CLASS(c)	(G_TYPE_CHECK_CLASS_TYPE ((c), G_TYPE_UNIX_CREDENTIALS_MESSAGE))
#define G_UNIX_CREDENTIALS_MESSAGE(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessage))
#define G_IS_UNIX_CREDENTIALS_MESSAGE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE))
#define G_UNIX_CREDENTIALS_MESSAGE_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass))
#define G_TYPE_UNIX_CREDENTIALS_MESSAGE	(g_unix_credentials_message_get_type ())

typedef struct _GUnixCredentialsMessagePrivate
    GUnixCredentialsMessagePrivate;
typedef struct _GUnixCredentialsMessageClass {
    GSocketControlMessageClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
} GUnixCredentialsMessageClass;
struct _GUnixCredentialsMessage {
    GSocketControlMessage parent_instance;
    GUnixCredentialsMessagePrivate *priv;
};
extern GCredentials
    *g_unix_credentials_message_get_credentials(GUnixCredentialsMessage *
						message);
extern GType g_unix_credentials_message_get_type(void);
extern gboolean g_unix_credentials_message_is_supported(void);
extern GSocketControlMessage *g_unix_credentials_message_new(void);
extern GSocketControlMessage
    *g_unix_credentials_message_new_with_credentials(GCredentials *
						     credentials);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40895"
>17.12.5. gio-unix-2.0/gio/gunixfdlist.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_FD_LIST_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_UNIX_FD_LIST, GUnixFDListClass))
#define G_IS_UNIX_FD_LIST_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_UNIX_FD_LIST))
#define G_UNIX_FD_LIST(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_UNIX_FD_LIST, GUnixFDList))
#define G_IS_UNIX_FD_LIST(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_UNIX_FD_LIST))
#define G_UNIX_FD_LIST_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_UNIX_FD_LIST, GUnixFDListClass))
#define G_TYPE_UNIX_FD_LIST	(g_unix_fd_list_get_type ())

typedef struct _GUnixFDListPrivate GUnixFDListPrivate;
typedef struct _GUnixFDListClass {
    GObjectClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GUnixFDListClass;
struct _GUnixFDList {
    GObject parent_instance;
    GUnixFDListPrivate *priv;
};
extern gint g_unix_fd_list_append(GUnixFDList * list, gint fd,
				  GError * *error);
extern gint g_unix_fd_list_get(GUnixFDList * list, gint index_,
			       GError * *error);
extern gint g_unix_fd_list_get_length(GUnixFDList * list);
extern GType g_unix_fd_list_get_type(void);
extern GUnixFDList *g_unix_fd_list_new(void);
extern GUnixFDList *g_unix_fd_list_new_from_array(const int *fds,
						  gint n_fds);
extern const int *g_unix_fd_list_peek_fds(GUnixFDList * list,
					  gint * length);
extern gint *g_unix_fd_list_steal_fds(GUnixFDList * list, gint * length);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40899"
>17.12.6. gio-unix-2.0/gio/gunixfdmessage.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_FD_MESSAGE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessageClass))
#define G_IS_UNIX_FD_MESSAGE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_UNIX_FD_MESSAGE))
#define G_UNIX_FD_MESSAGE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessage))
#define G_IS_UNIX_FD_MESSAGE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_UNIX_FD_MESSAGE))
#define G_UNIX_FD_MESSAGE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_UNIX_FD_MESSAGE, GUnixFDMessageClass))
#define G_TYPE_UNIX_FD_MESSAGE	(g_unix_fd_message_get_type ())

typedef struct _GUnixFDMessagePrivate GUnixFDMessagePrivate;
typedef struct _GUnixFDMessageClass {
    GSocketControlMessageClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
} GUnixFDMessageClass;
typedef struct _GUnixFDMessage {
    GSocketControlMessage parent_instance;
    GUnixFDMessagePrivate *priv;
} GUnixFDMessage;
extern gboolean g_unix_fd_message_append_fd(GUnixFDMessage * message,
					    gint fd, GError * *error);
extern GUnixFDList *g_unix_fd_message_get_fd_list(GUnixFDMessage *
						  message);
extern GType g_unix_fd_message_get_type(void);
extern GSocketControlMessage *g_unix_fd_message_new(void);
extern GSocketControlMessage
    *g_unix_fd_message_new_with_fd_list(GUnixFDList * fd_list);
extern gint *g_unix_fd_message_steal_fds(GUnixFDMessage * message,
					 gint * length);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40903"
>17.12.7. gio-unix-2.0/gio/gunixinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStreamClass))
#define G_IS_UNIX_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_INPUT_STREAM))
#define G_UNIX_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStream))
#define G_IS_UNIX_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_INPUT_STREAM))
#define G_UNIX_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_INPUT_STREAM, GUnixInputStreamClass))
#define G_TYPE_UNIX_INPUT_STREAM	(g_unix_input_stream_get_type ())

typedef struct _GUnixInputStream {
    GInputStream parent_instance;
    GUnixInputStreamPrivate *priv;
} GUnixInputStream;
typedef struct _GUnixInputStreamClass {
    GInputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GUnixInputStreamClass;
typedef struct _GUnixInputStreamPrivate GUnixInputStreamPrivate;
extern gboolean g_unix_input_stream_get_close_fd(GUnixInputStream *
						 stream);
extern gint g_unix_input_stream_get_fd(GUnixInputStream * stream);
extern GType g_unix_input_stream_get_type(void);
extern GInputStream *g_unix_input_stream_new(gint fd, gboolean close_fd);
extern void g_unix_input_stream_set_close_fd(GUnixInputStream * stream,
					     gboolean close_fd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40907"
>17.12.8. gio-unix-2.0/gio/gunixmounts.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_MOUNT_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_MOUNT_MONITOR, GUnixMountMonitorClass))
#define G_IS_UNIX_MOUNT_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_MOUNT_MONITOR))
#define G_UNIX_MOUNT_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_MOUNT_MONITOR, GUnixMountMonitor))
#define G_IS_UNIX_MOUNT_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_MOUNT_MONITOR))
#define G_TYPE_UNIX_MOUNT_MONITOR	(g_unix_mount_monitor_get_type ())

typedef struct _GUnixMountEntry GUnixMountEntry;
typedef struct _GUnixMountPoint GUnixMountPoint;
typedef struct _GUnixMountMonitor GUnixMountMonitor;
typedef struct _GUnixMountMonitorClass GUnixMountMonitorClass;
extern gboolean g_unix_is_mount_path_system_internal(const char
						     *mount_path);
extern GUnixMountEntry *g_unix_mount_at(const char *mount_path,
					guint64 * time_read);
extern gint g_unix_mount_compare(GUnixMountEntry * mount1,
				 GUnixMountEntry * mount2);
extern void g_unix_mount_free(GUnixMountEntry * mount_entry);
extern const char *g_unix_mount_get_device_path(GUnixMountEntry *
						mount_entry);
extern const char *g_unix_mount_get_fs_type(GUnixMountEntry * mount_entry);
extern const char *g_unix_mount_get_mount_path(GUnixMountEntry *
					       mount_entry);
extern gboolean g_unix_mount_guess_can_eject(GUnixMountEntry *
					     mount_entry);
extern GIcon *g_unix_mount_guess_icon(GUnixMountEntry * mount_entry);
extern char *g_unix_mount_guess_name(GUnixMountEntry * mount_entry);
extern gboolean g_unix_mount_guess_should_display(GUnixMountEntry *
						  mount_entry);
extern gboolean g_unix_mount_is_readonly(GUnixMountEntry * mount_entry);
extern gboolean g_unix_mount_is_system_internal(GUnixMountEntry *
						mount_entry);
extern GType g_unix_mount_monitor_get_type(void);
extern GUnixMountMonitor *g_unix_mount_monitor_new(void);
extern void g_unix_mount_monitor_set_rate_limit(GUnixMountMonitor *
						mount_monitor,
						int limit_msec);
extern gint g_unix_mount_point_compare(GUnixMountPoint * mount1,
				       GUnixMountPoint * mount2);
extern void g_unix_mount_point_free(GUnixMountPoint * mount_point);
extern const char *g_unix_mount_point_get_device_path(GUnixMountPoint *
						      mount_point);
extern const char *g_unix_mount_point_get_fs_type(GUnixMountPoint *
						  mount_point);
extern const char *g_unix_mount_point_get_mount_path(GUnixMountPoint *
						     mount_point);
extern const char *g_unix_mount_point_get_options(GUnixMountPoint *
						  mount_point);
extern gboolean g_unix_mount_point_guess_can_eject(GUnixMountPoint *
						   mount_point);
extern GIcon *g_unix_mount_point_guess_icon(GUnixMountPoint * mount_point);
extern char *g_unix_mount_point_guess_name(GUnixMountPoint * mount_point);
extern gboolean g_unix_mount_point_is_loopback(GUnixMountPoint *
					       mount_point);
extern gboolean g_unix_mount_point_is_readonly(GUnixMountPoint *
					       mount_point);
extern gboolean g_unix_mount_point_is_user_mountable(GUnixMountPoint *
						     mount_point);
extern gboolean g_unix_mount_points_changed_since(guint64 time);
extern GList *g_unix_mount_points_get(guint64 * time_read);
extern gboolean g_unix_mounts_changed_since(guint64 time);
extern GList *g_unix_mounts_get(guint64 * time_read);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40911"
>17.12.9. gio-unix-2.0/gio/gunixoutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStreamClass))
#define G_IS_UNIX_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_OUTPUT_STREAM))
#define G_UNIX_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStream))
#define G_IS_UNIX_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_OUTPUT_STREAM))
#define G_UNIX_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_OUTPUT_STREAM, GUnixOutputStreamClass))
#define G_TYPE_UNIX_OUTPUT_STREAM	(g_unix_output_stream_get_type ())

typedef struct _GUnixOutputStream {
    GOutputStream parent_instance;
    GUnixOutputStreamPrivate *priv;
} GUnixOutputStream;
typedef struct _GUnixOutputStreamClass {
    GOutputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GUnixOutputStreamClass;
typedef struct _GUnixOutputStreamPrivate GUnixOutputStreamPrivate;
extern gboolean g_unix_output_stream_get_close_fd(GUnixOutputStream *
						  stream);
extern gint g_unix_output_stream_get_fd(GUnixOutputStream * stream);
extern GType g_unix_output_stream_get_type(void);
extern GOutputStream *g_unix_output_stream_new(gint fd, gboolean close_fd);
extern void g_unix_output_stream_set_close_fd(GUnixOutputStream * stream,
					      gboolean close_fd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40915"
>17.12.10. gio-unix-2.0/gio/gunixsocketaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_UNIX_SOCKET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
#define G_IS_UNIX_SOCKET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_SOCKET_ADDRESS))
#define G_UNIX_SOCKET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress))
#define G_IS_UNIX_SOCKET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_SOCKET_ADDRESS))
#define G_UNIX_SOCKET_ADDRESS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
#define G_TYPE_UNIX_SOCKET_ADDRESS	(g_unix_socket_address_get_type ())

typedef struct _GUnixSocketAddress {
    GSocketAddress parent_instance;
    GUnixSocketAddressPrivate *priv;
} GUnixSocketAddress;
typedef struct _GUnixSocketAddressClass {
    GSocketAddressClass parent_class;
} GUnixSocketAddressClass;
typedef struct _GUnixSocketAddressPrivate GUnixSocketAddressPrivate;
extern gboolean g_unix_socket_address_abstract_names_supported(void);
extern GUnixSocketAddressType
g_unix_socket_address_get_address_type(GUnixSocketAddress * address);
extern gboolean g_unix_socket_address_get_is_abstract(GUnixSocketAddress *
						      address);
extern const char *g_unix_socket_address_get_path(GUnixSocketAddress *
						  address);
extern gsize g_unix_socket_address_get_path_len(GUnixSocketAddress *
						address);
extern GType g_unix_socket_address_get_type(void);
extern GSocketAddress *g_unix_socket_address_new(const char *path);
extern GSocketAddress *g_unix_socket_address_new_abstract(const char *path,
							  gint path_len);
extern GSocketAddress *g_unix_socket_address_new_with_type(const char
							   *path,
							   gint path_len,
							   GUnixSocketAddressType
							   type);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40919"
>17.12.11. glib-2.0/gio/gaction.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_ACTION	(g_action_get_type ())
#define G_ACTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_ACTION, GAction))
#define G_IS_ACTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_ACTION))
#define G_ACTION_GET_IFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_ACTION, GActionInterface))
#define SA_STACK	SA_ONSTACK

typedef struct _GActionInterface {
    GTypeInterface g_iface;
    const gchar *get_name;
    const GVariantType(*get_parameter_type) (GAction * action);
    const GVariantType(*get_state_type) (GAction * action);
    GVariant *(*get_state_hint) (GAction * action);
     gboolean(*get_enabled) (GAction * action);
    GVariant *(*get_state) (GAction * action);
    void (*change_state) (GAction * action, GVariant * value);
    void (*activate) (GAction * action, GVariant * parameter);
} GActionInterface;
extern void g_action_activate(GAction * action, GVariant * parameter);
extern void g_action_change_state(GAction * action, GVariant * value);
extern gboolean g_action_get_enabled(GAction * action);
extern const char *g_action_get_name(GAction * action);
extern GVariantType *g_action_get_parameter_type(GAction * action);
extern GVariant *g_action_get_state(GAction * action);
extern GVariant *g_action_get_state_hint(GAction * action);
extern GVariantType *g_action_get_state_type(GAction * action);
extern GType g_action_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40923"
>17.12.12. glib-2.0/gio/gactiongroup.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_ACTION_GROUP	(g_action_group_get_type ())
#define G_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_ACTION_GROUP, GActionGroup))
#define G_IS_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_ACTION_GROUP))
#define G_ACTION_GROUP_GET_IFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_ACTION_GROUP, GActionGroupInterface))

typedef struct _GActionGroupInterface {
    GTypeInterface g_iface;
     gboolean(*has_action) (GActionGroup * action_group,
			    const gchar * action_name);
    gchar **(*list_actions) (GActionGroup * action_group);
     gboolean(*get_action_enabled) (GActionGroup * action_group,
				    const gchar * action_name);
    const GVariantType *(*get_action_parameter_type) (GActionGroup *
						      action_group,
						      const gchar *
						      action_name);
    const GVariantType *(*get_action_state_type) (GActionGroup *
						  action_group,
						  const gchar *
						  action_name);
    GVariant *(*get_action_state_hint) (GActionGroup * action_group,
					const gchar * action_name);
    GVariant *(*get_action_state) (GActionGroup * action_group,
				   const gchar * action_name);
    void (*change_action_state) (GActionGroup * action_group,
				 const gchar * action_name,
				 GVariant * value);
    void (*activate_action) (GActionGroup * action_group,
			     const gchar * action_name,
			     GVariant * parameter);
    void (*action_added) (GActionGroup * action_group,
			  const gchar * action_name);
    void (*action_removed) (GActionGroup * action_group,
			    const gchar * action_name);
    void (*action_enabled_changed) (GActionGroup * action_group,
				    const gchar * action_name,
				    gboolean enabled);
    void (*action_state_changed) (GActionGroup * action_group,
				  const gchar * action_name,
				  GVariant * state);
     gboolean(*query_action) (GActionGroup * action_group,
			      const gchar * action_name,
			      gboolean * enabled,
			      const GVariantType * parameter_type,
			      const GVariantType * state_type,
			      GVariant * *state_hint, GVariant * *state);
} GActionGroupInterface;
extern void g_action_group_action_added(GActionGroup * action_group,
					const char *action_name);
extern void g_action_group_action_enabled_changed(GActionGroup *
						  action_group,
						  const char *action_name,
						  gboolean enabled);
extern void g_action_group_action_removed(GActionGroup * action_group,
					  const char *action_name);
extern void g_action_group_action_state_changed(GActionGroup *
						action_group,
						const char *action_name,
						GVariant * state);
extern void g_action_group_activate_action(GActionGroup * action_group,
					   const char *action_name,
					   GVariant * parameter);
extern void g_action_group_change_action_state(GActionGroup * action_group,
					       const char *action_name,
					       GVariant * value);
extern gboolean g_action_group_get_action_enabled(GActionGroup *
						  action_group,
						  const char *action_name);
extern GVariantType *g_action_group_get_action_parameter_type(GActionGroup
							      *
							      action_group,
							      const char
							      *action_name);
extern GVariant *g_action_group_get_action_state(GActionGroup *
						 action_group,
						 const char *action_name);
extern GVariant *g_action_group_get_action_state_hint(GActionGroup *
						      action_group,
						      const char
						      *action_name);
extern GVariantType *g_action_group_get_action_state_type(GActionGroup *
							  action_group,
							  const char
							  *action_name);
extern GType g_action_group_get_type(void);
extern gboolean g_action_group_has_action(GActionGroup * action_group,
					  const char *action_name);
extern gchar **g_action_group_list_actions(GActionGroup * action_group);
extern gboolean g_action_group_query_action(GActionGroup * action_group,
					    const char *action_name,
					    gboolean * enabled,
					    const GVariantType *
					    parameter_type,
					    const GVariantType *
					    state_type,
					    GVariant * *state_hint,
					    GVariant * *state);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40927"
>17.12.13. glib-2.0/gio/gactiongroupexporter.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern guint g_dbus_connection_export_action_group(GDBusConnection *
						   connection,
						   const gchar *
						   object_path,
						   GActionGroup *
						   action_group,
						   GError * *error);
extern void g_dbus_connection_unexport_action_group(GDBusConnection *
						    connection,
						    guint export_id);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40931"
>17.12.14. glib-2.0/gio/gactionmap.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_ACTION_MAP	(g_action_map_get_type ())
#define G_ACTION_MAP(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_ACTION_MAP, GActionMap))
#define G_IS_ACTION_MAP(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_ACTION_MAP))
#define G_ACTION_MAP_GET_IFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_ACTION_MAP, GActionMapInterface))

typedef struct _GActionMapInterface {
    GTypeInterface g_iface;
    GAction *(*lookup_action) (GActionMap * action_map,
			       const gchar * action_name);
    void (*add_action) (GActionMap * action_map, GAction * action);
    void (*remove_action) (GActionMap * action_map,
			   const gchar * action_name);
} GActionMapInterface;
typedef struct _GActionEntry {
    const gchar *name;
    void (*activate) (GSimpleAction * action, GVariant * parameter,
		      gpointer user_data);
    const gchar *parameter_type;
    const gchar *state;
    void (*change_state) (GSimpleAction * action, GVariant * value,
			  gpointer user_data);
    gsize padding[3];
} GActionEntry;
extern void g_action_map_add_action(GActionMap * action_map,
				    GAction * action);
extern void g_action_map_add_action_entries(GActionMap * action_map,
					    const GActionEntry * entries,
					    gint n_entries,
					    gpointer user_data);
extern GType g_action_map_get_type(void);
extern GAction *g_action_map_lookup_action(GActionMap * action_map,
					   const char *action_name);
extern void g_action_map_remove_action(GActionMap * action_map,
				       const char *action_name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40935"
>17.12.15. glib-2.0/gio/gappinfo.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_APP_INFO	(g_app_info_get_type ())
#define G_TYPE_APP_LAUNCH_CONTEXT	(g_app_launch_context_get_type ())
#define G_APP_LAUNCH_CONTEXT_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
#define G_IS_APP_LAUNCH_CONTEXT_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_APP_LAUNCH_CONTEXT))
#define G_APP_LAUNCH_CONTEXT(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContext))
#define G_APP_INFO(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_APP_INFO, GAppInfo))
#define G_IS_APP_LAUNCH_CONTEXT(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_APP_LAUNCH_CONTEXT))
#define G_IS_APP_INFO(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_APP_INFO))
#define G_APP_LAUNCH_CONTEXT_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
#define G_APP_INFO_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_APP_INFO, GAppInfoIface))

typedef struct _GAppLaunchContextClass {
    GObjectClass parent_class;
    char *(*get_display) (GAppLaunchContext * context, GAppInfo * info,
			  GList * files);
    char *(*get_startup_notify_id) (GAppLaunchContext * context,
				    GAppInfo * info, GList * files);
    void (*launch_failed) (GAppLaunchContext * context,
			   const char *startup_notify_id);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GAppLaunchContextClass;
typedef struct _GAppLaunchContextPrivate GAppLaunchContextPrivate;
typedef struct _GAppInfoIface {
    GTypeInterface g_iface;
    GAppInfo *(*dup) (GAppInfo * appinfo);
     gboolean(*equal) (GAppInfo * appinfo1, GAppInfo * appinfo2);
    const char *(*get_id) (GAppInfo * appinfo);
    const char *(*get_name) (GAppInfo * appinfo);
    const char *(*get_description) (GAppInfo * appinfo);
    const char *(*get_executable) (GAppInfo * appinfo);
    GIcon *(*get_icon) (GAppInfo * appinfo);
     gboolean(*launch) (GAppInfo * appinfo, GList * files,
			GAppLaunchContext * launch_context,
			GError * *error);
     gboolean(*supports_uris) (GAppInfo * appinfo);
     gboolean(*supports_files) (GAppInfo * appinfo);
     gboolean(*launch_uris) (GAppInfo * appinfo, GList * files,
			     GAppLaunchContext * launch_context,
			     GError * *error);
     gboolean(*should_show) (GAppInfo * appinfo);
     gboolean(*set_as_default_for_type) (GAppInfo * appinfo,
					 const char *content_type,
					 GError * *error);
     gboolean(*set_as_default_for_extension) (GAppInfo * appinfo,
					      const char *content_type,
					      GError * *error);
     gboolean(*add_supports_type) (GAppInfo * appinfo,
				   const char *content_type,
				   GError * *error);
     gboolean(*can_remove_supports_type) (GAppInfo * appinfo);
     gboolean(*remove_supports_type) (GAppInfo * appinfo,
				      const char *content_type,
				      GError * *error);
     gboolean(*can_delete) (GAppInfo * appinfo);
     gboolean(*do_delete) (GAppInfo * appinfo);
    const char *(*get_commandline) (GAppInfo * appinfo);
    const char *(*get_display_name) (GAppInfo * appinfo);
     gboolean(*set_as_last_used_for_type) (GAppInfo * appinfo,
					   const char *content_type,
					   GError * *error);
} GAppInfoIface;
struct _GAppLaunchContext {
    GObject parent_instance;
    GAppLaunchContextPrivate *priv;
};
extern gboolean g_app_info_add_supports_type(GAppInfo * appinfo,
					     const char *content_type,
					     GError * *error);
extern gboolean g_app_info_can_delete(GAppInfo * appinfo);
extern gboolean g_app_info_can_remove_supports_type(GAppInfo * appinfo);
extern GAppInfo *g_app_info_create_from_commandline(const char
						    *commandline,
						    const char
						    *application_name,
						    GAppInfoCreateFlags
						    flags,
						    GError * *error);
extern gboolean g_app_info_delete(GAppInfo * appinfo);
extern GAppInfo *g_app_info_dup(GAppInfo * appinfo);
extern gboolean g_app_info_equal(GAppInfo * appinfo1, GAppInfo * appinfo2);
extern GList *g_app_info_get_all(void);
extern GList *g_app_info_get_all_for_type(const char *content_type);
extern const char *g_app_info_get_commandline(GAppInfo * appinfo);
extern GAppInfo *g_app_info_get_default_for_type(const char *content_type,
						 gboolean
						 must_support_uris);
extern GAppInfo *g_app_info_get_default_for_uri_scheme(const char
						       *uri_scheme);
extern const char *g_app_info_get_description(GAppInfo * appinfo);
extern const char *g_app_info_get_display_name(GAppInfo * appinfo);
extern const char *g_app_info_get_executable(GAppInfo * appinfo);
extern GList *g_app_info_get_fallback_for_type(const char *content_type);
extern GIcon *g_app_info_get_icon(GAppInfo * appinfo);
extern const char *g_app_info_get_id(GAppInfo * appinfo);
extern const char *g_app_info_get_name(GAppInfo * appinfo);
extern GList *g_app_info_get_recommended_for_type(const char
						  *content_type);
extern GType g_app_info_get_type(void);
extern gboolean g_app_info_launch(GAppInfo * appinfo, GList * files,
				  GAppLaunchContext * launch_context,
				  GError * *error);
extern gboolean g_app_info_launch_default_for_uri(const char *uri,
						  GAppLaunchContext *
						  launch_context,
						  GError * *error);
extern gboolean g_app_info_launch_uris(GAppInfo * appinfo, GList * uris,
				       GAppLaunchContext * launch_context,
				       GError * *error);
extern gboolean g_app_info_remove_supports_type(GAppInfo * appinfo,
						const char *content_type,
						GError * *error);
extern void g_app_info_reset_type_associations(const char *content_type);
extern gboolean g_app_info_set_as_default_for_extension(GAppInfo * appinfo,
							const char
							*extension,
							GError * *error);
extern gboolean g_app_info_set_as_default_for_type(GAppInfo * appinfo,
						   const char
						   *content_type,
						   GError * *error);
extern gboolean g_app_info_set_as_last_used_for_type(GAppInfo * appinfo,
						     const char
						     *content_type,
						     GError * *error);
extern gboolean g_app_info_should_show(GAppInfo * appinfo);
extern gboolean g_app_info_supports_files(GAppInfo * appinfo);
extern gboolean g_app_info_supports_uris(GAppInfo * appinfo);
extern char *g_app_launch_context_get_display(GAppLaunchContext * context,
					      GAppInfo * info,
					      GList * files);
extern void g_app_launch_context_get_environment(GAppLaunchContext *
						 context);
extern char *g_app_launch_context_get_startup_notify_id(GAppLaunchContext *
							context,
							GAppInfo * info,
							GList * files);
extern GType g_app_launch_context_get_type(void);
extern void g_app_launch_context_launch_failed(GAppLaunchContext * context,
					       const char
					       *startup_notify_id);
extern GAppLaunchContext *g_app_launch_context_new(void);
extern void g_app_launch_context_setenv(GAppLaunchContext * context,
					const char *variable,
					const char *value);
extern void g_app_launch_context_unsetenv(GAppLaunchContext * context,
					  const char *variable);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40939"
>17.12.16. glib-2.0/gio/gapplication.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_APPLICATION	(g_application_get_type ())
#define G_APPLICATION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_APPLICATION, GApplicationClass))
#define G_IS_APPLICATION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_APPLICATION))
#define G_APPLICATION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_APPLICATION, GApplication))
#define G_IS_APPLICATION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_APPLICATION))
#define G_APPLICATION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_APPLICATION, GApplicationClass))

typedef struct _GApplicationPrivate GApplicationPrivate;
typedef struct _GApplicationClass {
    GObjectClass parent_class;
    void (*startup) (GApplication * application);
    void (*activate) (GApplication * application);
    void (*open) (GApplication * application, GFile * *files, gint n_files,
		  const gchar * hint);
    int (*command_line) (GApplication * application,
			 GApplicationCommandLine * command_line);
     gboolean(*local_command_line) (GApplication * application,
				    gchar * **arguments, int *exit_status);
    void (*before_emit) (GApplication * application,
			 GVariant * platform_data);
    void (*after_emit) (GApplication * application,
			GVariant * platform_data);
    void (*add_platform_data) (GApplication * application,
			       GVariantBuilder * builder);
    void (*quit_mainloop) (GApplication * application);
    void (*run_mainloop) (GApplication * application);
    void (*shutdown) (GApplication * application);
    gpointer padding[11];
} GApplicationClass;
struct _GApplication {
    GObject parent_instance;
    GApplicationPrivate *priv;
};
extern void g_application_activate(GApplication * application);
extern const char *g_application_get_application_id(GApplication *
						    application);
extern GApplication *g_application_get_default(void);
extern GApplicationFlags g_application_get_flags(GApplication *
						 application);
extern guint g_application_get_inactivity_timeout(GApplication *
						  application);
extern gboolean g_application_get_is_registered(GApplication *
						application);
extern gboolean g_application_get_is_remote(GApplication * application);
extern GType g_application_get_type(void);
extern void g_application_hold(GApplication * application);
extern gboolean g_application_id_is_valid(const char *application_id);
extern GApplication *g_application_new(const char *application_id,
				       GApplicationFlags flags);
extern void g_application_open(GApplication * application, GFile * *files,
			       gint n_files, const char *hint);
extern void g_application_quit(GApplication * application);
extern gboolean g_application_register(GApplication * application,
				       GCancellable * cancellable,
				       GError * *error);
extern void g_application_release(GApplication * application);
extern int g_application_run(GApplication * application, int argc,
			     char **argv);
extern void g_application_set_action_group(GApplication * application,
					   GActionGroup * action_group);
extern void g_application_set_application_id(GApplication * application,
					     const char *application_id);
extern void g_application_set_default(GApplication * application);
extern void g_application_set_flags(GApplication * application,
				    GApplicationFlags flags);
extern void g_application_set_inactivity_timeout(GApplication *
						 application,
						 guint inactivity_timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40943"
>17.12.17. glib-2.0/gio/gapplicationcommandline.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_APPLICATION_COMMAND_LINE	(g_application_command_line_get_type ())
#define G_APPLICATION_COMMAND_LINE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLineClass))
#define G_IS_APPLICATION_COMMAND_LINE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_APPLICATION_COMMAND_LINE))
#define G_APPLICATION_COMMAND_LINE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLine))
#define G_IS_APPLICATION_COMMAND_LINE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_APPLICATION_COMMAND_LINE))
#define G_APPLICATION_COMMAND_LINE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLineClass))

typedef struct _GApplicationCommandLinePrivate
    GApplicationCommandLinePrivate;
typedef struct _GApplicationCommandLineClass {
    GObjectClass parent_class;
    void (*print_literal) (GApplicationCommandLine * cmdline,
			   const gchar * message);
    void (*printerr_literal) (GApplicationCommandLine * cmdline,
			      const gchar * message);
    gpointer padding[12];
} GApplicationCommandLineClass;
struct _GApplicationCommandLine {
    GObject parent_instance;
    GApplicationCommandLinePrivate *priv;
};
extern gchar
    **g_application_command_line_get_arguments(GApplicationCommandLine *
					       cmdline, int *argc);
extern const char
    *g_application_command_line_get_cwd(GApplicationCommandLine * cmdline);
extern const char *const
    *g_application_command_line_get_environ(GApplicationCommandLine *
					    cmdline);
extern int
g_application_command_line_get_exit_status(GApplicationCommandLine *
					   cmdline);
extern gboolean
g_application_command_line_get_is_remote(GApplicationCommandLine *
					 cmdline);
extern GVariant
    *g_application_command_line_get_platform_data(GApplicationCommandLine *
						  cmdline);
extern GType g_application_command_line_get_type(void);
extern const char
    *g_application_command_line_getenv(GApplicationCommandLine * cmdline,
				       const char *name);
extern void g_application_command_line_print(GApplicationCommandLine *
					     cmdline, const char *format,
					     ...);
extern void g_application_command_line_printerr(GApplicationCommandLine *
						cmdline,
						const char *format, ...);
extern void
g_application_command_line_set_exit_status(GApplicationCommandLine *
					   cmdline, int exit_status);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40947"
>17.12.18. glib-2.0/gio/gasyncinitable.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_ASYNC_INITABLE	(g_async_initable_get_type ())
#define G_ASYNC_INITABLE(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ASYNC_INITABLE, GAsyncInitable))
#define G_IS_ASYNC_INITABLE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ASYNC_INITABLE))
#define G_ASYNC_INITABLE_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ASYNC_INITABLE, GAsyncInitableIface))
#define G_TYPE_IS_ASYNC_INITABLE(type)	(g_type_is_a ((type), G_TYPE_ASYNC_INITABLE))

typedef struct _GAsyncInitableIface {
    GTypeInterface g_iface;
    void (*init_async) (GAsyncInitable * initable, int io_priority,
			GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*init_finish) (GAsyncInitable * initable, GAsyncResult * res,
			     GError * *error);
} GAsyncInitableIface;
extern GType g_async_initable_get_type(void);
extern void g_async_initable_init_async(GAsyncInitable * initable,
					int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
extern gboolean g_async_initable_init_finish(GAsyncInitable * initable,
					     GAsyncResult * res,
					     GError * *error);
extern void g_async_initable_new_async(GType object_type, int io_priority,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data,
				       const gchar * first_property_name,
				       ...);
extern GObject *g_async_initable_new_finish(GAsyncInitable * initable,
					    GAsyncResult * res,
					    GError * *error);
extern void g_async_initable_new_valist_async(GType object_type,
					      const gchar *
					      first_property_name,
					      va_list var_args,
					      int io_priority,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern void g_async_initable_newv_async(GType object_type,
					guint n_parameters,
					GParameter * parameters,
					int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40951"
>17.12.19. glib-2.0/gio/gasyncresult.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_ASYNC_RESULT	(g_async_result_get_type ())
#define G_ASYNC_RESULT(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ASYNC_RESULT, GAsyncResult))
#define G_IS_ASYNC_RESULT(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ASYNC_RESULT))
#define G_ASYNC_RESULT_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ASYNC_RESULT, GAsyncResultIface))

typedef struct _GAsyncResultIface {
    GTypeInterface g_iface;
     gpointer(*get_user_data) (GAsyncResult * res);
    GObject *(*get_source_object) (GAsyncResult * res);
} GAsyncResultIface;
extern GObject *g_async_result_get_source_object(GAsyncResult * res);
extern GType g_async_result_get_type(void);
extern gpointer g_async_result_get_user_data(GAsyncResult * res);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40955"
>17.12.20. glib-2.0/gio/gbufferedinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_BUFFERED_INPUT_STREAM	(g_buffered_input_stream_get_type ())
#define G_BUFFERED_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass))
#define G_IS_BUFFERED_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_BUFFERED_INPUT_STREAM))
#define G_BUFFERED_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStream))
#define G_IS_BUFFERED_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_BUFFERED_INPUT_STREAM))
#define G_BUFFERED_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass))

typedef struct _GBufferedInputStreamClass {
    GFilterInputStreamClass parent_class;
     gssize(*fill) (GBufferedInputStream * stream, gsize count,
		    GCancellable * cancellable, GError * *error);
    void (*fill_async) (GBufferedInputStream * stream, gssize count,
			int io_priority, GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
     gssize(*fill_finish) (GBufferedInputStream * stream,
			   GAsyncResult * result, GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GBufferedInputStreamClass;
typedef struct _GBufferedInputStreamPrivate GBufferedInputStreamPrivate;
struct _GBufferedInputStream {
    GFilterInputStream parent_instance;
    GBufferedInputStreamPrivate *priv;
};
extern gssize g_buffered_input_stream_fill(GBufferedInputStream * stream,
					   gssize count,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_buffered_input_stream_fill_async(GBufferedInputStream *
					       stream, gssize count,
					       int io_priority,
					       GCancellable * cancellable,
					       GAsyncReadyCallback
					       callback,
					       gpointer user_data);
extern gssize g_buffered_input_stream_fill_finish(GBufferedInputStream *
						  stream,
						  GAsyncResult * result,
						  GError * *error);
extern gsize g_buffered_input_stream_get_available(GBufferedInputStream *
						   stream);
extern gsize g_buffered_input_stream_get_buffer_size(GBufferedInputStream *
						     stream);
extern GType g_buffered_input_stream_get_type(void);
extern GInputStream *g_buffered_input_stream_new(GInputStream *
						 base_stream);
extern GInputStream *g_buffered_input_stream_new_sized(GInputStream *
						       base_stream,
						       gsize size);
extern gsize g_buffered_input_stream_peek(GBufferedInputStream * stream,
					  void *buffer, gsize offset,
					  gsize count);
extern const void *g_buffered_input_stream_peek_buffer(GBufferedInputStream
						       * stream,
						       gsize * count);
extern int g_buffered_input_stream_read_byte(GBufferedInputStream * stream,
					     GCancellable * cancellable,
					     GError * *error);
extern void g_buffered_input_stream_set_buffer_size(GBufferedInputStream *
						    stream, gsize size);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40959"
>17.12.21. glib-2.0/gio/gbufferedoutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_BUFFERED_OUTPUT_STREAM	(g_buffered_output_stream_get_type ())
#define G_BUFFERED_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass))
#define G_IS_BUFFERED_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_BUFFERED_OUTPUT_STREAM))
#define G_BUFFERED_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStream))
#define G_IS_BUFFERED_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_BUFFERED_OUTPUT_STREAM))
#define G_BUFFERED_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass))

typedef struct _GBufferedOutputStreamClass {
    GFilterOutputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
} GBufferedOutputStreamClass;
typedef struct _GBufferedOutputStreamPrivate GBufferedOutputStreamPrivate;
struct _GBufferedOutputStream {
    GFilterOutputStream parent_instance;
    GBufferedOutputStreamPrivate *priv;
};
extern gboolean
g_buffered_output_stream_get_auto_grow(GBufferedOutputStream * stream);
extern gsize g_buffered_output_stream_get_buffer_size(GBufferedOutputStream
						      * stream);
extern GType g_buffered_output_stream_get_type(void);
extern GOutputStream *g_buffered_output_stream_new(GOutputStream *
						   base_stream);
extern GOutputStream *g_buffered_output_stream_new_sized(GOutputStream *
							 base_stream,
							 gsize size);
extern void g_buffered_output_stream_set_auto_grow(GBufferedOutputStream *
						   stream,
						   gboolean auto_grow);
extern void g_buffered_output_stream_set_buffer_size(GBufferedOutputStream
						     * stream, gsize size);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40963"
>17.12.22. glib-2.0/gio/gcancellable.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_CANCELLABLE	(g_cancellable_get_type ())
#define G_CANCELLABLE_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CANCELLABLE, GCancellableClass))
#define G_IS_CANCELLABLE_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CANCELLABLE))
#define G_CANCELLABLE(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CANCELLABLE, GCancellable))
#define G_IS_CANCELLABLE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CANCELLABLE))
#define G_CANCELLABLE_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CANCELLABLE, GCancellableClass))

typedef struct _GCancellableClass {
    GObjectClass parent_class;
    void (*cancelled) (GCancellable * cancellable);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GCancellableClass;
typedef struct _GCancellablePrivate GCancellablePrivate;
struct _GCancellable {
    GObject parent_instance;
    GCancellablePrivate *priv;
};
extern void g_cancellable_cancel(GCancellable * cancellable);
extern gulong g_cancellable_connect(GCancellable * cancellable,
				    GCallback callback, gpointer data,
				    GDestroyNotify data_destroy_func);
extern void g_cancellable_disconnect(GCancellable * cancellable,
				     gulong handler_id);
extern GCancellable *g_cancellable_get_current(void);
extern int g_cancellable_get_fd(GCancellable * cancellable);
extern GType g_cancellable_get_type(void);
extern gboolean g_cancellable_is_cancelled(GCancellable * cancellable);
extern gboolean g_cancellable_make_pollfd(GCancellable * cancellable,
					  GPollFD * pollfd);
extern GCancellable *g_cancellable_new(void);
extern void g_cancellable_pop_current(GCancellable * cancellable);
extern void g_cancellable_push_current(GCancellable * cancellable);
extern void g_cancellable_release_fd(GCancellable * cancellable);
extern void g_cancellable_reset(GCancellable * cancellable);
extern gboolean g_cancellable_set_error_if_cancelled(GCancellable *
						     cancellable,
						     GError * *error);
extern GSource *g_cancellable_source_new(GCancellable * cancellable);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40967"
>17.12.23. glib-2.0/gio/gcharsetconverter.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_CHARSET_CONVERTER	(g_charset_converter_get_type ())
#define G_CHARSET_CONVERTER_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass))
#define G_IS_CHARSET_CONVERTER_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CHARSET_CONVERTER))
#define G_CHARSET_CONVERTER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CHARSET_CONVERTER, GCharsetConverter))
#define G_IS_CHARSET_CONVERTER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CHARSET_CONVERTER))
#define G_CHARSET_CONVERTER_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass))

typedef struct _GCharsetConverterClass {
    GObjectClass parent_class;
} GCharsetConverterClass;
extern guint g_charset_converter_get_num_fallbacks(GCharsetConverter *
						   converter);
extern GType g_charset_converter_get_type(void);
extern gboolean g_charset_converter_get_use_fallback(GCharsetConverter *
						     converter);
extern GCharsetConverter *g_charset_converter_new(const char *to_charset,
						  const char *from_charset,
						  GError * *error);
extern void g_charset_converter_set_use_fallback(GCharsetConverter *
						 converter,
						 gboolean use_fallback);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40971"
>17.12.24. glib-2.0/gio/gcontenttype.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern gboolean g_content_type_can_be_executable(const gchar * type);
extern gboolean g_content_type_equals(const gchar * type1,
				      const gchar * type2);
extern gchar *g_content_type_from_mime_type(const gchar * mime_type);
extern gchar *g_content_type_get_description(const gchar * type);
extern GIcon *g_content_type_get_icon(const gchar * type);
extern gchar *g_content_type_get_mime_type(const gchar * type);
extern gchar *g_content_type_guess(const gchar * filename,
				   const guchar * data, gsize data_size,
				   gboolean * result_uncertain);
extern gchar **g_content_type_guess_for_tree(GFile * root);
extern gboolean g_content_type_is_a(const gchar * type,
				    const gchar * supertype);
extern gboolean g_content_type_is_unknown(const gchar * type);
extern GList *g_content_types_get_registered(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40975"
>17.12.25. glib-2.0/gio/gconverter.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_CONVERTER	(g_converter_get_type ())
#define G_CONVERTER(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_CONVERTER, GConverter))
#define G_IS_CONVERTER(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_CONVERTER))
#define G_CONVERTER_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_CONVERTER, GConverterIface))

typedef struct _GConverterIface {
    GTypeInterface g_iface;
     GConverterResult(*convert) (GConverter * converter, const void *inbuf,
				 gsize inbuf_size, void *outbuf,
				 gsize outbuf_size, GConverterFlags flags,
				 gsize * bytes_read, gsize * bytes_written,
				 GError * *error);
    void (*reset) (GConverter * converter);
} GConverterIface;
extern GConverterResult g_converter_convert(GConverter * converter,
					    const void *inbuf,
					    gsize inbuf_size, void *outbuf,
					    gsize outbuf_size,
					    GConverterFlags flags,
					    gsize * bytes_read,
					    gsize * bytes_written,
					    GError * *error);
extern GType g_converter_get_type(void);
extern void g_converter_reset(GConverter * converter);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40979"
>17.12.26. glib-2.0/gio/gconverterinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_CONVERTER_INPUT_STREAM	(g_converter_input_stream_get_type ())
#define G_CONVERTER_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass))
#define G_IS_CONVERTER_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CONVERTER_INPUT_STREAM))
#define G_CONVERTER_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStream))
#define G_IS_CONVERTER_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CONVERTER_INPUT_STREAM))
#define G_CONVERTER_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass))

typedef struct _GConverterInputStreamClass {
    GFilterInputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GConverterInputStreamClass;
typedef struct _GConverterInputStreamPrivate GConverterInputStreamPrivate;
struct _GConverterInputStream {
    GFilterInputStream parent_instance;
    GConverterInputStreamPrivate *priv;
};
extern GConverter
    *g_converter_input_stream_get_converter(GConverterInputStream *
					    converter_stream);
extern GType g_converter_input_stream_get_type(void);
extern GInputStream *g_converter_input_stream_new(GInputStream *
						  base_stream,
						  GConverter * converter);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40983"
>17.12.27. glib-2.0/gio/gconverteroutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_CONVERTER_OUTPUT_STREAM	(g_converter_output_stream_get_type ())
#define G_CONVERTER_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass))
#define G_IS_CONVERTER_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CONVERTER_OUTPUT_STREAM))
#define G_CONVERTER_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStream))
#define G_IS_CONVERTER_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CONVERTER_OUTPUT_STREAM))
#define G_CONVERTER_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass))

typedef struct _GConverterOutputStreamClass {
    GFilterOutputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GConverterOutputStreamClass;
typedef struct _GConverterOutputStreamPrivate
    GConverterOutputStreamPrivate;
struct _GConverterOutputStream {
    GFilterOutputStream parent_instance;
    GConverterOutputStreamPrivate *priv;
};
extern GConverter
    *g_converter_output_stream_get_converter(GConverterOutputStream *
					     converter_stream);
extern GType g_converter_output_stream_get_type(void);
extern GOutputStream *g_converter_output_stream_new(GOutputStream *
						    base_stream,
						    GConverter *
						    converter);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40987"
>17.12.28. glib-2.0/gio/gcredentials.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_CREDENTIALS	(g_credentials_get_type ())
#define G_CREDENTIALS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_CREDENTIALS, GCredentialsClass))
#define G_IS_CREDENTIALS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_CREDENTIALS))
#define G_CREDENTIALS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_CREDENTIALS, GCredentials))
#define G_IS_CREDENTIALS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_CREDENTIALS))
#define G_CREDENTIALS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_CREDENTIALS, GCredentialsClass))

typedef struct _GCredentialsClass GCredentialsClass;
extern gpointer g_credentials_get_native(GCredentials * credentials,
					 GCredentialsType native_type);
extern GType g_credentials_get_type(void);
extern uid_t g_credentials_get_unix_user(GCredentials * credentials,
					 GError * *error);
extern gboolean g_credentials_is_same_user(GCredentials * credentials,
					   GCredentials *
					   other_credentials,
					   GError * *error);
extern GCredentials *g_credentials_new(void);
extern void g_credentials_set_native(GCredentials * credentials,
				     GCredentialsType native_type,
				     gpointer native);
extern gboolean g_credentials_set_unix_user(GCredentials * credentials,
					    uid_t uid, GError * *error);
extern gchar *g_credentials_to_string(GCredentials * credentials);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40991"
>17.12.29. glib-2.0/gio/gdatainputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DATA_INPUT_STREAM	(g_data_input_stream_get_type ())
#define G_DATA_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass))
#define G_IS_DATA_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DATA_INPUT_STREAM))
#define G_DATA_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DATA_INPUT_STREAM, GDataInputStream))
#define G_IS_DATA_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DATA_INPUT_STREAM))
#define G_DATA_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass))

typedef struct _GDataInputStreamClass {
    GBufferedInputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GDataInputStreamClass;
typedef struct _GDataInputStreamPrivate GDataInputStreamPrivate;
struct _GDataInputStream {
    GBufferedInputStream parent_instance;
    GDataInputStreamPrivate *priv;
};
extern GDataStreamByteOrder
g_data_input_stream_get_byte_order(GDataInputStream * stream);
extern GDataStreamNewlineType
g_data_input_stream_get_newline_type(GDataInputStream * stream);
extern GType g_data_input_stream_get_type(void);
extern GDataInputStream *g_data_input_stream_new(GInputStream *
						 base_stream);
extern guchar g_data_input_stream_read_byte(GDataInputStream * stream,
					    GCancellable * cancellable,
					    GError * *error);
extern gint16 g_data_input_stream_read_int16(GDataInputStream * stream,
					     GCancellable * cancellable,
					     GError * *error);
extern gint32 g_data_input_stream_read_int32(GDataInputStream * stream,
					     GCancellable * cancellable,
					     GError * *error);
extern gint64 g_data_input_stream_read_int64(GDataInputStream * stream,
					     GCancellable * cancellable,
					     GError * *error);
extern char *g_data_input_stream_read_line(GDataInputStream * stream,
					   gsize * length,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_data_input_stream_read_line_async(GDataInputStream * stream,
						gint io_priority,
						GCancellable * cancellable,
						GAsyncReadyCallback
						callback,
						gpointer user_data);
extern char *g_data_input_stream_read_line_finish(GDataInputStream *
						  stream,
						  GAsyncResult * result,
						  gsize * length,
						  GError * *error);
extern char *g_data_input_stream_read_line_finish_utf8(GDataInputStream *
						       stream,
						       GAsyncResult *
						       result,
						       gsize * length,
						       GError * *error);
extern char *g_data_input_stream_read_line_utf8(GDataInputStream * stream,
						gsize * length,
						GCancellable * cancellable,
						GError * *error);
extern guint16 g_data_input_stream_read_uint16(GDataInputStream * stream,
					       GCancellable * cancellable,
					       GError * *error);
extern guint32 g_data_input_stream_read_uint32(GDataInputStream * stream,
					       GCancellable * cancellable,
					       GError * *error);
extern guint64 g_data_input_stream_read_uint64(GDataInputStream * stream,
					       GCancellable * cancellable,
					       GError * *error);
extern char *g_data_input_stream_read_until(GDataInputStream * stream,
					    const char *stop_chars,
					    gsize * length,
					    GCancellable * cancellable,
					    GError * *error);
extern void g_data_input_stream_read_until_async(GDataInputStream * stream,
						 const char *stop_chars,
						 gint io_priority,
						 GCancellable *
						 cancellable,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data);
extern char *g_data_input_stream_read_until_finish(GDataInputStream *
						   stream,
						   GAsyncResult * result,
						   gsize * length,
						   GError * *error);
extern char *g_data_input_stream_read_upto(GDataInputStream * stream,
					   const char *stop_chars,
					   gssize stop_chars_len,
					   gsize * length,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_data_input_stream_read_upto_async(GDataInputStream * stream,
						const char *stop_chars,
						gssize stop_chars_len,
						gint io_priority,
						GCancellable * cancellable,
						GAsyncReadyCallback
						callback,
						gpointer user_data);
extern char *g_data_input_stream_read_upto_finish(GDataInputStream *
						  stream,
						  GAsyncResult * result,
						  gsize * length,
						  GError * *error);
extern void g_data_input_stream_set_byte_order(GDataInputStream * stream,
					       GDataStreamByteOrder order);
extern void g_data_input_stream_set_newline_type(GDataInputStream * stream,
						 GDataStreamNewlineType
						 type);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40995"
>17.12.30. glib-2.0/gio/gdataoutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DATA_OUTPUT_STREAM	(g_data_output_stream_get_type ())
#define G_DATA_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass))
#define G_IS_DATA_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DATA_OUTPUT_STREAM))
#define G_DATA_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStream))
#define G_IS_DATA_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DATA_OUTPUT_STREAM))
#define G_DATA_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass))

typedef struct _GDataOutputStream {
    GFilterOutputStream parent_instance;
    GDataOutputStreamPrivate *priv;
} GDataOutputStream;
typedef struct _GDataOutputStreamClass {
    GFilterOutputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GDataOutputStreamClass;
typedef struct _GDataOutputStreamPrivate GDataOutputStreamPrivate;
extern GDataStreamByteOrder
g_data_output_stream_get_byte_order(GDataOutputStream * stream);
extern GType g_data_output_stream_get_type(void);
extern GDataOutputStream *g_data_output_stream_new(GOutputStream *
						   base_stream);
extern gboolean g_data_output_stream_put_byte(GDataOutputStream * stream,
					      guchar data,
					      GCancellable * cancellable,
					      GError * *error);
extern gboolean g_data_output_stream_put_int16(GDataOutputStream * stream,
					       gint16 data,
					       GCancellable * cancellable,
					       GError * *error);
extern gboolean g_data_output_stream_put_int32(GDataOutputStream * stream,
					       gint32 data,
					       GCancellable * cancellable,
					       GError * *error);
extern gboolean g_data_output_stream_put_int64(GDataOutputStream * stream,
					       gint64 data,
					       GCancellable * cancellable,
					       GError * *error);
extern gboolean g_data_output_stream_put_string(GDataOutputStream * stream,
						const char *str,
						GCancellable * cancellable,
						GError * *error);
extern gboolean g_data_output_stream_put_uint16(GDataOutputStream * stream,
						guint16 data,
						GCancellable * cancellable,
						GError * *error);
extern gboolean g_data_output_stream_put_uint32(GDataOutputStream * stream,
						guint32 data,
						GCancellable * cancellable,
						GError * *error);
extern gboolean g_data_output_stream_put_uint64(GDataOutputStream * stream,
						guint64 data,
						GCancellable * cancellable,
						GError * *error);
extern void g_data_output_stream_set_byte_order(GDataOutputStream * stream,
						GDataStreamByteOrder
						order);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN40999"
>17.12.31. glib-2.0/gio/gdbusactiongroup.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_ACTION_GROUP	(g_dbus_action_group_get_type ())
#define G_DBUS_ACTION_GROUP_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroupClass))
#define G_IS_DBUS_ACTION_GROUP_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_DBUS_ACTION_GROUP))
#define G_DBUS_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroup))
#define G_IS_DBUS_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DBUS_ACTION_GROUP))
#define G_DBUS_ACTION_GROUP_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroupClass))

extern GDBusActionGroup *g_dbus_action_group_get(GDBusConnection *
						 connection,
						 const gchar * bus_name,
						 const gchar *
						 object_path);
extern GType g_dbus_action_group_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41003"
>17.12.32. glib-2.0/gio/gdbusaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern gchar *g_dbus_address_get_for_bus_sync(GBusType bus_type,
					      GCancellable * cancellable,
					      GError * *error);
extern void g_dbus_address_get_stream(const gchar * address,
				      GCancellable * cancellable,
				      GAsyncReadyCallback callback,
				      gpointer user_data);
extern GIOStream *g_dbus_address_get_stream_finish(GAsyncResult * res,
						   gchar * *out_guid,
						   GError * *error);
extern GIOStream *g_dbus_address_get_stream_sync(const gchar * address,
						 gchar * *out_guid,
						 GCancellable *
						 cancellable,
						 GError * *error);
extern gboolean g_dbus_is_address(const gchar * string);
extern gboolean g_dbus_is_supported_address(const gchar * string,
					    GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41007"
>17.12.33. glib-2.0/gio/gdbusauthobserver.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_AUTH_OBSERVER	(g_dbus_auth_observer_get_type ())
#define G_DBUS_AUTH_OBSERVER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_AUTH_OBSERVER, GDBusAuthObserver))
#define G_IS_DBUS_AUTH_OBSERVER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_AUTH_OBSERVER))

extern gboolean
g_dbus_auth_observer_authorize_authenticated_peer(GDBusAuthObserver *
						  observer,
						  GIOStream * stream,
						  GCredentials *
						  credentials);
extern GType g_dbus_auth_observer_get_type(void);
extern GDBusAuthObserver *g_dbus_auth_observer_new(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41011"
>17.12.34. glib-2.0/gio/gdbusconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_CONNECTION	(g_dbus_connection_get_type ())
#define G_DBUS_CONNECTION(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_CONNECTION, GDBusConnection))
#define G_IS_DBUS_CONNECTION(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_CONNECTION))

typedef void (*GDBusInterfaceMethodCallFunc) (GDBusConnection * connection,
					      const gchar * sender,
					      const gchar * object_path,
					      const gchar * interface_name,
					      const gchar * method_name,
					      GVariant * parameters,
					      GDBusMethodInvocation *
					      invocation,
					      gpointer user_data);
typedef GVariant *(*GDBusInterfaceGetPropertyFunc) (GDBusConnection *
						    connection,
						    const gchar * sender,
						    const gchar *
						    object_path,
						    const gchar *
						    interface_name,
						    const gchar *
						    property_name,
						    GError * *error,
						    gpointer user_data);
typedef gboolean(*GDBusInterfaceSetPropertyFunc) (GDBusConnection *
						  connection,
						  const gchar * sender,
						  const gchar *
						  object_path,
						  const gchar *
						  interface_name,
						  const gchar *
						  property_name,
						  GVariant * value,
						  GError * *error,
						  gpointer user_data);
struct _GDBusInterfaceVTable {
    GDBusInterfaceMethodCallFunc method_call;
    GDBusInterfaceGetPropertyFunc get_property;
    GDBusInterfaceSetPropertyFunc set_property;
    gpointer padding[8];
};
typedef gchar **(*GDBusSubtreeEnumerateFunc) (GDBusConnection * connection,
					      const gchar * sender,
					      const gchar * object_path,
					      gpointer user_data);
typedef GDBusInterfaceInfo **(*GDBusSubtreeIntrospectFunc) (GDBusConnection
							    * connection,
							    const gchar *
							    sender,
							    const gchar *
							    object_path,
							    const gchar *
							    node,
							    gpointer
							    user_data);
typedef const GDBusInterfaceVTable
    *(*GDBusSubtreeDispatchFunc) (GDBusConnection * connection,
				  const gchar * sender,
				  const gchar * object_path,
				  const gchar * interface_name,
				  const gchar * node,
				  gpointer * out_user_data,
				  gpointer user_data);
struct _GDBusSubtreeVTable {
    GDBusSubtreeEnumerateFunc enumerate;
    GDBusSubtreeIntrospectFunc introspect;
    GDBusSubtreeDispatchFunc dispatch;
    gpointer padding[8];
};
typedef void (*GDBusSignalCallback) (GDBusConnection * connection,
				     const gchar * sender,
				     const gchar * object_path,
				     const gchar * interface_name,
				     const gchar * signal_name,
				     GVariant * paramters,
				     gpointer user_data);
typedef GDBusMessage *(*GDBusMessageFilterFunction) (GDBusConnection *
						     connection,
						     GDBusMessage *
						     message,
						     gboolean incoming,
						     gpointer user_data);
extern void g_bus_get(GBusType bus_type, GCancellable * cancellable,
		      GAsyncReadyCallback callback, gpointer user_data);
extern GDBusConnection *g_bus_get_finish(GAsyncResult * res,
					 GError * *error);
extern GDBusConnection *g_bus_get_sync(GBusType bus_type,
				       GCancellable * cancellable,
				       GError * *error);
extern guint g_dbus_connection_add_filter(GDBusConnection * connection,
					  GDBusMessageFilterFunction
					  filter_function, void *user_data,
					  GDestroyNotify
					  user_data_free_func);
extern void g_dbus_connection_call(GDBusConnection * connection,
				   const gchar * bus_name,
				   const gchar * object_path,
				   const gchar * interface_name,
				   const gchar * method_name,
				   GVariant * parameters,
				   const GVariantType * reply_type,
				   GDBusCallFlags flags, gint timeout_msec,
				   GCancellable * cancellable,
				   GAsyncReadyCallback callback,
				   gpointer user_data);
extern GVariant *g_dbus_connection_call_finish(GDBusConnection *
					       connection,
					       GAsyncResult * res,
					       GError * *error);
extern GVariant *g_dbus_connection_call_sync(GDBusConnection * connection,
					     const gchar * bus_name,
					     const gchar * object_path,
					     const gchar * interface_name,
					     const gchar * method_name,
					     GVariant * parameters,
					     const GVariantType *
					     reply_type,
					     GDBusCallFlags flags,
					     gint timeout_msec,
					     GCancellable * cancellable,
					     GError * *error);
extern void g_dbus_connection_call_with_unix_fd_list(GDBusConnection *
						     connection,
						     const gchar *
						     bus_name,
						     const gchar *
						     object_path,
						     const gchar *
						     interface_name,
						     const gchar *
						     method_name,
						     GVariant * parameters,
						     const GVariantType *
						     reply_type,
						     GDBusCallFlags flags,
						     gint timeout_msec,
						     GUnixFDList * fd_list,
						     GCancellable *
						     cancellable,
						     GAsyncReadyCallback
						     callback,
						     gpointer user_data);
extern GVariant
    *g_dbus_connection_call_with_unix_fd_list_finish(GDBusConnection *
						     connection,
						     GUnixFDList *
						     *out_fd_list,
						     GAsyncResult * res,
						     GError * *error);
extern GVariant
    *g_dbus_connection_call_with_unix_fd_list_sync(GDBusConnection *
						   connection,
						   const gchar * bus_name,
						   const gchar *
						   object_path,
						   const gchar *
						   interface_name,
						   const gchar *
						   method_name,
						   GVariant * parameters,
						   const GVariantType *
						   reply_type,
						   GDBusCallFlags flags,
						   gint timeout_msec,
						   GUnixFDList * fd_list,
						   GUnixFDList *
						   *out_fd_list,
						   GCancellable *
						   cancellable,
						   GError * *error);
extern void g_dbus_connection_close(GDBusConnection * connection,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
extern gboolean g_dbus_connection_close_finish(GDBusConnection *
					       connection,
					       GAsyncResult * res,
					       GError * *error);
extern gboolean g_dbus_connection_close_sync(GDBusConnection * connection,
					     GCancellable * cancellable,
					     GError * *error);
extern gboolean g_dbus_connection_emit_signal(GDBusConnection * connection,
					      const gchar *
					      destination_bus_name,
					      const gchar * object_path,
					      const gchar * interface_name,
					      const gchar * signal_name,
					      GVariant * parameters,
					      GError * *error);
extern void g_dbus_connection_flush(GDBusConnection * connection,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
extern gboolean g_dbus_connection_flush_finish(GDBusConnection *
					       connection,
					       GAsyncResult * res,
					       GError * *error);
extern gboolean g_dbus_connection_flush_sync(GDBusConnection * connection,
					     GCancellable * cancellable,
					     GError * *error);
extern GDBusCapabilityFlags
g_dbus_connection_get_capabilities(GDBusConnection * connection);
extern gboolean g_dbus_connection_get_exit_on_close(GDBusConnection *
						    connection);
extern const char *g_dbus_connection_get_guid(GDBusConnection *
					      connection);
extern GCredentials *g_dbus_connection_get_peer_credentials(GDBusConnection
							    * connection);
extern GIOStream *g_dbus_connection_get_stream(GDBusConnection *
					       connection);
extern GType g_dbus_connection_get_type(void);
extern const char *g_dbus_connection_get_unique_name(GDBusConnection *
						     connection);
extern gboolean g_dbus_connection_is_closed(GDBusConnection * connection);
extern void g_dbus_connection_new(GIOStream * stream, const gchar * guid,
				  GDBusConnectionFlags flags,
				  GDBusAuthObserver * observer,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
extern GDBusConnection *g_dbus_connection_new_finish(GAsyncResult * res,
						     GError * *error);
extern void g_dbus_connection_new_for_address(const gchar * address,
					      GDBusConnectionFlags flags,
					      GDBusAuthObserver * observer,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern GDBusConnection
    *g_dbus_connection_new_for_address_finish(GAsyncResult * res,
					      GError * *error);
extern GDBusConnection *g_dbus_connection_new_for_address_sync(const gchar
							       * address,
							       GDBusConnectionFlags
							       flags,
							       GDBusAuthObserver
							       * observer,
							       GCancellable
							       *
							       cancellable,
							       GError *
							       *error);
extern GDBusConnection *g_dbus_connection_new_sync(GIOStream * stream,
						   const gchar * guid,
						   GDBusConnectionFlags
						   flags,
						   GDBusAuthObserver *
						   observer,
						   GCancellable *
						   cancellable,
						   GError * *error);
extern guint g_dbus_connection_register_object(GDBusConnection *
					       connection,
					       const gchar * object_path,
					       GDBusInterfaceInfo *
					       interface_info,
					       const GDBusInterfaceVTable *
					       vtable, gpointer user_data,
					       GDestroyNotify
					       user_data_free_func,
					       GError * *error);
extern guint g_dbus_connection_register_subtree(GDBusConnection *
						connection,
						const gchar * object_path,
						const GDBusSubtreeVTable *
						vtable,
						GDBusSubtreeFlags flags,
						void *user_data,
						GDestroyNotify
						user_data_free_func,
						GError * *error);
extern void g_dbus_connection_remove_filter(GDBusConnection * connection,
					    guint filter_id);
extern gboolean g_dbus_connection_send_message(GDBusConnection *
					       connection,
					       GDBusMessage * message,
					       GDBusSendMessageFlags flags,
					       volatile unsigned int
					       *out_serial,
					       GError * *error);
extern void g_dbus_connection_send_message_with_reply(GDBusConnection *
						      connection,
						      GDBusMessage *
						      message,
						      GDBusSendMessageFlags
						      flags,
						      gint timeout_msec,
						      volatile unsigned int
						      *out_serial,
						      GCancellable *
						      cancellable,
						      GAsyncReadyCallback
						      callback,
						      gpointer user_data);
extern GDBusMessage
    *g_dbus_connection_send_message_with_reply_finish(GDBusConnection *
						      connection,
						      GAsyncResult * res,
						      GError * *error);
extern GDBusMessage
    *g_dbus_connection_send_message_with_reply_sync(GDBusConnection *
						    connection,
						    GDBusMessage * message,
						    GDBusSendMessageFlags
						    flags,
						    gint timeout_msec,
						    volatile unsigned int
						    *out_serial,
						    GCancellable *
						    cancellable,
						    GError * *error);
extern void g_dbus_connection_set_exit_on_close(GDBusConnection *
						connection,
						gboolean exit_on_close);
extern guint g_dbus_connection_signal_subscribe(GDBusConnection *
						connection,
						const gchar * sender,
						const gchar *
						interface_name,
						const gchar * member,
						const gchar * object_path,
						const gchar * arg0,
						GDBusSignalFlags flags,
						GDBusSignalCallback
						callback, void *user_data,
						GDestroyNotify
						user_data_free_func);
extern void g_dbus_connection_signal_unsubscribe(GDBusConnection *
						 connection,
						 guint subscription_id);
extern void g_dbus_connection_start_message_processing(GDBusConnection *
						       connection);
extern gboolean g_dbus_connection_unregister_object(GDBusConnection *
						    connection,
						    guint registration_id);
extern gboolean g_dbus_connection_unregister_subtree(GDBusConnection *
						     connection,
						     guint
						     registration_id);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41015"
>17.12.35. glib-2.0/gio/gdbuserror.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_DBUS_ERROR	g_dbus_error_quark()

struct _GDBusErrorEntry {
    gint error_code;
    const gchar *dbus_error_name;
};
extern gchar *g_dbus_error_encode_gerror(const GError * error);
extern gchar *g_dbus_error_get_remote_error(const GError * error);
extern gboolean g_dbus_error_is_remote_error(const GError * error);
extern GError *g_dbus_error_new_for_dbus_error(const gchar *
					       dbus_error_name,
					       const gchar *
					       dbus_error_message);
extern GQuark g_dbus_error_quark(void);
extern gboolean g_dbus_error_register_error(GQuark error_domain,
					    gint error_code,
					    const gchar * dbus_error_name);
extern void g_dbus_error_register_error_domain(const gchar *
					       error_domain_quark_name,
					       volatile gsize *
					       quark_volatile,
					       const GDBusErrorEntry *
					       entries, guint num_entries);
extern void g_dbus_error_set_dbus_error(GError * *error,
					const gchar * dbus_error_name,
					const gchar * dbus_error_message,
					const gchar * format, ...);
extern void g_dbus_error_set_dbus_error_valist(GError * *error,
					       const gchar *
					       dbus_error_name,
					       const gchar *
					       dbus_error_message,
					       const gchar * format,
					       va_list var_args);
extern gboolean g_dbus_error_strip_remote_error(GError * error);
extern gboolean g_dbus_error_unregister_error(GQuark error_domain,
					      gint error_code,
					      const gchar *
					      dbus_error_name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41019"
>17.12.36. glib-2.0/gio/gdbusinterface.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_INTERFACE	(g_dbus_interface_get_type())
#define G_DBUS_INTERFACE(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_INTERFACE, GDBusInterface))
#define G_IS_DBUS_INTERFACE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_INTERFACE))
#define G_DBUS_INTERFACE_GET_IFACE(o)	(G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_INTERFACE, GDBusInterfaceIface))

typedef struct _GDBusInterfaceIface {
    GTypeInterface parent_iface;
    GDBusInterfaceInfo *(*get_info) (GDBusInterface * interface_);
    GDBusObject *(*get_object) (GDBusInterface * interface_);
    void (*set_object) (GDBusInterface * interface_, GDBusObject * object);
    GDBusObject *(*dup_object) (GDBusInterface * interface_);
} GDBusInterfaceIface;
extern GDBusObject *g_dbus_interface_dup_object(GDBusInterface *
						interface_);
extern GDBusInterfaceInfo *g_dbus_interface_get_info(GDBusInterface *
						     interface_);
extern GDBusObject *g_dbus_interface_get_object(GDBusInterface *
						interface_);
extern GType g_dbus_interface_get_type(void);
extern void g_dbus_interface_set_object(GDBusInterface * interface_,
					GDBusObject * object);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41023"
>17.12.37. glib-2.0/gio/gdbusinterfaceskeleton.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_INTERFACE_SKELETON	(g_dbus_interface_skeleton_get_type ())
#define G_DBUS_INTERFACE_SKELETON_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass))
#define G_IS_DBUS_INTERFACE_SKELETON_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_INTERFACE_SKELETON))
#define G_DBUS_INTERFACE_SKELETON(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeleton))
#define G_IS_DBUS_INTERFACE_SKELETON(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_INTERFACE_SKELETON))
#define G_DBUS_INTERFACE_SKELETON_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass))

typedef struct _GDBusInterfaceSkeletonClass {
    GObjectClass parent_class;
    GDBusInterfaceInfo *(*get_info) (GDBusInterfaceSkeleton * interface_);
    GDBusInterfaceVTable *(*get_vtable) (GDBusInterfaceSkeleton *
					 interface_);
    GVariant *(*get_properties) (GDBusInterfaceSkeleton * interface_);
    void (*flush) (GDBusInterfaceSkeleton * interface_);
    gpointer vfunc_padding[8];
     gboolean(*g_authorize_method) (GDBusInterfaceSkeleton * interface_,
				    GDBusMethodInvocation * invocation);
    gpointer signal_padding[8];
} GDBusInterfaceSkeletonClass;
typedef struct _GDBusInterfaceSkeletonPrivate
    GDBusInterfaceSkeletonPrivate;
struct _GDBusInterfaceSkeleton {
    GObject parent_instance;
    GDBusInterfaceSkeletonPrivate *priv;
};
extern gboolean g_dbus_interface_skeleton_export(GDBusInterfaceSkeleton *
						 interface_,
						 GDBusConnection *
						 connection,
						 const gchar * object_path,
						 GError * *error);
extern void g_dbus_interface_skeleton_flush(GDBusInterfaceSkeleton *
					    interface_);
extern GDBusConnection
    *g_dbus_interface_skeleton_get_connection(GDBusInterfaceSkeleton *
					      interface_);
extern GList
    *g_dbus_interface_skeleton_get_connections(GDBusInterfaceSkeleton *
					       interface_);
extern GDBusInterfaceSkeletonFlags
g_dbus_interface_skeleton_get_flags(GDBusInterfaceSkeleton * interface_);
extern GDBusInterfaceInfo
    *g_dbus_interface_skeleton_get_info(GDBusInterfaceSkeleton *
					interface_);
extern const char
    *g_dbus_interface_skeleton_get_object_path(GDBusInterfaceSkeleton *
					       interface_);
extern GVariant
    *g_dbus_interface_skeleton_get_properties(GDBusInterfaceSkeleton *
					      interface_);
extern GType g_dbus_interface_skeleton_get_type(void);
extern GDBusInterfaceVTable
    *g_dbus_interface_skeleton_get_vtable(GDBusInterfaceSkeleton *
					  interface_);
extern gboolean
g_dbus_interface_skeleton_has_connection(GDBusInterfaceSkeleton *
					 interface_,
					 GDBusConnection * connection);
extern void g_dbus_interface_skeleton_set_flags(GDBusInterfaceSkeleton *
						interface_,
						GDBusInterfaceSkeletonFlags
						flags);
extern void g_dbus_interface_skeleton_unexport(GDBusInterfaceSkeleton *
					       interface_);
extern void
g_dbus_interface_skeleton_unexport_from_connection(GDBusInterfaceSkeleton *
						   interface_,
						   GDBusConnection *
						   connection);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41027"
>17.12.38. glib-2.0/gio/gdbusintrospection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_ANNOTATION_INFO	(g_dbus_annotation_info_get_type ())
#define G_TYPE_DBUS_ARG_INFO	(g_dbus_arg_info_get_type ())
#define G_TYPE_DBUS_INTERFACE_INFO	(g_dbus_interface_info_get_type ())
#define G_TYPE_DBUS_METHOD_INFO	(g_dbus_method_info_get_type ())
#define G_TYPE_DBUS_NODE_INFO	(g_dbus_node_info_get_type ())
#define G_TYPE_DBUS_PROPERTY_INFO	(g_dbus_property_info_get_type ())
#define G_TYPE_DBUS_SIGNAL_INFO	(g_dbus_signal_info_get_type ())

struct _GDBusAnnotationInfo {
    volatile gint ref_count;
    gchar *key;
    gchar *value;
    GDBusAnnotationInfo **annotations;
};
struct _GDBusArgInfo {
    volatile gint ref_count;
    gchar *name;
    gchar *signature;
    GDBusAnnotationInfo **annotations;
};
struct _GDBusMethodInfo {
    volatile gint ref_count;
    gchar *name;
    GDBusArgInfo **in_args;
    GDBusArgInfo **out_args;
    GDBusAnnotationInfo **annotations;
};
struct _GDBusSignalInfo {
    volatile gint ref_count;
    gchar *name;
    GDBusArgInfo **args;
    GDBusAnnotationInfo **annotations;
};
struct _GDBusPropertyInfo {
    volatile gint ref_count;
    gchar *name;
    gchar *signature;
    GDBusPropertyInfoFlags flags;
    GDBusAnnotationInfo **annotations;
};
struct _GDBusInterfaceInfo {
    volatile gint ref_count;
    gchar *name;
    GDBusMethodInfo **methods;
    GDBusSignalInfo **signals;
    GDBusPropertyInfo **properties;
    GDBusAnnotationInfo **annotations;
};
struct _GDBusNodeInfo {
    volatile gint ref_count;
    gchar *path;
    GDBusInterfaceInfo **interfaces;
    GDBusNodeInfo **nodes;
    GDBusAnnotationInfo **annotations;
};
extern GType g_dbus_annotation_info_get_type(void);
extern const char *g_dbus_annotation_info_lookup(GDBusAnnotationInfo *
						 *annotations,
						 const gchar * name);
extern GDBusAnnotationInfo *g_dbus_annotation_info_ref(GDBusAnnotationInfo
						       * info);
extern void g_dbus_annotation_info_unref(GDBusAnnotationInfo * info);
extern GType g_dbus_arg_info_get_type(void);
extern GDBusArgInfo *g_dbus_arg_info_ref(GDBusArgInfo * info);
extern void g_dbus_arg_info_unref(GDBusArgInfo * info);
extern void g_dbus_interface_info_cache_build(GDBusInterfaceInfo * info);
extern void g_dbus_interface_info_cache_release(GDBusInterfaceInfo * info);
extern void g_dbus_interface_info_generate_xml(GDBusInterfaceInfo * info,
					       guint indent,
					       GString * string_builder);
extern GType g_dbus_interface_info_get_type(void);
extern GDBusMethodInfo
    *g_dbus_interface_info_lookup_method(GDBusInterfaceInfo * info,
					 const gchar * name);
extern GDBusPropertyInfo
    *g_dbus_interface_info_lookup_property(GDBusInterfaceInfo * info,
					   const gchar * name);
extern GDBusSignalInfo
    *g_dbus_interface_info_lookup_signal(GDBusInterfaceInfo * info,
					 const gchar * name);
extern GDBusInterfaceInfo *g_dbus_interface_info_ref(GDBusInterfaceInfo *
						     info);
extern void g_dbus_interface_info_unref(GDBusInterfaceInfo * info);
extern GType g_dbus_method_info_get_type(void);
extern GDBusMethodInfo *g_dbus_method_info_ref(GDBusMethodInfo * info);
extern void g_dbus_method_info_unref(GDBusMethodInfo * info);
extern void g_dbus_node_info_generate_xml(GDBusNodeInfo * info,
					  guint indent,
					  GString * string_builder);
extern GType g_dbus_node_info_get_type(void);
extern GDBusInterfaceInfo *g_dbus_node_info_lookup_interface(GDBusNodeInfo
							     * info,
							     const gchar *
							     name);
extern GDBusNodeInfo *g_dbus_node_info_new_for_xml(const gchar * xml_data,
						   GError * *error);
extern GDBusNodeInfo *g_dbus_node_info_ref(GDBusNodeInfo * info);
extern void g_dbus_node_info_unref(GDBusNodeInfo * info);
extern GType g_dbus_property_info_get_type(void);
extern GDBusPropertyInfo *g_dbus_property_info_ref(GDBusPropertyInfo *
						   info);
extern void g_dbus_property_info_unref(GDBusPropertyInfo * info);
extern GType g_dbus_signal_info_get_type(void);
extern GDBusSignalInfo *g_dbus_signal_info_ref(GDBusSignalInfo * info);
extern void g_dbus_signal_info_unref(GDBusSignalInfo * info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41031"
>17.12.39. glib-2.0/gio/gdbusmenumodel.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_MENU_MODEL	(g_dbus_menu_model_get_type ())
#define G_DBUS_MENU_MODEL(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_DBUS_MENU_MODEL, GDBusMenuModel))
#define G_IS_DBUS_MENU_MODEL(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_DBUS_MENU_MODEL))

typedef struct _GDBusMenuModel GDBusMenuModel;
extern GDBusMenuModel *g_dbus_menu_model_get(GDBusConnection * connection,
					     const gchar * bus_name,
					     const gchar * object_path);
extern GType g_dbus_menu_model_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41035"
>17.12.40. glib-2.0/gio/gdbusmessage.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_MESSAGE	(g_dbus_message_get_type ())
#define G_DBUS_MESSAGE(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_MESSAGE, GDBusMessage))
#define G_IS_DBUS_MESSAGE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_MESSAGE))

extern gssize g_dbus_message_bytes_needed(guchar * blob, gsize blob_len,
					  GError * *error);
extern GDBusMessage *g_dbus_message_copy(GDBusMessage * message,
					 GError * *error);
extern const char *g_dbus_message_get_arg0(GDBusMessage * message);
extern GVariant *g_dbus_message_get_body(GDBusMessage * message);
extern GDBusMessageByteOrder g_dbus_message_get_byte_order(GDBusMessage *
							   message);
extern const char *g_dbus_message_get_destination(GDBusMessage * message);
extern const char *g_dbus_message_get_error_name(GDBusMessage * message);
extern GDBusMessageFlags g_dbus_message_get_flags(GDBusMessage * message);
extern GVariant *g_dbus_message_get_header(GDBusMessage * message,
					   GDBusMessageHeaderField
					   header_field);
extern guchar *g_dbus_message_get_header_fields(GDBusMessage * message);
extern const char *g_dbus_message_get_interface(GDBusMessage * message);
extern gboolean g_dbus_message_get_locked(GDBusMessage * message);
extern const char *g_dbus_message_get_member(GDBusMessage * message);
extern GDBusMessageType g_dbus_message_get_message_type(GDBusMessage *
							message);
extern guint32 g_dbus_message_get_num_unix_fds(GDBusMessage * message);
extern const char *g_dbus_message_get_path(GDBusMessage * message);
extern guint32 g_dbus_message_get_reply_serial(GDBusMessage * message);
extern const char *g_dbus_message_get_sender(GDBusMessage * message);
extern guint32 g_dbus_message_get_serial(GDBusMessage * message);
extern const char *g_dbus_message_get_signature(GDBusMessage * message);
extern GType g_dbus_message_get_type(void);
extern GUnixFDList *g_dbus_message_get_unix_fd_list(GDBusMessage *
						    message);
extern void g_dbus_message_lock(GDBusMessage * message);
extern GDBusMessage *g_dbus_message_new(void);
extern GDBusMessage *g_dbus_message_new_from_blob(guchar * blob,
						  gsize blob_len,
						  GDBusCapabilityFlags
						  capabilities,
						  GError * *error);
extern GDBusMessage *g_dbus_message_new_method_call(const gchar * name,
						    const gchar * path,
						    const gchar *
						    interface_,
						    const gchar * method);
extern GDBusMessage *g_dbus_message_new_method_error(GDBusMessage *
						     method_call_message,
						     const gchar *
						     error_name,
						     const gchar *
						     error_message_format,
						     ...);
extern GDBusMessage *g_dbus_message_new_method_error_literal(GDBusMessage *
							     method_call_message,
							     const gchar *
							     error_name,
							     const gchar *
							     error_message);
extern GDBusMessage *g_dbus_message_new_method_error_valist(GDBusMessage *
							    method_call_message,
							    const gchar *
							    error_name,
							    const gchar *
							    error_message_format,
							    va_list
							    var_args);
extern GDBusMessage *g_dbus_message_new_method_reply(GDBusMessage *
						     method_call_message);
extern GDBusMessage *g_dbus_message_new_signal(const gchar * path,
					       const gchar * interface_,
					       const gchar * signal);
extern gchar *g_dbus_message_print(GDBusMessage * message, guint indent);
extern void g_dbus_message_set_body(GDBusMessage * message,
				    GVariant * body);
extern void g_dbus_message_set_byte_order(GDBusMessage * message,
					  GDBusMessageByteOrder
					  byte_order);
extern void g_dbus_message_set_destination(GDBusMessage * message,
					   const gchar * value);
extern void g_dbus_message_set_error_name(GDBusMessage * message,
					  const gchar * value);
extern void g_dbus_message_set_flags(GDBusMessage * message,
				     GDBusMessageFlags flags);
extern void g_dbus_message_set_header(GDBusMessage * message,
				      GDBusMessageHeaderField header_field,
				      GVariant * value);
extern void g_dbus_message_set_interface(GDBusMessage * message,
					 const gchar * value);
extern void g_dbus_message_set_member(GDBusMessage * message,
				      const gchar * value);
extern void g_dbus_message_set_message_type(GDBusMessage * message,
					    GDBusMessageType type);
extern void g_dbus_message_set_num_unix_fds(GDBusMessage * message,
					    guint32 value);
extern void g_dbus_message_set_path(GDBusMessage * message,
				    const gchar * value);
extern void g_dbus_message_set_reply_serial(GDBusMessage * message,
					    guint32 value);
extern void g_dbus_message_set_sender(GDBusMessage * message,
				      const gchar * value);
extern void g_dbus_message_set_serial(GDBusMessage * message,
				      guint32 serial);
extern void g_dbus_message_set_signature(GDBusMessage * message,
					 const gchar * value);
extern void g_dbus_message_set_unix_fd_list(GDBusMessage * message,
					    GUnixFDList * fd_list);
extern guchar *g_dbus_message_to_blob(GDBusMessage * message,
				      gsize * out_size,
				      GDBusCapabilityFlags capabilities,
				      GError * *error);
extern gboolean g_dbus_message_to_gerror(GDBusMessage * message,
					 GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41039"
>17.12.41. glib-2.0/gio/gdbusmethodinvocation.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_METHOD_INVOCATION	(g_dbus_method_invocation_get_type ())
#define G_DBUS_METHOD_INVOCATION(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_METHOD_INVOCATION, GDBusMethodInvocation))
#define G_IS_DBUS_METHOD_INVOCATION(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_METHOD_INVOCATION))

extern GDBusConnection
    *g_dbus_method_invocation_get_connection(GDBusMethodInvocation *
					     invocation);
extern const char
    *g_dbus_method_invocation_get_interface_name(GDBusMethodInvocation *
						 invocation);
extern GDBusMessage
    *g_dbus_method_invocation_get_message(GDBusMethodInvocation *
					  invocation);
extern const GDBusMethodInfo
    *g_dbus_method_invocation_get_method_info(GDBusMethodInvocation *
					      invocation);
extern const char
    *g_dbus_method_invocation_get_method_name(GDBusMethodInvocation *
					      invocation);
extern const char
    *g_dbus_method_invocation_get_object_path(GDBusMethodInvocation *
					      invocation);
extern GVariant
    *g_dbus_method_invocation_get_parameters(GDBusMethodInvocation *
					     invocation);
extern const char
    *g_dbus_method_invocation_get_sender(GDBusMethodInvocation *
					 invocation);
extern GType g_dbus_method_invocation_get_type(void);
extern gpointer
g_dbus_method_invocation_get_user_data(GDBusMethodInvocation * invocation);
extern void
g_dbus_method_invocation_return_dbus_error(GDBusMethodInvocation *
					   invocation,
					   const gchar * error_name,
					   const gchar * error_message);
extern void g_dbus_method_invocation_return_error(GDBusMethodInvocation *
						  invocation,
						  GQuark domain, gint code,
						  const gchar * format,
						  ...);
extern void
g_dbus_method_invocation_return_error_literal(GDBusMethodInvocation *
					      invocation, GQuark domain,
					      gint code,
					      const gchar * message);
extern void
g_dbus_method_invocation_return_error_valist(GDBusMethodInvocation *
					     invocation, GQuark domain,
					     gint code,
					     const gchar * format,
					     va_list var_args);
extern void g_dbus_method_invocation_return_gerror(GDBusMethodInvocation *
						   invocation,
						   const GError * error);
extern void g_dbus_method_invocation_return_value(GDBusMethodInvocation *
						  invocation,
						  GVariant * parameters);
extern void
g_dbus_method_invocation_return_value_with_unix_fd_list
(GDBusMethodInvocation * invocation, GVariant * parameters, GUnixFDList * fd_list);
extern void g_dbus_method_invocation_take_error(GDBusMethodInvocation *
						invocation,
						GError * error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41043"
>17.12.42. glib-2.0/gio/gdbusnameowning.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef void (*GBusAcquiredCallback) (GDBusConnection * connection,
				      const gchar * name,
				      gpointer user_data);
typedef void (*GBusNameAcquiredCallback) (GDBusConnection * connection,
					  const gchar * name,
					  gpointer user_data);
typedef void (*GBusNameLostCallback) (GDBusConnection * connection,
				      const gchar * name,
				      gpointer user_data);
extern guint g_bus_own_name(GBusType bus_type, const gchar * name,
			    GBusNameOwnerFlags flags,
			    GBusAcquiredCallback bus_acquired_handler,
			    GBusNameAcquiredCallback name_acquired_handler,
			    GBusNameLostCallback name_lost_handler,
			    gpointer user_data,
			    GDestroyNotify user_data_free_func);
extern guint g_bus_own_name_on_connection(GDBusConnection * connection,
					  const gchar * name,
					  GBusNameOwnerFlags flags,
					  GBusNameAcquiredCallback
					  name_acquired_handler,
					  GBusNameLostCallback
					  name_lost_handler,
					  gpointer user_data,
					  GDestroyNotify
					  user_data_free_func);
extern guint g_bus_own_name_on_connection_with_closures(GDBusConnection *
							connection,
							const gchar * name,
							GBusNameOwnerFlags
							flags,
							GClosure *
							name_acquired_closure,
							GClosure *
							name_lost_closure);
extern guint g_bus_own_name_with_closures(GBusType bus_type,
					  const gchar * name,
					  GBusNameOwnerFlags flags,
					  GClosure * bus_acquired_closure,
					  GClosure * name_acquired_closure,
					  GClosure * name_lost_closure);
extern void g_bus_unown_name(guint owner_id);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41047"
>17.12.43. glib-2.0/gio/gdbusnamewatching.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef void (*GBusNameAppearedCallback) (GDBusConnection * connection,
					  const gchar * name,
					  const gchar * name_owner,
					  gpointer user_data);
typedef void (*GBusNameVanishedCallback) (GDBusConnection * connection,
					  const gchar * name,
					  gpointer user_data);
extern void g_bus_unwatch_name(guint watcher_id);
extern guint g_bus_watch_name(GBusType bus_type, const gchar * name,
			      GBusNameWatcherFlags flags,
			      GBusNameAppearedCallback
			      name_appeared_handler,
			      GBusNameVanishedCallback
			      name_vanished_handler, gpointer user_data,
			      GDestroyNotify user_data_free_func);
extern guint g_bus_watch_name_on_connection(GDBusConnection * connection,
					    const gchar * name,
					    GBusNameWatcherFlags flags,
					    GBusNameAppearedCallback
					    name_appeared_handler,
					    GBusNameVanishedCallback
					    name_vanished_handler,
					    gpointer user_data,
					    GDestroyNotify
					    user_data_free_func);
extern guint g_bus_watch_name_on_connection_with_closures(GDBusConnection *
							  connection,
							  const gchar *
							  name,
							  GBusNameWatcherFlags
							  flags,
							  GClosure *
							  name_appeared_closure,
							  GClosure *
							  name_vanished_closure);
extern guint g_bus_watch_name_with_closures(GBusType bus_type,
					    const gchar * name,
					    GBusNameWatcherFlags flags,
					    GClosure *
					    name_appeared_closure,
					    GClosure *
					    name_vanished_closure);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41051"
>17.12.44. glib-2.0/gio/gdbusobject.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_OBJECT	(g_dbus_object_get_type())
#define G_DBUS_OBJECT(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT, GDBusObject))
#define G_IS_DBUS_OBJECT(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT))
#define G_DBUS_OBJECT_GET_IFACE(o)	(G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_OBJECT, GDBusObjectIface))

typedef struct _GDBusObjectIface {
    GTypeInterface parent_iface;
    const gchar *(*get_object_path) (GDBusObject * object);
    GList *(*get_interfaces) (GDBusObject * object);
    GDBusInterface *(*get_interface) (GDBusObject * object,
				      const gchar * interface_name);
    void (*interface_added) (GDBusObject * object,
			     GDBusInterface * interface_);
    void (*interface_removed) (GDBusObject * object,
			       GDBusInterface * interface_);
} GDBusObjectIface;
extern GDBusInterface *g_dbus_object_get_interface(GDBusObject * object,
						   const gchar *
						   interface_name);
extern GList *g_dbus_object_get_interfaces(GDBusObject * object);
extern const char *g_dbus_object_get_object_path(GDBusObject * object);
extern GType g_dbus_object_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41055"
>17.12.45. glib-2.0/gio/gdbusobjectmanager.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_OBJECT_MANAGER	(g_dbus_object_manager_get_type())
#define G_DBUS_OBJECT_MANAGER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManager))
#define G_IS_DBUS_OBJECT_MANAGER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER))
#define G_DBUS_OBJECT_MANAGER_GET_IFACE(o)	(G_TYPE_INSTANCE_GET_INTERFACE((o), G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManagerIface))

typedef struct _GDBusObjectManagerIface {
    GTypeInterface parent_iface;
    const gchar *(*get_object_path) (GDBusObjectManager * manager);
    GList *(*get_objects) (GDBusObjectManager * manager);
    GDBusObject *(*get_object) (GDBusObjectManager * manager,
				const gchar * object_path);
    GDBusInterface *(*get_interface) (GDBusObjectManager * manager,
				      const gchar * object_path,
				      const gchar * interface_name);
    void (*object_added) (GDBusObjectManager * manager,
			  GDBusObject * object);
    void (*object_removed) (GDBusObjectManager * manager,
			    GDBusObject * object);
    void (*interface_added) (GDBusObjectManager * manager,
			     GDBusObject * object,
			     GDBusInterface * interface_);
    void (*interface_removed) (GDBusObjectManager * manager,
			       GDBusObject * object,
			       GDBusInterface * interface_);
} GDBusObjectManagerIface;
extern GDBusInterface
    *g_dbus_object_manager_get_interface(GDBusObjectManager * manager,
					 const gchar * object_path,
					 const gchar * interface_name);
extern GDBusObject *g_dbus_object_manager_get_object(GDBusObjectManager *
						     manager,
						     const gchar *
						     object_path);
extern const char *g_dbus_object_manager_get_object_path(GDBusObjectManager
							 * manager);
extern GList *g_dbus_object_manager_get_objects(GDBusObjectManager *
						manager);
extern GType g_dbus_object_manager_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41059"
>17.12.46. glib-2.0/gio/gdbusobjectmanagerclient.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT	(g_dbus_object_manager_client_get_type ())
#define G_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass))
#define G_IS_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT))
#define G_DBUS_OBJECT_MANAGER_CLIENT(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClient))
#define G_IS_DBUS_OBJECT_MANAGER_CLIENT(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT))
#define G_DBUS_OBJECT_MANAGER_CLIENT_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass))

typedef struct _GDBusObjectManagerClientClass {
    GObjectClass parent_class;
    void (*interface_proxy_signal) (GDBusObjectManagerClient * manager,
				    GDBusObjectProxy * object_proxy,
				    GDBusProxy * interface_proxy,
				    const gchar * sender_name,
				    const gchar * signal_name,
				    GVariant * parameters);
    void (*interface_proxy_properties_changed) (GDBusObjectManagerClient *
						manager,
						GDBusObjectProxy *
						object_proxy,
						GDBusProxy *
						interface_proxy,
						GVariant *
						changed_properties,
						const gchar *
						const
						*invalidated_properties);
    gpointer padding[8];
} GDBusObjectManagerClientClass;
typedef struct _GDBusObjectManagerClientPrivate
    GDBusObjectManagerClientPrivate;
struct _GDBusObjectManagerClient {
    GObject parent_instance;
    GDBusObjectManagerClientPrivate *priv;
};
extern GDBusConnection
    *g_dbus_object_manager_client_get_connection(GDBusObjectManagerClient *
						 manager);
extern GDBusObjectManagerClientFlags
g_dbus_object_manager_client_get_flags(GDBusObjectManagerClient * manager);
extern const char
    *g_dbus_object_manager_client_get_name(GDBusObjectManagerClient *
					   manager);
extern gchar
    *g_dbus_object_manager_client_get_name_owner(GDBusObjectManagerClient *
						 manager);
extern GType g_dbus_object_manager_client_get_type(void);
extern void g_dbus_object_manager_client_new(GDBusConnection * connection,
					     GDBusObjectManagerClientFlags
					     flags, const gchar * name,
					     const gchar * object_path,
					     GDBusProxyTypeFunc
					     get_proxy_type_func,
					     gpointer
					     get_proxy_type_user_data,
					     GDestroyNotify
					     get_proxy_type_destroy_notify,
					     GCancellable * cancellable,
					     GAsyncReadyCallback callback,
					     gpointer user_data);
extern GDBusObjectManager
    *g_dbus_object_manager_client_new_finish(GAsyncResult * res,
					     GError * *error);
extern void g_dbus_object_manager_client_new_for_bus(GBusType bus_type,
						     GDBusObjectManagerClientFlags
						     flags,
						     const gchar * name,
						     const gchar *
						     object_path,
						     GDBusProxyTypeFunc
						     get_proxy_type_func,
						     gpointer
						     get_proxy_type_user_data,
						     GDestroyNotify
						     get_proxy_type_destroy_notify,
						     GCancellable *
						     cancellable,
						     GAsyncReadyCallback
						     callback,
						     gpointer user_data);
extern GDBusObjectManager
    *g_dbus_object_manager_client_new_for_bus_finish(GAsyncResult * res,
						     GError * *error);
extern GDBusObjectManager
    *g_dbus_object_manager_client_new_for_bus_sync(GBusType bus_type,
						   GDBusObjectManagerClientFlags
						   flags,
						   const gchar * name,
						   const gchar *
						   object_path,
						   GDBusProxyTypeFunc
						   get_proxy_type_func,
						   gpointer
						   get_proxy_type_user_data,
						   GDestroyNotify
						   get_proxy_type_destroy_notify,
						   GCancellable *
						   cancellable,
						   GError * *error);
extern GDBusObjectManager
    *g_dbus_object_manager_client_new_sync(GDBusConnection * connection,
					   GDBusObjectManagerClientFlags
					   flags, const gchar * name,
					   const gchar * object_path,
					   GDBusProxyTypeFunc
					   get_proxy_type_func,
					   gpointer
					   get_proxy_type_user_data,
					   GDestroyNotify
					   get_proxy_type_destroy_notify,
					   GCancellable * cancellable,
					   GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41063"
>17.12.47. glib-2.0/gio/gdbusobjectmanagerserver.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_OBJECT_MANAGER_SERVER	(g_dbus_object_manager_server_get_type ())
#define G_DBUS_OBJECT_MANAGER_SERVER_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass))
#define G_IS_DBUS_OBJECT_MANAGER_SERVER_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_MANAGER_SERVER))
#define G_DBUS_OBJECT_MANAGER_SERVER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServer))
#define G_IS_DBUS_OBJECT_MANAGER_SERVER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER))
#define G_DBUS_OBJECT_MANAGER_SERVER_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass))

typedef struct _GDBusObjectManagerServerClass {
    GObjectClass parent_class;
    gpointer padding[8];
} GDBusObjectManagerServerClass;
typedef struct _GDBusObjectManagerServerPrivate
    GDBusObjectManagerServerPrivate;
struct _GDBusObjectManagerServer {
    GObject parent_instance;
    GDBusObjectManagerServerPrivate *priv;
};
extern void g_dbus_object_manager_server_export(GDBusObjectManagerServer *
						manager,
						GDBusObjectSkeleton *
						object);
extern void
g_dbus_object_manager_server_export_uniquely(GDBusObjectManagerServer *
					     manager,
					     GDBusObjectSkeleton * object);
extern GDBusConnection
    *g_dbus_object_manager_server_get_connection(GDBusObjectManagerServer *
						 manager);
extern GType g_dbus_object_manager_server_get_type(void);
extern GDBusObjectManagerServer *g_dbus_object_manager_server_new(const
								  gchar *
								  object_path);
extern void
g_dbus_object_manager_server_set_connection(GDBusObjectManagerServer *
					    manager,
					    GDBusConnection * connection);
extern gboolean
g_dbus_object_manager_server_unexport(GDBusObjectManagerServer * manager,
				      const gchar * object_path);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41067"
>17.12.48. glib-2.0/gio/gdbusobjectproxy.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_OBJECT_PROXY	(g_dbus_object_proxy_get_type ())
#define G_DBUS_OBJECT_PROXY_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass))
#define G_IS_DBUS_OBJECT_PROXY_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_PROXY))
#define G_DBUS_OBJECT_PROXY(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxy))
#define G_IS_DBUS_OBJECT_PROXY(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_PROXY))
#define G_DBUS_OBJECT_PROXY_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass))

typedef struct _GDBusObjectProxyClass {
    GObjectClass parent_class;
    gpointer padding[8];
} GDBusObjectProxyClass;
typedef struct _GDBusObjectProxyPrivate GDBusObjectProxyPrivate;
struct _GDBusObjectProxy {
    GObject parent_instance;
    GDBusObjectProxyPrivate *priv;
};
extern GDBusConnection *g_dbus_object_proxy_get_connection(GDBusObjectProxy
							   * proxy);
extern GType g_dbus_object_proxy_get_type(void);
extern GDBusObjectProxy *g_dbus_object_proxy_new(GDBusConnection *
						 connection,
						 const gchar *
						 object_path);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41071"
>17.12.49. glib-2.0/gio/gdbusobjectskeleton.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_OBJECT_SKELETON	(g_dbus_object_skeleton_get_type ())
#define G_DBUS_OBJECT_SKELETON_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass))
#define G_IS_DBUS_OBJECT_SKELETON_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_OBJECT_SKELETON))
#define G_DBUS_OBJECT_SKELETON(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeleton))
#define G_IS_DBUS_OBJECT_SKELETON(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_OBJECT_SKELETON))
#define G_DBUS_OBJECT_SKELETON_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass))

typedef struct _GDBusObjectSkeletonClass {
    GObjectClass parent_class;
     gboolean(*authorize_method) (GDBusObjectSkeleton * object,
				  GDBusInterfaceSkeleton * interface_,
				  GDBusMethodInvocation * invocation);
    gpointer padding[8];
} GDBusObjectSkeletonClass;
typedef struct _GDBusObjectSkeletonPrivate GDBusObjectSkeletonPrivate;
struct _GDBusObjectSkeleton {
    GObject parent_instance;
    GDBusObjectSkeletonPrivate *priv;
};
extern void g_dbus_object_skeleton_add_interface(GDBusObjectSkeleton *
						 object,
						 GDBusInterfaceSkeleton *
						 interface_);
extern void g_dbus_object_skeleton_flush(GDBusObjectSkeleton * object);
extern GType g_dbus_object_skeleton_get_type(void);
extern GDBusObjectSkeleton *g_dbus_object_skeleton_new(const gchar *
						       object_path);
extern void g_dbus_object_skeleton_remove_interface(GDBusObjectSkeleton *
						    object,
						    GDBusInterfaceSkeleton
						    * interface_);
extern void
g_dbus_object_skeleton_remove_interface_by_name(GDBusObjectSkeleton *
						object,
						const gchar *
						interface_name);
extern void g_dbus_object_skeleton_set_object_path(GDBusObjectSkeleton *
						   object,
						   const gchar *
						   object_path);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41075"
>17.12.50. glib-2.0/gio/gdbusproxy.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_PROXY	(g_dbus_proxy_get_type ())
#define G_DBUS_PROXY_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_DBUS_PROXY, GDBusProxyClass))
#define G_IS_DBUS_PROXY_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_DBUS_PROXY))
#define G_DBUS_PROXY(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_PROXY, GDBusProxy))
#define G_IS_DBUS_PROXY(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_PROXY))
#define G_DBUS_PROXY_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_DBUS_PROXY, GDBusProxyClass))

typedef struct _GDBusProxyClass {
    GObjectClass parent_class;
    void (*g_properties_changed) (GDBusProxy * proxy,
				  GVariant * changed_properties,
				  const gchar *
				  const *invalidated_properties);
    void (*g_signal) (GDBusProxy * proxy, const gchar * sender_name,
		      const gchar * signal_name, GVariant * parameters);
    gpointer padding[32];
} GDBusProxyClass;
typedef struct _GDBusProxyPrivate GDBusProxyPrivate;
struct _GDBusProxy {
    GObject parent_instance;
    GDBusProxyPrivate *priv;
};
extern void g_dbus_proxy_call(GDBusProxy * proxy,
			      const gchar * method_name,
			      GVariant * parameters, GDBusCallFlags flags,
			      gint timeout_msec,
			      GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
extern GVariant *g_dbus_proxy_call_finish(GDBusProxy * proxy,
					  GAsyncResult * res,
					  GError * *error);
extern GVariant *g_dbus_proxy_call_sync(GDBusProxy * proxy,
					const gchar * method_name,
					GVariant * parameters,
					GDBusCallFlags flags,
					gint timeout_msec,
					GCancellable * cancellable,
					GError * *error);
extern void g_dbus_proxy_call_with_unix_fd_list(GDBusProxy * proxy,
						const gchar * method_name,
						GVariant * parameters,
						GDBusCallFlags flags,
						gint timeout_msec,
						GUnixFDList * fd_list,
						GCancellable * cancellable,
						GAsyncReadyCallback
						callback,
						gpointer user_data);
extern GVariant *g_dbus_proxy_call_with_unix_fd_list_finish(GDBusProxy *
							    proxy,
							    GUnixFDList *
							    *out_fd_list,
							    GAsyncResult *
							    res,
							    GError *
							    *error);
extern GVariant *g_dbus_proxy_call_with_unix_fd_list_sync(GDBusProxy *
							  proxy,
							  const gchar *
							  method_name,
							  GVariant *
							  parameters,
							  GDBusCallFlags
							  flags,
							  gint
							  timeout_msec,
							  GUnixFDList *
							  fd_list,
							  GUnixFDList *
							  *out_fd_list,
							  GCancellable *
							  cancellable,
							  GError * *error);
extern GVariant *g_dbus_proxy_get_cached_property(GDBusProxy * proxy,
						  const gchar *
						  property_name);
extern gchar **g_dbus_proxy_get_cached_property_names(GDBusProxy * proxy);
extern GDBusConnection *g_dbus_proxy_get_connection(GDBusProxy * proxy);
extern gint g_dbus_proxy_get_default_timeout(GDBusProxy * proxy);
extern GDBusProxyFlags g_dbus_proxy_get_flags(GDBusProxy * proxy);
extern GDBusInterfaceInfo *g_dbus_proxy_get_interface_info(GDBusProxy *
							   proxy);
extern const char *g_dbus_proxy_get_interface_name(GDBusProxy * proxy);
extern const char *g_dbus_proxy_get_name(GDBusProxy * proxy);
extern gchar *g_dbus_proxy_get_name_owner(GDBusProxy * proxy);
extern const char *g_dbus_proxy_get_object_path(GDBusProxy * proxy);
extern GType g_dbus_proxy_get_type(void);
extern void g_dbus_proxy_new(GDBusConnection * connection,
			     GDBusProxyFlags flags,
			     GDBusInterfaceInfo * info, const gchar * name,
			     const gchar * object_path,
			     const gchar * interface_name,
			     GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
extern GDBusProxy *g_dbus_proxy_new_finish(GAsyncResult * res,
					   GError * *error);
extern void g_dbus_proxy_new_for_bus(GBusType bus_type,
				     GDBusProxyFlags flags,
				     GDBusInterfaceInfo * info,
				     const gchar * name,
				     const gchar * object_path,
				     const gchar * interface_name,
				     GCancellable * cancellable,
				     GAsyncReadyCallback callback,
				     gpointer user_data);
extern GDBusProxy *g_dbus_proxy_new_for_bus_finish(GAsyncResult * res,
						   GError * *error);
extern GDBusProxy *g_dbus_proxy_new_for_bus_sync(GBusType bus_type,
						 GDBusProxyFlags flags,
						 GDBusInterfaceInfo * info,
						 const gchar * name,
						 const gchar * object_path,
						 const gchar *
						 interface_name,
						 GCancellable *
						 cancellable,
						 GError * *error);
extern GDBusProxy *g_dbus_proxy_new_sync(GDBusConnection * connection,
					 GDBusProxyFlags flags,
					 GDBusInterfaceInfo * info,
					 const gchar * name,
					 const gchar * object_path,
					 const gchar * interface_name,
					 GCancellable * cancellable,
					 GError * *error);
extern void g_dbus_proxy_set_cached_property(GDBusProxy * proxy,
					     const gchar * property_name,
					     GVariant * value);
extern void g_dbus_proxy_set_default_timeout(GDBusProxy * proxy,
					     gint timeout_msec);
extern void g_dbus_proxy_set_interface_info(GDBusProxy * proxy,
					    GDBusInterfaceInfo * info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41079"
>17.12.51. glib-2.0/gio/gdbusserver.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DBUS_SERVER	(g_dbus_server_get_type ())
#define G_DBUS_SERVER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_DBUS_SERVER, GDBusServer))
#define G_IS_DBUS_SERVER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_DBUS_SERVER))

extern const char *g_dbus_server_get_client_address(GDBusServer * server);
extern GDBusServerFlags g_dbus_server_get_flags(GDBusServer * server);
extern const char *g_dbus_server_get_guid(GDBusServer * server);
extern GType g_dbus_server_get_type(void);
extern gboolean g_dbus_server_is_active(GDBusServer * server);
extern GDBusServer *g_dbus_server_new_sync(const gchar * address,
					   GDBusServerFlags flags,
					   const gchar * guid,
					   GDBusAuthObserver * observer,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_dbus_server_start(GDBusServer * server);
extern void g_dbus_server_stop(GDBusServer * server);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41083"
>17.12.52. glib-2.0/gio/gdbusutils.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern gchar *g_dbus_generate_guid(void);
extern GVariant *g_dbus_gvalue_to_gvariant(const GValue * gvalue,
					   const GVariantType * type);
extern void g_dbus_gvariant_to_gvalue(GVariant * value,
				      GValue * out_gvalue);
extern gboolean g_dbus_is_guid(const gchar * string);
extern gboolean g_dbus_is_interface_name(const gchar * string);
extern gboolean g_dbus_is_member_name(const gchar * string);
extern gboolean g_dbus_is_name(const gchar * string);
extern gboolean g_dbus_is_unique_name(const gchar * string);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41087"
>17.12.53. glib-2.0/gio/gdrive.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_DRIVE	(g_drive_get_type ())
#define G_DRIVE(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DRIVE, GDrive))
#define G_IS_DRIVE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DRIVE))
#define G_DRIVE_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DRIVE, GDriveIface))

typedef struct _GDriveIface {
    GTypeInterface g_iface;
    void (*changed) (GDrive * drive);
    void (*disconnected) (GDrive * drive);
    void (*eject_button) (GDrive * drive);
    char *(*get_name) (GDrive * drive);
    GIcon *(*get_icon) (GDrive * drive);
     gboolean(*has_volumes) (GDrive * drive);
    GList *(*get_volumes) (GDrive * drive);
     gboolean(*is_media_removable) (GDrive * drive);
     gboolean(*has_media) (GDrive * drive);
     gboolean(*is_media_check_automatic) (GDrive * drive);
     gboolean(*can_eject) (GDrive * drive);
     gboolean(*can_poll_for_media) (GDrive * drive);
    void (*eject) (GDrive * drive, GMountUnmountFlags flags,
		   GCancellable * cancellable,
		   GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*eject_finish) (GDrive * drive, GAsyncResult * result,
			      GError * *error);
    void (*poll_for_media) (GDrive * drive, GCancellable * cancellable,
			    GAsyncReadyCallback callback,
			    gpointer user_data);
     gboolean(*poll_for_media_finish) (GDrive * drive,
				       GAsyncResult * result,
				       GError * *error);
    char *(*get_identifier) (GDrive * drive, const char *kind);
    char **(*enumerate_identifiers) (GDrive * drive);
     GDriveStartStopType(*get_start_stop_type) (GDrive * drive);
     gboolean(*can_start) (GDrive * drive);
     gboolean(*can_start_degraded) (GDrive * drive);
    void (*start) (GDrive * drive, GDriveStartFlags flags,
		   GMountOperation mount_operation,
		   GCancellable * cancellable,
		   GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*start_finish) (GDrive * drive, GAsyncResult * result,
			      GError * *error);
     gboolean(*can_stop) (GDrive * drive);
    void (*stop) (GDrive * drive, GMountUnmountFlags flags,
		  GMountOperation * mount_operation,
		  GCancellable * cancellable, GAsyncReadyCallback callback,
		  gpointer user_data);
     gboolean(*stop_finish) (GDrive * drive, GAsyncResult * result,
			     GError * *error);
    void (*stop_button) (GDrive * drive);
    void (*eject_with_operation) (GDrive * drive, GMountUnmountFlags flags,
				  GMountOperation * mount_operation,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
     gboolean(*eject_with_operation_finish) (GDrive * drive,
					     GAsyncResult * result,
					     GError * *error);
    const gchar *(*get_sort_key) (GDrive * drive);
} GDriveIface;
extern gboolean g_drive_can_eject(GDrive * drive);
extern gboolean g_drive_can_poll_for_media(GDrive * drive);
extern gboolean g_drive_can_start(GDrive * drive);
extern gboolean g_drive_can_start_degraded(GDrive * drive);
extern gboolean g_drive_can_stop(GDrive * drive);
extern void g_drive_eject(GDrive * drive, GMountUnmountFlags flags,
			  GCancellable * cancellable,
			  GAsyncReadyCallback callback,
			  gpointer user_data);
extern gboolean g_drive_eject_finish(GDrive * drive, GAsyncResult * result,
				     GError * *error);
extern void g_drive_eject_with_operation(GDrive * drive,
					 GMountUnmountFlags flags,
					 GMountOperation * mount_operation,
					 GCancellable * cancellable,
					 GAsyncReadyCallback callback,
					 gpointer user_data);
extern gboolean g_drive_eject_with_operation_finish(GDrive * drive,
						    GAsyncResult * result,
						    GError * *error);
extern void g_drive_enumerate_identifiers(GDrive * drive);
extern GIcon *g_drive_get_icon(GDrive * drive);
extern char *g_drive_get_identifier(GDrive * drive, const char *kind);
extern char *g_drive_get_name(GDrive * drive);
extern const char *g_drive_get_sort_key(GDrive * drive);
extern GDriveStartStopType g_drive_get_start_stop_type(GDrive * drive);
extern GType g_drive_get_type(void);
extern GList *g_drive_get_volumes(GDrive * drive);
extern gboolean g_drive_has_media(GDrive * drive);
extern gboolean g_drive_has_volumes(GDrive * drive);
extern gboolean g_drive_is_media_check_automatic(GDrive * drive);
extern gboolean g_drive_is_media_removable(GDrive * drive);
extern void g_drive_poll_for_media(GDrive * drive,
				   GCancellable * cancellable,
				   GAsyncReadyCallback callback,
				   gpointer user_data);
extern gboolean g_drive_poll_for_media_finish(GDrive * drive,
					      GAsyncResult * result,
					      GError * *error);
extern void g_drive_start(GDrive * drive, GDriveStartFlags flags,
			  GMountOperation * mount_operation,
			  GCancellable * cancellable,
			  GAsyncReadyCallback callback,
			  gpointer user_data);
extern gboolean g_drive_start_finish(GDrive * drive, GAsyncResult * result,
				     GError * *error);
extern void g_drive_stop(GDrive * drive, GMountUnmountFlags flags,
			 GMountOperation * mount_operation,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
extern gboolean g_drive_stop_finish(GDrive * drive, GAsyncResult * result,
				    GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41091"
>17.12.54. glib-2.0/gio/gemblem.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_EMBLEM	(g_emblem_get_type ())
#define G_EMBLEM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_EMBLEM, GEmblemClass))
#define G_IS_EMBLEM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_EMBLEM))
#define G_EMBLEM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_EMBLEM, GEmblem))
#define G_IS_EMBLEM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_EMBLEM))
#define G_EMBLEM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_EMBLEM, GEmblemClass))

typedef struct _GEmblem GEmblem;
typedef struct _GEmblemClass GEmblemClass;
extern GIcon *g_emblem_get_icon(GEmblem * emblem);
extern GEmblemOrigin g_emblem_get_origin(GEmblem * emblem);
extern GType g_emblem_get_type(void);
extern GEmblem *g_emblem_new(GIcon * icon);
extern GEmblem *g_emblem_new_with_origin(GIcon * icon,
					 GEmblemOrigin origin);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41095"
>17.12.55. glib-2.0/gio/gemblemedicon.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_EMBLEMED_ICON	(g_emblemed_icon_get_type ())
#define G_EMBLEMED_ICON_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_EMBLEMED_ICON, GEmblemedIconClass))
#define G_IS_EMBLEMED_ICON_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_EMBLEMED_ICON))
#define G_EMBLEMED_ICON(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_EMBLEMED_ICON, GEmblemedIcon))
#define G_IS_EMBLEMED_ICON(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_EMBLEMED_ICON))
#define G_EMBLEMED_ICON_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_EMBLEMED_ICON, GEmblemedIconClass))

typedef struct _GEmblemedIcon {
    GObject parent_instance;
    GEmblemedIconPrivate *priv;
} GEmblemedIcon;
typedef struct _GEmblemedIconClass {
    GObjectClass parent_class;
} GEmblemedIconClass;
typedef struct _GEmblemedIconPrivate GEmblemedIconPrivate;
extern void g_emblemed_icon_add_emblem(GEmblemedIcon * emblemed,
				       GEmblem * emblem);
extern void g_emblemed_icon_clear_emblems(GEmblemedIcon * emblemed);
extern GList *g_emblemed_icon_get_emblems(GEmblemedIcon * emblemed);
extern GIcon *g_emblemed_icon_get_icon(GEmblemedIcon * emblemed);
extern GType g_emblemed_icon_get_type(void);
extern GIcon *g_emblemed_icon_new(GIcon * icon, GEmblem * emblem);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41099"
>17.12.56. glib-2.0/gio/gfile.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE	(g_file_get_type ())
#define G_FILE(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_FILE, GFile))
#define G_IS_FILE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_FILE))
#define G_FILE_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_FILE, GFileIface))

struct _GFileIface {
    GTypeInterface g_iface;
    GFile *(*dup) (GFile * file);
     guint(*hash) (GFile * file);
     gboolean(*equal) (GFile * file1, GFile * file2);
     gboolean(*is_native) (GFile * file);
     gboolean(*has_uri_scheme) (GFile * file, const char *uri_scheme);
    char *(*get_uri_scheme) (GFile * file);
    char *(*get_basename) (GFile * file);
    char *(*get_path) (GFile * file);
    char *(*get_uri) (GFile * file);
    char *(*get_parse_name) (GFile * file);
    GFile *(*get_parent) (GFile * file);
     gboolean(*prefix_matches) (GFile * prefix, GFile * file);
    char *(*get_relative_path) (GFile * parent, GFile * descendant);
    GFile *(*resolve_relative_path) (GFile * file,
				     const char *relative_path);
    GFile *(*get_child_for_display_name) (GFile * file,
					  const char *display_name,
					  GError * *error);
    GFileEnumerator *(*enumerate_children) (GFile * file,
					    const char *attributes,
					    GFileQueryInfoFlags flags,
					    GCancellable * cancellable,
					    GError * *error);
    void (*enumerate_children_async) (GFile * file, const char *attributes,
				      GFileQueryInfoFlags flags,
				      int io_priority,
				      GCancellable * cancellable,
				      GAsyncReadyCallback callback,
				      gpointer user_data);
    GFileEnumerator *(*enumerate_children_finish) (GFile * file,
						   GAsyncResult * res,
						   GError * *error);
    GFileInfo *(*query_info) (GFile * file, const char *attributes,
			      GFileQueryInfoFlags flags,
			      GCancellable * cancellable, GError * *error);
    void (*query_info_async) (GFile * file, const char *attributes,
			      GFileQueryInfoFlags flags, int io_priority,
			      GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
    GFileInfo *(*query_info_finish) (GFile * file, GAsyncResult * res,
				     GError * *error);
    GFileInfo *(*query_filesystem_info) (GFile * file,
					 const char *attributes,
					 GCancellable * cancellable,
					 GError * *error);
    void (*query_filesystem_info_async) (GFile * file,
					 const char *attributes,
					 int io_priority,
					 GCancellable * cancellable,
					 GAsyncReadyCallback callback,
					 gpointer user_data);
    GFileInfo *(*query_filesystem_info_finish) (GFile * file,
						GAsyncResult * res,
						GError * *error);
    GMount *(*find_enclosing_mount) (GFile * file,
				     GCancellable * cancellable,
				     GError * *error);
    void (*find_enclosing_mount_async) (GFile * file, int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
    GMount *(*find_enclosing_mount_finish) (GFile * file,
					    GAsyncResult * res,
					    GError * *error);
    GFile *(*set_display_name) (GFile * file, const char *display_name,
				GCancellable * cancellable,
				GError * *error);
    void (*set_display_name_async) (const char *display_name,
				    int io_priority,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
    GFile *(*set_display_name_finish) (GFile * file, GAsyncResult * res,
				       GError * *error);
    GFileAttributeInfoList *(*query_settable_attributes) (GFile * file,
							  GCancellable *
							  cancellable,
							  GError * *error);
    void (*_query_settable_attributes_async) (void);
    void (*_query_settable_attributes_finish) (void);
    GFileAttributeInfoList *(*query_writable_namespaces) (GFile * file,
							  GCancellable *
							  cancellable,
							  GError * *error);
    void (*_query_writable_namespaces_async) (void);
    void (*_query_writable_namespaces_finish) (void);
     gboolean(*set_attribute) (GFile * file, const char *attribute,
			       GFileAttributeType type, gpointer value_p,
			       GFileQueryInfoFlags flags,
			       GCancellable * cancellable,
			       GError * *error);
     gboolean(*set_attributes_from_info) (GFile * file, GFileInfo * info,
					  GFileQueryInfoFlags flags,
					  GCancellable * cancellable,
					  GError * *error);
    void (*set_attributes_async) (GFile * file, GFileInfo * info,
				  GFileQueryInfoFlags flags,
				  int io_priority,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
     gboolean(*set_attributes_finish) (GFile * file, GAsyncResult * result,
				       GFileInfo * *info, GError * *error);
    GFileInputStream *(*read_fn) (GFile * file, GCancellable * cancellable,
				  GError * *error);
    void (*read_async) (GFile * file, int io_priority,
			GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
    GFileInputStream *(*read_finish) (GFile * file, GAsyncResult * res,
				      GError * *error);
    GFileOutputStream *(*append_to) (GFile * file, GFileCreateFlags flags,
				     GCancellable * cancellable,
				     GError * *error);
    void (*append_to_async) (GFile * file, GFileCreateFlags flags,
			     int io_priority, GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
    GFileOutputStream *(*append_to_finish) (GFile * file,
					    GAsyncResult * res,
					    GError * *error);
    GFileOutputStream *(*create) (GFile * file, GFileCreateFlags flags,
				  GCancellable * cancellable,
				  GError * *error);
    void (*create_async) (GFile * file, GFileCreateFlags flags,
			  int io_priority, GCancellable * cancellable,
			  GAsyncReadyCallback callback,
			  gpointer user_data);
    GFileOutputStream *(*create_finish) (GFile * file, GAsyncResult * res,
					 GError * *error);
    GFileOutputStream *(*replace) (GFile * file, const char *etag,
				   gboolean make_backup,
				   GFileCreateFlags flags,
				   GCancellable * cancellable,
				   GError * *error);
    void (*replace_async) (GFile * file, const char *etag,
			   gboolean make_backup, GFileCreateFlags flags,
			   int io_priority, GCancellable * cancellable,
			   GAsyncReadyCallback callback,
			   gpointer user_data);
    GFileOutputStream *(*replace_finish) (GFile * file, GAsyncResult * res,
					  GError * *error);
     gboolean(*delete_file) (GFile * file, GCancellable * cancellable,
			     GError * *error);
    void (*_delete_file_async) (void);
    void (*_delete_file_finish) (void);
     gboolean(*trash) (GFile * file, GCancellable * cancellable,
		       GError * *error);
    void (*_trash_async) (void);
    void (*_trash_finish) (void);
     gboolean(*make_directory) (GFile * file, GCancellable * cancellable,
				GError * *error);
    void (*_make_directory_async) (void);
    void (*_make_directory_finish) (void);
     gboolean(*make_symbolic_link) (GFile * file,
				    const char *symlink_value,
				    GCancellable * cancellable,
				    GError * *error);
    void (*_make_symbolic_link_async) (void);
    void (*_make_symbolic_link_finish) (void);
     gboolean(*copy) (GFile * source, GFile * destination,
		      GFileCopyFlags flags, GCancellable * cancellable,
		      GFileProgressCallback progress_callback,
		      gpointer progress_callback_data, GError * *error);
    void (*copy_async) (GFile * source, GFile * destination,
			GFileCopyFlags flags, int io_priority,
			GCancellable * cancellable,
			GFileProgressCallback progress_callback,
			gpointer progress_callback_data,
			GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*copy_finish) (GFile * file, GAsyncResult * res,
			     GError * *error);
     gboolean(*move) (GFile * source, GFile * destination,
		      GFileCopyFlags flags, GCancellable * cancellable,
		      GFileProgressCallback progress_callback,
		      gpointer progress_callback_data, GError * *error);
    void (*_move_async) (void);
    void (*_move_finish) (void);
    void (*mount_mountable) (GFile * file, GMountMountFlags flags,
			     GMountOperation * mount_operation,
			     GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
    GFile *(*mount_mountable_finish) (GFile * file, GAsyncResult * result,
				      GError * *error);
    void (*unmount_mountable) (GFile * file, GMountMountFlags flags,
			       GCancellable * cancellable,
			       GAsyncReadyCallback callback,
			       gpointer user_data);
     gboolean(*unmount_mountable_finish) (GFile * file,
					  GAsyncResult * result,
					  GError * *error);
    void (*eject_mountable) (GFile * file, GMountMountFlags flags,
			     GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
     gboolean(*eject_mountable_finish) (GFile * file,
					GAsyncResult * result,
					GError * *error);
    void (*mount_enclosing_volume) (GFile * file, GMountMountFlags flags,
				    GMountOperation * mount_operation,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
     gboolean(*mount_enclosing_volume_finish) (GFile * file,
					       GAsyncResult * result,
					       GError * *error);
    GFileMonitor *(*monitor_dir) (GFile * file, GFileMonitorFlags flags,
				  GCancellable * cancellable,
				  GError * *error);
    GFileMonitor *(*monitor_file) (GFile * file, GFileMonitorFlags flags,
				   GCancellable * cancellable,
				   GError * *error);
    GFileIOStream *(*open_readwrite) (GFile * file,
				      GCancellable * cancellable,
				      GError * *error);
    void (*open_readwrite_async) (GFile * file, int io_priority,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
    GFileIOStream *(*open_readwrite_finish) (GFile * file,
					     GAsyncResult * res,
					     GError * *error);
    GFileIOStream *(*create_readwrite) (GFile * file,
					GFileCreateFlags flags,
					GCancellable * cancellable,
					GError * *error);
    void (*create_readwrite_async) (GFile * file, GFileCreateFlags flags,
				    int io_priority,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
    GFileIOStream *(*create_readwrite_finish) (GFile * file,
					       GAsyncResult * res,
					       GError * *error);
    GFileIOStream *(*replace_readwrite) (GFile * file, const char *etag,
					 gboolean make_backup,
					 GFileCreateFlags flags,
					 GCancellable * cancellable,
					 GError * *error);
    void (*replace_readwrite_async) (GFile * file, const char *etag,
				     gboolean make_backup,
				     GFileCreateFlags flags,
				     int io_priority,
				     GCancellable * cancellable,
				     GAsyncReadyCallback callback,
				     gpointer user_data);
    GFileIOStream *(*replace_readwrite_finish) (GFile * file,
						GAsyncResult * res,
						GError * *error);
    void (*start_mountable) (GFile * file, GDriveStartFlags flags,
			     GMountOperation * start_operation,
			     GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
     gboolean(*start_mountable_finish) (GFile * file,
					GAsyncResult * result,
					GError * *error);
    void (*stop_mountable) (GFile * file, GMountUnmountFlags flags,
			    GMountOperation * mount_operation,
			    GCancellable * cancellable,
			    GAsyncReadyCallback callback,
			    gpointer user_data);
     gboolean(*stop_mountable_finish) (GFile * file, GAsyncResult * result,
				       GError * *error);
    gboolean supports_thread_contexts;
    void (*unmount_mountable_with_operation) (GFile * file,
					      GMountUnmountFlags flags,
					      GMountOperation *
					      mount_operation,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
     gboolean(*unmount_mountable_with_operation_finish) (GFile * file,
							 GAsyncResult *
							 result,
							 GError * *error);
    void (*eject_mountable_with_operation) (GFile * file,
					    GMountUnmountFlags flags,
					    GMountOperation *
					    mount_operation,
					    GCancellable * cancellable,
					    GAsyncReadyCallback callback,
					    gpointer user_data);
     gboolean(*eject_mountable_with_operation_finish) (GFile * file,
						       GAsyncResult *
						       result,
						       GError * *error);
    void (*poll_mountable) (GFile * file, GCancellable * cancellable,
			    gpointer user_data);
     gboolean(*poll_mountable_finish) (GFile * file, GAsyncResult * result,
				       GError * *error);
};
extern GFileOutputStream *g_file_append_to(GFile * file,
					   GFileCreateFlags flags,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_file_append_to_async(GFile * file, GFileCreateFlags flags,
				   int io_priority,
				   GCancellable * cancellable,
				   GAsyncReadyCallback callback,
				   gpointer user_data);
extern GFileOutputStream *g_file_append_to_finish(GFile * file,
						  GAsyncResult * res,
						  GError * *error);
extern gboolean g_file_copy(GFile * source, GFile * destination,
			    GFileCopyFlags flags,
			    GCancellable * cancellable,
			    GFileProgressCallback progress_callback,
			    gpointer progress_callback_data,
			    GError * *error);
extern void g_file_copy_async(GFile * source, GFile * destination,
			      GFileCopyFlags flags, int io_priority,
			      GCancellable * cancellable,
			      GFileProgressCallback progress_callback,
			      gpointer progress_callback_data,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
extern gboolean g_file_copy_attributes(GFile * source, GFile * destination,
				       GFileCopyFlags flags,
				       GCancellable * cancellable,
				       GError * *error);
extern gboolean g_file_copy_finish(GFile * file, GAsyncResult * res,
				   GError * *error);
extern GFileOutputStream *g_file_create(GFile * file,
					GFileCreateFlags flags,
					GCancellable * cancellable,
					GError * *error);
extern void g_file_create_async(GFile * file, GFileCreateFlags flags,
				int io_priority,
				GCancellable * cancellable,
				GAsyncReadyCallback callback,
				gpointer user_data);
extern GFileOutputStream *g_file_create_finish(GFile * file,
					       GAsyncResult * res,
					       GError * *error);
extern GFileIOStream *g_file_create_readwrite(GFile * file,
					      GFileCreateFlags flags,
					      GCancellable * cancellable,
					      GError * *error);
extern void g_file_create_readwrite_async(GFile * file,
					  GFileCreateFlags flags,
					  int io_priority,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern GFileIOStream *g_file_create_readwrite_finish(GFile * file,
						     GAsyncResult * res,
						     GError * *error);
extern gboolean g_file_delete(GFile * file, GCancellable * cancellable,
			      GError * *error);
extern GFile *g_file_dup(GFile * file);
extern void g_file_eject_mountable(GFile * file, GMountUnmountFlags flags,
				   GCancellable * cancellable,
				   GAsyncReadyCallback callback,
				   gpointer user_data);
extern gboolean g_file_eject_mountable_finish(GFile * file,
					      GAsyncResult * result,
					      GError * *error);
extern void g_file_eject_mountable_with_operation(GFile * file,
						  GMountUnmountFlags flags,
						  GMountOperation *
						  mount_operation,
						  GCancellable *
						  cancellable,
						  GAsyncReadyCallback
						  callback,
						  gpointer user_data);
extern gboolean g_file_eject_mountable_with_operation_finish(GFile * file,
							     GAsyncResult *
							     result,
							     GError *
							     *error);
extern GFileEnumerator *g_file_enumerate_children(GFile * file,
						  const char *attributes,
						  GFileQueryInfoFlags
						  flags,
						  GCancellable *
						  cancellable,
						  GError * *error);
extern void g_file_enumerate_children_async(GFile * file,
					    const char *attributes,
					    GFileQueryInfoFlags flags,
					    int io_priority,
					    GCancellable * cancellable,
					    GAsyncReadyCallback callback,
					    gpointer user_data);
extern GFileEnumerator *g_file_enumerate_children_finish(GFile * file,
							 GAsyncResult *
							 res,
							 GError * *error);
extern gboolean g_file_equal(GFile * file1, GFile * file2);
extern GMount *g_file_find_enclosing_mount(GFile * file,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_file_find_enclosing_mount_async(GFile * file,
					      int io_priority,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern GMount *g_file_find_enclosing_mount_finish(GFile * file,
						  GAsyncResult * res,
						  GError * *error);
extern char *g_file_get_basename(GFile * file);
extern GFile *g_file_get_child(GFile * file, const char *name);
extern GFile *g_file_get_child_for_display_name(GFile * file,
						const char *display_name,
						GError * *error);
extern GFile *g_file_get_parent(GFile * file);
extern char *g_file_get_parse_name(GFile * file);
extern char *g_file_get_path(GFile * file);
extern char *g_file_get_relative_path(GFile * parent, GFile * descendant);
extern GType g_file_get_type(void);
extern char *g_file_get_uri(GFile * file);
extern char *g_file_get_uri_scheme(GFile * file);
extern gboolean g_file_has_parent(GFile * file, GFile * parent);
extern gboolean g_file_has_prefix(GFile * file, GFile * prefix);
extern gboolean g_file_has_uri_scheme(GFile * file,
				      const char *uri_scheme);
extern guint g_file_hash(gconstpointer file);
extern gboolean g_file_is_native(GFile * file);
extern gboolean g_file_load_contents(GFile * file,
				     GCancellable * cancellable,
				     char **contents, gsize * length,
				     char **etag_out, GError * *error);
extern void g_file_load_contents_async(GFile * file,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data);
extern gboolean g_file_load_contents_finish(GFile * file,
					    GAsyncResult * res,
					    char **contents,
					    gsize * length,
					    char **etag_out,
					    GError * *error);
extern void g_file_load_partial_contents_async(GFile * file,
					       GCancellable * cancellable,
					       GFileReadMoreCallback
					       read_more_callback,
					       GAsyncReadyCallback
					       callback,
					       gpointer user_data);
extern gboolean g_file_load_partial_contents_finish(GFile * file,
						    GAsyncResult * res,
						    char **contents,
						    gsize * length,
						    char **etag_out,
						    GError * *error);
extern gboolean g_file_make_directory(GFile * file,
				      GCancellable * cancellable,
				      GError * *error);
extern gboolean g_file_make_directory_with_parents(GFile * file,
						   GCancellable *
						   cancellable,
						   GError * *error);
extern gboolean g_file_make_symbolic_link(GFile * file,
					  const char *symlink_value,
					  GCancellable * cancellable,
					  GError * *error);
extern GFileMonitor *g_file_monitor(GFile * file, GFileMonitorFlags flags,
				    GCancellable * cancellable,
				    GError * *error);
extern GFileMonitor *g_file_monitor_directory(GFile * file,
					      GFileMonitorFlags flags,
					      GCancellable * cancellable,
					      GError * *error);
extern GFileMonitor *g_file_monitor_file(GFile * file,
					 GFileMonitorFlags flags,
					 GCancellable * cancellable,
					 GError * *error);
extern void g_file_mount_enclosing_volume(GFile * location,
					  GMountMountFlags flags,
					  GMountOperation *
					  mount_operation,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern gboolean g_file_mount_enclosing_volume_finish(GFile * location,
						     GAsyncResult * result,
						     GError * *error);
extern void g_file_mount_mountable(GFile * file, GMountMountFlags flags,
				   GMountOperation * mount_operation,
				   GCancellable * cancellable,
				   GAsyncReadyCallback callback,
				   gpointer user_data);
extern GFile *g_file_mount_mountable_finish(GFile * file,
					    GAsyncResult * result,
					    GError * *error);
extern gboolean g_file_move(GFile * source, GFile * destination,
			    GFileCopyFlags flags,
			    GCancellable * cancellable,
			    GFileProgressCallback progress_callback,
			    gpointer progress_callback_data,
			    GError * *error);
extern GFile *g_file_new_for_commandline_arg(const char *arg);
extern GFile *g_file_new_for_path(const char *path);
extern GFile *g_file_new_for_uri(const char *uri);
extern GFile *g_file_new_tmp(const char *tmpl, GFileIOStream * *iostream,
			     GError * *error);
extern GFileIOStream *g_file_open_readwrite(GFile * file,
					    GCancellable * cancellable,
					    GError * *error);
extern void g_file_open_readwrite_async(GFile * file, int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
extern GFileIOStream *g_file_open_readwrite_finish(GFile * file,
						   GAsyncResult * res,
						   GError * *error);
extern GFile *g_file_parse_name(const char *parse_name);
extern void g_file_poll_mountable(GFile * file, GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
extern gboolean g_file_poll_mountable_finish(GFile * file,
					     GAsyncResult * result,
					     GError * *error);
extern GAppInfo *g_file_query_default_handler(GFile * file,
					      GCancellable * cancellable,
					      GError * *error);
extern gboolean g_file_query_exists(GFile * file,
				    GCancellable * cancellable);
extern GFileType g_file_query_file_type(GFile * file,
					GFileQueryInfoFlags flags,
					GCancellable * cancellable);
extern GFileInfo *g_file_query_filesystem_info(GFile * file,
					       const char *attributes,
					       GCancellable * cancellable,
					       GError * *error);
extern void g_file_query_filesystem_info_async(GFile * file,
					       const char *attributes,
					       int io_priority,
					       GCancellable * cancellable,
					       GAsyncReadyCallback
					       callback,
					       gpointer user_data);
extern GFileInfo *g_file_query_filesystem_info_finish(GFile * file,
						      GAsyncResult * res,
						      GError * *error);
extern GFileInfo *g_file_query_info(GFile * file, const char *attributes,
				    GFileQueryInfoFlags flags,
				    GCancellable * cancellable,
				    GError * *error);
extern void g_file_query_info_async(GFile * file, const char *attributes,
				    GFileQueryInfoFlags flags,
				    int io_priority,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
extern GFileInfo *g_file_query_info_finish(GFile * file,
					   GAsyncResult * res,
					   GError * *error);
extern GFileAttributeInfoList *g_file_query_settable_attributes(GFile *
								file,
								GCancellable
								*
								cancellable,
								GError *
								*error);
extern GFileAttributeInfoList *g_file_query_writable_namespaces(GFile *
								file,
								GCancellable
								*
								cancellable,
								GError *
								*error);
extern GFileInputStream *g_file_read(GFile * file,
				     GCancellable * cancellable,
				     GError * *error);
extern void g_file_read_async(GFile * file, int io_priority,
			      GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
extern GFileInputStream *g_file_read_finish(GFile * file,
					    GAsyncResult * res,
					    GError * *error);
extern GFileOutputStream *g_file_replace(GFile * file, const char *etag,
					 gboolean make_backup,
					 GFileCreateFlags flags,
					 GCancellable * cancellable,
					 GError * *error);
extern void g_file_replace_async(GFile * file, const char *etag,
				 gboolean make_backup,
				 GFileCreateFlags flags, int io_priority,
				 GCancellable * cancellable,
				 GAsyncReadyCallback callback,
				 gpointer user_data);
extern gboolean g_file_replace_contents(GFile * file, char **contents,
					gsize length, const char *etag,
					gboolean make_backup,
					GFileCreateFlags flags,
					char **new_etag,
					GCancellable * cancellable,
					GError * *error);
extern void g_file_replace_contents_async(GFile * file,
					  const char *contents,
					  gsize length, const char *etag,
					  gboolean make_backup,
					  GFileCreateFlags flags,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern gboolean g_file_replace_contents_finish(GFile * file,
					       GAsyncResult * res,
					       char **new_etag,
					       GError * *error);
extern GFileOutputStream *g_file_replace_finish(GFile * file,
						GAsyncResult * res,
						GError * *error);
extern GFileIOStream *g_file_replace_readwrite(GFile * file,
					       const char *etag,
					       gboolean make_backup,
					       GFileCreateFlags flags,
					       GCancellable * cancellable,
					       GError * *error);
extern void g_file_replace_readwrite_async(GFile * file, const char *etag,
					   gboolean make_backup,
					   GFileCreateFlags flags,
					   int io_priority,
					   GCancellable * cancellable,
					   GAsyncReadyCallback callback,
					   gpointer user_data);
extern GFileIOStream *g_file_replace_readwrite_finish(GFile * file,
						      GAsyncResult * res,
						      GError * *error);
extern GFile *g_file_resolve_relative_path(GFile * file,
					   const char *relative_path);
extern gboolean g_file_set_attribute(GFile * file, const char *attribute,
				     GFileAttributeType type,
				     gpointer value_p,
				     GFileQueryInfoFlags flags,
				     GCancellable * cancellable,
				     GError * *error);
extern gboolean g_file_set_attribute_byte_string(GFile * file,
						 const char *attribute,
						 const char *value,
						 GFileQueryInfoFlags flags,
						 GCancellable *
						 cancellable,
						 GError * *error);
extern gboolean g_file_set_attribute_int32(GFile * file,
					   const char *attribute,
					   gint32 value,
					   GFileQueryInfoFlags flags,
					   GCancellable * cancellable,
					   GError * *error);
extern gboolean g_file_set_attribute_int64(GFile * file,
					   const char *attribute,
					   gint64 value,
					   GFileQueryInfoFlags flags,
					   GCancellable * cancellable,
					   GError * *error);
extern gboolean g_file_set_attribute_string(GFile * file,
					    const char *attribute,
					    const char *value,
					    GFileQueryInfoFlags flags,
					    GCancellable * cancellable,
					    GError * *error);
extern gboolean g_file_set_attribute_uint32(GFile * file,
					    const char *attribute,
					    guint32 value,
					    GFileQueryInfoFlags flags,
					    GCancellable * cancellable,
					    GError * *error);
extern gboolean g_file_set_attribute_uint64(GFile * file,
					    const char *attribute,
					    guint64 value,
					    GFileQueryInfoFlags flags,
					    GCancellable * cancellable,
					    GError * *error);
extern void g_file_set_attributes_async(GFile * file, GFileInfo * info,
					GFileQueryInfoFlags flags,
					int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
extern gboolean g_file_set_attributes_finish(GFile * file,
					     GAsyncResult * result,
					     GFileInfo * *info,
					     GError * *error);
extern gboolean g_file_set_attributes_from_info(GFile * file,
						GFileInfo * info,
						GFileQueryInfoFlags flags,
						GCancellable * cancellable,
						GError * *error);
extern GFile *g_file_set_display_name(GFile * file,
				      const char *display_name,
				      GCancellable * cancellable,
				      GError * *error);
extern void g_file_set_display_name_async(GFile * file,
					  const char *display_name,
					  int io_priority,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern GFile *g_file_set_display_name_finish(GFile * file,
					     GAsyncResult * res,
					     GError * *error);
extern void g_file_start_mountable(GFile * file, GDriveStartFlags flags,
				   GMountOperation * start_operation,
				   GCancellable * cancellable,
				   GAsyncReadyCallback callback,
				   gpointer user_data);
extern gboolean g_file_start_mountable_finish(GFile * file,
					      GAsyncResult * result,
					      GError * *error);
extern void g_file_stop_mountable(GFile * file, GMountUnmountFlags flags,
				  GMountOperation * mount_operation,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
extern gboolean g_file_stop_mountable_finish(GFile * file,
					     GAsyncResult * result,
					     GError * *error);
extern gboolean g_file_supports_thread_contexts(GFile * file);
extern gboolean g_file_trash(GFile * file, GCancellable * cancellable,
			     GError * *error);
extern void g_file_unmount_mountable(GFile * file,
				     GMountUnmountFlags flags,
				     GCancellable * cancellable,
				     GAsyncReadyCallback callback,
				     gpointer user_data);
extern gboolean g_file_unmount_mountable_finish(GFile * file,
						GAsyncResult * result,
						GError * *error);
extern void g_file_unmount_mountable_with_operation(GFile * file,
						    GMountUnmountFlags
						    flags,
						    GMountOperation *
						    mount_operation,
						    GCancellable *
						    cancellable,
						    GAsyncReadyCallback
						    callback,
						    gpointer user_data);
extern gboolean g_file_unmount_mountable_with_operation_finish(GFile *
							       file,
							       GAsyncResult
							       * result,
							       GError *
							       *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41103"
>17.12.57. glib-2.0/gio/gfileattribute.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct _GFileAttributeInfo {
    char *name;
    GFileAttributeType type;
    GFileAttributeInfoFlags flags;
};
struct _GFileAttributeInfoList {
    GFileAttributeInfo *infos;
    int n_infos;
};
extern void g_file_attribute_info_list_add(GFileAttributeInfoList * list,
					   const char *name,
					   GFileAttributeType type,
					   GFileAttributeInfoFlags flags);
extern GFileAttributeInfoList
    *g_file_attribute_info_list_dup(GFileAttributeInfoList * list);
extern GType g_file_attribute_info_list_get_type(void);
extern const GFileAttributeInfo
    *g_file_attribute_info_list_lookup(GFileAttributeInfoList * list,
				       const char *name);
extern GFileAttributeInfoList *g_file_attribute_info_list_new(void);
extern GFileAttributeInfoList
    *g_file_attribute_info_list_ref(GFileAttributeInfoList * list);
extern void g_file_attribute_info_list_unref(GFileAttributeInfoList *
					     list);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41107"
>17.12.58. glib-2.0/gio/gfileenumerator.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_ENUMERATOR	(g_file_enumerator_get_type ())
#define G_FILE_ENUMERATOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass))
#define G_IS_FILE_ENUMERATOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_ENUMERATOR))
#define G_FILE_ENUMERATOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_ENUMERATOR, GFileEnumerator))
#define G_IS_FILE_ENUMERATOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_ENUMERATOR))
#define G_FILE_ENUMERATOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass))

typedef struct _GFileEnumeratorClass {
    GObjectClass parent_class;
    GFileInfo *(*next_file) (GFileEnumerator * enumerator,
			     GCancellable * cancellable, GError * *error);
     gboolean(*close_fn) (GFileEnumerator * enumerator,
			  GCancellable * cancellable, GError * *error);
    void (*next_files_async) (GFileEnumerator * enumerator, int num_files,
			      int io_priority, GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
    GList *(*next_files_finish) (GFileEnumerator * enumerator,
				 GAsyncResult * result, GError * *error);
    void (*close_async) (GFileEnumerator * enumerator, int io_priority,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*close_finish) (GFileEnumerator * enumerator,
			      GAsyncResult * result, GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
} GFileEnumeratorClass;
typedef struct _GFileEnumeratorPrivate GFileEnumeratorPrivate;
struct _GFileEnumerator {
    GObject parent_instance;
    GFileEnumeratorPrivate *priv;
};
extern gboolean g_file_enumerator_close(GFileEnumerator * enumerator,
					GCancellable * cancellable,
					GError * *error);
extern void g_file_enumerator_close_async(GFileEnumerator * enumerator,
					  int io_priority,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern gboolean g_file_enumerator_close_finish(GFileEnumerator *
					       enumerator,
					       GAsyncResult * result,
					       GError * *error);
extern GFile *g_file_enumerator_get_container(GFileEnumerator *
					      enumerator);
extern GType g_file_enumerator_get_type(void);
extern gboolean g_file_enumerator_has_pending(GFileEnumerator *
					      enumerator);
extern gboolean g_file_enumerator_is_closed(GFileEnumerator * enumerator);
extern GFileInfo *g_file_enumerator_next_file(GFileEnumerator * enumerator,
					      GCancellable * cancellable,
					      GError * *error);
extern void g_file_enumerator_next_files_async(GFileEnumerator *
					       enumerator, int num_files,
					       int io_priority,
					       GCancellable * cancellable,
					       GAsyncReadyCallback
					       callback,
					       gpointer user_data);
extern GList *g_file_enumerator_next_files_finish(GFileEnumerator *
						  enumerator,
						  GAsyncResult * result,
						  GError * *error);
extern void g_file_enumerator_set_pending(GFileEnumerator * enumerator,
					  gboolean pending);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41111"
>17.12.59. glib-2.0/gio/gfileicon.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_ICON	(g_file_icon_get_type ())
#define G_FILE_ICON_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_ICON, GFileIconClass))
#define G_IS_FILE_ICON_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_ICON))
#define G_FILE_ICON(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_ICON, GFileIcon))
#define G_IS_FILE_ICON(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_ICON))
#define G_FILE_ICON_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_ICON, GFileIconClass))

typedef struct _GFileIconClass GFileIconClass;
extern GFile *g_file_icon_get_file(GFileIcon * icon);
extern GType g_file_icon_get_type(void);
extern GIcon *g_file_icon_new(GFile * file);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41115"
>17.12.60. glib-2.0/gio/gfileinfo.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_INFO	(g_file_info_get_type ())
#define G_FILE_INFO_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_INFO, GFileInfoClass))
#define G_IS_FILE_INFO_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_INFO))
#define G_FILE_INFO(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_INFO, GFileInfo))
#define G_IS_FILE_INFO(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_INFO))
#define G_FILE_INFO_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_INFO, GFileInfoClass))
#define G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE	"access::can-delete"
#define G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE	"access::can-execute"
#define G_FILE_ATTRIBUTE_ACCESS_CAN_READ	"access::can-read"
#define G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME	"access::can-rename"
#define G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH	"access::can-trash"
#define G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE	"access::can-write"
#define G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE	"dos::is-archive"
#define G_FILE_ATTRIBUTE_DOS_IS_SYSTEM	"dos::is-system"
#define G_FILE_ATTRIBUTE_ETAG_VALUE	"etag::value"
#define G_FILE_ATTRIBUTE_FILESYSTEM_FREE	"filesystem::free"
#define G_FILE_ATTRIBUTE_FILESYSTEM_READONLY	"filesystem::readonly"
#define G_FILE_ATTRIBUTE_FILESYSTEM_SIZE	"filesystem::size"
#define G_FILE_ATTRIBUTE_FILESYSTEM_TYPE	"filesystem::type"
#define G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW	"filesystem::use-preview"
#define G_FILE_ATTRIBUTE_FILESYSTEM_USED	"filesystem::used"
#define G_FILE_ATTRIBUTE_GVFS_BACKEND	"gvfs::backend"
#define G_FILE_ATTRIBUTE_ID_FILE	"id::file"
#define G_FILE_ATTRIBUTE_ID_FILESYSTEM	"id::filesystem"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT	"mountable::can-eject"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT	"mountable::can-mount"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL	"mountable::can-poll"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START	"mountable::can-start"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED	"mountable::can-start-degraded"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP	"mountable::can-stop"
#define G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT	"mountable::can-unmount"
#define G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI	"mountable::hal-udi"
#define G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC	"mountable::is-media-check-automatic"
#define G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE	"mountable::start-stop-type"
#define G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE	"mountable::unix-device"
#define G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE	"mountable::unix-device-file"
#define G_FILE_ATTRIBUTE_OWNER_GROUP	"owner::group"
#define G_FILE_ATTRIBUTE_OWNER_USER	"owner::user"
#define G_FILE_ATTRIBUTE_OWNER_USER_REAL	"owner::user-real"
#define G_FILE_ATTRIBUTE_PREVIEW_ICON	"preview::icon"
#define G_FILE_ATTRIBUTE_SELINUX_CONTEXT	"selinux::context"
#define G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE	"standard::allocated-size"
#define G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE	"standard::content-type"
#define G_FILE_ATTRIBUTE_STANDARD_COPY_NAME	"standard::copy-name"
#define G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION	"standard::description"
#define G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME	"standard::display-name"
#define G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME	"standard::edit-name"
#define G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE	"standard::fast-content-type"
#define G_FILE_ATTRIBUTE_STANDARD_ICON	"standard::icon"
#define G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP	"standard::is-backup"
#define G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN	"standard::is-hidden"
#define G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK	"standard::is-symlink"
#define G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL	"standard::is-virtual"
#define G_FILE_ATTRIBUTE_STANDARD_NAME	"standard::name"
#define G_FILE_ATTRIBUTE_STANDARD_SIZE	"standard::size"
#define G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER	"standard::sort-order"
#define G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET	"standard::symlink-target"
#define G_FILE_ATTRIBUTE_STANDARD_TARGET_URI	"standard::target-uri"
#define G_FILE_ATTRIBUTE_STANDARD_TYPE	"standard::type"
#define G_FILE_ATTRIBUTE_THUMBNAILING_FAILED	"thumbnail::failed"
#define G_FILE_ATTRIBUTE_THUMBNAIL_PATH	"thumbnail::path"
#define G_FILE_ATTRIBUTE_TIME_ACCESS	"time::access"
#define G_FILE_ATTRIBUTE_TIME_ACCESS_USEC	"time::access-usec"
#define G_FILE_ATTRIBUTE_TIME_CHANGED	"time::changed"
#define G_FILE_ATTRIBUTE_TIME_CHANGED_USEC	"time::changed-usec"
#define G_FILE_ATTRIBUTE_TIME_CREATED	"time::created"
#define G_FILE_ATTRIBUTE_TIME_CREATED_USEC	"time::created-usec"
#define G_FILE_ATTRIBUTE_TIME_MODIFIED	"time::modified"
#define G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC	"time::modified-usec"
#define G_FILE_ATTRIBUTE_TRASH_DELETION_DATE	"trash::deletion-date"
#define G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT	"trash::item-count"
#define G_FILE_ATTRIBUTE_TRASH_ORIG_PATH	"trash::orig-path"
#define G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE	"unix::block-size"
#define G_FILE_ATTRIBUTE_UNIX_BLOCKS	"unix::blocks"
#define G_FILE_ATTRIBUTE_UNIX_DEVICE	"unix::device"
#define G_FILE_ATTRIBUTE_UNIX_GID	"unix::gid"
#define G_FILE_ATTRIBUTE_UNIX_INODE	"unix::inode"
#define G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT	"unix::is-mountpoint"
#define G_FILE_ATTRIBUTE_UNIX_MODE	"unix::mode"
#define G_FILE_ATTRIBUTE_UNIX_NLINK	"unix::nlink"
#define G_FILE_ATTRIBUTE_UNIX_RDEV	"unix::rdev"
#define G_FILE_ATTRIBUTE_UNIX_UID	"unix::uid"

typedef struct _GFileInfoClass GFileInfoClass;
extern gboolean
g_file_attribute_matcher_enumerate_namespace(GFileAttributeMatcher *
					     matcher, const char *ns);
extern const char
    *g_file_attribute_matcher_enumerate_next(GFileAttributeMatcher *
					     matcher);
extern GType g_file_attribute_matcher_get_type(void);
extern gboolean g_file_attribute_matcher_matches(GFileAttributeMatcher *
						 matcher,
						 const char *attribute);
extern gboolean g_file_attribute_matcher_matches_only(GFileAttributeMatcher
						      * matcher,
						      const char
						      *attribute);
extern GFileAttributeMatcher *g_file_attribute_matcher_new(const char
							   *attributes);
extern GFileAttributeMatcher
    *g_file_attribute_matcher_ref(GFileAttributeMatcher * matcher);
extern GFileAttributeMatcher
    *g_file_attribute_matcher_subtract(GFileAttributeMatcher * matcher,
				       GFileAttributeMatcher * subtract);
extern char *g_file_attribute_matcher_to_string(GFileAttributeMatcher *
						matcher);
extern void g_file_attribute_matcher_unref(GFileAttributeMatcher *
					   matcher);
extern void g_file_info_clear_status(GFileInfo * info);
extern void g_file_info_copy_into(GFileInfo * src_info,
				  GFileInfo * dest_info);
extern GFileInfo *g_file_info_dup(GFileInfo * other);
extern char *g_file_info_get_attribute_as_string(GFileInfo * info,
						 const char *attribute);
extern gboolean g_file_info_get_attribute_boolean(GFileInfo * info,
						  const char *attribute);
extern const char *g_file_info_get_attribute_byte_string(GFileInfo * info,
							 const char
							 *attribute);
extern gboolean g_file_info_get_attribute_data(GFileInfo * info,
					       const char *attribute,
					       GFileAttributeType * type,
					       void **value_pp,
					       GFileAttributeStatus *
					       status);
extern gint32 g_file_info_get_attribute_int32(GFileInfo * info,
					      const char *attribute);
extern gint64 g_file_info_get_attribute_int64(GFileInfo * info,
					      const char *attribute);
extern GObject *g_file_info_get_attribute_object(GFileInfo * info,
						 const char *attribute);
extern GFileAttributeStatus g_file_info_get_attribute_status(GFileInfo *
							     info,
							     const char
							     *attribute);
extern const char *g_file_info_get_attribute_string(GFileInfo * info,
						    const char *attribute);
extern void g_file_info_get_attribute_stringv(GFileInfo * info,
					      const char *attribute);
extern GFileAttributeType g_file_info_get_attribute_type(GFileInfo * info,
							 const char
							 *attribute);
extern guint32 g_file_info_get_attribute_uint32(GFileInfo * info,
						const char *attribute);
extern guint64 g_file_info_get_attribute_uint64(GFileInfo * info,
						const char *attribute);
extern const char *g_file_info_get_content_type(GFileInfo * info);
extern const char *g_file_info_get_display_name(GFileInfo * info);
extern const char *g_file_info_get_edit_name(GFileInfo * info);
extern const char *g_file_info_get_etag(GFileInfo * info);
extern GFileType g_file_info_get_file_type(GFileInfo * info);
extern GIcon *g_file_info_get_icon(GFileInfo * info);
extern gboolean g_file_info_get_is_backup(GFileInfo * info);
extern gboolean g_file_info_get_is_hidden(GFileInfo * info);
extern gboolean g_file_info_get_is_symlink(GFileInfo * info);
extern void g_file_info_get_modification_time(GFileInfo * info,
					      GTimeVal * result);
extern const char *g_file_info_get_name(GFileInfo * info);
extern goffset g_file_info_get_size(GFileInfo * info);
extern gint32 g_file_info_get_sort_order(GFileInfo * info);
extern const char *g_file_info_get_symlink_target(GFileInfo * info);
extern GType g_file_info_get_type(void);
extern gboolean g_file_info_has_attribute(GFileInfo * info,
					  const char *attribute);
extern gboolean g_file_info_has_namespace(GFileInfo * info,
					  const char *name_space);
extern void g_file_info_list_attributes(GFileInfo * info,
					const char *name_space);
extern GFileInfo *g_file_info_new(void);
extern void g_file_info_remove_attribute(GFileInfo * info,
					 const char *attribute);
extern void g_file_info_set_attribute(GFileInfo * info,
				      const char *attribute,
				      GFileAttributeType type,
				      void *value_p);
extern void g_file_info_set_attribute_boolean(GFileInfo * info,
					      const char *attribute,
					      gboolean attr_value);
extern void g_file_info_set_attribute_byte_string(GFileInfo * info,
						  const char *attribute,
						  const char *attr_value);
extern void g_file_info_set_attribute_int32(GFileInfo * info,
					    const char *attribute,
					    gint32 attr_value);
extern void g_file_info_set_attribute_int64(GFileInfo * info,
					    const char *attribute,
					    gint64 attr_value);
extern void g_file_info_set_attribute_mask(GFileInfo * info,
					   GFileAttributeMatcher * mask);
extern void g_file_info_set_attribute_object(GFileInfo * info,
					     const char *attribute,
					     GObject * attr_value);
extern gboolean g_file_info_set_attribute_status(GFileInfo * info,
						 const char *attribute,
						 GFileAttributeStatus
						 status);
extern void g_file_info_set_attribute_string(GFileInfo * info,
					     const char *attribute,
					     const char *attr_value);
extern void g_file_info_set_attribute_stringv(GFileInfo * info,
					      const char *attribute,
					      char **attr_value);
extern void g_file_info_set_attribute_uint32(GFileInfo * info,
					     const char *attribute,
					     guint32 attr_value);
extern void g_file_info_set_attribute_uint64(GFileInfo * info,
					     const char *attribute,
					     guint64 attr_value);
extern void g_file_info_set_content_type(GFileInfo * info,
					 const char *content_type);
extern void g_file_info_set_display_name(GFileInfo * info,
					 const char *display_name);
extern void g_file_info_set_edit_name(GFileInfo * info,
				      const char *edit_name);
extern void g_file_info_set_file_type(GFileInfo * info, GFileType type);
extern void g_file_info_set_icon(GFileInfo * info, GIcon * icon);
extern void g_file_info_set_is_hidden(GFileInfo * info,
				      gboolean is_hidden);
extern void g_file_info_set_is_symlink(GFileInfo * info,
				       gboolean is_symlink);
extern void g_file_info_set_modification_time(GFileInfo * info,
					      GTimeVal * mtime);
extern void g_file_info_set_name(GFileInfo * info, const char *name);
extern void g_file_info_set_size(GFileInfo * info, goffset size);
extern void g_file_info_set_sort_order(GFileInfo * info,
				       gint32 sort_order);
extern void g_file_info_set_symlink_target(GFileInfo * info,
					   const char *symlink_target);
extern void g_file_info_unset_attribute_mask(GFileInfo * info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41119"
>17.12.61. glib-2.0/gio/gfileinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_INPUT_STREAM	(g_file_input_stream_get_type ())
#define G_FILE_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass))
#define G_IS_FILE_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_INPUT_STREAM))
#define G_FILE_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_INPUT_STREAM, GFileInputStream))
#define G_IS_FILE_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_INPUT_STREAM))
#define G_FILE_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass))

typedef struct _GFileInputStreamClass {
    GInputStreamClass parent_class;
     goffset(*tell) (GFileInputStream * stream);
     gboolean(*can_seek) (GFileInputStream * stream);
     gboolean(*seek) (GFileInputStream * stream, goffset offset,
		      GSeekType type, GCancellable * cancellable,
		      GError * *error);
    GFileInfo *(*query_info) (GFileInputStream * stream,
			      const char *attributes,
			      GCancellable * cancellable, GError * *error);
    void (*query_info_async) (GFileInputStream * stream,
			      const char *attributes, int io_priority,
			      GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
    GFileInfo *(*query_info_finish) (GFileInputStream * stream,
				     GAsyncResult * result,
				     GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GFileInputStreamClass;
typedef struct _GFileInputStreamPrivate GFileInputStreamPrivate;
struct _GFileInputStream {
    GInputStream parent_instance;
    GFileInputStreamPrivate *priv;
};
extern GType g_file_input_stream_get_type(void);
extern GFileInfo *g_file_input_stream_query_info(GFileInputStream * stream,
						 const char *attributes,
						 GCancellable *
						 cancellable,
						 GError * *error);
extern void g_file_input_stream_query_info_async(GFileInputStream * stream,
						 const char *attributes,
						 int io_priority,
						 GCancellable *
						 cancellable,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data);
extern GFileInfo *g_file_input_stream_query_info_finish(GFileInputStream *
							stream,
							GAsyncResult *
							result,
							GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41123"
>17.12.62. glib-2.0/gio/gfileiostream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_IO_STREAM	(g_file_io_stream_get_type ())
#define G_FILE_IO_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_IO_STREAM, GFileIOStreamClass))
#define G_IS_FILE_IO_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_IO_STREAM))
#define G_FILE_IO_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_IO_STREAM, GFileIOStream))
#define G_IS_FILE_IO_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_IO_STREAM))
#define G_FILE_IO_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_IO_STREAM, GFileIOStreamClass))

typedef struct _GFileIOStreamClass {
    GIOStreamClass parent_class;
     goffset(*tell) (GFileIOStream * stream);
     gboolean(*can_seek) (GFileIOStream * stream);
     gboolean(*seek) (GFileIOStream * stream, goffset offset,
		      GSeekType type, GCancellable * cancellable,
		      GError * *error);
     gboolean(*can_truncate) (GFileIOStream * stream);
     gboolean(*truncate_fn) (GFileIOStream * stream, goffset size,
			     GCancellable * cancellable, GError * *error);
    GFileInfo *(*query_info) (GFileIOStream * stream,
			      const char *attributes,
			      GCancellable * cancellable, GError * *error);
    void (*query_info_async) (GFileIOStream * stream,
			      const char *attributes, int io_priority,
			      GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
    GFileInfo *(*query_info_finish) (GFileIOStream * stream,
				     GAsyncResult * result,
				     GError * *error);
    char *(*get_etag) (GFileIOStream * stream);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GFileIOStreamClass;
typedef struct _GFileIOStreamPrivate GFileIOStreamPrivate;
struct _GFileIOStream {
    GIOStream parent_instance;
    GFileIOStreamPrivate *priv;
};
extern char *g_file_io_stream_get_etag(GFileIOStream * stream);
extern GType g_file_io_stream_get_type(void);
extern GFileInfo *g_file_io_stream_query_info(GFileIOStream * stream,
					      const char *attributes,
					      GCancellable * cancellable,
					      GError * *error);
extern void g_file_io_stream_query_info_async(GFileIOStream * stream,
					      const char *attributes,
					      int io_priority,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern GFileInfo *g_file_io_stream_query_info_finish(GFileIOStream *
						     stream,
						     GAsyncResult * result,
						     GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41127"
>17.12.63. glib-2.0/gio/gfilemonitor.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_MONITOR	(g_file_monitor_get_type ())
#define G_FILE_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_MONITOR, GFileMonitorClass))
#define G_IS_FILE_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_MONITOR))
#define G_FILE_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_MONITOR, GFileMonitor))
#define G_IS_FILE_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_MONITOR))
#define G_FILE_MONITOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_MONITOR, GFileMonitorClass))

typedef struct _GFileMonitorClass {
    GObjectClass parent_class;
    void (*changed) (GFileMonitor * monitor, GFile * file,
		     GFile * other_file, GFileMonitorEvent event_type);
     gboolean(*cancel) (GFileMonitor * monitor);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GFileMonitorClass;
typedef struct _GFileMonitorPrivate GFileMonitorPrivate;
struct _GFileMonitor {
    GObject parent_instance;
    GFileMonitorPrivate *priv;
};
extern gboolean g_file_monitor_cancel(GFileMonitor * monitor);
extern void g_file_monitor_emit_event(GFileMonitor * monitor,
				      GFile * child, GFile * other_file,
				      GFileMonitorEvent event_type);
extern GType g_file_monitor_get_type(void);
extern gboolean g_file_monitor_is_cancelled(GFileMonitor * monitor);
extern void g_file_monitor_set_rate_limit(GFileMonitor * monitor,
					  gint limit_msecs);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41131"
>17.12.64. glib-2.0/gio/gfilenamecompleter.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILENAME_COMPLETER	(g_filename_completer_get_type ())
#define G_FILENAME_COMPLETER_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass))
#define G_IS_FILENAME_COMPLETER_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILENAME_COMPLETER))
#define G_FILENAME_COMPLETER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILENAME_COMPLETER, GFilenameCompleter))
#define G_IS_FILENAME_COMPLETER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILENAME_COMPLETER))
#define G_FILENAME_COMPLETER_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass))

typedef struct _GFilenameCompleterClass {
    GObjectClass parent_class;
    void (*got_completion_data) (GFilenameCompleter * filename_completer);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
} GFilenameCompleterClass;
extern char *g_filename_completer_get_completion_suffix(GFilenameCompleter
							* completer,
							const char
							*initial_text);
extern void g_filename_completer_get_completions(GFilenameCompleter *
						 completer,
						 const char *initial_text);
extern GType g_filename_completer_get_type(void);
extern GFilenameCompleter *g_filename_completer_new(void);
extern void g_filename_completer_set_dirs_only(GFilenameCompleter *
					       completer,
					       gboolean dirs_only);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41135"
>17.12.65. glib-2.0/gio/gfileoutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILE_OUTPUT_STREAM	(g_file_output_stream_get_type ())
#define G_FILE_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass))
#define G_IS_FILE_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILE_OUTPUT_STREAM))
#define G_FILE_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStream))
#define G_IS_FILE_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILE_OUTPUT_STREAM))
#define G_FILE_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass))

typedef struct _GFileOutputStreamClass {
    GOutputStreamClass parent_class;
     goffset(*tell) (GFileOutputStream * stream);
     gboolean(*can_seek) (GFileOutputStream * stream);
     gboolean(*seek) (GFileOutputStream * stream, goffset offset,
		      GSeekType type, GCancellable * cancellable,
		      GError * *error);
     gboolean(*can_truncate) (GFileOutputStream * stream);
     gboolean(*truncate_fn) (GFileOutputStream * stream, goffset size,
			     GCancellable * cancellable, GError * *error);
    GFileInfo *(*query_info) (GFileOutputStream * stream,
			      const char *attributes,
			      GCancellable * cancellable, GError * *error);
    void (*query_info_async) (GFileOutputStream * stream,
			      const char *attributes, int io_priority,
			      GCancellable * cancellable,
			      GAsyncReadyCallback callback,
			      gpointer user_data);
    GFileInfo *(*query_info_finish) (GFileOutputStream * stream,
				     GAsyncResult * result,
				     GError * *error);
    char *(*get_etag) (GFileOutputStream * stream);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GFileOutputStreamClass;
typedef struct _GFileOutputStreamPrivate GFileOutputStreamPrivate;
struct _GFileOutputStream {
    GOutputStream parent_instance;
    GFileOutputStreamPrivate *priv;
};
extern char *g_file_output_stream_get_etag(GFileOutputStream * stream);
extern GType g_file_output_stream_get_type(void);
extern GFileInfo *g_file_output_stream_query_info(GFileOutputStream *
						  stream,
						  const char *attributes,
						  GCancellable *
						  cancellable,
						  GError * *error);
extern void g_file_output_stream_query_info_async(GFileOutputStream *
						  stream,
						  const char *attributes,
						  int io_priority,
						  GCancellable *
						  cancellable,
						  GAsyncReadyCallback
						  callback,
						  gpointer user_data);
extern GFileInfo *g_file_output_stream_query_info_finish(GFileOutputStream
							 * stream,
							 GAsyncResult *
							 result,
							 GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41139"
>17.12.66. glib-2.0/gio/gfilterinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILTER_INPUT_STREAM	(g_filter_input_stream_get_type ())
#define G_FILTER_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass))
#define G_IS_FILTER_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILTER_INPUT_STREAM))
#define G_FILTER_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStream))
#define G_IS_FILTER_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILTER_INPUT_STREAM))
#define G_FILTER_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass))

typedef struct _GFilterInputStreamClass {
    GInputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
} GFilterInputStreamClass;
struct _GFilterInputStream {
    GInputStream parent_instance;
    GInputStream *base_stream;
};
extern GInputStream
    *g_filter_input_stream_get_base_stream(GFilterInputStream * stream);
extern gboolean
g_filter_input_stream_get_close_base_stream(GFilterInputStream * stream);
extern GType g_filter_input_stream_get_type(void);
extern void g_filter_input_stream_set_close_base_stream(GFilterInputStream
							* stream,
							gboolean
							close_base);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41143"
>17.12.67. glib-2.0/gio/gfilteroutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_FILTER_OUTPUT_STREAM	(g_filter_output_stream_get_type ())
#define G_FILTER_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass))
#define G_IS_FILTER_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_FILTER_OUTPUT_STREAM))
#define G_FILTER_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStream))
#define G_IS_FILTER_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_FILTER_OUTPUT_STREAM))
#define G_FILTER_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass))

typedef struct _GFilterOutputStreamClass {
    GOutputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
} GFilterOutputStreamClass;
struct _GFilterOutputStream {
    GOutputStream parent_instance;
    GOutputStream *base_stream;
};
extern GOutputStream
    *g_filter_output_stream_get_base_stream(GFilterOutputStream * stream);
extern gboolean
g_filter_output_stream_get_close_base_stream(GFilterOutputStream * stream);
extern GType g_filter_output_stream_get_type(void);
extern void
g_filter_output_stream_set_close_base_stream(GFilterOutputStream * stream,
					     gboolean close_base);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41147"
>17.12.68. glib-2.0/gio/gicon.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_ICON	(g_icon_get_type ())
#define G_ICON(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_ICON, GIcon))
#define G_IS_ICON(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_ICON))
#define G_ICON_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_ICON, GIconIface))

typedef struct _GIconIface {
    GTypeInterface g_iface;
     guint(*hash) (GIcon * icon);
     gboolean(*equal) (GIcon * icon1, GIcon * icon2);
     gboolean(*to_tokens) (GIcon * icon, GPtrArray * tokens,
			   gint * out_version);
    GIcon *(*from_tokens) (GIcon * icon, gint num_tokens, gint version,
			   GError * *error);
} GIconIface;
extern gboolean g_icon_equal(GIcon * icon1, GIcon * icon2);
extern GType g_icon_get_type(void);
extern guint g_icon_hash(gconstpointer icon);
extern GIcon *g_icon_new_for_string(const gchar * str, GError * *error);
extern gchar *g_icon_to_string(GIcon * icon);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41151"
>17.12.69. glib-2.0/gio/ginetaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_INET_ADDRESS	(g_inet_address_get_type ())
#define G_INET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS, GInetAddressClass))
#define G_IS_INET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS))
#define G_INET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS, GInetAddress))
#define G_IS_INET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS))
#define G_INET_ADDRESS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS, GInetAddressClass))

typedef struct _GInetAddressClass {
    GObjectClass parent_class;
    gchar *(*to_string) (GInetAddress * address);
    const guint8 *(*to_bytes) (GInetAddress * address);
} GInetAddressClass;
typedef struct _GInetAddressPrivate GInetAddressPrivate;
struct _GInetAddress {
    GObject parent_instance;
    GInetAddressPrivate *priv;
};
extern gboolean g_inet_address_equal(GInetAddress * address,
				     GInetAddress * other_address);
extern GSocketFamily g_inet_address_get_family(GInetAddress * address);
extern gboolean g_inet_address_get_is_any(GInetAddress * address);
extern gboolean g_inet_address_get_is_link_local(GInetAddress * address);
extern gboolean g_inet_address_get_is_loopback(GInetAddress * address);
extern gboolean g_inet_address_get_is_mc_global(GInetAddress * address);
extern gboolean g_inet_address_get_is_mc_link_local(GInetAddress *
						    address);
extern gboolean g_inet_address_get_is_mc_node_local(GInetAddress *
						    address);
extern gboolean g_inet_address_get_is_mc_org_local(GInetAddress * address);
extern gboolean g_inet_address_get_is_mc_site_local(GInetAddress *
						    address);
extern gboolean g_inet_address_get_is_multicast(GInetAddress * address);
extern gboolean g_inet_address_get_is_site_local(GInetAddress * address);
extern gsize g_inet_address_get_native_size(GInetAddress * address);
extern GType g_inet_address_get_type(void);
extern GInetAddress *g_inet_address_new_any(GSocketFamily family);
extern GInetAddress *g_inet_address_new_from_bytes(const guint8 * bytes,
						   GSocketFamily family);
extern GInetAddress *g_inet_address_new_from_string(const gchar * string);
extern GInetAddress *g_inet_address_new_loopback(GSocketFamily family);
extern const unsigned char *g_inet_address_to_bytes(GInetAddress *
						    address);
extern gchar *g_inet_address_to_string(GInetAddress * address);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41155"
>17.12.70. glib-2.0/gio/ginetaddressmask.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_INET_ADDRESS_MASK	(g_inet_address_mask_get_type ())
#define G_INET_ADDRESS_MASK_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass))
#define G_IS_INET_ADDRESS_MASK_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS_MASK))
#define G_INET_ADDRESS_MASK(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS_MASK, GInetAddressMask))
#define G_IS_INET_ADDRESS_MASK(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS_MASK))
#define G_INET_ADDRESS_MASK_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass))

typedef struct _GInetAddressMaskClass {
    GObjectClass parent_class;
} GInetAddressMaskClass;
typedef struct _GInetAddressMaskPrivate GInetAddressMaskPrivate;
struct _GInetAddressMask {
    GObject parent_instance;
    GInetAddressMaskPrivate *priv;
};
extern gboolean g_inet_address_mask_equal(GInetAddressMask * mask,
					  GInetAddressMask * mask2);
extern GInetAddress *g_inet_address_mask_get_address(GInetAddressMask *
						     mask);
extern GSocketFamily g_inet_address_mask_get_family(GInetAddressMask *
						    mask);
extern guint g_inet_address_mask_get_length(GInetAddressMask * mask);
extern GType g_inet_address_mask_get_type(void);
extern gboolean g_inet_address_mask_matches(GInetAddressMask * mask,
					    GInetAddress * address);
extern GInetAddressMask *g_inet_address_mask_new(GInetAddress * addr,
						 guint length,
						 GError * *error);
extern GInetAddressMask *g_inet_address_mask_new_from_string(const gchar *
							     mask_string,
							     GError *
							     *error);
extern gchar *g_inet_address_mask_to_string(GInetAddressMask * mask);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41159"
>17.12.71. glib-2.0/gio/ginetsocketaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_INET_SOCKET_ADDRESS	(g_inet_socket_address_get_type ())
#define G_INET_SOCKET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
#define G_IS_INET_SOCKET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_SOCKET_ADDRESS))
#define G_INET_SOCKET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress))
#define G_IS_INET_SOCKET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_SOCKET_ADDRESS))
#define G_INET_SOCKET_ADDRESS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))

typedef struct _GInetSocketAddressClass {
    GSocketAddressClass parent_class;
} GInetSocketAddressClass;
typedef struct _GInetSocketAddressPrivate GInetSocketAddressPrivate;
struct _GInetSocketAddress {
    GSocketAddress parent_instance;
    GInetSocketAddressPrivate *priv;
};
extern GInetAddress *g_inet_socket_address_get_address(GInetSocketAddress *
						       address);
extern guint32 g_inet_socket_address_get_flowinfo(GInetSocketAddress *
						  address);
extern guint16 g_inet_socket_address_get_port(GInetSocketAddress *
					      address);
extern guint32 g_inet_socket_address_get_scope_id(GInetSocketAddress *
						  address);
extern GType g_inet_socket_address_get_type(void);
extern GSocketAddress *g_inet_socket_address_new(GInetAddress * address,
						 guint16 port);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41163"
>17.12.72. glib-2.0/gio/ginitable.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_INITABLE	(g_initable_get_type ())
#define G_INITABLE(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_INITABLE, GInitable))
#define G_IS_INITABLE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_INITABLE))
#define G_INITABLE_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_INITABLE, GInitableIface))
#define G_TYPE_IS_INITABLE(type)	(g_type_is_a ((type), G_TYPE_INITABLE))

typedef struct _GInitableIface {
    GTypeInterface g_iface;
     gboolean(*init) (GInitable * initable, GCancellable * cancellable,
		      GError * *error);
} GInitableIface;
extern GType g_initable_get_type(void);
extern gboolean g_initable_init(GInitable * initable,
				GCancellable * cancellable,
				GError * *error);
extern gpointer g_initable_new(GType object_type,
			       GCancellable * cancellable, GError * *error,
			       const gchar * first_property_name, ...);
extern GObject *g_initable_new_valist(GType object_type,
				      const gchar * first_property_name,
				      va_list var_args,
				      GCancellable * cancellable,
				      GError * *error);
extern gpointer g_initable_newv(GType object_type, guint n_parameters,
				GParameter * parameters,
				GCancellable * cancellable,
				GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41167"
>17.12.73. glib-2.0/gio/ginputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_INPUT_STREAM	(g_input_stream_get_type ())
#define G_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INPUT_STREAM, GInputStreamClass))
#define G_IS_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INPUT_STREAM))
#define G_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INPUT_STREAM, GInputStream))
#define G_IS_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INPUT_STREAM))
#define G_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INPUT_STREAM, GInputStreamClass))

typedef struct _GInputStreamClass {
    GObjectClass parent_class;
     gssize(*read_fn) (GInputStream * stream, void *buffer, gsize count,
		       GCancellable * cancellable, GError * *error);
     gssize(*skip) (GInputStream * stream, gsize count,
		    GCancellable * cancellable, GError * *error);
     gboolean(*close_fn) (GInputStream * stream,
			  GCancellable * cancellable, GError * *error);
    void (*read_async) (GInputStream * stream, void *buffer, gsize count,
			int io_priority, GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
     gssize(*read_finish) (GInputStream * stream, GAsyncResult * result,
			   GError * *error);
    void (*skip_async) (GInputStream * stream, gsize count,
			int io_priority, GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
     gssize(*skip_finish) (GInputStream * stream, GAsyncResult * result,
			   GError * *error);
    void (*close_async) (GInputStream * stream, int io_priority,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*close_finish) (GInputStream * stream, GAsyncResult * result,
			      GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GInputStreamClass;
typedef struct _GInputStreamPrivate GInputStreamPrivate;
struct _GInputStream {
    GObject parent_instance;
    GInputStreamPrivate *priv;
};
extern void g_input_stream_clear_pending(GInputStream * stream);
extern gboolean g_input_stream_close(GInputStream * stream,
				     GCancellable * cancellable,
				     GError * *error);
extern void g_input_stream_close_async(GInputStream * stream,
				       int io_priority,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data);
extern gboolean g_input_stream_close_finish(GInputStream * stream,
					    GAsyncResult * result,
					    GError * *error);
extern GType g_input_stream_get_type(void);
extern gboolean g_input_stream_has_pending(GInputStream * stream);
extern gboolean g_input_stream_is_closed(GInputStream * stream);
extern gssize g_input_stream_read(GInputStream * stream, void *buffer,
				  gsize count, GCancellable * cancellable,
				  GError * *error);
extern gboolean g_input_stream_read_all(GInputStream * stream,
					void *buffer, gsize count,
					gsize * bytes_read,
					GCancellable * cancellable,
					GError * *error);
extern void g_input_stream_read_async(GInputStream * stream, void *buffer,
				      gsize count, int io_priority,
				      GCancellable * cancellable,
				      GAsyncReadyCallback callback,
				      gpointer user_data);
extern gssize g_input_stream_read_finish(GInputStream * stream,
					 GAsyncResult * result,
					 GError * *error);
extern gboolean g_input_stream_set_pending(GInputStream * stream,
					   GError * *error);
extern gssize g_input_stream_skip(GInputStream * stream, gsize count,
				  GCancellable * cancellable,
				  GError * *error);
extern void g_input_stream_skip_async(GInputStream * stream, gsize count,
				      int io_priority,
				      GCancellable * cancellable,
				      GAsyncReadyCallback callback,
				      gpointer user_data);
extern gssize g_input_stream_skip_finish(GInputStream * stream,
					 GAsyncResult * result,
					 GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41171"
>17.12.74. glib-2.0/gio/gio.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __GIO_GIO_H_INSIDE__</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41175"
>17.12.75. glib-2.0/gio/gioenums.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef enum {
    G_APP_INFO_CREATE_NONE,
    G_APP_INFO_CREATE_NEEDS_TERMINAL = (1 &#60;&#60; 0),
    G_APP_INFO_CREATE_SUPPORTS_URIS = (1 &#60;&#60; 1),
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = (1 &#60;&#60; 2)
} GAppInfoCreateFlags;
typedef enum {
    G_CONVERTER_NO_FLAGS,
    G_CONVERTER_INPUT_AT_END = (1 &#60;&#60; 0),
    G_CONVERTER_FLUSH = (1 &#60;&#60; 1)
} GConverterFlags;
typedef enum {
    G_CONVERTER_ERROR,
    G_CONVERTER_CONVERTED,
    G_CONVERTER_FINISHED,
    G_CONVERTER_FLUSHED
} GConverterResult;
typedef enum {
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN,
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN,
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN
} GDataStreamByteOrder;
typedef enum {
    G_DATA_STREAM_NEWLINE_TYPE_LF,
    G_DATA_STREAM_NEWLINE_TYPE_CR,
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF,
    G_DATA_STREAM_NEWLINE_TYPE_ANY
} GDataStreamNewlineType;
typedef enum {
    G_FILE_ATTRIBUTE_TYPE_INVALID,
    G_FILE_ATTRIBUTE_TYPE_STRING,
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING,
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN,
    G_FILE_ATTRIBUTE_TYPE_UINT32,
    G_FILE_ATTRIBUTE_TYPE_INT32,
    G_FILE_ATTRIBUTE_TYPE_UINT64,
    G_FILE_ATTRIBUTE_TYPE_INT64,
    G_FILE_ATTRIBUTE_TYPE_OBJECT,
    G_FILE_ATTRIBUTE_TYPE_STRINGV
} GFileAttributeType;
typedef enum {
    G_FILE_ATTRIBUTE_INFO_NONE,
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = (1 &#60;&#60; 0),
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = (1 &#60;&#60; 1)
} GFileAttributeInfoFlags;
typedef enum {
    G_FILE_ATTRIBUTE_STATUS_UNSET,
    G_FILE_ATTRIBUTE_STATUS_SET,
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING
} GFileAttributeStatus;
typedef enum {
    G_FILE_QUERY_INFO_NONE,
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = (1 &#60;&#60; 0)
} GFileQueryInfoFlags;
typedef enum {
    G_FILE_CREATE_NONE,
    G_FILE_CREATE_PRIVATE = (1 &#60;&#60; 0),
    G_FILE_CREATE_REPLACE_DESTINATION = (1 &#60;&#60; 1)
} GFileCreateFlags;
typedef enum {
    G_MOUNT_MOUNT_NONE
} GMountMountFlags;
typedef enum {
    G_MOUNT_UNMOUNT_NONE,
    G_MOUNT_UNMOUNT_FORCE = (1 &#60;&#60; 0)
} GMountUnmountFlags;
typedef enum {
    G_DRIVE_START_NONE
} GDriveStartFlags;
typedef enum {
    G_DRIVE_START_STOP_TYPE_UNKNOWN,
    G_DRIVE_START_STOP_TYPE_SHUTDOWN,
    G_DRIVE_START_STOP_TYPE_NETWORK,
    G_DRIVE_START_STOP_TYPE_MULTIDISK,
    G_DRIVE_START_STOP_TYPE_PASSWORD
} GDriveStartStopType;
typedef enum {
    G_FILE_COPY_NONE,
    G_FILE_COPY_OVERWRITE = (1 &#60;&#60; 0),
    G_FILE_COPY_BACKUP = (1 &#60;&#60; 1),
    G_FILE_COPY_NOFOLLOW_SYMLINKS = (1 &#60;&#60; 2),
    G_FILE_COPY_ALL_METADATA = (1 &#60;&#60; 3),
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = (1 &#60;&#60; 4),
    G_FILE_COPY_TARGET_DEFAULT_PERMS = (1 &#60;&#60; 5)
} GFileCopyFlags;
typedef enum {
    G_FILE_MONITOR_NONE,
    G_FILE_MONITOR_WATCH_MOUNTS = (1 &#60;&#60; 0),
    G_FILE_MONITOR_SEND_MOVED = (1 &#60;&#60; 1)
} GFileMonitorFlags;
typedef enum {
    G_FILE_TYPE_UNKNOWN,
    G_FILE_TYPE_REGULAR,
    G_FILE_TYPE_DIRECTORY,
    G_FILE_TYPE_SYMBOLIC_LINK,
    G_FILE_TYPE_SPECIAL,
    G_FILE_TYPE_SHORTCUT,
    G_FILE_TYPE_MOUNTABLE
} GFileType;
typedef enum {
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS,
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL,
    G_FILESYSTEM_PREVIEW_TYPE_NEVER
} GFilesystemPreviewType;
typedef enum {
    G_FILE_MONITOR_EVENT_CHANGED,
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT,
    G_FILE_MONITOR_EVENT_DELETED,
    G_FILE_MONITOR_EVENT_CREATED,
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED,
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT,
    G_FILE_MONITOR_EVENT_UNMOUNTED,
    G_FILE_MONITOR_EVENT_MOVED
} GFileMonitorEvent;
typedef enum {
    G_IO_ERROR_FAILED,
    G_IO_ERROR_NOT_FOUND,
    G_IO_ERROR_EXISTS,
    G_IO_ERROR_IS_DIRECTORY,
    G_IO_ERROR_NOT_DIRECTORY,
    G_IO_ERROR_NOT_EMPTY,
    G_IO_ERROR_NOT_REGULAR_FILE,
    G_IO_ERROR_NOT_SYMBOLIC_LINK,
    G_IO_ERROR_NOT_MOUNTABLE_FILE,
    G_IO_ERROR_FILENAME_TOO_LONG,
    G_IO_ERROR_INVALID_FILENAME,
    G_IO_ERROR_TOO_MANY_LINKS,
    G_IO_ERROR_NO_SPACE,
    G_IO_ERROR_INVALID_ARGUMENT,
    G_IO_ERROR_PERMISSION_DENIED,
    G_IO_ERROR_NOT_SUPPORTED,
    G_IO_ERROR_NOT_MOUNTED,
    G_IO_ERROR_ALREADY_MOUNTED,
    G_IO_ERROR_CLOSED,
    G_IO_ERROR_CANCELLED,
    G_IO_ERROR_PENDING,
    G_IO_ERROR_READ_ONLY,
    G_IO_ERROR_CANT_CREATE_BACKUP,
    G_IO_ERROR_WRONG_ETAG,
    G_IO_ERROR_TIMED_OUT,
    G_IO_ERROR_WOULD_RECURSE,
    G_IO_ERROR_BUSY,
    G_IO_ERROR_WOULD_BLOCK,
    G_IO_ERROR_HOST_NOT_FOUND,
    G_IO_ERROR_WOULD_MERGE,
    G_IO_ERROR_FAILED_HANDLED,
    G_IO_ERROR_TOO_MANY_OPEN_FILES,
    G_IO_ERROR_NOT_INITIALIZED,
    G_IO_ERROR_ADDRESS_IN_USE,
    G_IO_ERROR_PARTIAL_INPUT,
    G_IO_ERROR_INVALID_DATA,
    G_IO_ERROR_DBUS_ERROR,
    G_IO_ERROR_HOST_UNREACHABLE,
    G_IO_ERROR_NETWORK_UNREACHABLE,
    G_IO_ERROR_CONNECTION_REFUSED,
    G_IO_ERROR_PROXY_FAILED,
    G_IO_ERROR_PROXY_AUTH_FAILED,
    G_IO_ERROR_PROXY_NEED_AUTH,
    G_IO_ERROR_PROXY_NOT_ALLOWED
} GIOErrorEnum;
typedef enum {
    G_ASK_PASSWORD_NEED_PASSWORD = (1 &#60;&#60; 0),
    G_ASK_PASSWORD_NEED_USERNAME = (1 &#60;&#60; 1),
    G_ASK_PASSWORD_NEED_DOMAIN = (1 &#60;&#60; 2),
    G_ASK_PASSWORD_SAVING_SUPPORTED = (1 &#60;&#60; 3),
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = (1 &#60;&#60; 4)
} GAskPasswordFlags;
typedef enum {
    G_PASSWORD_SAVE_NEVER,
    G_PASSWORD_SAVE_FOR_SESSION,
    G_PASSWORD_SAVE_PERMANENTLY
} GPasswordSave;
typedef enum {
    G_MOUNT_OPERATION_HANDLED,
    G_MOUNT_OPERATION_ABORTED,
    G_MOUNT_OPERATION_UNHANDLED
} GMountOperationResult;
typedef enum {
    G_OUTPUT_STREAM_SPLICE_NONE,
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = (1 &#60;&#60; 0),
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = (1 &#60;&#60; 1)
} GOutputStreamSpliceFlags;
typedef enum {
    G_IO_STREAM_SPLICE_NONE,
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = (1 &#60;&#60; 0),
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = (1 &#60;&#60; 1),
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = (1 &#60;&#60; 2)
} GIOStreamSpliceFlags;
typedef enum {
    G_EMBLEM_ORIGIN_UNKNOWN,
    G_EMBLEM_ORIGIN_DEVICE,
    G_EMBLEM_ORIGIN_LIVEMETADATA,
    G_EMBLEM_ORIGIN_TAG
} GEmblemOrigin;
typedef enum {
    G_RESOLVER_ERROR_NOT_FOUND,
    G_RESOLVER_ERROR_TEMPORARY_FAILURE,
    G_RESOLVER_ERROR_INTERNAL
} GResolverError;
typedef enum {
    G_RESOURCE_ERROR_NOT_FOUND,
    G_RESOURCE_ERROR_INTERNAL
} GResourceError;
typedef enum {
    G_RESOURCE_FLAGS_NONE,
    G_RESOURCE_FLAGS_COMPRESSED = (1 &#60;&#60; 0)
} GResourceFlags;
typedef enum {
    G_RESOURCE_LOOKUP_FLAGS_NONE
} GResourceLookupFlags;
typedef enum {
    G_SOCKET_FAMILY_INVALID,
    G_SOCKET_FAMILY_UNIX,
    G_SOCKET_FAMILY_IPV4,
    G_SOCKET_FAMILY_IPV6
} GSocketFamily;
typedef enum {
    G_SOCKET_TYPE_INVALID,
    G_SOCKET_TYPE_STREAM,
    G_SOCKET_TYPE_DATAGRAM,
    G_SOCKET_TYPE_SEQPACKET
} GSocketType;
typedef enum {
    G_SOCKET_MSG_NONE,
    G_SOCKET_MSG_OOB,
    G_SOCKET_MSG_PEEK,
    G_SOCKET_MSG_DONTROUTE
} GSocketMsgFlags;
typedef enum {
    G_SOCKET_PROTOCOL_UNKNOWN = -1,
    G_SOCKET_PROTOCOL_DEFAULT,
    G_SOCKET_PROTOCOL_TCP,
    G_SOCKET_PROTOCOL_UDP,
    G_SOCKET_PROTOCOL_SCTP
} GSocketProtocol;
typedef enum {
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB,
    G_ZLIB_COMPRESSOR_FORMAT_GZIP,
    G_ZLIB_COMPRESSOR_FORMAT_RAW
} GZlibCompressorFormat;
typedef enum {
    G_UNIX_SOCKET_ADDRESS_INVALID,
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS,
    G_UNIX_SOCKET_ADDRESS_PATH,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
} GUnixSocketAddressType;
typedef enum {
    G_BUS_TYPE_STARTER = -1,
    G_BUS_TYPE_NONE,
    G_BUS_TYPE_SYSTEM,
    G_BUS_TYPE_SESSION
} GBusType;
typedef enum {
    G_BUS_NAME_OWNER_FLAGS_NONE,
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = (1 &#60;&#60; 0),
    G_BUS_NAME_OWNER_FLAGS_REPLACE = (1 &#60;&#60; 1)
} GBusNameOwnerFlags;
typedef enum {
    G_BUS_NAME_WATCHER_FLAGS_NONE,
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = (1 &#60;&#60; 0)
} GBusNameWatcherFlags;
typedef enum {
    G_DBUS_PROXY_FLAGS_NONE,
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = (1 &#60;&#60; 0),
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = (1 &#60;&#60; 1),
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = (1 &#60;&#60; 2),
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = (1 &#60;&#60; 3)
} GDBusProxyFlags;
typedef enum {
    G_DBUS_ERROR_FAILED,
    G_DBUS_ERROR_NO_MEMORY,
    G_DBUS_ERROR_SERVICE_UNKNOWN,
    G_DBUS_ERROR_NAME_HAS_NO_OWNER,
    G_DBUS_ERROR_NO_REPLY,
    G_DBUS_ERROR_IO_ERROR,
    G_DBUS_ERROR_BAD_ADDRESS,
    G_DBUS_ERROR_NOT_SUPPORTED,
    G_DBUS_ERROR_LIMITS_EXCEEDED,
    G_DBUS_ERROR_ACCESS_DENIED,
    G_DBUS_ERROR_AUTH_FAILED,
    G_DBUS_ERROR_NO_SERVER,
    G_DBUS_ERROR_TIMEOUT,
    G_DBUS_ERROR_NO_NETWORK,
    G_DBUS_ERROR_ADDRESS_IN_USE,
    G_DBUS_ERROR_DISCONNECTED,
    G_DBUS_ERROR_INVALID_ARGS,
    G_DBUS_ERROR_FILE_NOT_FOUND,
    G_DBUS_ERROR_FILE_EXISTS,
    G_DBUS_ERROR_UNKNOWN_METHOD,
    G_DBUS_ERROR_TIMED_OUT,
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND,
    G_DBUS_ERROR_MATCH_RULE_INVALID,
    G_DBUS_ERROR_SPAWN_EXEC_FAILED,
    G_DBUS_ERROR_SPAWN_FORK_FAILED,
    G_DBUS_ERROR_SPAWN_CHILD_EXITED,
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED,
    G_DBUS_ERROR_SPAWN_FAILED,
    G_DBUS_ERROR_SPAWN_SETUP_FAILED,
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID,
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID,
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND,
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID,
    G_DBUS_ERROR_SPAWN_FILE_INVALID,
    G_DBUS_ERROR_SPAWN_NO_MEMORY,
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN,
    G_DBUS_ERROR_INVALID_SIGNATURE,
    G_DBUS_ERROR_INVALID_FILE_CONTENT,
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN,
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN,
    G_DBUS_ERROR_OBJECT_PATH_IN_USE
} GDBusError;
typedef enum {
    G_DBUS_CONNECTION_FLAGS_NONE,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = (1 &#60;&#60; 0),
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = (1 &#60;&#60; 1),
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = (1 &#60;&#60; 2),
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = (1 &#60;&#60; 3),
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = (1 &#60;&#60; 4)
} GDBusConnectionFlags;
typedef enum {
    G_DBUS_CAPABILITY_FLAGS_NONE,
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = (1 &#60;&#60; 0)
} GDBusCapabilityFlags;
typedef enum {
    G_DBUS_CALL_FLAGS_NONE,
    G_DBUS_CALL_FLAGS_NO_AUTO_START = (1 &#60;&#60; 0)
} GDBusCallFlags;
typedef enum {
    G_DBUS_MESSAGE_TYPE_INVALID,
    G_DBUS_MESSAGE_TYPE_METHOD_CALL,
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
    G_DBUS_MESSAGE_TYPE_ERROR,
    G_DBUS_MESSAGE_TYPE_SIGNAL
} GDBusMessageType;
typedef enum {
    G_DBUS_MESSAGE_FLAGS_NONE,
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = (1 &#60;&#60; 0),
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = (1 &#60;&#60; 1)
} GDBusMessageFlags;
typedef enum {
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID,
    G_DBUS_MESSAGE_HEADER_FIELD_PATH,
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE,
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER,
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME,
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL,
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION,
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER,
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE,
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS
} GDBusMessageHeaderField;
typedef enum {
    G_DBUS_PROPERTY_INFO_FLAGS_NONE,
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = (1 &#60;&#60; 0),
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = (1 &#60;&#60; 1)
} GDBusPropertyInfoFlags;
typedef enum {
    G_DBUS_SUBTREE_FLAGS_NONE,
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = (1 &#60;&#60; 0)
} GDBusSubtreeFlags;
typedef enum {
    G_DBUS_SERVER_FLAGS_NONE,
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = (1 &#60;&#60; 0),
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = (1 &#60;&#60; 1)
} GDBusServerFlags;
typedef enum {
    G_DBUS_SIGNAL_FLAGS_NONE,
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = (1 &#60;&#60; 0)
} GDBusSignalFlags;
typedef enum {
    G_DBUS_SEND_MESSAGE_FLAGS_NONE,
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = (1 &#60;&#60; 0)
} GDBusSendMessageFlags;
typedef enum {
    G_CREDENTIALS_TYPE_INVALID,
    G_CREDENTIALS_TYPE_LINUX_UCRED,
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED,
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED
} GCredentialsType;
typedef enum {
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN,
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN
} GDBusMessageByteOrder;
typedef enum {
    G_APPLICATION_FLAGS_NONE,
    G_APPLICATION_IS_SERVICE = (1 &#60;&#60; 0),
    G_APPLICATION_IS_LAUNCHER = (1 &#60;&#60; 1),
    G_APPLICATION_HANDLES_OPEN = (1 &#60;&#60; 2),
    G_APPLICATION_HANDLES_COMMAND_LINE = (1 &#60;&#60; 3),
    G_APPLICATION_SEND_ENVIRONMENT = (1 &#60;&#60; 4),
    G_APPLICATION_NON_UNIQUE = (1 &#60;&#60; 5)
} GApplicationFlags;
typedef enum {
    G_TLS_ERROR_UNAVAILABLE,
    G_TLS_ERROR_MISC,
    G_TLS_ERROR_BAD_CERTIFICATE,
    G_TLS_ERROR_NOT_TLS,
    G_TLS_ERROR_HANDSHAKE,
    G_TLS_ERROR_CERTIFICATE_REQUIRED,
    G_TLS_ERROR_EOF
} GTlsError;
typedef enum {
    G_TLS_CERTIFICATE_UNKNOWN_CA = (1 &#60;&#60; 0),
    G_TLS_CERTIFICATE_BAD_IDENTITY = (1 &#60;&#60; 1),
    G_TLS_CERTIFICATE_NOT_ACTIVATED = (1 &#60;&#60; 2),
    G_TLS_CERTIFICATE_EXPIRED = (1 &#60;&#60; 3),
    G_TLS_CERTIFICATE_REVOKED = (1 &#60;&#60; 4),
    G_TLS_CERTIFICATE_INSECURE = (1 &#60;&#60; 5),
    G_TLS_CERTIFICATE_GENERIC_ERROR = (1 &#60;&#60; 6),
    G_TLS_CERTIFICATE_VALIDATE_ALL = 0x007f
} GTlsCertificateFlags;
typedef enum {
    G_TLS_AUTHENTICATION_NONE,
    G_TLS_AUTHENTICATION_REQUESTED,
    G_TLS_AUTHENTICATION_REQUIRED
} GTlsAuthenticationMode;
typedef enum {
    G_TLS_REHANDSHAKE_NEVER,
    G_TLS_REHANDSHAKE_SAFELY,
    G_TLS_REHANDSHAKE_UNSAFELY
} GTlsRehandshakeMode;
typedef enum _GTlsPasswordFlags {
    G_TLS_PASSWORD_NONE,
    G_TLS_PASSWORD_RETRY = 1 &#60;&#60; 1,
    G_TLS_PASSWORD_MANY_TRIES = 1 &#60;&#60; 2,
    G_TLS_PASSWORD_FINAL_TRY = 1 &#60;&#60; 3
} GTlsPasswordFlags;
typedef enum {
    G_TLS_INTERACTION_UNHANDLED,
    G_TLS_INTERACTION_HANDLED,
    G_TLS_INTERACTION_FAILED
} GTlsInteractionResult;
typedef enum {
    G_DBUS_INTERFACE_SKELETON_FLAGS_NONE,
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD =
	(1 &#60;&#60; 0)
} GDBusInterfaceSkeletonFlags;
typedef enum {
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = (1 &#60;&#60; 0)
} GDBusObjectManagerClientFlags;
typedef enum {
    G_TLS_DATABASE_VERIFY_NONE
} GTlsDatabaseVerifyFlags;
typedef enum {
    G_TLS_DATABASE_LOOKUP_NONE,
    G_TLS_DATABASE_LOOKUP_KEYPAIR
} GTlsDatabaseLookupFlags;
typedef enum {
    G_IO_MODULE_SCOPE_NONE,
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
} GIOModuleScopeFlags;
typedef enum {
    G_SOCKET_CLIENT_RESOLVING,
    G_SOCKET_CLIENT_RESOLVED,
    G_SOCKET_CLIENT_CONNECTING,
    G_SOCKET_CLIENT_CONNECTED,
    G_SOCKET_CLIENT_PROXY_NEGOTIATING,
    G_SOCKET_CLIENT_PROXY_NEGOTIATED,
    G_SOCKET_CLIENT_TLS_HANDSHAKING,
    G_SOCKET_CLIENT_TLS_HANDSHAKED,
    G_SOCKET_CLIENT_COMPLETE
} GSocketClientEvent;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41179"
>17.12.76. glib-2.0/gio/gioenumtypes.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_APPLICATION_FLAGS	(g_application_flags_get_type ())
#define G_TYPE_APP_INFO_CREATE_FLAGS	(g_app_info_create_flags_get_type ())
#define G_TYPE_ASK_PASSWORD_FLAGS	(g_ask_password_flags_get_type ())
#define G_TYPE_BUS_NAME_OWNER_FLAGS	(g_bus_name_owner_flags_get_type ())
#define G_TYPE_BUS_NAME_WATCHER_FLAGS	(g_bus_name_watcher_flags_get_type ())
#define G_TYPE_BUS_TYPE	(g_bus_type_get_type ())
#define G_TYPE_CONVERTER_FLAGS	(g_converter_flags_get_type ())
#define G_TYPE_CONVERTER_RESULT	(g_converter_result_get_type ())
#define G_TYPE_CREDENTIALS_TYPE	(g_credentials_type_get_type ())
#define G_TYPE_DATA_STREAM_BYTE_ORDER	(g_data_stream_byte_order_get_type ())
#define G_TYPE_DATA_STREAM_NEWLINE_TYPE	(g_data_stream_newline_type_get_type ())
#define G_TYPE_DBUS_CALL_FLAGS	(g_dbus_call_flags_get_type ())
#define G_TYPE_DBUS_CAPABILITY_FLAGS	(g_dbus_capability_flags_get_type ())
#define G_TYPE_DBUS_CONNECTION_FLAGS	(g_dbus_connection_flags_get_type ())
#define G_TYPE_DBUS_ERROR	(g_dbus_error_get_type ())
#define G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS	(g_dbus_interface_skeleton_flags_get_type ())
#define G_TYPE_DBUS_MESSAGE_BYTE_ORDER	(g_dbus_message_byte_order_get_type ())
#define G_TYPE_DBUS_MESSAGE_FLAGS	(g_dbus_message_flags_get_type ())
#define G_TYPE_DBUS_MESSAGE_HEADER_FIELD	(g_dbus_message_header_field_get_type ())
#define G_TYPE_DBUS_MESSAGE_TYPE	(g_dbus_message_type_get_type ())
#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS	(g_dbus_object_manager_client_flags_get_type ())
#define G_TYPE_DBUS_PROPERTY_INFO_FLAGS	(g_dbus_property_info_flags_get_type ())
#define G_TYPE_DBUS_PROXY_FLAGS	(g_dbus_proxy_flags_get_type ())
#define G_TYPE_DBUS_SEND_MESSAGE_FLAGS	(g_dbus_send_message_flags_get_type ())
#define G_TYPE_DBUS_SERVER_FLAGS	(g_dbus_server_flags_get_type ())
#define G_TYPE_DBUS_SIGNAL_FLAGS	(g_dbus_signal_flags_get_type ())
#define G_TYPE_DBUS_SUBTREE_FLAGS	(g_dbus_subtree_flags_get_type ())
#define G_TYPE_DRIVE_START_FLAGS	(g_drive_start_flags_get_type ())
#define G_TYPE_DRIVE_START_STOP_TYPE	(g_drive_start_stop_type_get_type ())
#define G_TYPE_EMBLEM_ORIGIN	(g_emblem_origin_get_type ())
#define G_TYPE_FILESYSTEM_PREVIEW_TYPE	(g_filesystem_preview_type_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS	(g_file_attribute_info_flags_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_STATUS	(g_file_attribute_status_get_type ())
#define G_TYPE_FILE_ATTRIBUTE_TYPE	(g_file_attribute_type_get_type ())
#define G_TYPE_FILE_COPY_FLAGS	(g_file_copy_flags_get_type ())
#define G_TYPE_FILE_CREATE_FLAGS	(g_file_create_flags_get_type ())
#define G_TYPE_FILE_MONITOR_EVENT	(g_file_monitor_event_get_type ())
#define G_TYPE_FILE_MONITOR_FLAGS	(g_file_monitor_flags_get_type ())
#define G_TYPE_FILE_QUERY_INFO_FLAGS	(g_file_query_info_flags_get_type ())
#define G_TYPE_FILE_TYPE	(g_file_type_get_type ())
#define G_TYPE_IO_ERROR_ENUM	(g_io_error_enum_get_type ())
#define G_TYPE_IO_MODULE_SCOPE_FLAGS	(g_io_module_scope_flags_get_type ())
#define G_TYPE_IO_STREAM_SPLICE_FLAGS	(g_io_stream_splice_flags_get_type ())
#define G_TYPE_MOUNT_MOUNT_FLAGS	(g_mount_mount_flags_get_type ())
#define G_TYPE_MOUNT_OPERATION_RESULT	(g_mount_operation_result_get_type ())
#define G_TYPE_MOUNT_UNMOUNT_FLAGS	(g_mount_unmount_flags_get_type ())
#define G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS	(g_output_stream_splice_flags_get_type ())
#define G_TYPE_PASSWORD_SAVE	(g_password_save_get_type ())
#define G_TYPE_RESOLVER_ERROR	(g_resolver_error_get_type ())
#define G_TYPE_RESOURCE_ERROR	(g_resource_error_get_type ())
#define G_TYPE_RESOURCE_FLAGS	(g_resource_flags_get_type ())
#define G_TYPE_RESOURCE_LOOKUP_FLAGS	(g_resource_lookup_flags_get_type ())
#define G_TYPE_SETTINGS_BIND_FLAGS	(g_settings_bind_flags_get_type ())
#define G_TYPE_SOCKET_CLIENT_EVENT	(g_socket_client_event_get_type ())
#define G_TYPE_SOCKET_FAMILY	(g_socket_family_get_type ())
#define G_TYPE_SOCKET_MSG_FLAGS	(g_socket_msg_flags_get_type ())
#define G_TYPE_SOCKET_PROTOCOL	(g_socket_protocol_get_type ())
#define G_TYPE_SOCKET_TYPE	(g_socket_type_get_type ())
#define G_TYPE_TLS_AUTHENTICATION_MODE	(g_tls_authentication_mode_get_type ())
#define G_TYPE_TLS_CERTIFICATE_FLAGS	(g_tls_certificate_flags_get_type ())
#define G_TYPE_TLS_DATABASE_LOOKUP_FLAGS	(g_tls_database_lookup_flags_get_type ())
#define G_TYPE_TLS_DATABASE_VERIFY_FLAGS	(g_tls_database_verify_flags_get_type ())
#define G_TYPE_TLS_ERROR	(g_tls_error_get_type ())
#define G_TYPE_TLS_INTERACTION_RESULT	(g_tls_interaction_result_get_type ())
#define G_TYPE_TLS_PASSWORD_FLAGS	(g_tls_password_flags_get_type ())
#define G_TYPE_TLS_REHANDSHAKE_MODE	(g_tls_rehandshake_mode_get_type ())
#define G_TYPE_UNIX_SOCKET_ADDRESS_TYPE	(g_unix_socket_address_type_get_type ())
#define G_TYPE_ZLIB_COMPRESSOR_FORMAT	(g_zlib_compressor_format_get_type ())

extern GType g_app_info_create_flags_get_type(void);
extern GType g_application_flags_get_type(void);
extern GType g_ask_password_flags_get_type(void);
extern GType g_bus_name_owner_flags_get_type(void);
extern GType g_bus_name_watcher_flags_get_type(void);
extern GType g_bus_type_get_type(void);
extern GType g_converter_flags_get_type(void);
extern GType g_converter_result_get_type(void);
extern GType g_credentials_type_get_type(void);
extern GType g_data_stream_byte_order_get_type(void);
extern GType g_data_stream_newline_type_get_type(void);
extern GType g_dbus_call_flags_get_type(void);
extern GType g_dbus_capability_flags_get_type(void);
extern GType g_dbus_connection_flags_get_type(void);
extern GType g_dbus_error_get_type(void);
extern GType g_dbus_interface_skeleton_flags_get_type(void);
extern GType g_dbus_message_byte_order_get_type(void);
extern GType g_dbus_message_flags_get_type(void);
extern GType g_dbus_message_header_field_get_type(void);
extern GType g_dbus_message_type_get_type(void);
extern GType g_dbus_object_manager_client_flags_get_type(void);
extern GType g_dbus_property_info_flags_get_type(void);
extern GType g_dbus_proxy_flags_get_type(void);
extern GType g_dbus_send_message_flags_get_type(void);
extern GType g_dbus_server_flags_get_type(void);
extern GType g_dbus_signal_flags_get_type(void);
extern GType g_dbus_subtree_flags_get_type(void);
extern GType g_drive_start_flags_get_type(void);
extern GType g_drive_start_stop_type_get_type(void);
extern GType g_emblem_origin_get_type(void);
extern GType g_file_attribute_info_flags_get_type(void);
extern GType g_file_attribute_status_get_type(void);
extern GType g_file_attribute_type_get_type(void);
extern GType g_file_copy_flags_get_type(void);
extern GType g_file_create_flags_get_type(void);
extern GType g_file_monitor_event_get_type(void);
extern GType g_file_monitor_flags_get_type(void);
extern GType g_file_query_info_flags_get_type(void);
extern GType g_file_type_get_type(void);
extern GType g_filesystem_preview_type_get_type(void);
extern GType g_io_error_enum_get_type(void);
extern GType g_io_module_scope_flags_get_type(void);
extern GType g_io_stream_splice_flags_get_type(void);
extern GType g_mount_mount_flags_get_type(void);
extern GType g_mount_operation_result_get_type(void);
extern GType g_mount_unmount_flags_get_type(void);
extern GType g_output_stream_splice_flags_get_type(void);
extern GType g_password_save_get_type(void);
extern GType g_resolver_error_get_type(void);
extern GType g_resource_error_get_type(void);
extern GType g_resource_flags_get_type(void);
extern GType g_resource_lookup_flags_get_type(void);
extern GType g_settings_bind_flags_get_type(void);
extern GType g_socket_client_event_get_type(void);
extern GType g_socket_family_get_type(void);
extern GType g_socket_msg_flags_get_type(void);
extern GType g_socket_protocol_get_type(void);
extern GType g_socket_type_get_type(void);
extern GType g_tls_authentication_mode_get_type(void);
extern GType g_tls_certificate_flags_get_type(void);
extern GType g_tls_database_lookup_flags_get_type(void);
extern GType g_tls_database_verify_flags_get_type(void);
extern GType g_tls_error_get_type(void);
extern GType g_tls_interaction_result_get_type(void);
extern GType g_tls_password_flags_get_type(void);
extern GType g_tls_rehandshake_mode_get_type(void);
extern GType g_unix_socket_address_type_get_type(void);
extern GType g_zlib_compressor_format_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41183"
>17.12.77. glib-2.0/gio/gioerror.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_IO_ERROR	g_io_error_quark()

extern GIOErrorEnum g_io_error_from_errno(gint err_no);
extern GQuark g_io_error_quark(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41187"
>17.12.78. glib-2.0/gio/giomodule.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_IO_TYPE_MODULE	(g_io_module_get_type ())
#define G_IO_MODULE_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_IO_TYPE_MODULE, GIOModuleClass))
#define G_IO_IS_MODULE_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_IO_TYPE_MODULE))
#define G_IO_MODULE(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_IO_TYPE_MODULE, GIOModule))
#define G_IO_IS_MODULE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_IO_TYPE_MODULE))
#define G_IO_MODULE_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_IO_TYPE_MODULE, GIOModuleClass))

typedef struct _GIOModuleScope GIOModuleScope;
extern const char *g_io_extension_get_name(GIOExtension * extension);
extern gint g_io_extension_get_priority(GIOExtension * extension);
extern GType g_io_extension_get_type(GIOExtension * extension);
extern GIOExtension
    *g_io_extension_point_get_extension_by_name(GIOExtensionPoint *
						extension_point,
						const char *name);
extern GList *g_io_extension_point_get_extensions(GIOExtensionPoint *
						  extension_point);
extern GType g_io_extension_point_get_required_type(GIOExtensionPoint *
						    extension_point);
extern GIOExtension *g_io_extension_point_implement(const char
						    *extension_point_name,
						    GType type,
						    const char
						    *extension_name,
						    gint priority);
extern GIOExtensionPoint *g_io_extension_point_lookup(const char *name);
extern GIOExtensionPoint *g_io_extension_point_register(const char *name);
extern void g_io_extension_point_set_required_type(GIOExtensionPoint *
						   extension_point,
						   GType type);
extern GTypeClass *g_io_extension_ref_class(GIOExtension * extension);
extern GType g_io_module_get_type(void);
extern GIOModule *g_io_module_new(const gchar * filename);
extern void g_io_module_scope_block(GIOModuleScope * scope,
				    const gchar * basename);
extern void g_io_module_scope_free(GIOModuleScope * scope);
extern GIOModuleScope *g_io_module_scope_new(GIOModuleScopeFlags flags);
extern GList *g_io_modules_load_all_in_directory(const gchar * dirname);
extern GList *g_io_modules_load_all_in_directory_with_scope(const gchar *
							    dirname,
							    GIOModuleScope
							    * scope);
extern void g_io_modules_scan_all_in_directory(const char *dirname);
extern void g_io_modules_scan_all_in_directory_with_scope(const gchar *
							  dirname,
							  GIOModuleScope *
							  scope);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41191"
>17.12.79. glib-2.0/gio/gioscheduler.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void g_io_scheduler_cancel_all_jobs(void);
extern gboolean g_io_scheduler_job_send_to_mainloop(GIOSchedulerJob * job,
						    GSourceFunc func,
						    gpointer user_data,
						    GDestroyNotify notify);
extern void g_io_scheduler_job_send_to_mainloop_async(GIOSchedulerJob *
						      job,
						      GSourceFunc func,
						      gpointer user_data,
						      GDestroyNotify
						      notify);
extern void g_io_scheduler_push_job(GIOSchedulerJobFunc job_func,
				    gpointer user_data,
				    GDestroyNotify notify,
				    gint io_priority,
				    GCancellable * cancellable);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41195"
>17.12.80. glib-2.0/gio/giostream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_IO_STREAM	(g_io_stream_get_type ())
#define G_IO_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_IO_STREAM, GIOStreamClass))
#define G_IS_IO_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_IO_STREAM))
#define G_IO_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_IO_STREAM, GIOStream))
#define G_IS_IO_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_IO_STREAM))
#define G_IO_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_IO_STREAM, GIOStreamClass))

typedef struct _GIOStreamPrivate GIOStreamPrivate;
typedef struct _GIOStreamClass {
    GObjectClass parent_class;
    GInputStream *(*get_input_stream) (GIOStream * stream);
    GOutputStream *(*get_output_stream) (GIOStream * stream);
     gboolean(*close_fn) (GIOStream * stream, GCancellable * cancellable,
			  GError * *error);
    void (*close_async) (GIOStream * stream, int io_priority,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*close_finish) (GIOStream * stream, GAsyncResult * result,
			      GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
    void (*_g_reserved8) (void);
    void (*_g_reserved9) (void);
    void (*_g_reserved10) (void);
} GIOStreamClass;
struct _GIOStream {
    GObject parent_instance;
    GIOStreamPrivate *priv;
};
extern void g_io_stream_clear_pending(GIOStream * stream);
extern gboolean g_io_stream_close(GIOStream * stream,
				  GCancellable * cancellable,
				  GError * *error);
extern void g_io_stream_close_async(GIOStream * stream, int io_priority,
				    GCancellable * cancellable,
				    GAsyncReadyCallback callback,
				    gpointer user_data);
extern gboolean g_io_stream_close_finish(GIOStream * stream,
					 GAsyncResult * result,
					 GError * *error);
extern GInputStream *g_io_stream_get_input_stream(GIOStream * stream);
extern GOutputStream *g_io_stream_get_output_stream(GIOStream * stream);
extern GType g_io_stream_get_type(void);
extern gboolean g_io_stream_has_pending(GIOStream * stream);
extern gboolean g_io_stream_is_closed(GIOStream * stream);
extern gboolean g_io_stream_set_pending(GIOStream * stream,
					GError * *error);
extern void g_io_stream_splice_async(GIOStream * stream1,
				     GIOStream * stream2,
				     GIOStreamSpliceFlags flags,
				     int io_priority,
				     GCancellable * cancellable,
				     GAsyncReadyCallback callback,
				     gpointer user_data);
extern gboolean g_io_stream_splice_finish(GAsyncResult * result,
					  GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41199"
>17.12.81. glib-2.0/gio/giotypes.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct _GAppLaunchContext GAppLaunchContext;
typedef struct _GAppInfo GAppInfo;
typedef struct _GAsyncResult GAsyncResult;
typedef struct _GAsyncInitable GAsyncInitable;
typedef struct _GBufferedInputStream GBufferedInputStream;
typedef struct _GBufferedOutputStream GBufferedOutputStream;
typedef struct _GCancellable GCancellable;
typedef struct _GCharsetConverter GCharsetConverter;
typedef struct _GConverter GConverter;
typedef struct _GConverterInputStream GConverterInputStream;
typedef struct _GConverterOutputStream GConverterOutputStream;
typedef struct _GDataInputStream GDataInputStream;
typedef struct _GSimplePermission GSimplePermission;
typedef struct _GZlibCompressor GZlibCompressor;
typedef struct _GZlibDecompressor GZlibDecompressor;
typedef struct _GSimpleActionGroup GSimpleActionGroup;
typedef struct _GRemoteActionGroup GRemoteActionGroup;
typedef struct _GDBusActionGroup GDBusActionGroup;
typedef struct _GActionMap GActionMap;
typedef struct _GActionGroup GActionGroup;
typedef struct _GSimpleAction GSimpleAction;
typedef struct _GAction GAction;
typedef struct _GApplication GApplication;
typedef struct _GApplicationCommandLine GApplicationCommandLine;
typedef struct _GSettingsBackend GSettingsBackend;
typedef struct _GSettings GSettings;
typedef struct _GPermission GPermission;
typedef struct _GMenuModel GMenuModel;
typedef struct _GDrive GDrive;
typedef struct _GFileEnumerator GFileEnumerator;
typedef struct _GFileMonitor GFileMonitor;
typedef struct _GFilterInputStream GFilterInputStream;
typedef struct _GFilterOutputStream GFilterOutputStream;
typedef struct _GFile GFile;
typedef struct _GFileInfo GFileInfo;
typedef struct _GFileAttributeMatcher GFileAttributeMatcher;
typedef struct _GFileAttributeInfo GFileAttributeInfo;
typedef struct _GFileAttributeInfoList GFileAttributeInfoList;
typedef struct _GFileDescriptorBased GFileDescriptorBased;
typedef struct _GFileInputStream GFileInputStream;
typedef struct _GFileOutputStream GFileOutputStream;
typedef struct _GFileIOStream GFileIOStream;
typedef struct _GFileIcon GFileIcon;
typedef struct _GFilenameCompleter GFilenameCompleter;
typedef struct _GIcon GIcon;
typedef struct _GInetAddress GInetAddress;
typedef struct _GInetAddressMask GInetAddressMask;
typedef struct _GInetSocketAddress GInetSocketAddress;
typedef struct _GInputStream GInputStream;
typedef struct _GInitable GInitable;
typedef struct _GIOModule GIOModule;
typedef struct _GIOExtensionPoint GIOExtensionPoint;
typedef struct _GIOExtension GIOExtension;
typedef struct _GIOSchedulerJob GIOSchedulerJob;
typedef struct _GIOStreamAdapter GIOStreamAdapter;
typedef struct _GLoadableIcon GLoadableIcon;
typedef struct _GMemoryInputStream GMemoryInputStream;
typedef struct _GMemoryOutputStream GMemoryOutputStream;
typedef struct _GMount GMount;
typedef struct _GMountOperation GMountOperation;
typedef struct _GNetworkAddress GNetworkAddress;
typedef struct _GNetworkMonitor GNetworkMonitor;
typedef struct _GNetworkService GNetworkService;
typedef struct _GOutputStream GOutputStream;
typedef struct _GIOStream GIOStream;
typedef struct _GPollableInputStream GPollableInputStream;
typedef struct _GPollableOutputStream GPollableOutputStream;
typedef struct _GResolver GResolver;
typedef struct _GResource GResource;
typedef struct _GSeekable GSeekable;
typedef struct _GSimpleAsyncResult GSimpleAsyncResult;
typedef struct _GSocket GSocket;
typedef struct _GSocketControlMessage GSocketControlMessage;
typedef struct _GSocketClient GSocketClient;
typedef struct _GSocketConnection GSocketConnection;
typedef struct _GSocketListener GSocketListener;
typedef struct _GSocketService GSocketService;
typedef struct _GSocketAddress GSocketAddress;
typedef struct _GSocketAddressEnumerator GSocketAddressEnumerator;
typedef struct _GSocketConnectable GSocketConnectable;
typedef struct _GSrvTarget GSrvTarget;
typedef struct _GTcpConnection GTcpConnection;
typedef struct _GTcpWrapperConnection GTcpWrapperConnection;
typedef struct _GThreadedSocketService GThreadedSocketService;
typedef struct _GThemedIcon GThemedIcon;
typedef struct _GTlsCertificate GTlsCertificate;
typedef struct _GTlsClientConnection GTlsClientConnection;
typedef struct _GTlsConnection GTlsConnection;
typedef struct _GTlsDatabase GTlsDatabase;
typedef struct _GTlsFileDatabase GTlsFileDatabase;
typedef struct _GTlsInteraction GTlsInteraction;
typedef struct _GTlsPassword GTlsPassword;
typedef struct _GTlsServerConnection GTlsServerConnection;
typedef struct _GVfs GVfs;
typedef struct _GProxyResolver GProxyResolver;
typedef struct _GProxy GProxy;
typedef struct _GProxyAddress GProxyAddress;
typedef struct _GProxyAddressEnumerator GProxyAddressEnumerator;
typedef struct _GVolume GVolume;
typedef struct _GVolumeMonitor GVolumeMonitor;
typedef void (*GAsyncReadyCallback) (GObject * source_object,
				     GAsyncResult * res,
				     gpointer user_data);
typedef void (*GFileProgressCallback) (goffset current_num_bytes,
				       goffset total_num_bytes,
				       gpointer user_data);
typedef gboolean(*GFileReadMoreCallback) (const char *file_contents,
					  goffset file_size,
					  gpointer callback_data);
typedef gboolean(*GIOSchedulerJobFunc) (GIOSchedulerJob * job,
					GCancellable * cancellable,
					gpointer user_data);
typedef void (*GSimpleAsyncThreadFunc) (GSimpleAsyncResult * res,
					GObject * object,
					GCancellable * cancellable);
typedef struct _GInputVector {
    gpointer buffer;
    gsize size;
} GInputVector;
typedef struct _GOutputVector {
    gconstpointer buffer;
    gsize size;
} GOutputVector;
typedef struct _GCredentials GCredentials;
typedef struct _GUnixCredentialsMessage GUnixCredentialsMessage;
typedef struct _GUnixFDList GUnixFDList;
typedef struct _GDBusMessage GDBusMessage;
typedef struct _GDBusConnection GDBusConnection;
typedef struct _GDBusProxy GDBusProxy;
typedef struct _GDBusMethodInvocation GDBusMethodInvocation;
typedef struct _GDBusServer GDBusServer;
typedef struct _GDBusAuthObserver GDBusAuthObserver;
typedef struct _GDBusErrorEntry GDBusErrorEntry;
typedef struct _GDBusInterfaceVTable GDBusInterfaceVTable;
typedef struct _GDBusSubtreeVTable GDBusSubtreeVTable;
typedef struct _GDBusAnnotationInfo GDBusAnnotationInfo;
typedef struct _GDBusArgInfo GDBusArgInfo;
typedef struct _GDBusMethodInfo GDBusMethodInfo;
typedef struct _GDBusSignalInfo GDBusSignalInfo;
typedef struct _GDBusPropertyInfo GDBusPropertyInfo;
typedef struct _GDBusInterfaceInfo GDBusInterfaceInfo;
typedef struct _GDBusNodeInfo GDBusNodeInfo;
typedef struct _GDBusInterface GDBusInterface;
typedef struct _GDBusInterfaceSkeleton GDBusInterfaceSkeleton;
typedef struct _GDBusObject GDBusObject;
typedef struct _GDBusObjectSkeleton GDBusObjectSkeleton;
typedef struct _GDBusObjectProxy GDBusObjectProxy;
typedef struct _GDBusObjectManager GDBusObjectManager;
typedef struct _GDBusObjectManagerClient GDBusObjectManagerClient;
typedef struct _GDBusObjectManagerServer GDBusObjectManagerServer;
typedef GType(*GDBusProxyTypeFunc) (GDBusObjectManagerClient * manager,
				    const gchar * object_path,
				    const gchar * interface_name,
				    gpointer user_data);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41203"
>17.12.82. glib-2.0/gio/gloadableicon.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_LOADABLE_ICON	(g_loadable_icon_get_type ())
#define G_LOADABLE_ICON(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_LOADABLE_ICON, GLoadableIcon))
#define G_IS_LOADABLE_ICON(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_LOADABLE_ICON))
#define G_LOADABLE_ICON_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_LOADABLE_ICON, GLoadableIconIface))

typedef struct _GLoadableIconIface {
    GTypeInterface g_iface;
    GInputStream *(*load) (GLoadableIcon * icon, int size, char **type,
			   GCancellable * cancellable, GError * *error);
    void (*load_async) (GLoadableIcon * icon, int size,
			GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
    GInputStream *(*load_finish) (GLoadableIcon * icon, GAsyncResult * res,
				  char **type, GError * *error);
} GLoadableIconIface;
extern GType g_loadable_icon_get_type(void);
extern GInputStream *g_loadable_icon_load(GLoadableIcon * icon, int size,
					  char **type,
					  GCancellable * cancellable,
					  GError * *error);
extern void g_loadable_icon_load_async(GLoadableIcon * icon, int size,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data);
extern GInputStream *g_loadable_icon_load_finish(GLoadableIcon * icon,
						 GAsyncResult * res,
						 char **type,
						 GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41207"
>17.12.83. glib-2.0/gio/gmemoryinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_MEMORY_INPUT_STREAM	(g_memory_input_stream_get_type ())
#define G_MEMORY_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass))
#define G_IS_MEMORY_INPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MEMORY_INPUT_STREAM))
#define G_MEMORY_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStream))
#define G_IS_MEMORY_INPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MEMORY_INPUT_STREAM))
#define G_MEMORY_INPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass))

typedef struct _GMemoryInputStreamClass {
    GInputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GMemoryInputStreamClass;
typedef struct _GMemoryInputStreamPrivate GMemoryInputStreamPrivate;
struct _GMemoryInputStream {
    GInputStream parent_instance;
    GMemoryInputStreamPrivate *priv;
};
extern void g_memory_input_stream_add_data(GMemoryInputStream * stream,
					   const void *data, gssize len,
					   GDestroyNotify destroy);
extern GType g_memory_input_stream_get_type(void);
extern GInputStream *g_memory_input_stream_new(void);
extern GInputStream *g_memory_input_stream_new_from_data(const void *data,
							 gssize len,
							 GDestroyNotify
							 destroy);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41211"
>17.12.84. glib-2.0/gio/gmemoryoutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_MEMORY_OUTPUT_STREAM	(g_memory_output_stream_get_type ())
#define G_MEMORY_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass))
#define G_IS_MEMORY_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MEMORY_OUTPUT_STREAM))
#define G_MEMORY_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStream))
#define G_IS_MEMORY_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MEMORY_OUTPUT_STREAM))
#define G_MEMORY_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass))

typedef struct _GMemoryOutputStreamClass {
    GOutputStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GMemoryOutputStreamClass;
typedef struct _GMemoryOutputStreamPrivate GMemoryOutputStreamPrivate;
struct _GMemoryOutputStream {
    GOutputStream parent_instance;
    GMemoryOutputStreamPrivate *priv;
};
typedef gpointer(*GReallocFunc) (gpointer data, gsize size);
extern gpointer g_memory_output_stream_get_data(GMemoryOutputStream *
						ostream);
extern gsize g_memory_output_stream_get_data_size(GMemoryOutputStream *
						  ostream);
extern gsize g_memory_output_stream_get_size(GMemoryOutputStream *
					     ostream);
extern GType g_memory_output_stream_get_type(void);
extern GOutputStream *g_memory_output_stream_new(gpointer data, gsize size,
						 GReallocFunc
						 realloc_function,
						 GDestroyNotify
						 destroy_function);
extern gpointer g_memory_output_stream_steal_data(GMemoryOutputStream *
						  ostream);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41215"
>17.12.85. glib-2.0/gio/gmenu.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_MENU	(g_menu_get_type ())
#define G_TYPE_MENU_ITEM	(g_menu_item_get_type ())
#define G_MENU(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_MENU, GMenu))
#define G_MENU_ITEM(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_MENU_ITEM, GMenuItem))
#define G_IS_MENU(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_MENU))
#define G_IS_MENU_ITEM(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_MENU_ITEM))

typedef struct _GMenuItem GMenuItem;
typedef struct _GMenu GMenu;
extern void g_menu_append(GMenu * menu, const gchar * label,
			  const gchar * detailed_action);
extern void g_menu_append_item(GMenu * menu, GMenuItem * item);
extern void g_menu_append_section(GMenu * menu, const gchar * label,
				  GMenuModel * section);
extern void g_menu_append_submenu(GMenu * menu, const gchar * label,
				  GMenuModel * submenu);
extern void g_menu_freeze(GMenu * menu);
extern GType g_menu_get_type(void);
extern void g_menu_insert(GMenu * menu, gint position, const gchar * label,
			  const gchar * detailed_action);
extern void g_menu_insert_item(GMenu * menu, gint position,
			       GMenuItem * item);
extern void g_menu_insert_section(GMenu * menu, gint position,
				  const gchar * label,
				  GMenuModel * section);
extern void g_menu_insert_submenu(GMenu * menu, gint position,
				  const gchar * label,
				  GMenuModel * submenu);
extern GType g_menu_item_get_type(void);
extern GMenuItem *g_menu_item_new(const gchar * label,
				  const gchar * detailed_action);
extern GMenuItem *g_menu_item_new_section(const gchar * label,
					  GMenuModel * section);
extern GMenuItem *g_menu_item_new_submenu(const gchar * label,
					  GMenuModel * submenu);
extern void g_menu_item_set_action_and_target(GMenuItem * menu_item,
					      const gchar * action,
					      const gchar * format_string,
					      ...);
extern void g_menu_item_set_action_and_target_value(GMenuItem * menu_item,
						    const gchar * action,
						    GVariant *
						    target_value);
extern void g_menu_item_set_attribute(GMenuItem * menu_item,
				      const gchar * attribute,
				      const gchar * format_string, ...);
extern void g_menu_item_set_attribute_value(GMenuItem * menu_item,
					    const gchar * attribute,
					    GVariant * value);
extern void g_menu_item_set_detailed_action(GMenuItem * menu_item,
					    const gchar * detailed_action);
extern void g_menu_item_set_label(GMenuItem * menu_item,
				  const gchar * label);
extern void g_menu_item_set_link(GMenuItem * menu_item, const gchar * link,
				 GMenuModel * model);
extern void g_menu_item_set_section(GMenuItem * menu_item,
				    GMenuModel * section);
extern void g_menu_item_set_submenu(GMenuItem * menu_item,
				    GMenuModel * submenu);
extern GMenu *g_menu_new(void);
extern void g_menu_prepend(GMenu * menu, const gchar * label,
			   const gchar * detailed_action);
extern void g_menu_prepend_item(GMenu * menu, GMenuItem * item);
extern void g_menu_prepend_section(GMenu * menu, const gchar * label,
				   GMenuModel * section);
extern void g_menu_prepend_submenu(GMenu * menu, const gchar * label,
				   GMenuModel * submenu);
extern void g_menu_remove(GMenu * menu, gint position);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41219"
>17.12.86. glib-2.0/gio/gmenuexporter.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern guint g_dbus_connection_export_menu_model(GDBusConnection *
						 connection,
						 const gchar * object_path,
						 GMenuModel * menu,
						 GError * *error);
extern void g_dbus_connection_unexport_menu_model(GDBusConnection *
						  connection,
						  guint export_id);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41223"
>17.12.87. glib-2.0/gio/gmenumodel.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_MENU_ATTRIBUTE_ITER	(g_menu_attribute_iter_get_type ())
#define G_TYPE_MENU_LINK_ITER	(g_menu_link_iter_get_type ())
#define G_TYPE_MENU_MODEL	(g_menu_model_get_type ())
#define G_MENU_ATTRIBUTE_ITER_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass))
#define G_MENU_LINK_ITER_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass))
#define G_MENU_MODEL_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_MENU_MODEL, GMenuModelClass))
#define G_IS_MENU_ATTRIBUTE_ITER_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_MENU_ATTRIBUTE_ITER))
#define G_IS_MENU_LINK_ITER_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_MENU_LINK_ITER))
#define G_IS_MENU_MODEL_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_MENU_MODEL))
#define G_MENU_ATTRIBUTE_ITER(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIter))
#define G_MENU_LINK_ITER(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_MENU_LINK_ITER, GMenuLinkIter))
#define G_MENU_MODEL(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_MENU_MODEL, GMenuModel))
#define G_IS_MENU_ATTRIBUTE_ITER(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_MENU_ATTRIBUTE_ITER))
#define G_IS_MENU_LINK_ITER(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_MENU_LINK_ITER))
#define G_IS_MENU_MODEL(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_MENU_MODEL))
#define G_MENU_ATTRIBUTE_ITER_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass))
#define G_MENU_LINK_ITER_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass))
#define G_MENU_MODEL_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_MENU_MODEL, GMenuModelClass))
#define G_MENU_ATTRIBUTE_ACTION	"action"
#define G_MENU_ATTRIBUTE_LABEL	"label"
#define G_MENU_LINK_SECTION	"section"
#define G_MENU_LINK_SUBMENU	"submenu"
#define G_MENU_ATTRIBUTE_TARGET	"target"

typedef struct _GMenuModelPrivate GMenuModelPrivate;
typedef struct _GMenuModelClass {
    GObjectClass parent_class;
     gboolean(*is_mutable) (GMenuModel * model);
     gint(*get_n_items) (GMenuModel * model);
    void (*get_item_attributes) (GMenuModel * model, gint item_index,
				 GHashTable * *attributes);
    GMenuAttributeIter *(*iterate_item_attributes) (GMenuModel * model,
						    gint item_index);
    GVariant *(*get_item_attribute_value) (GMenuModel * model,
					   gint item_index,
					   const gchar * attribute,
					   const GVariantType *
					   expected_type);
    void (*get_item_links) (GMenuModel * model, gint item_index,
			    GHashTable * *attributes);
    GMenuLinkIter *(*iterate_item_links) (GMenuModel * model,
					  gint item_index);
    GMenuModel *(*get_item_link) (GMenuModel * model, gint item_index,
				  const gchar * link);
} GMenuModelClass;
typedef struct _GMenuAttributeIterPrivate GMenuAttributeIterPrivate;
typedef struct _GMenuAttributeIterClass {
    GObjectClass parent_class;
     gboolean(*get_next) (GMenuAttributeIter * iter,
			  const gchar * *out_type, GVariant * *value);
} GMenuAttributeIterClass;
typedef struct _GMenuAttributeIter {
    GObject parent_instance;
    GMenuAttributeIterPrivate *priv;
} GMenuAttributeIter;
typedef struct _GMenuLinkIterPrivate GMenuLinkIterPrivate;
typedef struct _GMenuLinkIterClass {
    GObjectClass parent_class;
     gboolean(*get_next) (GMenuLinkIter * iter, const gchar * *out_name,
			  GMenuModel * *value);
} GMenuLinkIterClass;
typedef struct _GMenuLinkIter {
    GObject parent_instance;
    GMenuLinkIterPrivate *priv;
} GMenuLinkIter;
struct _GMenuModel {
    GObject parent_instance;
    GMenuModelPrivate *priv;
};
extern const char *g_menu_attribute_iter_get_name(GMenuAttributeIter *
						  iter);
extern gboolean g_menu_attribute_iter_get_next(GMenuAttributeIter * iter,
					       const gchar * *out_name,
					       GVariant * *value);
extern GType g_menu_attribute_iter_get_type(void);
extern GVariant *g_menu_attribute_iter_get_value(GMenuAttributeIter *
						 iter);
extern gboolean g_menu_attribute_iter_next(GMenuAttributeIter * iter);
extern const char *g_menu_link_iter_get_name(GMenuLinkIter * iter);
extern gboolean g_menu_link_iter_get_next(GMenuLinkIter * iter,
					  const gchar * *out_link,
					  GMenuModel * *value);
extern GType g_menu_link_iter_get_type(void);
extern GMenuModel *g_menu_link_iter_get_value(GMenuLinkIter * iter);
extern gboolean g_menu_link_iter_next(GMenuLinkIter * iter);
extern gboolean g_menu_model_get_item_attribute(GMenuModel * model,
						gint item_index,
						const gchar * attribute,
						const gchar *
						format_string, ...);
extern GVariant *g_menu_model_get_item_attribute_value(GMenuModel * model,
						       gint item_index,
						       const gchar *
						       attribute,
						       const GVariantType *
						       expected_type);
extern GMenuModel *g_menu_model_get_item_link(GMenuModel * model,
					      gint item_index,
					      const gchar * link);
extern gint g_menu_model_get_n_items(GMenuModel * model);
extern GType g_menu_model_get_type(void);
extern gboolean g_menu_model_is_mutable(GMenuModel * model);
extern void g_menu_model_items_changed(GMenuModel * model, gint position,
				       gint removed, gint added);
extern GMenuAttributeIter *g_menu_model_iterate_item_attributes(GMenuModel
								* model,
								gint
								item_index);
extern GMenuLinkIter *g_menu_model_iterate_item_links(GMenuModel * model,
						      gint item_index);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41227"
>17.12.88. glib-2.0/gio/gmount.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_MOUNT	(g_mount_get_type ())
#define G_MOUNT(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_MOUNT, GMount))
#define G_IS_MOUNT(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_MOUNT))
#define G_MOUNT_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_MOUNT, GMountIface))

extern gboolean g_mount_can_eject(GMount * mount);
extern gboolean g_mount_can_unmount(GMount * mount);
extern void g_mount_eject(GMount * mount, GMountUnmountFlags flags,
			  GCancellable * cancellable,
			  GAsyncReadyCallback callback,
			  gpointer user_data);
extern gboolean g_mount_eject_finish(GMount * mount, GAsyncResult * result,
				     GError * *error);
extern void g_mount_eject_with_operation(GMount * mount,
					 GMountUnmountFlags flags,
					 GMountOperation * mount_operation,
					 GCancellable * cancellable,
					 GAsyncReadyCallback callback,
					 gpointer user_data);
extern gboolean g_mount_eject_with_operation_finish(GMount * mount,
						    GAsyncResult * result,
						    GError * *error);
extern GFile *g_mount_get_default_location(GMount * mount);
extern GDrive *g_mount_get_drive(GMount * mount);
extern GIcon *g_mount_get_icon(GMount * mount);
extern char *g_mount_get_name(GMount * mount);
extern GFile *g_mount_get_root(GMount * mount);
extern const char *g_mount_get_sort_key(GMount * mount);
extern GType g_mount_get_type(void);
extern char *g_mount_get_uuid(GMount * mount);
extern GVolume *g_mount_get_volume(GMount * mount);
extern void g_mount_guess_content_type(GMount * mount,
				       gboolean force_rescan,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data);
extern gchar **g_mount_guess_content_type_finish(GMount * mount,
						 GAsyncResult * result,
						 GError * *error);
extern gchar **g_mount_guess_content_type_sync(GMount * mount,
					       gboolean force_rescan,
					       GCancellable * cancellable,
					       GError * *error);
extern gboolean g_mount_is_shadowed(GMount * mount);
extern void g_mount_remount(GMount * mount, GMountMountFlags flags,
			    GMountOperation * mount_operation,
			    GCancellable * cancellable,
			    GAsyncReadyCallback callback,
			    gpointer user_data);
extern gboolean g_mount_remount_finish(GMount * mount,
				       GAsyncResult * result,
				       GError * *error);
extern void g_mount_shadow(GMount * mount);
extern void g_mount_unmount(GMount * mount, GMountUnmountFlags flags,
			    GCancellable * cancellable,
			    GAsyncReadyCallback callback,
			    gpointer user_data);
extern gboolean g_mount_unmount_finish(GMount * mount,
				       GAsyncResult * result,
				       GError * *error);
extern void g_mount_unmount_with_operation(GMount * mount,
					   GMountUnmountFlags flags,
					   GMountOperation *
					   mount_operation,
					   GCancellable * cancellable,
					   GAsyncReadyCallback callback,
					   gpointer user_data);
extern gboolean g_mount_unmount_with_operation_finish(GMount * mount,
						      GAsyncResult *
						      result,
						      GError * *error);
extern void g_mount_unshadow(GMount * mount);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41231"
>17.12.89. glib-2.0/gio/gmountoperation.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_MOUNT_OPERATION	(g_mount_operation_get_type ())
#define G_MOUNT_OPERATION_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MOUNT_OPERATION, GMountOperationClass))
#define G_IS_MOUNT_OPERATION_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MOUNT_OPERATION))
#define G_MOUNT_OPERATION(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MOUNT_OPERATION, GMountOperation))
#define G_IS_MOUNT_OPERATION(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MOUNT_OPERATION))
#define G_MOUNT_OPERATION_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MOUNT_OPERATION, GMountOperationClass))

typedef struct _GMountOperationClass {
    GObjectClass parent_class;
    void (*ask_password) (void);
    void (*ask_question) (void);
    void (*reply) (void);
    void (*aborted) (void);
    void (*show_processes) (void);
    void (*show_unmount_progress) (void);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
    void (*_g_reserved8) (void);
    void (*_g_reserved9) (void);
} GMountOperationClass;
typedef struct _GMountOperationPrivate GMountOperationPrivate;
struct _GMountOperation {
    GObject parent_instance;
    GMountOperationPrivate *priv;
};
extern gboolean g_mount_operation_get_anonymous(GMountOperation * op);
extern int g_mount_operation_get_choice(GMountOperation * op);
extern const char *g_mount_operation_get_domain(GMountOperation * op);
extern const char *g_mount_operation_get_password(GMountOperation * op);
extern GPasswordSave g_mount_operation_get_password_save(GMountOperation *
							 op);
extern GType g_mount_operation_get_type(void);
extern const char *g_mount_operation_get_username(GMountOperation * op);
extern GMountOperation *g_mount_operation_new(void);
extern void g_mount_operation_reply(GMountOperation * op,
				    GMountOperationResult result);
extern void g_mount_operation_set_anonymous(GMountOperation * op,
					    gboolean anonymous);
extern void g_mount_operation_set_choice(GMountOperation * op, int choice);
extern void g_mount_operation_set_domain(GMountOperation * op,
					 const char *domain);
extern void g_mount_operation_set_password(GMountOperation * op,
					   const char *password);
extern void g_mount_operation_set_password_save(GMountOperation * op,
						GPasswordSave save);
extern void g_mount_operation_set_username(GMountOperation * op,
					   const char *username);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41235"
>17.12.90. glib-2.0/gio/gnativevolumemonitor.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_NATIVE_VOLUME_MONITOR	(g_native_volume_monitor_get_type ())
#define G_NATIVE_VOLUME_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitorClass))
#define G_IS_NATIVE_VOLUME_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NATIVE_VOLUME_MONITOR))
#define G_NATIVE_VOLUME_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitor))
#define G_IS_NATIVE_VOLUME_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NATIVE_VOLUME_MONITOR))
#define G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME	"gio-native-volume-monitor"

typedef struct _GNativeVolumeMonitor {
    GVolumeMonitor parent_instance;
} GNativeVolumeMonitor;
typedef struct _GNativeVolumeMonitorClass {
    GVolumeMonitorClass parent_class;
    GMount *(*get_mount_for_mount_path) (const char *mount_path,
					 GCancellable * cancellable);
} GNativeVolumeMonitorClass;
extern GType g_native_volume_monitor_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41239"
>17.12.91. glib-2.0/gio/gnetworkaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_NETWORK_ADDRESS	(g_network_address_get_type ())
#define G_NETWORK_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
#define G_IS_NETWORK_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
#define G_NETWORK_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
#define G_IS_NETWORK_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
#define G_NETWORK_ADDRESS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))

typedef struct _GNetworkAddressClass {
    GObjectClass parent_class;
} GNetworkAddressClass;
typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;
struct _GNetworkAddress {
    GObject parent_instance;
    GNetworkAddressPrivate *priv;
};
extern const char *g_network_address_get_hostname(GNetworkAddress * addr);
extern guint16 g_network_address_get_port(GNetworkAddress * addr);
extern const char *g_network_address_get_scheme(GNetworkAddress * addr);
extern GType g_network_address_get_type(void);
extern GSocketConnectable *g_network_address_new(const gchar * hostname,
						 guint16 port);
extern GSocketConnectable *g_network_address_parse(const gchar *
						   host_and_port,
						   guint16 default_port,
						   GError * *error);
extern GSocketConnectable *g_network_address_parse_uri(const gchar * uri,
						       guint16
						       default_port,
						       GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41243"
>17.12.92. glib-2.0/gio/gnetworkmonitor.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_NETWORK_MONITOR	(g_network_monitor_get_type ())
#define G_NETWORK_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitor))
#define G_IS_NETWORK_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_MONITOR))
#define G_NETWORK_MONITOR_GET_INTERFACE(o)	(G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitorInterface))
#define G_NETWORK_MONITOR_EXTENSION_POINT_NAME	"gio-network-monitor"

typedef struct _GNetworkMonitorInterface {
    GTypeInterface g_iface;
    void (*network_changed) (GNetworkMonitor * monitor,
			     gboolean available);
     gboolean(*can_reach) (GNetworkMonitor * monitor,
			   GSocketConnectable * connectable,
			   GCancellable * cancellable, GError * *error);
    void (*can_reach_async) (GNetworkMonitor * monitor,
			     GSocketConnectable * connectable,
			     GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
     gboolean(*can_reach_finish) (GNetworkMonitor * monitor,
				  GAsyncResult * result, GError * *error);
} GNetworkMonitorInterface;
extern gboolean g_network_monitor_can_reach(GNetworkMonitor * monitor,
					    GSocketConnectable *
					    connectable,
					    GCancellable * cancellable,
					    GError * *error);
extern void g_network_monitor_can_reach_async(GNetworkMonitor * monitor,
					      GSocketConnectable *
					      connectable,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern gboolean g_network_monitor_can_reach_finish(GNetworkMonitor *
						   monitor,
						   GAsyncResult * result,
						   GError * *error);
extern GNetworkMonitor *g_network_monitor_get_default(void);
extern gboolean g_network_monitor_get_network_available(GNetworkMonitor *
							monitor);
extern GType g_network_monitor_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41247"
>17.12.93. glib-2.0/gio/gnetworkservice.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_NETWORK_SERVICE	(g_network_service_get_type ())
#define G_NETWORK_SERVICE_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
#define G_IS_NETWORK_SERVICE_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
#define G_NETWORK_SERVICE(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
#define G_IS_NETWORK_SERVICE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
#define G_NETWORK_SERVICE_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))

typedef struct _GNetworkServiceClass {
    GObjectClass parent_class;
} GNetworkServiceClass;
typedef struct _GNetworkServicePrivate GNetworkServicePrivate;
struct _GNetworkService {
    GObject parent_instance;
    GNetworkServicePrivate *priv;
};
extern const gchar *g_network_service_get_domain(GNetworkService * srv);
extern const gchar *g_network_service_get_protocol(GNetworkService * srv);
extern const gchar *g_network_service_get_scheme(GNetworkService * srv);
extern const gchar *g_network_service_get_service(GNetworkService * srv);
extern GType g_network_service_get_type(void);
extern GSocketConnectable *g_network_service_new(const gchar * service,
						 const gchar * protocol,
						 const gchar * domain);
extern void g_network_service_set_scheme(GNetworkService * srv,
					 const gchar * scheme);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41251"
>17.12.94. glib-2.0/gio/goutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_OUTPUT_STREAM	(g_output_stream_get_type ())
#define G_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_OUTPUT_STREAM, GOutputStreamClass))
#define G_IS_OUTPUT_STREAM_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_OUTPUT_STREAM))
#define G_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_OUTPUT_STREAM, GOutputStream))
#define G_IS_OUTPUT_STREAM(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_OUTPUT_STREAM))
#define G_OUTPUT_STREAM_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_OUTPUT_STREAM, GOutputStreamClass))

typedef struct _GOutputStreamClass {
    GObjectClass parent_class;
     gssize(*write_fn) (GOutputStream * stream, const void *buffer,
			gsize count, GCancellable * cancellable,
			GError * *error);
     gssize(*splice) (GOutputStream * stream, GInputStream * source,
		      GOutputStreamSpliceFlags flags,
		      GCancellable * cancellable, GError * *error);
     gboolean(*flush) (GOutputStream * stream, GCancellable * cancellable,
		       GError * *error);
     gboolean(*close_fn) (GOutputStream * stream,
			  GCancellable * cancellable, GError * *error);
    void (*write_async) (GOutputStream * stream, const void *buffer,
			 gsize count, int io_priority,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
     gssize(*write_finish) (GOutputStream * stream, GAsyncResult * result,
			    GError * *error);
    void (*splice_async) (GOutputStream * stream, GInputStream * source,
			  GOutputStreamSpliceFlags flags, int io_priority,
			  GCancellable * cancellable,
			  GAsyncReadyCallback callback,
			  gpointer user_data);
     gssize(*splice_finish) (GOutputStream * stream, GAsyncResult * result,
			     GError * *error);
    void (*flush_async) (GOutputStream * stream, int io_priority,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*flush_finish) (GOutputStream * stream,
			      GAsyncResult * result, GError * *error);
    void (*close_async) (GOutputStream * stream, int io_priority,
			 GCancellable * cancellable,
			 GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*close_finish) (GOutputStream * stream,
			      GAsyncResult * result, GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
    void (*_g_reserved8) (void);
} GOutputStreamClass;
typedef struct _GOutputStreamPrivate GOutputStreamPrivate;
struct _GOutputStream {
    GObject parent_instance;
    GOutputStreamPrivate *priv;
};
extern void g_output_stream_clear_pending(GOutputStream * stream);
extern gboolean g_output_stream_close(GOutputStream * stream,
				      GCancellable * cancellable,
				      GError * *error);
extern void g_output_stream_close_async(GOutputStream * stream,
					int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
extern gboolean g_output_stream_close_finish(GOutputStream * stream,
					     GAsyncResult * result,
					     GError * *error);
extern gboolean g_output_stream_flush(GOutputStream * stream,
				      GCancellable * cancellable,
				      GError * *error);
extern void g_output_stream_flush_async(GOutputStream * stream,
					int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
extern gboolean g_output_stream_flush_finish(GOutputStream * stream,
					     GAsyncResult * result,
					     GError * *error);
extern GType g_output_stream_get_type(void);
extern gboolean g_output_stream_has_pending(GOutputStream * stream);
extern gboolean g_output_stream_is_closed(GOutputStream * stream);
extern gboolean g_output_stream_is_closing(GOutputStream * stream);
extern gboolean g_output_stream_set_pending(GOutputStream * stream,
					    GError * *error);
extern gssize g_output_stream_splice(GOutputStream * stream,
				     GInputStream * source,
				     GOutputStreamSpliceFlags flags,
				     GCancellable * cancellable,
				     GError * *error);
extern void g_output_stream_splice_async(GOutputStream * stream,
					 GInputStream * source,
					 GOutputStreamSpliceFlags flags,
					 int io_priority,
					 GCancellable * cancellable,
					 GAsyncReadyCallback callback,
					 gpointer user_data);
extern gssize g_output_stream_splice_finish(GOutputStream * stream,
					    GAsyncResult * result,
					    GError * *error);
extern gssize g_output_stream_write(GOutputStream * stream,
				    const void *buffer, gsize count,
				    GCancellable * cancellable,
				    GError * *error);
extern gboolean g_output_stream_write_all(GOutputStream * stream,
					  const void *buffer, gsize count,
					  gsize * bytes_written,
					  GCancellable * cancellable,
					  GError * *error);
extern void g_output_stream_write_async(GOutputStream * stream,
					const void *buffer, gsize count,
					int io_priority,
					GCancellable * cancellable,
					GAsyncReadyCallback callback,
					gpointer user_data);
extern gssize g_output_stream_write_finish(GOutputStream * stream,
					   GAsyncResult * result,
					   GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41255"
>17.12.95. glib-2.0/gio/gpermission.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_PERMISSION	(g_permission_get_type ())
#define G_PERMISSION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_PERMISSION, GPermissionClass))
#define G_IS_PERMISSION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_PERMISSION))
#define G_PERMISSION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_PERMISSION, GPermission))
#define G_IS_PERMISSION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_PERMISSION))
#define G_PERMISSION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_PERMISSION, GPermissionClass))

typedef struct _GPermissionPrivate GPermissionPrivate;
typedef struct _GPermissionClass {
    GObjectClass parent_class;
     gboolean(*acquire) (GPermission * permission,
			 GCancellable * cancellable, GError * *error);
    void (*acquire_async) (GPermission * permission,
			   GCancellable * cancellable,
			   GAsyncReadyCallback callback,
			   gpointer user_data);
     gboolean(*acquire_finish) (GPermission * permission,
				GAsyncResult * result, GError * *error);
     gboolean(*release) (GPermission * permission,
			 GCancellable * cancellable, GError * *error);
    void (*release_async) (GPermission * permission,
			   GCancellable * cancellable,
			   GAsyncReadyCallback callback,
			   gpointer user_data);
     gboolean(*release_finish) (GPermission * permission,
				GAsyncResult * result, GError * *error);
    gpointer reserved[16];
} GPermissionClass;
struct _GPermission {
    GObject parent_instance;
    GPermissionPrivate *priv;
};
extern gboolean g_permission_acquire(GPermission * permission,
				     GCancellable * cancellable,
				     GError * *error);
extern void g_permission_acquire_async(GPermission * permission,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data);
extern gboolean g_permission_acquire_finish(GPermission * permission,
					    GAsyncResult * result,
					    GError * *error);
extern gboolean g_permission_get_allowed(GPermission * permission);
extern gboolean g_permission_get_can_acquire(GPermission * permission);
extern gboolean g_permission_get_can_release(GPermission * permission);
extern GType g_permission_get_type(void);
extern void g_permission_impl_update(GPermission * permission,
				     gboolean allowed,
				     gboolean can_acquire,
				     gboolean can_release);
extern gboolean g_permission_release(GPermission * permission,
				     GCancellable * cancellable,
				     GError * *error);
extern void g_permission_release_async(GPermission * permission,
				       GCancellable * cancellable,
				       GAsyncReadyCallback callback,
				       gpointer user_data);
extern gboolean g_permission_release_finish(GPermission * permission,
					    GAsyncResult * result,
					    GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41259"
>17.12.96. glib-2.0/gio/gpollableinputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_POLLABLE_INPUT_STREAM	(g_pollable_input_stream_get_type ())
#define G_POLLABLE_INPUT_STREAM(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStream))
#define G_IS_POLLABLE_INPUT_STREAM(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_POLLABLE_INPUT_STREAM))
#define G_POLLABLE_INPUT_STREAM_GET_INTERFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStreamInterface))

typedef struct _GPollableInputStreamInterface {
    GTypeInterface g_iface;
     gboolean(*can_poll) (GPollableInputStream * stream);
     gboolean(*is_readable) (GPollableInputStream * stream);
    GSource *(*create_source) (GPollableInputStream * stream,
			       GCancellable * cancellable);
     gssize(*read_nonblocking) (GPollableInputStream * stream,
				void *buffer, gsize size, GError * *error);
} GPollableInputStreamInterface;
extern gboolean g_pollable_input_stream_can_poll(GPollableInputStream *
						 stream);
extern GSource *g_pollable_input_stream_create_source(GPollableInputStream
						      * stream,
						      GCancellable *
						      cancellable);
extern GType g_pollable_input_stream_get_type(void);
extern gboolean g_pollable_input_stream_is_readable(GPollableInputStream *
						    stream);
extern gssize g_pollable_input_stream_read_nonblocking(GPollableInputStream
						       * stream,
						       void *buffer,
						       gsize size,
						       GCancellable *
						       cancellable,
						       GError * *error);
extern GSource *g_pollable_source_new(GObject * pollable_stream);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41263"
>17.12.97. glib-2.0/gio/gpollableoutputstream.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_POLLABLE_OUTPUT_STREAM	(g_pollable_output_stream_get_type ())
#define G_POLLABLE_OUTPUT_STREAM(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStream))
#define G_IS_POLLABLE_OUTPUT_STREAM(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM))
#define G_POLLABLE_OUTPUT_STREAM_GET_INTERFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStreamInterface))

typedef struct _GPollableOutputStreamInterface {
    GTypeInterface g_iface;
     gboolean(*can_poll) (GPollableOutputStream * stream);
     gboolean(*is_writable) (GPollableOutputStream * stream);
    GSource *(*create_source) (GPollableOutputStream * stream,
			       GCancellable * cancellable);
     gssize(*write_nonblocking) (GPollableOutputStream * stream,
				 const void *buffer, gsize size,
				 GError * *error);
} GPollableOutputStreamInterface;
extern gboolean g_pollable_output_stream_can_poll(GPollableOutputStream *
						  stream);
extern GSource
    *g_pollable_output_stream_create_source(GPollableOutputStream * stream,
					    GCancellable * cancellable);
extern GType g_pollable_output_stream_get_type(void);
extern gboolean g_pollable_output_stream_is_writable(GPollableOutputStream
						     * stream);
extern gssize
g_pollable_output_stream_write_nonblocking(GPollableOutputStream * stream,
					   const void *buffer, gsize size,
					   GCancellable * cancellable,
					   GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41267"
>17.12.98. glib-2.0/gio/gproxy.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_PROXY	(g_proxy_get_type ())
#define G_PROXY(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY, GProxy))
#define G_IS_PROXY(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY))
#define G_PROXY_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_PROXY, GProxyInterface))
#define G_PROXY_EXTENSION_POINT_NAME	"gio-proxy"

typedef struct _GProxyInterface {
    GTypeInterface g_iface;
    GIOStream *(*connect) (GProxy * proxy, GIOStream * connection,
			   GProxyAddress * proxy_address,
			   GCancellable * cancellable, GError * *error);
    void (*connect_async) (GProxy * proxy, GIOStream * connection,
			   GProxyAddress * proxy_address,
			   GCancellable * cancellable,
			   GAsyncReadyCallback callback,
			   gpointer user_data);
    GIOStream *(*connect_finish) (GProxy * proxy, GAsyncResult * result,
				  GError * *error);
     gboolean(*supports_hostname) (GProxy * proxy);
} GProxyInterface;
extern GIOStream *g_proxy_connect(GProxy * proxy, GIOStream * connection,
				  GProxyAddress * proxy_address,
				  GCancellable * cancellable,
				  GError * *error);
extern void g_proxy_connect_async(GProxy * proxy, GIOStream * connection,
				  GProxyAddress * proxy_address,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
extern GIOStream *g_proxy_connect_finish(GProxy * proxy,
					 GAsyncResult * result,
					 GError * *error);
extern GProxy *g_proxy_get_default_for_protocol(const gchar * protocol);
extern GType g_proxy_get_type(void);
extern gboolean g_proxy_supports_hostname(GProxy * proxy);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41271"
>17.12.99. glib-2.0/gio/gproxyaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_PROXY_ADDRESS	(g_proxy_address_get_type ())
#define G_PROXY_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_ADDRESS, GProxyAddressClass))
#define G_IS_PROXY_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_ADDRESS))
#define G_PROXY_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_ADDRESS, GProxyAddress))
#define G_IS_PROXY_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_ADDRESS))
#define G_PROXY_ADDRESS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_ADDRESS, GProxyAddressClass))

typedef struct _GProxyAddressClass {
    GInetSocketAddressClass parent_class;
} GProxyAddressClass;
typedef struct _GProxyAddressPrivate GProxyAddressPrivate;
struct _GProxyAddress {
    GInetSocketAddress parent_instance;
    GProxyAddressPrivate *priv;
};
extern const gchar *g_proxy_address_get_destination_hostname(GProxyAddress
							     * proxy);
extern guint16 g_proxy_address_get_destination_port(GProxyAddress * proxy);
extern const gchar *g_proxy_address_get_password(GProxyAddress * proxy);
extern const gchar *g_proxy_address_get_protocol(GProxyAddress * proxy);
extern GType g_proxy_address_get_type(void);
extern const gchar *g_proxy_address_get_username(GProxyAddress * proxy);
extern GSocketAddress *g_proxy_address_new(GInetAddress * inetaddr,
					   guint16 port,
					   const gchar * protocol,
					   const gchar * dest_hostname,
					   guint16 dest_port,
					   const gchar * username,
					   const gchar * password);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41275"
>17.12.100. glib-2.0/gio/gproxyaddressenumerator.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_PROXY_ADDRESS_ENUMERATOR	(g_proxy_address_enumerator_get_type ())
#define G_PROXY_ADDRESS_ENUMERATOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass))
#define G_IS_PROXY_ADDRESS_ENUMERATOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_PROXY_ADDRESS_ENUMERATOR))
#define G_PROXY_ADDRESS_ENUMERATOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumerator))
#define G_IS_PROXY_ADDRESS_ENUMERATOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR))
#define G_PROXY_ADDRESS_ENUMERATOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass))

typedef struct _GProxyAddressEnumeratorClass {
    GSocketAddressEnumeratorClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
} GProxyAddressEnumeratorClass;
typedef struct _GProxyAddressEnumeratorPrivate
    GProxyAddressEnumeratorPrivate;
struct _GProxyAddressEnumerator {
    GSocketAddressEnumerator parent_instance;
    GProxyAddressEnumeratorPrivate *priv;
};
extern GType g_proxy_address_enumerator_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41279"
>17.12.101. glib-2.0/gio/gproxyresolver.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_PROXY_RESOLVER	(g_proxy_resolver_get_type ())
#define G_PROXY_RESOLVER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_PROXY_RESOLVER, GProxyResolver))
#define G_IS_PROXY_RESOLVER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_PROXY_RESOLVER))
#define G_PROXY_RESOLVER_GET_IFACE(o)	(G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_PROXY_RESOLVER, GProxyResolverInterface))
#define G_PROXY_RESOLVER_EXTENSION_POINT_NAME	"gio-proxy-resolver"

typedef struct _GProxyResolverInterface {
    GTypeInterface g_iface;
     gboolean(*is_supported) (GProxyResolver * resolver);
    gchar **(*lookup) (GProxyResolver * resolver, const gchar * uri,
		       GCancellable * cancellable, GError * *error);
    void (*lookup_async) (GProxyResolver * resolver, const gchar * uri,
			  GCancellable * cancellable,
			  GAsyncReadyCallback callback,
			  gpointer user_data);
    gchar **(*lookup_finish) (GProxyResolver * resolver,
			      GAsyncResult * result, GError * *error);
} GProxyResolverInterface;
extern GProxyResolver *g_proxy_resolver_get_default(void);
extern GType g_proxy_resolver_get_type(void);
extern gboolean g_proxy_resolver_is_supported(GProxyResolver * resolver);
extern gchar **g_proxy_resolver_lookup(GProxyResolver * resolver,
				       const gchar * uri,
				       GCancellable * cancellable,
				       GError * *error);
extern void g_proxy_resolver_lookup_async(GProxyResolver * resolver,
					  const gchar * uri,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern gchar **g_proxy_resolver_lookup_finish(GProxyResolver * resolver,
					      GAsyncResult * result,
					      GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41283"
>17.12.102. glib-2.0/gio/gremoteactiongroup.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_REMOTE_ACTION_GROUP	(g_remote_action_group_get_type ())
#define G_REMOTE_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroup))
#define G_IS_REMOTE_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_REMOTE_ACTION_GROUP))
#define G_REMOTE_ACTION_GROUP_GET_IFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroupInterface))

typedef struct _GRemoteActionGroupInterface {
    GTypeInterface g_iface;
    void (*activate_action_full) (GRemoteActionGroup * resolver,
				  const gchar * action_name,
				  GVariant * parameter,
				  GVariant * platform_data);
    void (*change_action_state_full) (GRemoteActionGroup * resolver,
				      const gchar * action_name,
				      GVariant * value,
				      GVariant * platform_data);
} GRemoteActionGroupInterface;
extern void g_remote_action_group_activate_action_full(GRemoteActionGroup *
						       remote,
						       const gchar *
						       action_name,
						       GVariant *
						       parameter,
						       GVariant *
						       platform_data);
extern void
g_remote_action_group_change_action_state_full(GRemoteActionGroup * remote,
					       const gchar * action_name,
					       GVariant * value,
					       GVariant * platform_data);
extern GType g_remote_action_group_get_type(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41287"
>17.12.103. glib-2.0/gio/gresolver.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_RESOLVER_ERROR	(g_resolver_error_quark ())
#define G_TYPE_RESOLVER	(g_resolver_get_type ())
#define G_RESOLVER_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_RESOLVER, GResolverClass))
#define G_IS_RESOLVER_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_RESOLVER))
#define G_RESOLVER(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_RESOLVER, GResolver))
#define G_IS_RESOLVER(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_RESOLVER))
#define G_RESOLVER_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_RESOLVER, GResolverClass))

typedef struct _GResolverPrivate GResolverPrivate;
typedef struct _GResolverClass {
    GObjectClass parent_class;
    void (*reload) (GResolver * resolver);
    GList *(*lookup_by_name) (GResolver * resolver, const gchar * hostname,
			      GCancellable * cancellable, GError * *error);
    void (*lookup_by_name_async) (GResolver * resolver,
				  const gchar * hostname,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
    GList *(*lookup_by_name_finish) (GResolver * resolver,
				     GAsyncResult * result,
				     GError * *error);
    gchar *(*lookup_by_address) (GResolver * resolver,
				 GInetAddress * address,
				 GCancellable * cancellable,
				 GError * *error);
    void (*lookup_by_address_async) (GResolver * resolver,
				     GInetAddress * address,
				     GCancellable * cancellable,
				     GAsyncReadyCallback callback,
				     gpointer user_data);
    gchar *(*lookup_by_address_finish) (GResolver * resolver,
					GAsyncResult * result,
					GError * *error);
     GList(*lookup_service) (GResolver * resolver, const gchar * rrname,
			     GCancellable * cancellable, GError * *error);
    void (*lookup_service_async) (GResolver * resolver,
				  const gchar * rrname,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
    GList *(*lookup_service_finish) (GResolver * resolver,
				     GAsyncResult * result,
				     GError * *error);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
} GResolverClass;
struct _GResolver {
    GObject parent_instance;
    GResolverPrivate *priv;
};
extern GQuark g_resolver_error_quark(void);
extern void g_resolver_free_addresses(GList * addresses);
extern void g_resolver_free_targets(GList * targets);
extern GResolver *g_resolver_get_default(void);
extern GType g_resolver_get_type(void);
extern gchar *g_resolver_lookup_by_address(GResolver * resolver,
					   GInetAddress * address,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_resolver_lookup_by_address_async(GResolver * resolver,
					       GInetAddress * address,
					       GCancellable * cancellable,
					       GAsyncReadyCallback
					       callback,
					       gpointer user_data);
extern gchar *g_resolver_lookup_by_address_finish(GResolver * resolver,
						  GAsyncResult * result,
						  GError * *error);
extern GList *g_resolver_lookup_by_name(GResolver * resolver,
					const gchar * hostname,
					GCancellable * cancellable,
					GError * *error);
extern void g_resolver_lookup_by_name_async(GResolver * resolver,
					    const gchar * hostname,
					    GCancellable * cancellable,
					    GAsyncReadyCallback callback,
					    gpointer user_data);
extern GList *g_resolver_lookup_by_name_finish(GResolver * resolver,
					       GAsyncResult * result,
					       GError * *error);
extern GList *g_resolver_lookup_service(GResolver * resolver,
					const gchar * service,
					const gchar * protocol,
					const gchar * domain,
					GCancellable * cancellable,
					GError * *error);
extern void g_resolver_lookup_service_async(GResolver * resolver,
					    const gchar * service,
					    const gchar * protocol,
					    const gchar * domain,
					    GCancellable * cancellable,
					    GAsyncReadyCallback callback,
					    gpointer user_data);
extern GList *g_resolver_lookup_service_finish(GResolver * resolver,
					       GAsyncResult * result,
					       GError * *error);
extern void g_resolver_set_default(GResolver * resolver);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41291"
>17.12.104. glib-2.0/gio/gresource.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_RESOURCE_ERROR	(g_resource_error_quark ())
#define G_TYPE_RESOURCE	(g_resource_get_type ())

typedef struct _GStaticResource {
    const guint8 *data;
    gsize data_len;
    GResource *resource;
    GStaticResource *next;
    gpointer padding;
} GStaticResource;
extern void g_resource_enumerate_children(GResource * resource,
					  const gchar * path,
					  GResourceLookupFlags
					  lookup_flags, GError * *error);
extern GQuark g_resource_error_quark(void);
extern gboolean g_resource_get_info(GResource * resource,
				    const gchar * path,
				    GResourceLookupFlags lookup_flags,
				    gsize * size, guint32 * flags,
				    GError * *error);
extern GType g_resource_get_type(void);
extern GResource *g_resource_load(const gchar * filename, GError * *error);
extern GBytes *g_resource_lookup_data(GResource * resource,
				      const gchar * path,
				      GResourceLookupFlags lookup_flags,
				      GError * *error);
extern GResource *g_resource_new_from_data(GBytes * data, GError * *error);
extern GInputStream *g_resource_open_stream(GResource * resource,
					    const gchar * path,
					    GResourceLookupFlags
					    lookup_flags, GError * *error);
extern GResource *g_resource_ref(GResource * resource);
extern void g_resource_unref(GResource * resource);
extern void g_resources_enumerate_children(const gchar * path,
					   GResourceLookupFlags
					   lookup_flags, GError * *error);
extern gboolean g_resources_get_info(const gchar * path,
				     GResourceLookupFlags lookup_flags,
				     gsize * size, guint32 * flags,
				     GError * *error);
extern GBytes *g_resources_lookup_data(const gchar * path,
				       GResourceLookupFlags lookup_flags,
				       GError * *error);
extern GInputStream *g_resources_open_stream(const gchar * path,
					     GResourceLookupFlags
					     lookup_flags,
					     GError * *error);
extern void g_resources_register(GResource * resource);
extern void g_resources_unregister(GResource * resource);
extern void g_static_resource_fini(GStaticResource * static_resource);
extern GResource *g_static_resource_get_resource(GStaticResource *
						 static_resource);
extern void g_static_resource_init(GStaticResource * static_resource);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41295"
>17.12.105. glib-2.0/gio/gseekable.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SEEKABLE	(g_seekable_get_type ())
#define G_SEEKABLE(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SEEKABLE, GSeekable))
#define G_IS_SEEKABLE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SEEKABLE))
#define G_SEEKABLE_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SEEKABLE, GSeekableIface))

typedef struct _GSeekableIface {
    GTypeInterface g_iface;
     goffset(*tell) (GSeekable * seekable);
     gboolean(*can_seek) (GSeekable * seekable);
     gboolean(*seek) (GSeekable * seekable, goffset offset, GSeekType type,
		      GCancellable * cancellable, GError * *error);
     gboolean(*can_truncate) (GSeekable * seekable);
     gboolean(*truncate_fn) (GSeekable * seekable, goffset offset,
			     GCancellable * cancellable, GError * *error);
} GSeekableIface;
extern gboolean g_seekable_can_seek(GSeekable * seekable);
extern gboolean g_seekable_can_truncate(GSeekable * seekable);
extern GType g_seekable_get_type(void);
extern gboolean g_seekable_seek(GSeekable * seekable, goffset offset,
				GSeekType type, GCancellable * cancellable,
				GError * *error);
extern goffset g_seekable_tell(GSeekable * seekable);
extern gboolean g_seekable_truncate(GSeekable * seekable, goffset offset,
				    GCancellable * cancellable,
				    GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41299"
>17.12.106. glib-2.0/gio/gsettings.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SETTINGS	(g_settings_get_type ())
#define G_SETTINGS_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SETTINGS, GSettingsClass))
#define G_IS_SETTINGS_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SETTINGS))
#define G_SETTINGS(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SETTINGS, GSettings))
#define G_IS_SETTINGS(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SETTINGS))
#define G_SETTINGS_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SETTINGS, GSettingsClass))

typedef struct _GSettingsPrivate GSettingsPrivate;
typedef struct _GSettingsClass {
    GObjectClass parent_class;
    void (*writable_changed) (GSettings * settings, const gchar * key);
    void (*changed) (GSettings * settings, const gchar * key);
     gboolean(*writable_change_event) (GSettings * settings, GQuark key);
     gboolean(*change_event) (GSettings * settings, const GQuark * keys,
			      gint n_keys);
    gpointer padding[20];
} GSettingsClass;
struct _GSettings {
    GObject parent_instance;
    GSettingsPrivate *priv;
};
typedef GVariant *(*GSettingsBindSetMapping) (const GValue * value,
					      const GVariantType *
					      expected_type,
					      gpointer user_data);
typedef gboolean(*GSettingsBindGetMapping) (GValue * value,
					    GVariant * variant,
					    gpointer user_data);
typedef gboolean(*GSettingsGetMapping) (GVariant * value,
					gpointer * result,
					gpointer user_data);
typedef enum {
    G_SETTINGS_BIND_DEFAULT,
    G_SETTINGS_BIND_GET = (1 &#60;&#60; 0),
    G_SETTINGS_BIND_SET = (1 &#60;&#60; 1),
    G_SETTINGS_BIND_NO_SENSITIVITY = (1 &#60;&#60; 2),
    G_SETTINGS_BIND_GET_NO_CHANGES = (1 &#60;&#60; 3),
    G_SETTINGS_BIND_INVERT_BOOLEAN = (1 &#60;&#60; 4)
} GSettingsBindFlags;
extern void g_settings_apply(GSettings * settings);
extern void g_settings_bind(GSettings * settings, const gchar * key,
			    void *object, const gchar * property,
			    GSettingsBindFlags flags);
extern void g_settings_bind_with_mapping(GSettings * settings,
					 const gchar * key, void *object,
					 const gchar * property,
					 GSettingsBindFlags flags,
					 GSettingsBindGetMapping
					 get_mapping,
					 GSettingsBindSetMapping
					 set_mapping, void *user_data,
					 GDestroyNotify destroy);
extern void g_settings_bind_writable(GSettings * settings,
				     const gchar * key, void *object,
				     const gchar * property,
				     gboolean inverted);
extern GAction *g_settings_create_action(GSettings * settings,
					 const gchar * key);
extern void g_settings_delay(GSettings * settings);
extern void g_settings_get(GSettings * settings, const gchar * key,
			   const gchar * format, ...);
extern gboolean g_settings_get_boolean(GSettings * settings,
				       const gchar * key);
extern GSettings *g_settings_get_child(GSettings * settings,
				       const gchar * name);
extern gdouble g_settings_get_double(GSettings * settings,
				     const gchar * key);
extern gint g_settings_get_enum(GSettings * settings, const gchar * key);
extern guint g_settings_get_flags(GSettings * settings, const gchar * key);
extern gboolean g_settings_get_has_unapplied(GSettings * settings);
extern gint g_settings_get_int(GSettings * settings, const gchar * key);
extern void *g_settings_get_mapped(GSettings * settings, const gchar * key,
				   GSettingsGetMapping mapping,
				   void *user_data);
extern GVariant *g_settings_get_range(GSettings * settings,
				      const gchar * key);
extern gchar *g_settings_get_string(GSettings * settings,
				    const gchar * key);
extern gchar **g_settings_get_strv(GSettings * settings,
				   const gchar * key);
extern GType g_settings_get_type(void);
extern guint g_settings_get_uint(GSettings * settings, const gchar * key);
extern GVariant *g_settings_get_value(GSettings * settings,
				      const gchar * key);
extern gboolean g_settings_is_writable(GSettings * settings,
				       const gchar * name);
extern gchar **g_settings_list_children(GSettings * settings);
extern gchar **g_settings_list_keys(GSettings * settings);
extern const gchar *const *g_settings_list_relocatable_schemas(void);
extern const gchar *const *g_settings_list_schemas(void);
extern GSettings *g_settings_new(const gchar * schema_id);
extern GSettings *g_settings_new_full(GSettingsSchema * schema,
				      GSettingsBackend * backend,
				      const gchar * path);
extern GSettings *g_settings_new_with_backend(const gchar * schema_id,
					      GSettingsBackend * backend);
extern GSettings *g_settings_new_with_backend_and_path(const gchar *
						       schema_id,
						       GSettingsBackend *
						       backend,
						       const gchar * path);
extern GSettings *g_settings_new_with_path(const gchar * schema_id,
					   const gchar * path);
extern gboolean g_settings_range_check(GSettings * settings,
				       const gchar * key,
				       GVariant * value);
extern void g_settings_reset(GSettings * settings, const gchar * key);
extern void g_settings_revert(GSettings * settings);
extern gboolean g_settings_set(GSettings * settings, const gchar * key,
			       const gchar * format, ...);
extern gboolean g_settings_set_boolean(GSettings * settings,
				       const gchar * key, gboolean value);
extern gboolean g_settings_set_double(GSettings * settings,
				      const gchar * key, gdouble value);
extern gboolean g_settings_set_enum(GSettings * settings,
				    const gchar * key, gint value);
extern gboolean g_settings_set_flags(GSettings * settings,
				     const gchar * key, guint value);
extern gboolean g_settings_set_int(GSettings * settings, const gchar * key,
				   gint value);
extern gboolean g_settings_set_string(GSettings * settings,
				      const gchar * key,
				      const gchar * value);
extern gboolean g_settings_set_strv(GSettings * settings,
				    const gchar * key,
				    const gchar * const *value);
extern gboolean g_settings_set_uint(GSettings * settings,
				    const gchar * key, guint value);
extern gboolean g_settings_set_value(GSettings * settings,
				     const gchar * key, GVariant * value);
extern void g_settings_sync(void);
extern void g_settings_unbind(void *object, const gchar * property);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41303"
>17.12.107. glib-2.0/gio/gsettingsbackend.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SETTINGS_BACKEND	(g_settings_backend_get_type ())
#define G_SETTINGS_BACKEND_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SETTINGS_BACKEND, GSettingsBackendClass))
#define G_IS_SETTINGS_BACKEND_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SETTINGS_BACKEND))
#define G_SETTINGS_BACKEND(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SETTINGS_BACKEND, GSettingsBackend))
#define G_IS_SETTINGS_BACKEND(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SETTINGS_BACKEND))
#define G_SETTINGS_BACKEND_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SETTINGS_BACKEND, GSettingsBackendClass))
#define G_SETTINGS_BACKEND_EXTENSION_POINT_NAME	"gsettings-backend"

typedef struct _GSettingsBackendPrivate GSettingsBackendPrivate;
typedef struct _GSettingsBackendClass {
    GObjectClass parent_class;
    GVariant *(*read) (GSettingsBackend * backend, const gchar * key,
		       const GVariantType * expected_type,
		       gboolean default_value);
     gboolean(*get_writable) (GSettingsBackend * backend,
			      const gchar * key);
     gboolean(*write) (GSettingsBackend * backend, const gchar * key,
		       GVariant * value, gpointer origin_tag);
     gboolean(*write_tree) (GSettingsBackend * backend, GTree * tree,
			    gpointer origin_tag);
    void (*reset) (GSettingsBackend * backend, const gchar * key,
		   gpointer origin_tag);
    void (*subscribe) (GSettingsBackend * backend, const gchar * name);
    void (*unsubscribe) (GSettingsBackend * backend, const gchar * name);
    void (*sync) (GSettingsBackend * backend);
    GPermission *(*get_permission) (GSettingsBackend * backend,
				    const gchar * path);
    gpointer padding[24];
} GSettingsBackendClass;
struct _GSettingsBackend {
    GObject parent_instance;
    GSettingsBackendPrivate *priv;
};
extern GSettingsBackend *g_keyfile_settings_backend_new(const gchar *
							filename,
							const gchar *
							root_path,
							const gchar *
							root_group);
extern GSettingsBackend *g_memory_settings_backend_new(void);
extern GSettingsBackend *g_null_settings_backend_new(void);
extern void g_settings_backend_changed(GSettingsBackend * backend,
				       const gchar * key,
				       gpointer origin_tag);
extern void g_settings_backend_changed_tree(GSettingsBackend * backend,
					    GTree * tree,
					    gpointer origin_tag);
extern void g_settings_backend_flatten_tree(GTree * tree, gchar * *path,
					    const gchar * **keys,
					    GVariant * **values);
extern GSettingsBackend *g_settings_backend_get_default(void);
extern GType g_settings_backend_get_type(void);
extern void g_settings_backend_keys_changed(GSettingsBackend * backend,
					    const gchar * path,
					    const gchar * const *items,
					    gpointer origin_tag);
extern void g_settings_backend_path_changed(GSettingsBackend * backend,
					    const gchar * path,
					    gpointer origin_tag);
extern void g_settings_backend_path_writable_changed(GSettingsBackend *
						     backend,
						     const gchar * path);
extern void g_settings_backend_writable_changed(GSettingsBackend * backend,
						const gchar * key);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41307"
>17.12.108. glib-2.0/gio/gsettingsschema.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SETTINGS_SCHEMA	(g_settings_schema_get_type ())
#define G_TYPE_SETTINGS_SCHEMA_SOURCE	(g_settings_schema_source_get_type ())

typedef struct _GSettingsSchemaSource GSettingsSchemaSource;
typedef struct _GSettingsSchema GSettingsSchema;
extern const gchar *g_settings_schema_get_id(GSettingsSchema * schema);
extern const gchar *g_settings_schema_get_path(GSettingsSchema * schema);
extern GType g_settings_schema_get_type(void);
extern GSettingsSchema *g_settings_schema_ref(GSettingsSchema * schema);
extern GSettingsSchemaSource *g_settings_schema_source_get_default(void);
extern GType g_settings_schema_source_get_type(void);
extern GSettingsSchema
    *g_settings_schema_source_lookup(GSettingsSchemaSource * source,
				     const gchar * schema_id,
				     gboolean recursive);
extern GSettingsSchemaSource
    *g_settings_schema_source_new_from_directory(const gchar * directory,
						 GSettingsSchemaSource *
						 parent, gboolean trusted,
						 GError * *error);
extern GSettingsSchemaSource
    *g_settings_schema_source_ref(GSettingsSchemaSource * source);
extern void g_settings_schema_source_unref(GSettingsSchemaSource * source);
extern void g_settings_schema_unref(GSettingsSchema * schema);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41311"
>17.12.109. glib-2.0/gio/gsimpleaction.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SIMPLE_ACTION	(g_simple_action_get_type ())
#define G_SIMPLE_ACTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SIMPLE_ACTION, GSimpleAction))
#define G_IS_SIMPLE_ACTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SIMPLE_ACTION))

extern GType g_simple_action_get_type(void);
extern GSimpleAction *g_simple_action_new(const gchar * name,
					  GVariantType * parameter_type);
extern GSimpleAction *g_simple_action_new_stateful(const gchar * name,
						   GVariantType *
						   parameter_type,
						   GVariant * state);
extern void g_simple_action_set_enabled(GSimpleAction * simple,
					gboolean enabled);
extern void g_simple_action_set_state(GSimpleAction * simple,
				      GVariant * value);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41315"
>17.12.110. glib-2.0/gio/gsimpleactiongroup.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SIMPLE_ACTION_GROUP	(g_simple_action_group_get_type ())
#define G_SIMPLE_ACTION_GROUP_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass))
#define G_IS_SIMPLE_ACTION_GROUP_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SIMPLE_ACTION_GROUP))
#define G_SIMPLE_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroup))
#define G_IS_SIMPLE_ACTION_GROUP(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SIMPLE_ACTION_GROUP))
#define G_SIMPLE_ACTION_GROUP_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass))

typedef struct _GSimpleActionGroupPrivate GSimpleActionGroupPrivate;
typedef struct _GSimpleActionGroupClass {
    GObjectClass parent_class;
    gpointer padding[12];
} GSimpleActionGroupClass;
struct _GSimpleActionGroup {
    GObject parent_instance;
    GSimpleActionGroupPrivate *priv;
};
extern void g_simple_action_group_add_entries(GSimpleActionGroup * simple,
					      const GActionEntry * entries,
					      gint n_entries,
					      gpointer user_data);
extern GType g_simple_action_group_get_type(void);
extern void g_simple_action_group_insert(GSimpleActionGroup * simple,
					 GAction * action);
extern GAction *g_simple_action_group_lookup(GSimpleActionGroup * simple,
					     const gchar * action_name);
extern GSimpleActionGroup *g_simple_action_group_new(void);
extern void g_simple_action_group_remove(GSimpleActionGroup * simple,
					 const gchar * action_name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41319"
>17.12.111. glib-2.0/gio/gsimpleasyncresult.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SIMPLE_ASYNC_RESULT	(g_simple_async_result_get_type ())
#define G_SIMPLE_ASYNC_RESULT_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass))
#define G_IS_SIMPLE_ASYNC_RESULT_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SIMPLE_ASYNC_RESULT))
#define G_SIMPLE_ASYNC_RESULT(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResult))
#define G_IS_SIMPLE_ASYNC_RESULT(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SIMPLE_ASYNC_RESULT))
#define G_SIMPLE_ASYNC_RESULT_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass))

typedef struct _GSimpleAsyncResultClass GSimpleAsyncResultClass;
extern void g_simple_async_report_error_in_idle(GObject * object,
						GAsyncReadyCallback
						callback,
						gpointer user_data,
						GQuark domain, gint code,
						const char *format, ...);
extern void g_simple_async_report_gerror_in_idle(GObject * object,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data,
						 const GError * error);
extern void g_simple_async_report_take_gerror_in_idle(GObject * object,
						      GAsyncReadyCallback
						      callback,
						      gpointer user_data,
						      GError * error);
extern void g_simple_async_result_complete(GSimpleAsyncResult * simple);
extern void g_simple_async_result_complete_in_idle(GSimpleAsyncResult *
						   simple);
extern gboolean
g_simple_async_result_get_op_res_gboolean(GSimpleAsyncResult * simple);
extern gpointer
g_simple_async_result_get_op_res_gpointer(GSimpleAsyncResult * simple);
extern gssize g_simple_async_result_get_op_res_gssize(GSimpleAsyncResult *
						      simple);
extern gpointer g_simple_async_result_get_source_tag(GSimpleAsyncResult *
						     simple);
extern GType g_simple_async_result_get_type(void);
extern gboolean g_simple_async_result_is_valid(GAsyncResult * result,
					       GObject * source,
					       gpointer source_tag);
extern GSimpleAsyncResult *g_simple_async_result_new(GObject *
						     source_object,
						     GAsyncReadyCallback
						     callback,
						     gpointer user_data,
						     gpointer source_tag);
extern GSimpleAsyncResult *g_simple_async_result_new_error(GObject *
							   source_object,
							   GAsyncReadyCallback
							   callback,
							   gpointer
							   user_data,
							   GQuark domain,
							   gint code,
							   const char
							   *format, ...);
extern GSimpleAsyncResult *g_simple_async_result_new_from_error(GObject *
								source_object,
								GAsyncReadyCallback
								callback,
								gpointer
								user_data,
								const
								GError *
								error);
extern GSimpleAsyncResult *g_simple_async_result_new_take_error(GObject *
								source_object,
								GAsyncReadyCallback
								callback,
								gpointer
								user_data,
								GError *
								error);
extern gboolean g_simple_async_result_propagate_error(GSimpleAsyncResult *
						      simple,
						      GError * *dest);
extern void g_simple_async_result_run_in_thread(GSimpleAsyncResult *
						simple,
						GSimpleAsyncThreadFunc
						func, int io_priority,
						GCancellable *
						cancellable);
extern void g_simple_async_result_set_check_cancellable(GSimpleAsyncResult
							* simple,
							GCancellable *
							check_cancellable);
extern void g_simple_async_result_set_error(GSimpleAsyncResult * simple,
					    GQuark domain, gint code,
					    const char *format, ...);
extern void g_simple_async_result_set_error_va(GSimpleAsyncResult * simple,
					       GQuark domain, gint code,
					       const char *format,
					       va_list args);
extern void g_simple_async_result_set_from_error(GSimpleAsyncResult *
						 simple,
						 const GError * error);
extern void
g_simple_async_result_set_handle_cancellation(GSimpleAsyncResult * simple,
					      gboolean
					      handle_cancellation);
extern void g_simple_async_result_set_op_res_gboolean(GSimpleAsyncResult *
						      simple,
						      gboolean op_res);
extern void g_simple_async_result_set_op_res_gpointer(GSimpleAsyncResult *
						      simple,
						      gpointer op_res,
						      GDestroyNotify
						      destroy_op_res);
extern void g_simple_async_result_set_op_res_gssize(GSimpleAsyncResult *
						    simple, gssize op_res);
extern void g_simple_async_result_take_error(GSimpleAsyncResult * simple,
					     GError * error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41323"
>17.12.112. glib-2.0/gio/gsimplepermission.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SIMPLE_PERMISSION	(g_simple_permission_get_type ())
#define G_SIMPLE_PERMISSION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SIMPLE_PERMISSION, GSimplePermission))
#define G_IS_SIMPLE_PERMISSION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SIMPLE_PERMISSION))

extern GType g_simple_permission_get_type(void);
extern GPermission *g_simple_permission_new(gboolean allowed);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41327"
>17.12.113. glib-2.0/gio/gsocket.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET	(g_socket_get_type ())
#define G_SOCKET_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SOCKET, GSocketClass))
#define G_IS_SOCKET_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SOCKET))
#define G_SOCKET(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SOCKET, GSocket))
#define G_IS_SOCKET(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SOCKET))
#define G_SOCKET_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SOCKET, GSocketClass))

typedef struct _GSocketPrivate GSocketPrivate;
typedef struct _GSocketClass {
    GObjectClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
    void (*_g_reserved8) (void);
    void (*_g_reserved9) (void);
    void (*_g_reserved10) (void);
} GSocketClass;
struct _GSocket {
    GObject parent_instance;
    GSocketPrivate *priv;
};
extern GSocket *g_socket_accept(GSocket * socket,
				GCancellable * cancellable,
				GError * *error);
extern gboolean g_socket_bind(GSocket * socket, GSocketAddress * address,
			      gboolean allow_reuse, GError * *error);
extern gboolean g_socket_check_connect_result(GSocket * socket,
					      GError * *error);
extern gboolean g_socket_close(GSocket * socket, GError * *error);
extern GIOCondition g_socket_condition_check(GSocket * socket,
					     GIOCondition condition);
extern gboolean g_socket_condition_timed_wait(GSocket * socket,
					      GIOCondition condition,
					      gint64 timeout,
					      GCancellable * cancellable,
					      GError * *error);
extern gboolean g_socket_condition_wait(GSocket * socket,
					GIOCondition condition,
					GCancellable * cancellable,
					GError * *error);
extern gboolean g_socket_connect(GSocket * socket,
				 GSocketAddress * address,
				 GCancellable * cancellable,
				 GError * *error);
extern GSource *g_socket_create_source(GSocket * socket,
				       GIOCondition condition,
				       GCancellable * cancellable);
extern gssize g_socket_get_available_bytes(GSocket * socket);
extern gboolean g_socket_get_blocking(GSocket * socket);
extern gboolean g_socket_get_broadcast(GSocket * socket);
extern GCredentials *g_socket_get_credentials(GSocket * socket,
					      GError * *error);
extern GSocketFamily g_socket_get_family(GSocket * socket);
extern int g_socket_get_fd(GSocket * socket);
extern gboolean g_socket_get_keepalive(GSocket * socket);
extern gint g_socket_get_listen_backlog(GSocket * socket);
extern GSocketAddress *g_socket_get_local_address(GSocket * socket,
						  GError * *error);
extern gboolean g_socket_get_multicast_loopback(GSocket * socket);
extern guint g_socket_get_multicast_ttl(GSocket * socket);
extern GSocketProtocol g_socket_get_protocol(GSocket * socket);
extern GSocketAddress *g_socket_get_remote_address(GSocket * socket,
						   GError * *error);
extern GSocketType g_socket_get_socket_type(GSocket * socket);
extern guint g_socket_get_timeout(GSocket * socket);
extern guint g_socket_get_ttl(GSocket * socket);
extern GType g_socket_get_type(void);
extern gboolean g_socket_is_closed(GSocket * socket);
extern gboolean g_socket_is_connected(GSocket * socket);
extern gboolean g_socket_join_multicast_group(GSocket * socket,
					      GInetAddress * group,
					      gboolean source_specific,
					      const char *iface,
					      GError * *error);
extern gboolean g_socket_leave_multicast_group(GSocket * socket,
					       GInetAddress * group,
					       gboolean source_specific,
					       const char *iface,
					       GError * *error);
extern gboolean g_socket_listen(GSocket * socket, GError * *error);
extern GSocket *g_socket_new(GSocketFamily family, GSocketType type,
			     GSocketProtocol protocol, GError * *error);
extern GSocket *g_socket_new_from_fd(gint fd, GError * *error);
extern gssize g_socket_receive(GSocket * socket, gchar * buffer,
			       gsize size, GCancellable * cancellable,
			       GError * *error);
extern gssize g_socket_receive_from(GSocket * socket,
				    GSocketAddress * *address,
				    gchar * buffer, gsize size,
				    GCancellable * cancellable,
				    GError * *error);
extern gssize g_socket_receive_message(GSocket * socket,
				       GSocketAddress * *address,
				       GInputVector * vectors,
				       gint num_vectors,
				       GSocketControlMessage * **messages,
				       gint * num_messages, gint * flags,
				       GCancellable * cancellable,
				       GError * *error);
extern gssize g_socket_receive_with_blocking(GSocket * socket,
					     gchar * buffer, gsize size,
					     gboolean blocking,
					     GCancellable * cancellable,
					     GError * *error);
extern gssize g_socket_send(GSocket * socket, const char *buffer,
			    gsize size, GCancellable * cancellable,
			    GError * *error);
extern gssize g_socket_send_message(GSocket * socket,
				    GSocketAddress * address,
				    GOutputVector * vectors,
				    gint num_vectors,
				    GSocketControlMessage * *messages,
				    gint num_messages, gint flags,
				    GCancellable * cancellable,
				    GError * *error);
extern gssize g_socket_send_to(GSocket * socket, GSocketAddress * address,
			       const char *buffer, gsize size,
			       GCancellable * cancellable,
			       GError * *error);
extern gssize g_socket_send_with_blocking(GSocket * socket,
					  const char *buffer, gsize size,
					  gboolean blocking,
					  GCancellable * cancellable,
					  GError * *error);
extern void g_socket_set_blocking(GSocket * socket, gboolean blocking);
extern void g_socket_set_broadcast(GSocket * socket, gboolean broadcast);
extern void g_socket_set_keepalive(GSocket * socket, gboolean keepalive);
extern void g_socket_set_listen_backlog(GSocket * socket, gint backlog);
extern void g_socket_set_multicast_loopback(GSocket * socket,
					    gboolean loopback);
extern void g_socket_set_multicast_ttl(GSocket * socket, guint ttl);
extern void g_socket_set_timeout(GSocket * socket, guint timeout);
extern void g_socket_set_ttl(GSocket * socket, guint ttl);
extern gboolean g_socket_shutdown(GSocket * socket, gboolean shutdown_read,
				  gboolean shutdown_write,
				  GError * *error);
extern gboolean g_socket_speaks_ipv4(GSocket * socket);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41331"
>17.12.114. glib-2.0/gio/gsocketaddress.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_ADDRESS	(g_socket_address_get_type ())
#define G_SOCKET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
#define G_IS_SOCKET_ADDRESS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS))
#define G_SOCKET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddress))
#define G_IS_SOCKET_ADDRESS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS))
#define G_SOCKET_ADDRESS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))

typedef struct _GSocketAddressClass {
    GObjectClass parent_class;
     GSocketFamily(*get_family) (GSocketAddress * address);
     gssize(*get_native_size) (GSocketAddress * address);
     gboolean(*to_native) (GSocketAddress * address, gpointer dest,
			   gsize destlen, GError * *error);
} GSocketAddressClass;
struct _GSocketAddress {
    GObject parent_instance;
};
extern GSocketFamily g_socket_address_get_family(GSocketAddress * address);
extern gssize g_socket_address_get_native_size(GSocketAddress * address);
extern GType g_socket_address_get_type(void);
extern GSocketAddress *g_socket_address_new_from_native(gpointer native,
							gsize len);
extern gboolean g_socket_address_to_native(GSocketAddress * address,
					   gpointer dest, gsize destlen,
					   GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41335"
>17.12.115. glib-2.0/gio/gsocketaddressenumerator.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_ADDRESS_ENUMERATOR	(g_socket_address_enumerator_get_type ())
#define G_SOCKET_ADDRESS_ENUMERATOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass))
#define G_IS_SOCKET_ADDRESS_ENUMERATOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS_ENUMERATOR))
#define G_SOCKET_ADDRESS_ENUMERATOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumerator))
#define G_IS_SOCKET_ADDRESS_ENUMERATOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR))
#define G_SOCKET_ADDRESS_ENUMERATOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass))

typedef struct _GSocketAddressEnumeratorClass {
    GObjectClass parent_class;
    GSocketAddress *(*next) (GSocketAddressEnumerator * enumerator,
			     GCancellable * cancellable, GError * *error);
    void (*next_async) (GSocketAddressEnumerator * enumerator,
			GCancellable * cancellable,
			GAsyncReadyCallback callback, gpointer user_data);
    GSocketAddress *(*next_finish) (GSocketAddressEnumerator * enumerator,
				    GAsyncResult * result,
				    GError * *error);
} GSocketAddressEnumeratorClass;
struct _GSocketAddressEnumerator {
    GObject parent_instance;
};
extern GType g_socket_address_enumerator_get_type(void);
extern GSocketAddress
    *g_socket_address_enumerator_next(GSocketAddressEnumerator *
				      enumerator,
				      GCancellable * cancellable,
				      GError * *error);
extern void g_socket_address_enumerator_next_async(GSocketAddressEnumerator
						   * enumerator,
						   GCancellable *
						   cancellable,
						   GAsyncReadyCallback
						   callback,
						   gpointer user_data);
extern GSocketAddress
    *g_socket_address_enumerator_next_finish(GSocketAddressEnumerator *
					     enumerator,
					     GAsyncResult * result,
					     GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41339"
>17.12.116. glib-2.0/gio/gsocketclient.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_CLIENT	(g_socket_client_get_type ())
#define G_SOCKET_CLIENT_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SOCKET_CLIENT, GSocketClientClass))
#define G_IS_SOCKET_CLIENT_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SOCKET_CLIENT))
#define G_SOCKET_CLIENT(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SOCKET_CLIENT, GSocketClient))
#define G_IS_SOCKET_CLIENT(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SOCKET_CLIENT))
#define G_SOCKET_CLIENT_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SOCKET_CLIENT, GSocketClientClass))

typedef struct _GSocketClientPrivate GSocketClientPrivate;
typedef struct _GSocketClientClass {
    GObjectClass parent_class;
    void (*event) (GSocketClient * client, GSocketClientEvent event,
		   GSocketConnectable * connectable,
		   GIOStream * connection);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
} GSocketClientClass;
struct _GSocketClient {
    GObject parent_instance;
    GSocketClientPrivate *priv;
};
extern void g_socket_client_add_application_proxy(GSocketClient * client,
						  const gchar * protocol);
extern GSocketConnection *g_socket_client_connect(GSocketClient * client,
						  GSocketConnectable *
						  connectable,
						  GCancellable *
						  cancellable,
						  GError * *error);
extern void g_socket_client_connect_async(GSocketClient * client,
					  GSocketConnectable * connectable,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern GSocketConnection *g_socket_client_connect_finish(GSocketClient *
							 client,
							 GAsyncResult *
							 result,
							 GError * *error);
extern GSocketConnection *g_socket_client_connect_to_host(GSocketClient *
							  client,
							  const gchar *
							  host_and_port,
							  guint16
							  default_port,
							  GCancellable *
							  cancellable,
							  GError * *error);
extern void g_socket_client_connect_to_host_async(GSocketClient * client,
						  const gchar *
						  host_and_port,
						  guint16 default_port,
						  GCancellable *
						  cancellable,
						  GAsyncReadyCallback
						  callback,
						  gpointer user_data);
extern GSocketConnection
    *g_socket_client_connect_to_host_finish(GSocketClient * client,
					    GAsyncResult * result,
					    GError * *error);
extern GSocketConnection *g_socket_client_connect_to_service(GSocketClient
							     * client,
							     const gchar *
							     domain,
							     const gchar *
							     service,
							     GCancellable *
							     cancellable,
							     GError *
							     *error);
extern void g_socket_client_connect_to_service_async(GSocketClient *
						     client,
						     const gchar * domain,
						     const gchar * service,
						     GCancellable *
						     cancellable,
						     GAsyncReadyCallback
						     callback,
						     gpointer user_data);
extern GSocketConnection
    *g_socket_client_connect_to_service_finish(GSocketClient * client,
					       GAsyncResult * result,
					       GError * *error);
extern GSocketConnection *g_socket_client_connect_to_uri(GSocketClient *
							 client,
							 const gchar * uri,
							 guint16
							 default_port,
							 GCancellable *
							 cancellable,
							 GError * *error);
extern void g_socket_client_connect_to_uri_async(GSocketClient * client,
						 const gchar * uri,
						 guint16 default_port,
						 GCancellable *
						 cancellable,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data);
extern GSocketConnection
    *g_socket_client_connect_to_uri_finish(GSocketClient * client,
					   GAsyncResult * result,
					   GError * *error);
extern gboolean g_socket_client_get_enable_proxy(GSocketClient * client);
extern GSocketFamily g_socket_client_get_family(GSocketClient * client);
extern GSocketAddress *g_socket_client_get_local_address(GSocketClient *
							 client);
extern GSocketProtocol g_socket_client_get_protocol(GSocketClient *
						    client);
extern GSocketType g_socket_client_get_socket_type(GSocketClient * client);
extern guint g_socket_client_get_timeout(GSocketClient * client);
extern gboolean g_socket_client_get_tls(GSocketClient * client);
extern GTlsCertificateFlags
g_socket_client_get_tls_validation_flags(GSocketClient * client);
extern GType g_socket_client_get_type(void);
extern GSocketClient *g_socket_client_new(void);
extern void g_socket_client_set_enable_proxy(GSocketClient * client,
					     gboolean enable);
extern void g_socket_client_set_family(GSocketClient * client,
				       GSocketFamily family);
extern void g_socket_client_set_local_address(GSocketClient * client,
					      GSocketAddress * address);
extern void g_socket_client_set_protocol(GSocketClient * client,
					 GSocketProtocol protocol);
extern void g_socket_client_set_socket_type(GSocketClient * client,
					    GSocketType type);
extern void g_socket_client_set_timeout(GSocketClient * client,
					guint timeout);
extern void g_socket_client_set_tls(GSocketClient * client, gboolean tls);
extern void g_socket_client_set_tls_validation_flags(GSocketClient *
						     client,
						     GTlsCertificateFlags
						     flags);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41343"
>17.12.117. glib-2.0/gio/gsocketconnectable.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_CONNECTABLE	(g_socket_connectable_get_type ())
#define G_SOCKET_CONNECTABLE(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable))
#define G_IS_SOCKET_CONNECTABLE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SOCKET_CONNECTABLE))
#define G_SOCKET_CONNECTABLE_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface))

typedef struct _GSocketConnectableIface {
    GTypeInterface g_iface;
    GSocketAddressEnumerator *(*enumerate) (GSocketConnectable *
					    connectable);
    GSocketAddressEnumerator *(*proxy_enumerate) (GSocketConnectable *
						  connectable);
} GSocketConnectableIface;
extern GSocketAddressEnumerator
    *g_socket_connectable_enumerate(GSocketConnectable * connectable);
extern GType g_socket_connectable_get_type(void);
extern GSocketAddressEnumerator
    *g_socket_connectable_proxy_enumerate(GSocketConnectable *
					  connectable);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41347"
>17.12.118. glib-2.0/gio/gsocketconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_CONNECTION	(g_socket_connection_get_type ())
#define G_SOCKET_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass))
#define G_IS_SOCKET_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SOCKET_CONNECTION))
#define G_SOCKET_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SOCKET_CONNECTION, GSocketConnection))
#define G_IS_SOCKET_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SOCKET_CONNECTION))
#define G_SOCKET_CONNECTION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass))

typedef struct _GSocketConnectionPrivate GSocketConnectionPrivate;
typedef struct _GSocketConnectionClass {
    GIOStreamClass parent_class;
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
} GSocketConnectionClass;
struct _GSocketConnection {
    GIOStream parent_instance;
    GSocketConnectionPrivate *priv;
};
extern gboolean g_socket_connection_connect(GSocketConnection * connection,
					    GSocketAddress * address,
					    GCancellable * cancellable,
					    GError * *error);
extern void g_socket_connection_connect_async(GSocketConnection *
					      connection,
					      GSocketAddress * address,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern gboolean g_socket_connection_connect_finish(GSocketConnection *
						   connection,
						   GAsyncResult * result,
						   GError * *error);
extern GSocketConnection
    *g_socket_connection_factory_create_connection(GSocket * socket);
extern GType g_socket_connection_factory_lookup_type(GSocketFamily family,
						     GSocketType type,
						     gint protocol_id);
extern void g_socket_connection_factory_register_type(GType g_type,
						      GSocketFamily family,
						      GSocketType type,
						      gint protocol);
extern GSocketAddress
    *g_socket_connection_get_local_address(GSocketConnection * connection,
					   GError * *error);
extern GSocketAddress
    *g_socket_connection_get_remote_address(GSocketConnection * connection,
					    GError * *error);
extern GSocket *g_socket_connection_get_socket(GSocketConnection *
					       connection);
extern GType g_socket_connection_get_type(void);
extern gboolean g_socket_connection_is_connected(GSocketConnection *
						 connection);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41351"
>17.12.119. glib-2.0/gio/gsocketcontrolmessage.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_CONTROL_MESSAGE	(g_socket_control_message_get_type ())
#define G_SOCKET_CONTROL_MESSAGE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessageClass))
#define G_IS_SOCKET_CONTROL_MESSAGE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SOCKET_CONTROL_MESSAGE))
#define G_SOCKET_CONTROL_MESSAGE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessage))
#define G_IS_SOCKET_CONTROL_MESSAGE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SOCKET_CONTROL_MESSAGE))
#define G_SOCKET_CONTROL_MESSAGE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessageClass))

typedef struct _GSocketControlMessagePrivate GSocketControlMessagePrivate;
typedef struct _GSocketControlMessageClass {
    GObjectClass parent_class;
     gsize(*get_size) (GSocketControlMessage * message);
    int (*get_level) (GSocketControlMessage * message);
    int (*get_type) (GSocketControlMessage * message);
    void (*serialize) (GSocketControlMessage * message, gpointer data);
    GSocketControlMessage *(*deserialize) (int level, int type, gsize size,
					   gpointer data);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GSocketControlMessageClass;
struct _GSocketControlMessage {
    GObject parent_instance;
    GSocketControlMessagePrivate *priv;
};
extern GSocketControlMessage *g_socket_control_message_deserialize(int
								   level,
								   int
								   type,
								   gsize
								   size,
								   gpointer
								   data);
extern int g_socket_control_message_get_level(GSocketControlMessage *
					      message);
extern int g_socket_control_message_get_msg_type(GSocketControlMessage *
						 message);
extern gsize g_socket_control_message_get_size(GSocketControlMessage *
					       message);
extern GType g_socket_control_message_get_type(void);
extern void g_socket_control_message_serialize(GSocketControlMessage *
					       message, gpointer data);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41355"
>17.12.120. glib-2.0/gio/gsocketlistener.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_LISTENER	(g_socket_listener_get_type ())
#define G_SOCKET_LISTENER_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SOCKET_LISTENER, GSocketListenerClass))
#define G_IS_SOCKET_LISTENER_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SOCKET_LISTENER))
#define G_SOCKET_LISTENER(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SOCKET_LISTENER, GSocketListener))
#define G_IS_SOCKET_LISTENER(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SOCKET_LISTENER))
#define G_SOCKET_LISTENER_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SOCKET_LISTENER, GSocketListenerClass))

typedef struct _GSocketListenerPrivate GSocketListenerPrivate;
typedef struct _GSocketListenerClass {
    GObjectClass parent_class;
    void (*changed) (GSocketListener * listener);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
} GSocketListenerClass;
struct _GSocketListener {
    GObject parent_instance;
    GSocketListenerPrivate *priv;
};
extern GSocketConnection *g_socket_listener_accept(GSocketListener *
						   listener,
						   GObject *
						   *source_object,
						   GCancellable *
						   cancellable,
						   GError * *error);
extern void g_socket_listener_accept_async(GSocketListener * listener,
					   GCancellable * cancellable,
					   GAsyncReadyCallback callback,
					   gpointer user_data);
extern GSocketConnection *g_socket_listener_accept_finish(GSocketListener *
							  listener,
							  GAsyncResult *
							  result,
							  GObject *
							  *source_object,
							  GError * *error);
extern GSocket *g_socket_listener_accept_socket(GSocketListener * listener,
						GObject * *source_object,
						GCancellable * cancellable,
						GError * *error);
extern void g_socket_listener_accept_socket_async(GSocketListener *
						  listener,
						  GCancellable *
						  cancellable,
						  GAsyncReadyCallback
						  callback,
						  gpointer user_data);
extern GSocket *g_socket_listener_accept_socket_finish(GSocketListener *
						       listener,
						       GAsyncResult *
						       result,
						       GObject *
						       *source_object,
						       GError * *error);
extern gboolean g_socket_listener_add_address(GSocketListener * listener,
					      GSocketAddress * address,
					      GSocketType type,
					      GSocketProtocol protocol,
					      GObject * source_object,
					      GSocketAddress *
					      *effective_address,
					      GError * *error);
extern guint16 g_socket_listener_add_any_inet_port(GSocketListener *
						   listener,
						   GObject * source_object,
						   GError * *error);
extern gboolean g_socket_listener_add_inet_port(GSocketListener * listener,
						guint16 port,
						GObject * source_object,
						GError * *error);
extern gboolean g_socket_listener_add_socket(GSocketListener * listener,
					     GSocket * socket,
					     GObject * source_object,
					     GError * *error);
extern void g_socket_listener_close(GSocketListener * listener);
extern GType g_socket_listener_get_type(void);
extern GSocketListener *g_socket_listener_new(void);
extern void g_socket_listener_set_backlog(GSocketListener * listener,
					  int listen_backlog);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41359"
>17.12.121. glib-2.0/gio/gsocketservice.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SOCKET_SERVICE	(g_socket_service_get_type ())
#define G_SOCKET_SERVICE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_SOCKET_SERVICE, GSocketServiceClass))
#define G_IS_SOCKET_SERVICE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_SOCKET_SERVICE))
#define G_SOCKET_SERVICE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_SOCKET_SERVICE, GSocketService))
#define G_IS_SOCKET_SERVICE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_SOCKET_SERVICE))
#define G_SOCKET_SERVICE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_SOCKET_SERVICE, GSocketServiceClass))

typedef struct _GSocketServicePrivate GSocketServicePrivate;
typedef struct _GSocketServiceClass {
    GSocketListenerClass parent_class;
     gboolean(*incoming) (GSocketService * service,
			  GSocketConnection * connection,
			  GObject * source_object);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
} GSocketServiceClass;
struct _GSocketService {
    GSocketListener parent_instance;
    GSocketServicePrivate *priv;
};
extern GType g_socket_service_get_type(void);
extern gboolean g_socket_service_is_active(GSocketService * service);
extern GSocketService *g_socket_service_new(void);
extern void g_socket_service_start(GSocketService * service);
extern void g_socket_service_stop(GSocketService * service);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41363"
>17.12.122. glib-2.0/gio/gsrvtarget.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_SRV_TARGET	(g_srv_target_get_type ())

extern GSrvTarget *g_srv_target_copy(GSrvTarget * target);
extern void g_srv_target_free(GSrvTarget * target);
extern const char *g_srv_target_get_hostname(GSrvTarget * target);
extern guint16 g_srv_target_get_port(GSrvTarget * target);
extern guint16 g_srv_target_get_priority(GSrvTarget * target);
extern GType g_srv_target_get_type(void);
extern guint16 g_srv_target_get_weight(GSrvTarget * target);
extern GList *g_srv_target_list_sort(GList * targets);
extern GSrvTarget *g_srv_target_new(const gchar * hostname, guint16 port,
				    guint16 priority, guint16 weight);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41367"
>17.12.123. glib-2.0/gio/gtcpconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TCP_CONNECTION	(g_tcp_connection_get_type ())
#define G_TCP_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TCP_CONNECTION, GTcpConnectionClass))
#define G_IS_TCP_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TCP_CONNECTION))
#define G_TCP_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TCP_CONNECTION, GTcpConnection))
#define G_IS_TCP_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TCP_CONNECTION))
#define G_TCP_CONNECTION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TCP_CONNECTION, GTcpConnectionClass))

typedef struct _GTcpConnectionPrivate GTcpConnectionPrivate;
typedef struct _GTcpConnectionClass {
    GSocketConnectionClass parent_class;
} GTcpConnectionClass;
struct _GTcpConnection {
    GSocketConnection parent_instance;
    GTcpConnectionPrivate *priv;
};
extern gboolean g_tcp_connection_get_graceful_disconnect(GTcpConnection *
							 connection);
extern GType g_tcp_connection_get_type(void);
extern void g_tcp_connection_set_graceful_disconnect(GTcpConnection *
						     connection,
						     gboolean
						     graceful_disconnect);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41371"
>17.12.124. glib-2.0/gio/gtcpwrapperconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TCP_WRAPPER_CONNECTION	(g_tcp_wrapper_connection_get_type ())
#define G_TCP_WRAPPER_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass))
#define G_IS_TCP_WRAPPER_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TCP_WRAPPER_CONNECTION))
#define G_TCP_WRAPPER_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnection))
#define G_IS_TCP_WRAPPER_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TCP_WRAPPER_CONNECTION))
#define G_TCP_WRAPPER_CONNECTION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass))

typedef struct _GTcpWrapperConnectionPrivate GTcpWrapperConnectionPrivate;
typedef struct _GTcpWrapperConnectionClass {
    GTcpConnectionClass parent_class;
} GTcpWrapperConnectionClass;
struct _GTcpWrapperConnection {
    GTcpConnection parent_instance;
    GTcpWrapperConnectionPrivate *priv;
};
extern GIOStream
    *g_tcp_wrapper_connection_get_base_io_stream(GTcpWrapperConnection *
						 conn);
extern GType g_tcp_wrapper_connection_get_type(void);
extern GSocketConnection *g_tcp_wrapper_connection_new(GIOStream *
						       base_io_stream,
						       GSocket * socket);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41375"
>17.12.125. glib-2.0/gio/gthemedicon.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_THEMED_ICON	(g_themed_icon_get_type ())
#define G_THEMED_ICON_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_THEMED_ICON, GThemedIconClass))
#define G_IS_THEMED_ICON_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_THEMED_ICON))
#define G_THEMED_ICON(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_THEMED_ICON, GThemedIcon))
#define G_IS_THEMED_ICON(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_THEMED_ICON))
#define G_THEMED_ICON_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_THEMED_ICON, GThemedIconClass))

typedef struct _GThemedIconClass GThemedIconClass;
extern void g_themed_icon_append_name(GThemedIcon * icon,
				      const char *iconname);
extern const char *const *g_themed_icon_get_names(GThemedIcon * icon);
extern GType g_themed_icon_get_type(void);
extern GIcon *g_themed_icon_new(const char *iconname);
extern GIcon *g_themed_icon_new_from_names(char **iconnames, int len);
extern GIcon *g_themed_icon_new_with_default_fallbacks(const char
						       *iconname);
extern void g_themed_icon_prepend_name(GThemedIcon * icon,
				       const char *iconname);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41379"
>17.12.126. glib-2.0/gio/gthreadedsocketservice.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_THREADED_SOCKET_SERVICE	(g_threaded_socket_service_get_type ())
#define G_THREADED_SOCKET_SERVICE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketServiceClass))
#define G_IS_THREADED_SOCKET_SERVICE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_THREADED_SOCKET_SERVICE))
#define G_THREADED_SOCKET_SERVICE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketService))
#define G_IS_THREADED_SOCKET_SERVICE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_THREADED_SOCKET_SERVICE))
#define G_THREADED_SOCKET_SERVICE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketServiceClass))

typedef struct _GThreadedSocketServicePrivate
    GThreadedSocketServicePrivate;
typedef struct _GThreadedSocketServiceClass {
    GSocketServiceClass parent_class;
     gboolean(*run) (GThreadedSocketService * service,
		     GSocketConnection * connection,
		     GObject * source_object);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
} GThreadedSocketServiceClass;
struct _GThreadedSocketService {
    GSocketService parent_instance;
    GThreadedSocketServicePrivate *priv;
};
extern GType g_threaded_socket_service_get_type(void);
extern GSocketService *g_threaded_socket_service_new(int max_threads);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41383"
>17.12.127. glib-2.0/gio/gtlsbackend.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_BACKEND	(g_tls_backend_get_type ())
#define G_TLS_BACKEND(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_TLS_BACKEND, GTlsBackend))
#define G_IS_TLS_BACKEND(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_TLS_BACKEND))
#define G_TLS_BACKEND_GET_INTERFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_TLS_BACKEND, GTlsBackendInterface))
#define G_TLS_BACKEND_EXTENSION_POINT_NAME	"gio-tls-backend"

typedef struct _GTlsBackend GTlsBackend;
typedef struct _GTlsBackendInterface {
    GTypeInterface g_iface;
     gboolean(*supports_tls) (GTlsBackend * backend);
     GType(*get_certificate_type) (void);
     GType(*get_client_connection_type) (void);
     GType(*get_server_connection_type) (void);
     GType(*get_file_database_type) (void);
    GTlsDatabase *(*get_default_database) (GTlsBackend * backend);
} GTlsBackendInterface;
extern GType g_tls_backend_get_certificate_type(GTlsBackend * backend);
extern GType g_tls_backend_get_client_connection_type(GTlsBackend *
						      backend);
extern GTlsBackend *g_tls_backend_get_default(void);
extern GTlsDatabase *g_tls_backend_get_default_database(GTlsBackend *
							backend);
extern GType g_tls_backend_get_file_database_type(GTlsBackend * backend);
extern GType g_tls_backend_get_server_connection_type(GTlsBackend *
						      backend);
extern GType g_tls_backend_get_type(void);
extern gboolean g_tls_backend_supports_tls(GTlsBackend * backend);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41387"
>17.12.128. glib-2.0/gio/gtlscertificate.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_CERTIFICATE	(g_tls_certificate_get_type ())
#define G_TLS_CERTIFICATE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass))
#define G_IS_TLS_CERTIFICATE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_CERTIFICATE))
#define G_TLS_CERTIFICATE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CERTIFICATE, GTlsCertificate))
#define G_IS_TLS_CERTIFICATE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CERTIFICATE))
#define G_TLS_CERTIFICATE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass))

typedef struct _GTlsCertificateClass {
    GObjectClass parent_class;
     GTlsCertificateFlags(*verify) (GTlsCertificate * cert,
				    GSocketConnectable * identity,
				    GTlsCertificate * trusted_ca);
    gpointer padding[8];
} GTlsCertificateClass;
typedef struct _GTlsCertificatePrivate GTlsCertificatePrivate;
extern GTlsCertificate *g_tls_certificate_get_issuer(GTlsCertificate *
						     cert);
extern GType g_tls_certificate_get_type(void);
extern GList *g_tls_certificate_list_new_from_file(const gchar * file,
						   GError * *error);
extern GTlsCertificate *g_tls_certificate_new_from_file(const gchar * file,
							GError * *error);
extern GTlsCertificate *g_tls_certificate_new_from_files(const gchar *
							 cert_file,
							 const gchar *
							 key_file,
							 GError * *error);
extern GTlsCertificate *g_tls_certificate_new_from_pem(const gchar * data,
						       gssize length,
						       GError * *error);
extern GTlsCertificateFlags g_tls_certificate_verify(GTlsCertificate *
						     cert,
						     GSocketConnectable *
						     identity,
						     GTlsCertificate *
						     trusted_ca);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41391"
>17.12.129. glib-2.0/gio/gtlsclientconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_CLIENT_CONNECTION	(g_tls_client_connection_get_type ())
#define G_TLS_CLIENT_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnection))
#define G_IS_TLS_CLIENT_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CLIENT_CONNECTION))
#define G_TLS_CLIENT_CONNECTION_GET_INTERFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnectionInterface))

typedef struct _GTlsClientConnectionInterface {
    GTypeInterface g_iface;
} GTlsClientConnectionInterface;
extern GList *g_tls_client_connection_get_accepted_cas(GTlsClientConnection
						       * conn);
extern GSocketConnectable
    *g_tls_client_connection_get_server_identity(GTlsClientConnection *
						 conn);
extern GType g_tls_client_connection_get_type(void);
extern gboolean g_tls_client_connection_get_use_ssl3(GTlsClientConnection *
						     conn);
extern GTlsCertificateFlags
g_tls_client_connection_get_validation_flags(GTlsClientConnection * conn);
extern GIOStream *g_tls_client_connection_new(GIOStream * base_io_stream,
					      GSocketConnectable *
					      server_identity,
					      GError * *error);
extern void
g_tls_client_connection_set_server_identity(GTlsClientConnection * conn,
					    GSocketConnectable * identity);
extern void g_tls_client_connection_set_use_ssl3(GTlsClientConnection *
						 conn, gboolean use_ssl3);
extern void
g_tls_client_connection_set_validation_flags(GTlsClientConnection * conn,
					     GTlsCertificateFlags flags);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41395"
>17.12.130. glib-2.0/gio/gtlsconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_CONNECTION	(g_tls_connection_get_type ())
#define G_TLS_ERROR	(g_tls_error_quark ())
#define G_TLS_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_CONNECTION, GTlsConnectionClass))
#define G_IS_TLS_CONNECTION_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_CONNECTION))
#define G_TLS_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_CONNECTION, GTlsConnection))
#define G_IS_TLS_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_CONNECTION))
#define G_TLS_CONNECTION_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_CONNECTION, GTlsConnectionClass))

typedef struct _GTlsConnectionClass {
    GIOStreamClass parent_class;
     gboolean(*accept_certificate) (GTlsConnection * connection,
				    GTlsCertificate * peer_cert,
				    GTlsCertificateFlags errors);
     gboolean(*handshake) (GTlsConnection * conn,
			   GCancellable * cancellable, GError * *error);
    void (*handshake_async) (GTlsConnection * conn, int io_priority,
			     GCancellable * cancellable,
			     GAsyncReadyCallback callback,
			     gpointer user_data);
     gboolean(*handshake_finish) (GTlsConnection * conn,
				  GAsyncResult * result, GError * *error);
    gpointer padding[8];
} GTlsConnectionClass;
typedef struct _GTlsConnectionPrivate GTlsConnectionPrivate;
struct _GTlsConnection {
    GIOStream parent_instance;
    GTlsConnectionPrivate *priv;
};
extern gboolean g_tls_connection_emit_accept_certificate(GTlsConnection *
							 conn,
							 GTlsCertificate *
							 peer_cert,
							 GTlsCertificateFlags
							 errors);
extern GTlsCertificate *g_tls_connection_get_certificate(GTlsConnection *
							 conn);
extern GTlsDatabase *g_tls_connection_get_database(GTlsConnection * conn);
extern GTlsInteraction *g_tls_connection_get_interaction(GTlsConnection *
							 conn);
extern GTlsCertificate
    *g_tls_connection_get_peer_certificate(GTlsConnection * conn);
extern GTlsCertificateFlags
g_tls_connection_get_peer_certificate_errors(GTlsConnection * conn);
extern GTlsRehandshakeMode
g_tls_connection_get_rehandshake_mode(GTlsConnection * conn);
extern gboolean g_tls_connection_get_require_close_notify(GTlsConnection *
							  conn);
extern GType g_tls_connection_get_type(void);
extern gboolean g_tls_connection_get_use_system_certdb(GTlsConnection *
						       conn);
extern gboolean g_tls_connection_handshake(GTlsConnection * conn,
					   GCancellable * cancellable,
					   GError * *error);
extern void g_tls_connection_handshake_async(GTlsConnection * conn,
					     int io_priority,
					     GCancellable * cancellable,
					     GAsyncReadyCallback callback,
					     gpointer user_data);
extern gboolean g_tls_connection_handshake_finish(GTlsConnection * conn,
						  GAsyncResult * result,
						  GError * *error);
extern void g_tls_connection_set_certificate(GTlsConnection * conn,
					     GTlsCertificate *
					     certificate);
extern void g_tls_connection_set_database(GTlsConnection * conn,
					  GTlsDatabase * database);
extern void g_tls_connection_set_interaction(GTlsConnection * conn,
					     GTlsInteraction *
					     interaction);
extern void g_tls_connection_set_rehandshake_mode(GTlsConnection * conn,
						  GTlsRehandshakeMode
						  mode);
extern void g_tls_connection_set_require_close_notify(GTlsConnection *
						      conn,
						      gboolean
						      require_close_notify);
extern void g_tls_connection_set_use_system_certdb(GTlsConnection * conn,
						   gboolean
						   use_system_certdb);
extern GQuark g_tls_error_quark(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41399"
>17.12.131. glib-2.0/gio/gtlsdatabase.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_DATABASE	(g_tls_database_get_type ())
#define G_TLS_DATABASE_CLASS(class)	(G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TLS_DATABASE, GTlsDatabaseClass))
#define G_IS_TLS_DATABASE_CLASS(class)	(G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TLS_DATABASE))
#define G_TLS_DATABASE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_DATABASE, GTlsDatabase))
#define G_IS_TLS_DATABASE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_DATABASE))
#define G_TLS_DATABASE_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_CLASS ((inst), G_TYPE_TLS_DATABASE, GTlsDatabaseClass))
#define G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER	"1.3.6.1.5.5.7.3.1"
#define G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT	"1.3.6.1.5.5.7.3.2"

typedef struct _GTlsDatabaseClass {
    GObjectClass parent_class;
     GTlsCertificateFlags(*verify_chain) (GTlsDatabase * self,
					  GTlsCertificate * chain,
					  const gchar * purpose,
					  GSocketConnectable * identity,
					  GTlsInteraction * interaction,
					  GTlsDatabaseVerifyFlags flags,
					  GCancellable * cancellable,
					  GError * *error);
    void (*verify_chain_async) (GTlsDatabase * self,
				GTlsCertificate * chain,
				const gchar * purpose,
				GSocketConnectable * identity,
				GTlsInteraction * interaction,
				GTlsDatabaseVerifyFlags flags,
				GCancellable * cancellable,
				GAsyncReadyCallback callback,
				gpointer user_data);
     GTlsCertificateFlags(*verify_chain_finish) (GTlsDatabase * self,
						 GAsyncResult * result,
						 GError * *error);
    gchar *(*create_certificate_handle) (GTlsDatabase * self,
					 GTlsCertificate * certificate);
    GTlsCertificate *(*lookup_certificate_for_handle) (GTlsDatabase * self,
						       const gchar *
						       handle,
						       GTlsInteraction *
						       interaction,
						       GTlsDatabaseLookupFlags
						       flags,
						       GCancellable *
						       cancellable,
						       GError * *error);
    void (*lookup_certificate_for_handle_async) (GTlsDatabase * self,
						 const gchar * handle,
						 GTlsInteraction *
						 interaction,
						 GTlsDatabaseLookupFlags
						 flags,
						 GCancellable *
						 cancellable,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data);
    GTlsCertificate *(*lookup_certificate_for_handle_finish) (GTlsDatabase
							      * self,
							      GAsyncResult
							      * result,
							      GError *
							      *error);
    GTlsCertificate *(*lookup_certificate_issuer) (GTlsDatabase * self,
						   GTlsCertificate *
						   certificate,
						   GTlsInteraction *
						   interaction,
						   GTlsDatabaseLookupFlags
						   flags,
						   GCancellable *
						   cancellable,
						   GError * *error);
    void (*lookup_certificate_issuer_async) (GTlsDatabase * self,
					     GTlsCertificate * certificate,
					     GTlsInteraction * interaction,
					     GTlsDatabaseLookupFlags flags,
					     GCancellable * cancellable,
					     GAsyncReadyCallback callback,
					     gpointer user_data);
    GTlsCertificate *(*lookup_certificate_issuer_finish) (GTlsDatabase *
							  self,
							  GAsyncResult *
							  result,
							  GError * *error);
    GList *(*lookup_certificates_issued_by) (GTlsDatabase * self,
					     GByteArray * issuer_raw_dn,
					     GTlsInteraction * interaction,
					     GTlsDatabaseLookupFlags flags,
					     GCancellable * cancellable,
					     GError * *error);
    void (*lookup_certificates_issued_by_async) (GTlsDatabase * self,
						 GByteArray *
						 issuer_raw_dn,
						 GTlsInteraction *
						 interaction,
						 GTlsDatabaseLookupFlags
						 flags,
						 GCancellable *
						 cancellable,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data);
    GList *(*lookup_certificates_issued_by_finish) (GTlsDatabase * self,
						    GAsyncResult * result,
						    GError * *error);
    gpointer padding[16];
} GTlsDatabaseClass;
typedef struct _GTlsDatabasePrivate GTlsDatabasePrivate;
struct _GTlsDatabase {
    GObject parent_instance;
    GTlsDatabasePrivate *priv;
};
extern gchar *g_tls_database_create_certificate_handle(GTlsDatabase * self,
						       GTlsCertificate *
						       certificate);
extern GType g_tls_database_get_type(void);
extern GTlsCertificate
    *g_tls_database_lookup_certificate_for_handle(GTlsDatabase * self,
						  const gchar * handle,
						  GTlsInteraction *
						  interaction,
						  GTlsDatabaseLookupFlags
						  flags,
						  GCancellable *
						  cancellable,
						  GError * *error);
extern void g_tls_database_lookup_certificate_for_handle_async(GTlsDatabase
							       * self,
							       const gchar
							       * handle,
							       GTlsInteraction
							       *
							       interaction,
							       GTlsDatabaseLookupFlags
							       flags,
							       GCancellable
							       *
							       cancellable,
							       GAsyncReadyCallback
							       callback,
							       gpointer
							       user_data);
extern GTlsCertificate
    *g_tls_database_lookup_certificate_for_handle_finish(GTlsDatabase *
							 self,
							 GAsyncResult *
							 result,
							 GError * *error);
extern GTlsCertificate
    *g_tls_database_lookup_certificate_issuer(GTlsDatabase * self,
					      GTlsCertificate *
					      certificate,
					      GTlsInteraction *
					      interaction,
					      GTlsDatabaseLookupFlags
					      flags,
					      GCancellable * cancellable,
					      GError * *error);
extern void g_tls_database_lookup_certificate_issuer_async(GTlsDatabase *
							   self,
							   GTlsCertificate
							   * certificate,
							   GTlsInteraction
							   * interaction,
							   GTlsDatabaseLookupFlags
							   flags,
							   GCancellable *
							   cancellable,
							   GAsyncReadyCallback
							   callback,
							   gpointer
							   user_data);
extern GTlsCertificate
    *g_tls_database_lookup_certificate_issuer_finish(GTlsDatabase * self,
						     GAsyncResult * result,
						     GError * *error);
extern GList *g_tls_database_lookup_certificates_issued_by(GTlsDatabase *
							   self,
							   GByteArray *
							   issuer_raw_dn,
							   GTlsInteraction
							   * interaction,
							   GTlsDatabaseLookupFlags
							   flags,
							   GCancellable *
							   cancellable,
							   GError *
							   *error);
extern void g_tls_database_lookup_certificates_issued_by_async(GTlsDatabase
							       * self,
							       GByteArray *
							       issuer_raw_dn,
							       GTlsInteraction
							       *
							       interaction,
							       GTlsDatabaseLookupFlags
							       flags,
							       GCancellable
							       *
							       cancellable,
							       GAsyncReadyCallback
							       callback,
							       gpointer
							       user_data);
extern GList
    *g_tls_database_lookup_certificates_issued_by_finish(GTlsDatabase *
							 self,
							 GAsyncResult *
							 result,
							 GError * *error);
extern GTlsCertificateFlags g_tls_database_verify_chain(GTlsDatabase *
							self,
							GTlsCertificate *
							chain,
							const gchar *
							purpose,
							GSocketConnectable
							* identity,
							GTlsInteraction *
							interaction,
							GTlsDatabaseVerifyFlags
							flags,
							GCancellable *
							cancellable,
							GError * *error);
extern void g_tls_database_verify_chain_async(GTlsDatabase * self,
					      GTlsCertificate * chain,
					      const gchar * purpose,
					      GSocketConnectable *
					      identity,
					      GTlsInteraction *
					      interaction,
					      GTlsDatabaseVerifyFlags
					      flags,
					      GCancellable * cancellable,
					      GAsyncReadyCallback callback,
					      gpointer user_data);
extern GTlsCertificateFlags g_tls_database_verify_chain_finish(GTlsDatabase
							       * self,
							       GAsyncResult
							       * result,
							       GError *
							       *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41403"
>17.12.132. glib-2.0/gio/gtlsfiledatabase.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_FILE_DATABASE	(g_tls_file_database_get_type ())
#define G_TLS_FILE_DATABASE(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabase))
#define G_IS_TLS_FILE_DATABASE(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_FILE_DATABASE))
#define G_TLS_FILE_DATABASE_GET_INTERFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabaseInterface))

typedef struct _GTlsFileDatabaseInterface {
    GTypeInterface g_iface;
    gpointer padding[8];
} GTlsFileDatabaseInterface;
extern GType g_tls_file_database_get_type(void);
extern GTlsDatabase *g_tls_file_database_new(const gchar * anchors,
					     GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41407"
>17.12.133. glib-2.0/gio/gtlsinteraction.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_INTERACTION	(g_tls_interaction_get_type ())
#define G_TLS_INTERACTION_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TLS_INTERACTION, GTlsInteractionClass))
#define G_IS_TLS_INTERACTION_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TLS_INTERACTION))
#define G_TLS_INTERACTION(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TLS_INTERACTION, GTlsInteraction))
#define G_IS_TLS_INTERACTION(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TLS_INTERACTION))
#define G_TLS_INTERACTION_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TLS_INTERACTION, GTlsInteractionClass))

typedef struct _GTlsInteractionClass {
    GObjectClass parent_class;
     GTlsInteractionResult(*ask_password) (GTlsInteraction * interaction,
					   GTlsPassword * password,
					   GCancellable * cancellable,
					   GError * *error);
    void (*ask_password_async) (GTlsInteraction * interaction,
				GTlsPassword * password,
				GCancellable * cancellable,
				GAsyncReadyCallback callback,
				gpointer user_data);
     GTlsInteractionResult(*ask_password_finish) (GTlsInteraction *
						  interaction,
						  GAsyncResult * result,
						  GError * *error);
    gpointer padding[24];
} GTlsInteractionClass;
typedef struct _GTlsInteractionPrivate GTlsInteractionPrivate;
struct _GTlsInteraction {
    GObject parent_instance;
    GTlsInteractionPrivate *priv;
};
extern GTlsInteractionResult g_tls_interaction_ask_password(GTlsInteraction
							    * interaction,
							    GTlsPassword *
							    password,
							    GCancellable *
							    cancellable,
							    GError *
							    *error);
extern void g_tls_interaction_ask_password_async(GTlsInteraction *
						 interaction,
						 GTlsPassword * password,
						 GCancellable *
						 cancellable,
						 GAsyncReadyCallback
						 callback,
						 gpointer user_data);
extern GTlsInteractionResult
g_tls_interaction_ask_password_finish(GTlsInteraction * interaction,
				      GAsyncResult * result,
				      GError * *error);
extern GType g_tls_interaction_get_type(void);
extern GTlsInteractionResult
g_tls_interaction_invoke_ask_password(GTlsInteraction * interaction,
				      GTlsPassword * password,
				      GCancellable * cancellable,
				      GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41411"
>17.12.134. glib-2.0/gio/gtlspassword.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_PASSWORD	(g_tls_password_get_type ())
#define G_TLS_PASSWORD_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_TLS_PASSWORD, GTlsPasswordClass))
#define G_IS_TLS_PASSWORD_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_TLS_PASSWORD))
#define G_TLS_PASSWORD(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_TLS_PASSWORD, GTlsPassword))
#define G_IS_TLS_PASSWORD(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_TLS_PASSWORD))
#define G_TLS_PASSWORD_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_TLS_PASSWORD, GTlsPasswordClass))

typedef struct _GTlsPasswordClass {
    GObjectClass parent_class;
    const guchar *(*get_value) (GTlsPassword * password, gsize * length);
    void (*set_value) (GTlsPassword * password, guchar * value,
		       gssize length, GDestroyNotify destroy);
    const gchar *(*get_default_warning) (GTlsPassword * password);
    gpointer padding[4];
} GTlsPasswordClass;
typedef struct _GTlsPasswordPrivate GTlsPasswordPrivate;
struct _GTlsPassword {
    GObject parent_instance;
    GTlsPasswordPrivate *priv;
};
extern const char *g_tls_password_get_description(GTlsPassword * password);
extern GTlsPasswordFlags g_tls_password_get_flags(GTlsPassword * password);
extern GType g_tls_password_get_type(void);
extern const unsigned char *g_tls_password_get_value(GTlsPassword *
						     password,
						     gsize * length);
extern const char *g_tls_password_get_warning(GTlsPassword * password);
extern GTlsPassword *g_tls_password_new(GTlsPasswordFlags flags,
					const gchar * description);
extern void g_tls_password_set_description(GTlsPassword * password,
					   const gchar * description);
extern void g_tls_password_set_flags(GTlsPassword * password,
				     GTlsPasswordFlags flags);
extern void g_tls_password_set_value(GTlsPassword * password,
				     const guchar * value, gssize length);
extern void g_tls_password_set_value_full(GTlsPassword * password,
					  guchar * value, gssize length,
					  GDestroyNotify destroy);
extern void g_tls_password_set_warning(GTlsPassword * password,
				       const gchar * warning);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41415"
>17.12.135. glib-2.0/gio/gtlsserverconnection.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_TYPE_TLS_SERVER_CONNECTION	(g_tls_server_connection_get_type ())
#define G_TLS_SERVER_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnection))
#define G_IS_TLS_SERVER_CONNECTION(inst)	(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TLS_SERVER_CONNECTION))
#define G_TLS_SERVER_CONNECTION_GET_INTERFACE(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnectionInterface))

typedef struct _GTlsServerConnectionInterface {
    GTypeInterface g_iface;
} GTlsServerConnectionInterface;
extern GType g_tls_server_connection_get_type(void);
extern GIOStream *g_tls_server_connection_new(GIOStream * base_io_stream,
					      GTlsCertificate *
					      certificate,
					      GError * *error);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41419"
>17.12.136. glib-2.0/gio/gvfs.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_VFS_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_VFS, GVfsClass))
#define G_IS_VFS_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_VFS))
#define G_VFS(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_VFS, GVfs))
#define G_IS_VFS(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_VFS))
#define G_VFS_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_VFS, GVfsClass))
#define G_TYPE_VFS	(g_vfs_get_type ())
#define G_VFS_EXTENSION_POINT_NAME	"gio-vfs"

typedef struct _GVfsClass {
    GObjectClass parent_class;
     gboolean(*is_active) (GVfs * vfs);
    GFile *(*get_file_for_path) (GVfs * vfs, const char *path);
    GFile *(*get_file_for_uri) (GVfs * vfs, const char *uri);
    const gchar *const *(*get_supported_uri_schemes) (GVfs * vfs);
    GFile *(*parse_name) (GVfs * vfs, const char *parse_name);
    void (*local_file_add_info) (GVfs * vfs, const char *filename,
				 guint64 device,
				 GFileAttributeMatcher * attribute_matcher,
				 GFileInfo * info,
				 GCancellable * cancellable,
				 gpointer * extra_data,
				 GDestroyNotify * free_extra_data);
    void (*add_writable_namespaces) (GVfs * vfs,
				     GFileAttributeInfoList * list);
     gboolean(*local_file_set_attributes) (GVfs * vfs,
					   const char *filename,
					   GFileInfo * info,
					   GFileQueryInfoFlags flags,
					   GCancellable * cancellable,
					   GError * *error);
    void (*local_file_removed) (GVfs * vfs, const char *filename);
    void (*local_file_moved) (GVfs * vfs, const char *source,
			      const char *dest);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
    void (*_g_reserved7) (void);
} GVfsClass;
struct _GVfs {
    GObject parent_instance;
};
extern GVfs *g_vfs_get_default(void);
extern GFile *g_vfs_get_file_for_path(GVfs * vfs, const char *path);
extern GFile *g_vfs_get_file_for_uri(GVfs * vfs, const char *uri);
extern GVfs *g_vfs_get_local(void);
extern const char *const *g_vfs_get_supported_uri_schemes(GVfs * vfs);
extern GType g_vfs_get_type(void);
extern gboolean g_vfs_is_active(GVfs * vfs);
extern GFile *g_vfs_parse_name(GVfs * vfs, const char *parse_name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41423"
>17.12.137. glib-2.0/gio/gvolume.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_VOLUME(obj)	(G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_VOLUME, GVolume))
#define G_IS_VOLUME(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_VOLUME))
#define G_VOLUME_GET_IFACE(obj)	(G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_VOLUME, GVolumeIface))
#define G_TYPE_VOLUME	(g_volume_get_type ())
#define G_VOLUME_IDENTIFIER_KIND_CLASS	"class"
#define G_VOLUME_IDENTIFIER_KIND_HAL_UDI	"hal-udi"
#define G_VOLUME_IDENTIFIER_KIND_LABEL	"label"
#define G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT	"nfs-mount"
#define G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE	"unix-device"
#define G_VOLUME_IDENTIFIER_KIND_UUID	"uuid"

typedef struct _GVolumeIface {
    GTypeInterface g_iface;
    void (*changed) (GVolume * volume);
    void (*removed) (GVolume * volume);
    char *(*get_name) (GVolume * volume);
    GIcon *(*get_icon) (GVolume * volume);
    char *(*get_uuid) (GVolume * volume);
    GDrive *(*get_drive) (GVolume * volume);
    GMount *(*get_mount) (GVolume * volume);
     gboolean(*can_mount) (GVolume * volume);
     gboolean(*can_eject) (GVolume * volume);
    void (*mount_fn) (GVolume * volume, GMountMountFlags flags,
		      GMountOperation * mount_operation,
		      GCancellable * cancellable,
		      GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*mount_finish) (GVolume * volume, GAsyncResult * result,
			      GError * *error);
    void (*eject) (GVolume * volume, GMountUnmountFlags flags,
		   GCancellable * cancellable,
		   GAsyncReadyCallback callback, gpointer user_data);
     gboolean(*eject_finish) (GVolume * volume, GAsyncResult * result,
			      GError * *error);
    char *(*get_identifier) (GVolume * volume, const char *kind);
    char **(*enumerate_identifiers) (GVolume * volume);
     gboolean(*should_automount) (GVolume * volume);
    GFile *(*get_activation_root) (GVolume * volume);
    void (*eject_with_operation) (GVolume * volume,
				  GMountUnmountFlags flags,
				  GMountOperation * mount_operation,
				  GCancellable * cancellable,
				  GAsyncReadyCallback callback,
				  gpointer user_data);
     gboolean(*eject_with_operation_finish) (GVolume * volume,
					     GAsyncResult * result,
					     GError * *error);
    const char *(*get_sort_key) (GVolume * volume);
} GVolumeIface;
extern gboolean g_volume_can_eject(GVolume * volume);
extern gboolean g_volume_can_mount(GVolume * volume);
extern void g_volume_eject(GVolume * volume, GMountUnmountFlags flags,
			   GCancellable * cancellable,
			   GAsyncReadyCallback callback,
			   gpointer user_data);
extern gboolean g_volume_eject_finish(GVolume * volume,
				      GAsyncResult * result,
				      GError * *error);
extern void g_volume_eject_with_operation(GVolume * volume,
					  GMountUnmountFlags flags,
					  GMountOperation *
					  mount_operation,
					  GCancellable * cancellable,
					  GAsyncReadyCallback callback,
					  gpointer user_data);
extern gboolean g_volume_eject_with_operation_finish(GVolume * volume,
						     GAsyncResult * result,
						     GError * *error);
extern void g_volume_enumerate_identifiers(GVolume * volume);
extern GFile *g_volume_get_activation_root(GVolume * volume);
extern GDrive *g_volume_get_drive(GVolume * volume);
extern GIcon *g_volume_get_icon(GVolume * volume);
extern char *g_volume_get_identifier(GVolume * volume, const char *kind);
extern GMount *g_volume_get_mount(GVolume * volume);
extern char *g_volume_get_name(GVolume * volume);
extern const char *g_volume_get_sort_key(GVolume * volume);
extern GType g_volume_get_type(void);
extern char *g_volume_get_uuid(GVolume * volume);
extern void g_volume_mount(GVolume * volume, GMountMountFlags flags,
			   GMountOperation * mount_operation,
			   GCancellable * cancellable,
			   GAsyncReadyCallback callback,
			   gpointer user_data);
extern gboolean g_volume_mount_finish(GVolume * volume,
				      GAsyncResult * result,
				      GError * *error);
extern gboolean g_volume_should_automount(GVolume * volume);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41427"
>17.12.138. glib-2.0/gio/gvolumemonitor.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_VOLUME_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass))
#define G_IS_VOLUME_MONITOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_VOLUME_MONITOR))
#define G_VOLUME_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_VOLUME_MONITOR, GVolumeMonitor))
#define G_IS_VOLUME_MONITOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_VOLUME_MONITOR))
#define G_VOLUME_MONITOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass))
#define G_TYPE_VOLUME_MONITOR	(g_volume_monitor_get_type ())
#define G_VOLUME_MONITOR_EXTENSION_POINT_NAME	"gio-volume-monitor"

typedef struct _GVolumeMonitorClass {
    GObjectClass parent_class;
    void (*volume_added) (GVolumeMonitor * volume_monitor,
			  GVolume * volume);
    void (*volume_removed) (GVolumeMonitor * volume_monitor,
			    GVolume * volume);
    void (*volume_changed) (GVolumeMonitor * volume_monitor,
			    GVolume * volume);
    void (*mount_added) (GVolumeMonitor * volume_monitor, GMount * mount);
    void (*mount_removed) (GVolumeMonitor * volume_monitor,
			   GMount * mount);
    void (*mount_pre_unmount) (GVolumeMonitor * volume_monitor,
			       GMount * mount);
    void (*mount_changed) (GVolumeMonitor * volume_monitor,
			   GMount * mount);
    void (*drive_connected) (GVolumeMonitor * volume_monitor,
			     GDrive * drive);
    void (*drive_disconnected) (GVolumeMonitor * volume_monitor,
				GDrive * drive);
    void (*drive_changed) (GVolumeMonitor * volume_monitor,
			   GDrive * drive);
     gboolean(*is_supported) (void);
    GList *(*get_connected_drives) (GVolumeMonitor * volume_monitor);
    GList *(*get_volumes) (GVolumeMonitor * volume_monitor);
    GList *(*get_mounts) (GVolumeMonitor * volume_monitor);
    GVolume *(*get_volume_for_uuid) (GVolumeMonitor * volume_monitor,
				     const char *uuid);
    GMount *(*get_mount_for_uuid) (GVolumeMonitor * volume_monitor,
				   const char *uuid);
    GVolume *(*adopt_orphan_mount) (GMount * mount,
				    GVolumeMonitor * volume_monitor);
    void (*drive_eject_button) (GVolumeMonitor * volume_monitor,
				GDrive * drive);
    void (*drive_stop_button) (GVolumeMonitor * volume_monitor,
			       GDrive * drive);
    void (*_g_reserved1) (void);
    void (*_g_reserved2) (void);
    void (*_g_reserved3) (void);
    void (*_g_reserved4) (void);
    void (*_g_reserved5) (void);
    void (*_g_reserved6) (void);
} GVolumeMonitorClass;
struct _GVolumeMonitor {
    GObject parent_instance;
    gpointer priv;
};
extern GVolume *g_volume_monitor_adopt_orphan_mount(GMount * mount);
extern GVolumeMonitor *g_volume_monitor_get(void);
extern GList *g_volume_monitor_get_connected_drives(GVolumeMonitor *
						    volume_monitor);
extern GMount *g_volume_monitor_get_mount_for_uuid(GVolumeMonitor *
						   volume_monitor,
						   const char *uuid);
extern GList *g_volume_monitor_get_mounts(GVolumeMonitor * volume_monitor);
extern GType g_volume_monitor_get_type(void);
extern GVolume *g_volume_monitor_get_volume_for_uuid(GVolumeMonitor *
						     volume_monitor,
						     const char *uuid);
extern GList *g_volume_monitor_get_volumes(GVolumeMonitor *
					   volume_monitor);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41431"
>17.12.139. glib-2.0/gio/gzlibcompressor.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_ZLIB_COMPRESSOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass))
#define G_IS_ZLIB_COMPRESSOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_ZLIB_COMPRESSOR))
#define G_ZLIB_COMPRESSOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressor))
#define G_IS_ZLIB_COMPRESSOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_ZLIB_COMPRESSOR))
#define G_ZLIB_COMPRESSOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass))
#define G_TYPE_ZLIB_COMPRESSOR	(g_zlib_compressor_get_type ())

typedef struct _GZlibCompressorClass {
    GObjectClass parent_class;
} GZlibCompressorClass;
extern GFileInfo *g_zlib_compressor_get_file_info(GZlibCompressor *
						  compressor);
extern GType g_zlib_compressor_get_type(void);
extern GZlibCompressor *g_zlib_compressor_new(GZlibCompressorFormat format,
					      int level);
extern void g_zlib_compressor_set_file_info(GZlibCompressor * compressor,
					    GFileInfo * file_info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41435"
>17.12.140. glib-2.0/gio/gzlibdecompressor.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define G_ZLIB_DECOMPRESSOR_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass))
#define G_IS_ZLIB_DECOMPRESSOR_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_ZLIB_DECOMPRESSOR))
#define G_ZLIB_DECOMPRESSOR(o)	(G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressor))
#define G_IS_ZLIB_DECOMPRESSOR(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_ZLIB_DECOMPRESSOR))
#define G_ZLIB_DECOMPRESSOR_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass))
#define G_TYPE_ZLIB_DECOMPRESSOR	(g_zlib_decompressor_get_type ())

typedef struct _GZlibDecompressorClass {
    GObjectClass parent_class;
} GZlibDecompressorClass;
extern GFileInfo *g_zlib_decompressor_get_file_info(GZlibDecompressor *
						    decompressor);
extern GType g_zlib_decompressor_get_type(void);
extern GZlibDecompressor *g_zlib_decompressor_new(GZlibCompressorFormat
						  format);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libgio-2.0.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libgio-2.0man.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Interfaces for libgio-2.0</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="gtk.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Interface Definitions for libgio-2.0</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>