<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Linux Standard Base Core Specification, Generic Part</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Linux Standard Base Core Specification, Generic Part</A
></H1
><P
CLASS="EDITION"
>LSB Core - Generic 5.0&nbsp;Edition </P
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2015 Linux Foundation</P
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="LEGAL"
></A
><P
>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1;
with no Invariant Sections, with no Front-Cover Texts, and with no
Back-Cover Texts.  A copy of the license is included in the section
entitled "GNU Free Documentation License".</P
><P
></P
></DIV
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN10"
></A
><P
>Portions of the text may be copyrighted by the following parties:</P
><P
></P
><UL
><LI
><P
>The Regents of the University of California</P
></LI
><LI
><P
>Free Software Foundation</P
></LI
><LI
><P
>Ian F. Darwin</P
></LI
><LI
><P
>Paul Vixie</P
></LI
><LI
><P
>BSDI (now Wind River)</P
></LI
><LI
><P
>Jean-loup Gailly and Mark Adler</P
></LI
><LI
><P
>Massachusetts Institute of Technology</P
></LI
><LI
><P
>Apple Inc.</P
></LI
><LI
><P
>Easy Software Products</P
></LI
><LI
><P
>artofcode LLC</P
></LI
><LI
><P
>Till Kamppeter</P
></LI
><LI
><P
>Manfred Wassman</P
></LI
><LI
><P
>Python Software Foundation</P
></LI
></UL
><P
>These excerpts are being used in accordance
with their respective licenses.</P
><P
>Linux is the registered trademark of Linus
Torvalds in the U.S. and other countries.</P
><P
>UNIX is a registered trademark of The Open Group.</P
><P
>LSB is a trademark of the Linux Foundation in the United States and
other countries.</P
><P
>AMD is a trademark of Advanced Micro Devices, Inc.</P
><P
>Intel and Itanium are registered trademarks and Intel386
is a trademark of Intel Corporation.</P
><P
>PowerPC is a registered trademark and PowerPC Architecture is a
trademark of the IBM Corporation. </P
><P
>S/390 is a registered trademark of the IBM Corporation. </P
><P
>OpenGL is a registered trademark of Silicon Graphics, Inc.</P
><P
>PAM documentation is Copyright (C) Andrew G. Morgan 1996-9.  All
rights reserved.  Used under the following conditions:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Redistributions of source code must retain the above copyright
      notice, and the entire permission notice in its entirety,
      including the disclaimer of warranties.</P
></LI
><LI
><P
>Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.</P
></LI
><LI
><P
>The name of the author may not be used to endorse or promote
      products derived from this software without specific prior
      written permission.</P
></LI
></OL
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#OVERVIEW"
>Foreword</A
></DT
><DT
><A
HREF="#STATUS"
>Status of this Document</A
></DT
><DT
><A
HREF="#INTRO"
>Introduction</A
></DT
><DT
>I. <A
HREF="#TOCINTRO"
>Introductory Elements</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#SCOPE"
>Scope</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#GENSCOPE"
>General</A
></DT
><DT
>1.2. <A
HREF="#MODSCOPE"
>Module Specific Scope</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#NORMATIVEREFS"
>References</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#NORMATIVEREFSSECT"
>Normative References</A
></DT
><DT
>2.2. <A
HREF="#INFORMATIVEREFS"
>Informative References/Bibliography</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#REQUIREMENTS"
>Requirements</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#RLIBRARIES"
>Relevant Libraries</A
></DT
><DT
>3.2. <A
HREF="#IMPLEMENTATION"
>LSB Implementation Conformance</A
></DT
><DT
>3.3. <A
HREF="#APPLICATION"
>LSB Application Conformance</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#DEFS"
>Terms and Definitions</A
></DT
><DT
>5. <A
HREF="#DOCCONV"
>Documentation Conventions</A
></DT
><DT
>6. <A
HREF="#POSIXCONFLICTS"
>Relationship To ISO/IEC 9945 POSIX</A
></DT
><DT
>7. <A
HREF="#RELTOLF"
>Relationship To Other Linux Foundation Specifications</A
></DT
></DL
></DD
><DT
>II. <A
HREF="#ELF-GENERIC"
>Executable And Linking Format (ELF)</A
></DT
><DD
><DL
><DT
>8. <A
HREF="#ELFINTRO"
>Introduction</A
></DT
><DT
>9. <A
HREF="#LOWLEVEL"
>Low Level System Information</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#OSINTERFACE"
>Operating System Interface</A
></DT
><DT
>9.2. <A
HREF="#MACHINEINTERFACE"
>Machine Interface</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#TOCOBJFORMAT"
>Object Format</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#OBJFMT"
>Object Files</A
></DT
><DT
>10.2. <A
HREF="#SECTIONS"
>Sections</A
></DT
><DT
>10.3. <A
HREF="#SPECIALSECTIONS"
>Special Sections</A
></DT
><DT
>10.4. <A
HREF="#SYMMAP"
>Symbol Mapping</A
></DT
><DT
>10.5. <A
HREF="#DWARFEXT"
>DWARF Extensions</A
></DT
><DT
>10.6. <A
HREF="#EHFRAMECHPT"
>Exception Frames</A
></DT
><DT
>10.7. <A
HREF="#SYMVERSION"
>Symbol Versioning</A
></DT
><DT
>10.8. <A
HREF="#NOTEABITAG"
>ABI note tag</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#TOCDYNLNK"
>Dynamic Linking</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#DYNLNK"
>Program Loading and Dynamic Linking</A
></DT
><DT
>11.2. <A
HREF="#PROGHEADER"
>Program Header</A
></DT
><DT
>11.3. <A
HREF="#DYNAMICSECTION"
>Dynamic Entries</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#CXXCLASSES"
>C++ Class Representations</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#CXXDATAREPRESENTATION"
>C++ Data Representation</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#SYMMAP.CXX"
>Symbol Mapping</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#SYMMAPPING"
>Symbol Mapping</A
></DT
></DL
></DD
></DL
></DD
><DT
>III. <A
HREF="#TOCBASELIB"
>Base Libraries</A
></DT
><DD
><DL
><DT
>14. <A
HREF="#BASELIB"
>Base Libraries</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN2163"
>Introduction</A
></DT
><DT
>14.2. <A
HREF="#PROGINTERP"
>Program Interpreter</A
></DT
><DT
>14.3. <A
HREF="#LIBC"
>Interfaces for libc</A
></DT
><DT
>14.4. <A
HREF="#LIBC-DDEFS"
>Data Definitions for libc</A
></DT
><DT
>14.5. <A
HREF="#LIBCMAN"
>Interface Definitions for libc</A
></DT
><DT
>14.6. <A
HREF="#LIBM"
>Interfaces for libm</A
></DT
><DT
>14.7. <A
HREF="#LIBM-DDEFS"
>Data Definitions for libm</A
></DT
><DT
>14.8. <A
HREF="#LIBMMAN"
>Interface Definitions for libm</A
></DT
><DT
>14.9. <A
HREF="#LIBPTHREAD"
>Interfaces for libpthread</A
></DT
><DT
>14.10. <A
HREF="#LIBPTHREAD-DDEFS"
>Data Definitions for libpthread</A
></DT
><DT
>14.11. <A
HREF="#LIBPTHREADMAN"
>Interface Definitions for libpthread</A
></DT
><DT
>14.12. <A
HREF="#LIBGCC-S"
>Interfaces for libgcc_s</A
></DT
><DT
>14.13. <A
HREF="#LIBGCC-S-DDEFS"
>Data Definitions for libgcc_s</A
></DT
><DT
>14.14. <A
HREF="#LIBGCC-SMAN"
>Interface Definitions for libgcc_s</A
></DT
><DT
>14.15. <A
HREF="#LIBDL"
>Interfaces for libdl</A
></DT
><DT
>14.16. <A
HREF="#LIBDL-DDEFS"
>Data Definitions for libdl</A
></DT
><DT
>14.17. <A
HREF="#LIBDLMAN"
>Interface Definitions for libdl</A
></DT
><DT
>14.18. <A
HREF="#LIBRT"
>Interfaces for librt</A
></DT
><DT
>14.19. <A
HREF="#LIBRT-DDEFS"
>Data Definitions for librt</A
></DT
><DT
>14.20. <A
HREF="#LIBCRYPT"
>Interfaces for libcrypt</A
></DT
><DT
>14.21. <A
HREF="#LIBCRYPT-DDEFS"
>Data Definitions for libcrypt</A
></DT
><DT
>14.22. <A
HREF="#LIBCRYPTMAN"
>Interface Definitions for libcrypt</A
></DT
><DT
>14.23. <A
HREF="#LIBPAM"
>Interfaces for libpam</A
></DT
><DT
>14.24. <A
HREF="#LIBPAM-DDEFS"
>Data Definitions for libpam</A
></DT
><DT
>14.25. <A
HREF="#LIBPAMMAN"
>Interface Definitions for libpam</A
></DT
></DL
></DD
></DL
></DD
><DT
>IV. <A
HREF="#TOCUTILLIB"
>Utility Libraries</A
></DT
><DD
><DL
><DT
>15. <A
HREF="#UTILLIB"
>Utility Libraries</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#AEN28514"
>Introduction</A
></DT
><DT
>15.2. <A
HREF="#LIBZ"
>Interfaces for libz</A
></DT
><DT
>15.3. <A
HREF="#LIBZ-DDEFS"
>Data Definitions for libz</A
></DT
><DT
>15.4. <A
HREF="#LIBZMAN"
>Interface Definitions for libz</A
></DT
><DT
>15.5. <A
HREF="#LIBNCURSES"
>Interfaces for libncurses</A
></DT
><DT
>15.6. <A
HREF="#LIBNCURSES-DDEFS"
>Data Definitions for libncurses</A
></DT
><DT
>15.7. <A
HREF="#LIBNCURSESMAN"
>Interface Definitions for libncurses</A
></DT
><DT
>15.8. <A
HREF="#LIBNCURSESW"
>Interfaces for libncursesw</A
></DT
><DT
>15.9. <A
HREF="#LIBNCURSESW-DDEFS"
>Data Definitions for libncursesw</A
></DT
><DT
>15.10. <A
HREF="#LIBNCURSESWMAN"
>Interface Definitions for libncursesw</A
></DT
><DT
>15.11. <A
HREF="#LIBUTIL"
>Interfaces for libutil</A
></DT
><DT
>15.12. <A
HREF="#LIBUTIL-DDEFS"
>Data Definitions for libutil</A
></DT
><DT
>15.13. <A
HREF="#LIBUTILMAN"
>Interface Definitions for libutil</A
></DT
></DL
></DD
></DL
></DD
><DT
>V. <A
HREF="#CXXTOCBASELIB"
>C++ Libraries</A
></DT
><DD
><DL
><DT
>16. <A
HREF="#CXXBASELIB"
>Libraries</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#LIBSTDCXX"
>Interfaces for libstdcxx</A
></DT
><DT
>16.2. <A
HREF="#LIBSTDCXXMAN"
>Interface Definitions for libstdcxx</A
></DT
></DL
></DD
></DL
></DD
><DT
>VI. <A
HREF="#TOCCOMMAND"
>Commands and Utilities</A
></DT
><DD
><DL
><DT
>17. <A
HREF="#COMMAND"
>Commands and Utilities</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#CMDUTIL"
>Commands and Utilities</A
></DT
><DT
>17.2. <A
HREF="#CMDBEHAV"
>Command Behavior</A
></DT
></DL
></DD
></DL
></DD
><DT
>VII. <A
HREF="#TOCEXECENV"
>Execution Environment</A
></DT
><DD
><DL
><DT
>18. <A
HREF="#EXECENVFHS"
>File System Hierarchy</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#DEV"
><TT
CLASS="FILENAME"
>/dev</TT
>: Device Files</A
></DT
><DT
>18.2. <A
HREF="#ETC"
><TT
CLASS="FILENAME"
>/etc</TT
>: Host-specific system configuration</A
></DT
><DT
>18.3. <A
HREF="#FHS-USER-ACCOUNTING-DBS"
>User Accounting Databases</A
></DT
><DT
>18.4. <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
></DT
></DL
></DD
><DT
>19. <A
HREF="#EXECSTUFF"
>Additional Recommendations</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#PERMISSIONS-SHOULD"
>Recommendations for applications on ownership and permissions</A
></DT
></DL
></DD
><DT
>20. <A
HREF="#EXECENV-ADDNTL-BHVR"
>Additional Behaviors</A
></DT
><DD
><DL
><DT
>20.1. <A
HREF="#AEN61171"
>Mandatory Optional Behaviors</A
></DT
><DT
>20.2. <A
HREF="#EXEC-OPT-MANDATORY"
>Optional Mandatory Behaviors</A
></DT
><DT
>20.3. <A
HREF="#EXECUTABLE-SCRIPTS"
>Executable Scripts</A
></DT
></DL
></DD
><DT
>21. <A
HREF="#LOCALIZATION"
>Localization</A
></DT
><DD
><DL
><DT
>21.1. <A
HREF="#AEN61343"
>Introduction</A
></DT
><DT
>21.2. <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
></DT
><DT
>21.3. <A
HREF="#LOCALIZATION-GLOB"
>Pattern Matching Notation</A
></DT
></DL
></DD
></DL
></DD
><DT
>VIII. <A
HREF="#TOCSYSINIT"
>System Initialization</A
></DT
><DD
><DL
><DT
>22. <A
HREF="#SYSINIT"
>System Initialization</A
></DT
><DD
><DL
><DT
>22.1. <A
HREF="#CRONJOBS"
>Cron Jobs</A
></DT
><DT
>22.2. <A
HREF="#INISCRPTACT"
>Init Script Actions</A
></DT
><DT
>22.3. <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
></DT
><DT
>22.4. <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
></DT
><DT
>22.5. <A
HREF="#RUNLEVELS"
>Run Levels</A
></DT
><DT
>22.6. <A
HREF="#FACILNAME"
>Facility Names</A
></DT
><DT
>22.7. <A
HREF="#SCRPTNAMES"
>Script Names</A
></DT
><DT
>22.8. <A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
></DT
></DL
></DD
></DL
></DD
><DT
>IX. <A
HREF="#TOCUSERSGROUPS"
>Users &#38; Groups</A
></DT
><DD
><DL
><DT
>23. <A
HREF="#USERSGROUPS"
>Users &#38; Groups</A
></DT
><DD
><DL
><DT
>23.1. <A
HREF="#USERGRPDATABASE"
>User and Group Database</A
></DT
><DT
>23.2. <A
HREF="#USERNAMES"
>User &#38; Group Names</A
></DT
><DT
>23.3. <A
HREF="#UIDRANGE"
>User ID Ranges</A
></DT
><DT
>23.4. <A
HREF="#USERGRPRAT"
>Rationale</A
></DT
></DL
></DD
></DL
></DD
><DT
>X. <A
HREF="#TOCLIBNSS"
>Network Security Services</A
></DT
><DD
><DL
><DT
>24. <A
HREF="#NSSLIBS"
>Libraries</A
></DT
><DD
><DL
><DT
>24.1. <A
HREF="#LIBNSPR4"
>Interfaces for libnspr4</A
></DT
><DT
>24.2. <A
HREF="#LIBNSPR4-DDEFS"
>Data Definitions for libnspr4</A
></DT
><DT
>24.3. <A
HREF="#LIBNSS3"
>Interfaces for libnss3</A
></DT
><DT
>24.4. <A
HREF="#LIBNSS3-DDEFS"
>Data Definitions for libnss3</A
></DT
><DT
>24.5. <A
HREF="#LIBSSL3"
>Interfaces for libssl3</A
></DT
><DT
>24.6. <A
HREF="#LIBSSL3-DDEFS"
>Data Definitions for libssl3</A
></DT
></DL
></DD
></DL
></DD
><DT
>XI. <A
HREF="#PACKAGEFMT"
>Package Format and Installation</A
></DT
><DD
><DL
><DT
>25. <A
HREF="#SWINSTALL"
>Software Installation</A
></DT
><DD
><DL
><DT
>25.1. <A
HREF="#SWINSTALL-INTRO"
>Introduction</A
></DT
><DT
>25.2. <A
HREF="#PKGFORMAT"
>Package File Format</A
></DT
><DT
>25.3. <A
HREF="#PKGSCRIPTS"
>Package Script Restrictions</A
></DT
><DT
>25.4. <A
HREF="#PKGTOOLS"
>Package Tools</A
></DT
><DT
>25.5. <A
HREF="#PKGNAMECONV"
>Package Naming Conventions</A
></DT
><DT
>25.6. <A
HREF="#PKGDEPEND"
>Package Dependencies</A
></DT
><DT
>25.7. <A
HREF="#PKGARCHCON"
>Package Architecture Considerations</A
></DT
></DL
></DD
></DL
></DD
><DT
>A. <A
HREF="#APP-A"
>Alphabetical Listing of Interfaces by Library</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#APP-LIBC"
>libc</A
></DT
><DT
>A.2. <A
HREF="#APP-LIBCRYPT"
>libcrypt</A
></DT
><DT
>A.3. <A
HREF="#APP-LIBDL"
>libdl</A
></DT
><DT
>A.4. <A
HREF="#APP-LIBGCC-S"
>libgcc_s</A
></DT
><DT
>A.5. <A
HREF="#APP-LIBM"
>libm</A
></DT
><DT
>A.6. <A
HREF="#APP-LIBNCURSES"
>libncurses</A
></DT
><DT
>A.7. <A
HREF="#APP-LIBNCURSESW"
>libncursesw</A
></DT
><DT
>A.8. <A
HREF="#APP-LIBPAM"
>libpam</A
></DT
><DT
>A.9. <A
HREF="#APP-LIBPTHREAD"
>libpthread</A
></DT
><DT
>A.10. <A
HREF="#APP-LIBRT"
>librt</A
></DT
><DT
>A.11. <A
HREF="#APP-LIBUTIL"
>libutil</A
></DT
><DT
>A.12. <A
HREF="#APP-LIBZ"
>libz</A
></DT
><DT
>A.13. <A
HREF="#APP-LIBNSPR4"
>libnspr4</A
></DT
><DT
>A.14. <A
HREF="#APP-LIBNSS3"
>libnss3</A
></DT
><DT
>A.15. <A
HREF="#APP-LIBSSL3"
>libssl3</A
></DT
></DL
></DD
><DT
>B. <A
HREF="#GFDL"
>GNU Free Documentation License (Informative)</A
></DT
><DD
><DL
><DT
>B.1. <A
HREF="#GFDL-0"
>PREAMBLE</A
></DT
><DT
>B.2. <A
HREF="#GFDL-1"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>B.3. <A
HREF="#GFDL-2"
>VERBATIM COPYING</A
></DT
><DT
>B.4. <A
HREF="#GFDL-3"
>COPYING IN QUANTITY</A
></DT
><DT
>B.5. <A
HREF="#GFDL-4"
>MODIFICATIONS</A
></DT
><DT
>B.6. <A
HREF="#GFDL-5"
>COMBINING DOCUMENTS</A
></DT
><DT
>B.7. <A
HREF="#GFDL-6"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>B.8. <A
HREF="#GFDL-7"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>B.9. <A
HREF="#GFDL-8"
>TRANSLATION</A
></DT
><DT
>B.10. <A
HREF="#GFDL-9"
>TERMINATION</A
></DT
><DT
>B.11. <A
HREF="#GFDL-10"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>B.12. <A
HREF="#GFDL-11"
>How to use this License for your documents</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>10-1. <A
HREF="#VERDEFENTRIES"
>Version Definition Entries</A
></DT
><DT
>10-2. <A
HREF="#VERDEFEXTS"
>Version Definition Auxiliary Entries</A
></DT
><DT
>10-3. <A
HREF="#VERNEEDFIG"
>Version Needed Entries</A
></DT
><DT
>10-4. <A
HREF="#VERNEEDEXTFIG"
>Version Needed Auxiliary Entries</A
></DT
><DT
>11-1. <A
HREF="#AEN1789"
>Dynamic Structure</A
></DT
><DT
>12-1. <A
HREF="#CXX-VIRTUALTABLE-CAT1"
>Category 1 Virtual Table</A
></DT
><DT
>12-2. <A
HREF="#CXX-VIRTUALTABLE-CAT2"
>Category 2 Virtual Table</A
></DT
><DT
>12-3. <A
HREF="#CXX-RTTI"
>Run-Time Type Information Prefix</A
></DT
><DT
>12-4. <A
HREF="#CXX-RTTI-CLASS"
>Run-Time Type Information For Classes with no base class</A
></DT
><DT
>12-5. <A
HREF="#CXX-RTTI-SICLASS"
>Run-Time Type Information for Classes with a single base class</A
></DT
><DT
>12-6. <A
HREF="#CXX-RTTI-VMICLASS"
>Run-Time Type Information for classes with multiple inheritance</A
></DT
><DT
>12-7. <A
HREF="#CXX-RTTI-POINTERCLASS"
>Run-Time Type Information for pointer types</A
></DT
><DT
>12-8. <A
HREF="#CXX-RTTI-PTOMEMBERCLASS"
>Run-Time Type Information for pointer to member types</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>2-1. <A
HREF="#STD.BASE"
>Normative References</A
></DT
><DT
>2-2. <A
HREF="#AEN217"
>Other References</A
></DT
><DT
>3-1. <A
HREF="#TBL-GLSB-STDLIB"
>Standard Library Names</A
></DT
><DT
>3-2. <A
HREF="#TBL-LSBGENERIC-ARCHLIB"
>Standard Library Names defined in the Architecture Specific Parts of the LSB Core Specification</A
></DT
><DT
>9-1. <A
HREF="#AEN582"
>Scalar Types</A
></DT
><DT
>10-1. <A
HREF="#TBL.ABIUPDATE"
>ELF Section Types</A
></DT
><DT
>10-2. <A
HREF="#TBL.LSB"
>Additional Section Types</A
></DT
><DT
>10-3. <A
HREF="#AEN743"
>ELF Special Sections</A
></DT
><DT
>10-4. <A
HREF="#AEN956"
>Additional Special Sections</A
></DT
><DT
>10-5. <A
HREF="#AEN1101"
>DWARF Exception Header value format</A
></DT
><DT
>10-6. <A
HREF="#AEN1148"
>DWARF Exception Header application</A
></DT
><DT
>10-7. <A
HREF="#AEN1182"
>Additional DWARF Call Frame Instructions</A
></DT
><DT
>10-8. <A
HREF="#AEN1214"
>Call Frame Information Format</A
></DT
><DT
>10-9. <A
HREF="#AEN1224"
>Common Information Entry Format</A
></DT
><DT
>10-10. <A
HREF="#AEN1349"
>Frame Description Entry Format</A
></DT
><DT
>10-11. <A
HREF="#AEN1442"
><SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> Section Format</A
></DT
><DT
>11-1. <A
HREF="#AEN1749"
>Linux Segment Types</A
></DT
><DT
>12-1. <A
HREF="#TBL-CXX-CLASSREP"
>Class Components</A
></DT
><DT
>12-2. <A
HREF="#TBL-CXX-VTABLE"
>Primary vtable for K (example)</A
></DT
><DT
>14-1. <A
HREF="#LIB-LIBC-DEF"
>libc Definition</A
></DT
><DT
>14-2. <A
HREF="#TBL-LIBC-RPC-INTS"
>libc - RPC Function Interfaces</A
></DT
><DT
>14-3. <A
HREF="#TBL-LIBC-RPC-DEPINTS"
>libc - RPC Deprecated Function Interfaces</A
></DT
><DT
>14-4. <A
HREF="#TBL-LIBC-EPOLL-INTS"
>libc - Epoll Function Interfaces</A
></DT
><DT
>14-5. <A
HREF="#TBL-LIBC-SYSTE-INTS"
>libc - System Calls Function Interfaces</A
></DT
><DT
>14-6. <A
HREF="#TBL-LIBC-SYSTE-DEPINTS"
>libc - System Calls Deprecated Function Interfaces</A
></DT
><DT
>14-7. <A
HREF="#TBL-LIBC-STAND-INTS"
>libc - Standard I/O Function Interfaces</A
></DT
><DT
>14-8. <A
HREF="#TBL-LIBC-STAND-DEPINTS"
>libc - Standard I/O Deprecated Function Interfaces</A
></DT
><DT
>14-9. <A
HREF="#TBL-LIBC-STAND-DATA"
>libc - Standard I/O Data Interfaces</A
></DT
><DT
>14-10. <A
HREF="#TBL-LIBC-SIGNA-INTS"
>libc - Signal Handling Function Interfaces</A
></DT
><DT
>14-11. <A
HREF="#TBL-LIBC-SIGNA-DEPINTS"
>libc - Signal Handling Deprecated Function Interfaces</A
></DT
><DT
>14-12. <A
HREF="#TBL-LIBC-SIGNA-DATA"
>libc - Signal Handling Data Interfaces</A
></DT
><DT
>14-13. <A
HREF="#TBL-LIBC-LOCAL-INTS"
>libc - Localization Functions Function Interfaces</A
></DT
><DT
>14-14. <A
HREF="#TBL-LIBC-LOCAL-DATA"
>libc - Localization Functions Data Interfaces</A
></DT
><DT
>14-15. <A
HREF="#TBL-LIBC-POSIX-INTS"
>libc - Posix Spawn Option Function Interfaces</A
></DT
><DT
>14-16. <A
HREF="#TBL-LIBC-POSIY-INTS"
>libc - Posix Advisory Option Function Interfaces</A
></DT
><DT
>14-17. <A
HREF="#TBL-LIBC-SOCKE-INTS"
>libc - Socket Interface Function Interfaces</A
></DT
><DT
>14-18. <A
HREF="#TBL-LIBC-SOCKE-DATA"
>libc - Socket Interface Data Interfaces</A
></DT
><DT
>14-19. <A
HREF="#TBL-LIBC-WIDE-INTS"
>libc - Wide Characters Function Interfaces</A
></DT
><DT
>14-20. <A
HREF="#TBL-LIBC-STRIN-INTS"
>libc - String Functions Function Interfaces</A
></DT
><DT
>14-21. <A
HREF="#TBL-LIBC-STRIN-DEPINTS"
>libc - String Functions Deprecated Function Interfaces</A
></DT
><DT
>14-22. <A
HREF="#TBL-LIBC-IPC-F-INTS"
>libc - IPC Functions Function Interfaces</A
></DT
><DT
>14-23. <A
HREF="#TBL-LIBC-REGUL-INTS"
>libc - Regular Expressions Function Interfaces</A
></DT
><DT
>14-24. <A
HREF="#TBL-LIBC-CHARA-INTS"
>libc - Character Type Functions Function Interfaces</A
></DT
><DT
>14-25. <A
HREF="#TBL-LIBC-TIME-INTS"
>libc - Time Manipulation Function Interfaces</A
></DT
><DT
>14-26. <A
HREF="#TBL-LIBC-TIME-DATA"
>libc - Time Manipulation Data Interfaces</A
></DT
><DT
>14-27. <A
HREF="#TBL-LIBC-TERMI-INTS"
>libc - Terminal Interface Functions Function Interfaces</A
></DT
><DT
>14-28. <A
HREF="#TBL-LIBC-SYSTF-INTS"
>libc - System Database Interface Function Interfaces</A
></DT
><DT
>14-29. <A
HREF="#TBL-LIBC-SYSTF-DEPINTS"
>libc - System Database Interface Deprecated Function Interfaces</A
></DT
><DT
>14-30. <A
HREF="#TBL-LIBC-LANGU-INTS"
>libc - Language Support Function Interfaces</A
></DT
><DT
>14-31. <A
HREF="#TBL-LIBC-LARGE-INTS"
>libc - Large File Support Function Interfaces</A
></DT
><DT
>14-32. <A
HREF="#TBL-LIBC-LARGE-DEPINTS"
>libc - Large File Support Deprecated Function Interfaces</A
></DT
><DT
>14-33. <A
HREF="#TBL-LIBC-INOTI-INTS"
>libc - Inotify Function Interfaces</A
></DT
><DT
>14-34. <A
HREF="#TBL-LIBC-STANE-INTS"
>libc - Standard Library Function Interfaces</A
></DT
><DT
>14-35. <A
HREF="#TBL-LIBC-STANE-DEPINTS"
>libc - Standard Library Deprecated Function Interfaces</A
></DT
><DT
>14-36. <A
HREF="#TBL-LIBC-STANE-DATA"
>libc - Standard Library Data Interfaces</A
></DT
><DT
>14-37. <A
HREF="#TBL-LIBC-GNU-E-INTS"
>libc - GNU Extensions for libc Function Interfaces</A
></DT
><DT
>14-38. <A
HREF="#LIB-LIBM-DEF"
>libm Definition</A
></DT
><DT
>14-39. <A
HREF="#TBL-LIBM-MATH-INTS"
>libm - Math Function Interfaces</A
></DT
><DT
>14-40. <A
HREF="#TBL-LIBM-MATH-DEPINTS"
>libm - Math Deprecated Function Interfaces</A
></DT
><DT
>14-41. <A
HREF="#TBL-LIBM-MATH-DATA"
>libm - Math Data Interfaces</A
></DT
><DT
>14-42. <A
HREF="#LIB-LIBPTHREAD-DEF"
>libpthread Definition</A
></DT
><DT
>14-43. <A
HREF="#TBL-LIBPTHREAD-REALT-INTS"
>libpthread - Realtime Threads Function Interfaces</A
></DT
><DT
>14-44. <A
HREF="#TBL-LIBPTHREAD-ADVAN-INTS"
>libpthread - Advanced Realtime Threads Function Interfaces</A
></DT
><DT
>14-45. <A
HREF="#TBL-LIBPTHREAD-POSIX-INTS"
>libpthread - Posix Threads Function Interfaces</A
></DT
><DT
>14-46. <A
HREF="#TBL-LIBPTHREAD-POSIX-DEPINTS"
>libpthread - Posix Threads Deprecated Function Interfaces</A
></DT
><DT
>14-47. <A
HREF="#TBL-LIBPTHREAD-THREA-INTS"
>libpthread - Thread aware versions of libc interfaces Function Interfaces</A
></DT
><DT
>14-48. <A
HREF="#TBL-LIBPTHREAD-GNU-E-INTS"
>libpthread - GNU Extensions for libpthread Function Interfaces</A
></DT
><DT
>14-49. <A
HREF="#TBL-LIBPTHREAD-SYSTE-INTS"
>libpthread - System Calls Function Interfaces</A
></DT
><DT
>14-50. <A
HREF="#TBL-LIBPTHREAD-STAND-INTS"
>libpthread - Standard I/O Function Interfaces</A
></DT
><DT
>14-51. <A
HREF="#TBL-LIBPTHREAD-SIGNA-INTS"
>libpthread - Signal Handling Function Interfaces</A
></DT
><DT
>14-52. <A
HREF="#TBL-LIBPTHREAD-STANE-INTS"
>libpthread - Standard Library Function Interfaces</A
></DT
><DT
>14-53. <A
HREF="#TBL-LIBPTHREAD-SOCKE-INTS"
>libpthread - Socket Interface Function Interfaces</A
></DT
><DT
>14-54. <A
HREF="#TBL-LIBPTHREAD-TERMI-INTS"
>libpthread - Terminal Interface Functions Function Interfaces</A
></DT
><DT
>14-55. <A
HREF="#LIB-LIBGCC-S-DEF"
>libgcc_s Definition</A
></DT
><DT
>14-56. <A
HREF="#TBL-LIBGCC-S-UNWIN-INTS"
>libgcc_s - Unwind Library Function Interfaces</A
></DT
><DT
>14-57. <A
HREF="#LIB-LIBDL-DEF"
>libdl Definition</A
></DT
><DT
>14-58. <A
HREF="#TBL-LIBDL-DYNAM-INTS"
>libdl - Dynamic Loader Function Interfaces</A
></DT
><DT
>14-59. <A
HREF="#LIB-LIBRT-DEF"
>librt Definition</A
></DT
><DT
>14-60. <A
HREF="#TBL-LIBRT-SHARE-INTS"
>librt - Shared Memory Objects Function Interfaces</A
></DT
><DT
>14-61. <A
HREF="#TBL-LIBRT-ASYNC-INTS"
>librt - Asynchronous I/O Function Interfaces</A
></DT
><DT
>14-62. <A
HREF="#TBL-LIBRT-CLOCK-INTS"
>librt - Clock Function Interfaces</A
></DT
><DT
>14-63. <A
HREF="#TBL-LIBRT-TIMER-INTS"
>librt - Timers Function Interfaces</A
></DT
><DT
>14-64. <A
HREF="#TBL-LIBRT-MESSA-INTS"
>librt - Message Queues Function Interfaces</A
></DT
><DT
>14-65. <A
HREF="#LIB-LIBCRYPT-DEF"
>libcrypt Definition</A
></DT
><DT
>14-66. <A
HREF="#TBL-LIBCRYPT-ENCRY-INTS"
>libcrypt - Encryption Function Interfaces</A
></DT
><DT
>14-67. <A
HREF="#LIB-LIBPAM-DEF"
>libpam Definition</A
></DT
><DT
>14-68. <A
HREF="#TBL-LIBPAM-PLUGG-INTS"
>libpam - Pluggable Authentication API Function Interfaces</A
></DT
><DT
>15-1. <A
HREF="#LIB-LIBZ-DEF"
>libz Definition</A
></DT
><DT
>15-2. <A
HREF="#TBL-LIBZ-COMPR-INTS"
>libz - Compression Library Function Interfaces</A
></DT
><DT
>15-3. <A
HREF="#LIB-LIBNCURSES-DEF"
>libncurses Definition</A
></DT
><DT
>15-4. <A
HREF="#TBL-LIBNCURSES-CURSE-INTS"
>libncurses - Curses Function Interfaces</A
></DT
><DT
>15-5. <A
HREF="#TBL-LIBNCURSES-CURSE-DEPINTS"
>libncurses - Curses Deprecated Function Interfaces</A
></DT
><DT
>15-6. <A
HREF="#TBL-LIBNCURSES-CURSE-DATA"
>libncurses - Curses Data Interfaces</A
></DT
><DT
>15-7. <A
HREF="#LIB-LIBNCURSESW-DEF"
>libncursesw Definition</A
></DT
><DT
>15-8. <A
HREF="#TBL-LIBNCURSESW-CURSE-INTS"
>libncursesw - Curses Wide Function Interfaces</A
></DT
><DT
>15-9. <A
HREF="#TBL-LIBNCURSESW-CURSE-DEPINTS"
>libncursesw - Curses Wide Deprecated Function Interfaces</A
></DT
><DT
>15-10. <A
HREF="#TBL-LIBNCURSESW-CURSE-DATA"
>libncursesw - Curses Wide Data Interfaces</A
></DT
><DT
>15-11. <A
HREF="#LIB-LIBUTIL-DEF"
>libutil Definition</A
></DT
><DT
>15-12. <A
HREF="#TBL-LIBUTIL-UTILI-INTS"
>libutil - Utility Functions Function Interfaces</A
></DT
><DT
>16-1. <A
HREF="#LIB-LIBSTDCXX-DEF"
>libstdcxx Definition</A
></DT
><DT
>16-2. <A
HREF="#TBL-LIBSTDCXX-C-R-INTS"
>libstdcxx - C++ Runtime Support Function Interfaces</A
></DT
><DT
>16-3. <A
HREF="#TBL-LIBSTDCXX-C-R-DATA"
>libstdcxx - C++ Runtime Support Data Interfaces</A
></DT
><DT
>16-4. <A
HREF="#TBL-LIBSTDCXX-C-T-DATA"
>libstdcxx - C++ type descriptors for built-in types Data Interfaces</A
></DT
><DT
>16-5. <A
HREF="#TBL-LIBSTDCXX-C-INTS"
>libstdcxx - C++ _Rb_tree Function Interfaces</A
></DT
><DT
>16-6. <A
HREF="#CLS-24325-0"
>Primary vtable for type_info</A
></DT
><DT
>16-7. <A
HREF="#RTTI-24030"
>typeinfo for type_info</A
></DT
><DT
>16-8. <A
HREF="#TBL-LIBSTDCXX-CLASS-INTS"
>libstdcxx - Class type_info Function Interfaces</A
></DT
><DT
>16-9. <A
HREF="#TBL-LIBSTDCXX-CLASS-DATA"
>libstdcxx - Class type_info Data Interfaces</A
></DT
><DT
>16-10. <A
HREF="#CLS-24328-0"
>Primary vtable for __cxxabiv1::__enum_type_info</A
></DT
><DT
>16-11. <A
HREF="#RTTI-24099"
>typeinfo for __cxxabiv1::__enum_type_info</A
></DT
><DT
>16-12. <A
HREF="#TBL-LIBSTDCXX-CLAST-INTS"
>libstdcxx - Class __cxxabiv1::__enum_type_info Function Interfaces</A
></DT
><DT
>16-13. <A
HREF="#TBL-LIBSTDCXX-CLAST-DATA"
>libstdcxx - Class __cxxabiv1::__enum_type_info Data Interfaces</A
></DT
><DT
>16-14. <A
HREF="#CLS-24330-0"
>Primary vtable for __cxxabiv1::__array_type_info</A
></DT
><DT
>16-15. <A
HREF="#RTTI-24101"
>typeinfo for __cxxabiv1::__array_type_info</A
></DT
><DT
>16-16. <A
HREF="#TBL-LIBSTDCXX-CLASU-INTS"
>libstdcxx - Class __cxxabiv1::__array_type_info Function Interfaces</A
></DT
><DT
>16-17. <A
HREF="#TBL-LIBSTDCXX-CLASU-DATA"
>libstdcxx - Class __cxxabiv1::__array_type_info Data Interfaces</A
></DT
><DT
>16-18. <A
HREF="#CLS-23981-0"
>Primary vtable for __cxxabiv1::__class_type_info</A
></DT
><DT
>16-19. <A
HREF="#RTTI-24031"
>typeinfo for __cxxabiv1::__class_type_info</A
></DT
><DT
>16-20. <A
HREF="#TBL-LIBSTDCXX-CLASV-INTS"
>libstdcxx - Class __cxxabiv1::__class_type_info Function Interfaces</A
></DT
><DT
>16-21. <A
HREF="#TBL-LIBSTDCXX-CLASV-DATA"
>libstdcxx - Class __cxxabiv1::__class_type_info Data Interfaces</A
></DT
><DT
>16-22. <A
HREF="#CLS-24327-0"
>Primary vtable for __cxxabiv1::__pbase_type_info</A
></DT
><DT
>16-23. <A
HREF="#RTTI-24032"
>typeinfo for __cxxabiv1::__pbase_type_info</A
></DT
><DT
>16-24. <A
HREF="#TBL-LIBSTDCXX-CLASW-INTS"
>libstdcxx - Class __cxxabiv1::__pbase_type_info Function Interfaces</A
></DT
><DT
>16-25. <A
HREF="#TBL-LIBSTDCXX-CLASW-DATA"
>libstdcxx - Class __cxxabiv1::__pbase_type_info Data Interfaces</A
></DT
><DT
>16-26. <A
HREF="#CLS-23983-0"
>Primary vtable for __cxxabiv1::__pointer_type_info</A
></DT
><DT
>16-27. <A
HREF="#RTTI-24098"
>typeinfo for __cxxabiv1::__pointer_type_info</A
></DT
><DT
>16-28. <A
HREF="#TBL-LIBSTDCXX-CLASX-INTS"
>libstdcxx - Class __cxxabiv1::__pointer_type_info Function Interfaces</A
></DT
><DT
>16-29. <A
HREF="#TBL-LIBSTDCXX-CLASX-DATA"
>libstdcxx - Class __cxxabiv1::__pointer_type_info Data Interfaces</A
></DT
><DT
>16-30. <A
HREF="#CLS-24329-0"
>Primary vtable for __cxxabiv1::__function_type_info</A
></DT
><DT
>16-31. <A
HREF="#RTTI-24100"
>typeinfo for __cxxabiv1::__function_type_info</A
></DT
><DT
>16-32. <A
HREF="#TBL-LIBSTDCXX-CLASY-INTS"
>libstdcxx - Class __cxxabiv1::__function_type_info Function Interfaces</A
></DT
><DT
>16-33. <A
HREF="#TBL-LIBSTDCXX-CLASY-DATA"
>libstdcxx - Class __cxxabiv1::__function_type_info Data Interfaces</A
></DT
><DT
>16-34. <A
HREF="#CLS-23979-0"
>Primary vtable for __cxxabiv1::__si_class_type_info</A
></DT
><DT
>16-35. <A
HREF="#RTTI-24094"
>typeinfo for __cxxabiv1::__si_class_type_info</A
></DT
><DT
>16-36. <A
HREF="#TBL-LIBSTDCXX-CLASZ-INTS"
>libstdcxx - Class __cxxabiv1::__si_class_type_info Function Interfaces</A
></DT
><DT
>16-37. <A
HREF="#TBL-LIBSTDCXX-CLASZ-DATA"
>libstdcxx - Class __cxxabiv1::__si_class_type_info Data Interfaces</A
></DT
><DT
>16-38. <A
HREF="#CLS-23980-0"
>Primary vtable for __cxxabiv1::__vmi_class_type_info</A
></DT
><DT
>16-39. <A
HREF="#RTTI-24093"
>typeinfo for __cxxabiv1::__vmi_class_type_info</A
></DT
><DT
>16-40. <A
HREF="#TBL-LIBSTDCXX-CLATA-INTS"
>libstdcxx - Class __cxxabiv1::__vmi_class_type_info Function Interfaces</A
></DT
><DT
>16-41. <A
HREF="#TBL-LIBSTDCXX-CLATA-DATA"
>libstdcxx - Class __cxxabiv1::__vmi_class_type_info Data Interfaces</A
></DT
><DT
>16-42. <A
HREF="#CLS-23982-0"
>Primary vtable for __cxxabiv1::__fundamental_type_info</A
></DT
><DT
>16-43. <A
HREF="#RTTI-24102"
>typeinfo for __cxxabiv1::__fundamental_type_info</A
></DT
><DT
>16-44. <A
HREF="#TBL-LIBSTDCXX-CLATB-INTS"
>libstdcxx - Class __cxxabiv1::__fundamental_type_info Function Interfaces</A
></DT
><DT
>16-45. <A
HREF="#TBL-LIBSTDCXX-CLATB-DATA"
>libstdcxx - Class __cxxabiv1::__fundamental_type_info Data Interfaces</A
></DT
><DT
>16-46. <A
HREF="#CLS-24326-0"
>Primary vtable for __cxxabiv1::__pointer_to_member_type_info</A
></DT
><DT
>16-47. <A
HREF="#RTTI-24097"
>typeinfo for __cxxabiv1::__pointer_to_member_type_info</A
></DT
><DT
>16-48. <A
HREF="#TBL-LIBSTDCXX-CLATC-INTS"
>libstdcxx - Class __cxxabiv1::__pointer_to_member_type_info Function Interfaces</A
></DT
><DT
>16-49. <A
HREF="#TBL-LIBSTDCXX-CLATC-DATA"
>libstdcxx - Class __cxxabiv1::__pointer_to_member_type_info Data Interfaces</A
></DT
><DT
>16-50. <A
HREF="#TBL-LIBSTDCXX-CLATD-DATA"
>libstdcxx - Class __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-51. <A
HREF="#TBL-LIBSTDCXX-CLATE-DATA"
>libstdcxx - Class __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-52. <A
HREF="#TBL-LIBSTDCXX-CLATF-INTS"
>libstdcxx - Class __gnu_cxx::__pool_alloc_base Function Interfaces</A
></DT
><DT
>16-53. <A
HREF="#CLS-29351-0"
>Primary vtable for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-54. <A
HREF="#TBL-LIBSTDCXX-CLATG-INTS"
>libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-55. <A
HREF="#TBL-LIBSTDCXX-CLATG-DATA"
>libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-56. <A
HREF="#CLS-29211-0"
>Primary vtable for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-57. <A
HREF="#TBL-LIBSTDCXX-CLATH-INTS"
>libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-58. <A
HREF="#TBL-LIBSTDCXX-CLATH-DATA"
>libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-59. <A
HREF="#CLS-24321-0"
>Primary vtable for exception</A
></DT
><DT
>16-60. <A
HREF="#RTTI-24002"
>typeinfo for exception</A
></DT
><DT
>16-61. <A
HREF="#TBL-LIBSTDCXX-CLATI-INTS"
>libstdcxx - Class exception Function Interfaces</A
></DT
><DT
>16-62. <A
HREF="#TBL-LIBSTDCXX-CLATI-DATA"
>libstdcxx - Class exception Data Interfaces</A
></DT
><DT
>16-63. <A
HREF="#CLS-24323-0"
>Primary vtable for bad_typeid</A
></DT
><DT
>16-64. <A
HREF="#RTTI-24095"
>typeinfo for bad_typeid</A
></DT
><DT
>16-65. <A
HREF="#TBL-LIBSTDCXX-CLATJ-INTS"
>libstdcxx - Class bad_typeid Function Interfaces</A
></DT
><DT
>16-66. <A
HREF="#TBL-LIBSTDCXX-CLATJ-DATA"
>libstdcxx - Class bad_typeid Data Interfaces</A
></DT
><DT
>16-67. <A
HREF="#CLS-24313-0"
>Primary vtable for logic_error</A
></DT
><DT
>16-68. <A
HREF="#RTTI-23998"
>typeinfo for logic_error</A
></DT
><DT
>16-69. <A
HREF="#TBL-LIBSTDCXX-CLATK-INTS"
>libstdcxx - Class logic_error Function Interfaces</A
></DT
><DT
>16-70. <A
HREF="#TBL-LIBSTDCXX-CLATK-DATA"
>libstdcxx - Class logic_error Data Interfaces</A
></DT
><DT
>16-71. <A
HREF="#CLS-24243-0"
>Primary vtable for range_error</A
></DT
><DT
>16-72. <A
HREF="#RTTI-24054"
>typeinfo for range_error</A
></DT
><DT
>16-73. <A
HREF="#TBL-LIBSTDCXX-CLATL-INTS"
>libstdcxx - Class range_error Function Interfaces</A
></DT
><DT
>16-74. <A
HREF="#TBL-LIBSTDCXX-CLATL-DATA"
>libstdcxx - Class range_error Data Interfaces</A
></DT
><DT
>16-75. <A
HREF="#CLS-24247-0"
>Primary vtable for domain_error</A
></DT
><DT
>16-76. <A
HREF="#RTTI-24058"
>typeinfo for domain_error</A
></DT
><DT
>16-77. <A
HREF="#TBL-LIBSTDCXX-CLATM-INTS"
>libstdcxx - Class domain_error Function Interfaces</A
></DT
><DT
>16-78. <A
HREF="#TBL-LIBSTDCXX-CLATM-DATA"
>libstdcxx - Class domain_error Data Interfaces</A
></DT
><DT
>16-79. <A
HREF="#CLS-24245-0"
>Primary vtable for length_error</A
></DT
><DT
>16-80. <A
HREF="#RTTI-24056"
>typeinfo for length_error</A
></DT
><DT
>16-81. <A
HREF="#TBL-LIBSTDCXX-CLATN-INTS"
>libstdcxx - Class length_error Function Interfaces</A
></DT
><DT
>16-82. <A
HREF="#TBL-LIBSTDCXX-CLATN-DATA"
>libstdcxx - Class length_error Data Interfaces</A
></DT
><DT
>16-83. <A
HREF="#CLS-24244-0"
>Primary vtable for out_of_range</A
></DT
><DT
>16-84. <A
HREF="#RTTI-24055"
>typeinfo for out_of_range</A
></DT
><DT
>16-85. <A
HREF="#TBL-LIBSTDCXX-CLATO-INTS"
>libstdcxx - Class out_of_range Function Interfaces</A
></DT
><DT
>16-86. <A
HREF="#TBL-LIBSTDCXX-CLATO-DATA"
>libstdcxx - Class out_of_range Data Interfaces</A
></DT
><DT
>16-87. <A
HREF="#CLS-24320-0"
>Primary vtable for bad_exception</A
></DT
><DT
>16-88. <A
HREF="#RTTI-24091"
>typeinfo for bad_exception</A
></DT
><DT
>16-89. <A
HREF="#TBL-LIBSTDCXX-CLATP-INTS"
>libstdcxx - Class bad_exception Function Interfaces</A
></DT
><DT
>16-90. <A
HREF="#TBL-LIBSTDCXX-CLATP-DATA"
>libstdcxx - Class bad_exception Data Interfaces</A
></DT
><DT
>16-91. <A
HREF="#CLS-24312-0"
>Primary vtable for runtime_error</A
></DT
><DT
>16-92. <A
HREF="#RTTI-23999"
>typeinfo for runtime_error</A
></DT
><DT
>16-93. <A
HREF="#TBL-LIBSTDCXX-CLATQ-INTS"
>libstdcxx - Class runtime_error Function Interfaces</A
></DT
><DT
>16-94. <A
HREF="#TBL-LIBSTDCXX-CLATQ-DATA"
>libstdcxx - Class runtime_error Data Interfaces</A
></DT
><DT
>16-95. <A
HREF="#CLS-24242-0"
>Primary vtable for overflow_error</A
></DT
><DT
>16-96. <A
HREF="#RTTI-24053"
>typeinfo for overflow_error</A
></DT
><DT
>16-97. <A
HREF="#TBL-LIBSTDCXX-CLATR-INTS"
>libstdcxx - Class overflow_error Function Interfaces</A
></DT
><DT
>16-98. <A
HREF="#TBL-LIBSTDCXX-CLATR-DATA"
>libstdcxx - Class overflow_error Data Interfaces</A
></DT
><DT
>16-99. <A
HREF="#CLS-24241-0"
>Primary vtable for underflow_error</A
></DT
><DT
>16-100. <A
HREF="#RTTI-24052"
>typeinfo for underflow_error</A
></DT
><DT
>16-101. <A
HREF="#TBL-LIBSTDCXX-CLATS-INTS"
>libstdcxx - Class underflow_error Function Interfaces</A
></DT
><DT
>16-102. <A
HREF="#TBL-LIBSTDCXX-CLATS-DATA"
>libstdcxx - Class underflow_error Data Interfaces</A
></DT
><DT
>16-103. <A
HREF="#CLS-24246-0"
>Primary vtable for invalid_argument</A
></DT
><DT
>16-104. <A
HREF="#RTTI-24057"
>typeinfo for invalid_argument</A
></DT
><DT
>16-105. <A
HREF="#TBL-LIBSTDCXX-CLATT-INTS"
>libstdcxx - Class invalid_argument Function Interfaces</A
></DT
><DT
>16-106. <A
HREF="#TBL-LIBSTDCXX-CLATT-DATA"
>libstdcxx - Class invalid_argument Data Interfaces</A
></DT
><DT
>16-107. <A
HREF="#CLS-24324-0"
>Primary vtable for bad_cast</A
></DT
><DT
>16-108. <A
HREF="#RTTI-24096"
>typeinfo for bad_cast</A
></DT
><DT
>16-109. <A
HREF="#TBL-LIBSTDCXX-CLATU-INTS"
>libstdcxx - Class bad_cast Function Interfaces</A
></DT
><DT
>16-110. <A
HREF="#TBL-LIBSTDCXX-CLATU-DATA"
>libstdcxx - Class bad_cast Data Interfaces</A
></DT
><DT
>16-111. <A
HREF="#CLS-24322-0"
>Primary vtable for bad_alloc</A
></DT
><DT
>16-112. <A
HREF="#RTTI-24092"
>typeinfo for bad_alloc</A
></DT
><DT
>16-113. <A
HREF="#TBL-LIBSTDCXX-CLATV-INTS"
>libstdcxx - Class bad_alloc Function Interfaces</A
></DT
><DT
>16-114. <A
HREF="#TBL-LIBSTDCXX-CLATV-DATA"
>libstdcxx - Class bad_alloc Data Interfaces</A
></DT
><DT
>16-115. <A
HREF="#TBL-LIBSTDCXX-STRUC-DATA"
>libstdcxx - struct __numeric_limits_base Data Interfaces</A
></DT
><DT
>16-116. <A
HREF="#TBL-LIBSTDCXX-STRUD-DATA"
>libstdcxx - struct numeric_limits&#60;long double&#62; Data Interfaces</A
></DT
><DT
>16-117. <A
HREF="#TBL-LIBSTDCXX-STRUE-DATA"
>libstdcxx - struct numeric_limits&#60;long long&#62; Data Interfaces</A
></DT
><DT
>16-118. <A
HREF="#TBL-LIBSTDCXX-STRUF-DATA"
>libstdcxx - struct numeric_limits&#60;unsigned long long&#62; Data Interfaces</A
></DT
><DT
>16-119. <A
HREF="#TBL-LIBSTDCXX-STRUG-DATA"
>libstdcxx - struct numeric_limits&#60;float&#62; Data Interfaces</A
></DT
><DT
>16-120. <A
HREF="#TBL-LIBSTDCXX-STRUH-DATA"
>libstdcxx - struct numeric_limits&#60;double&#62; Data Interfaces</A
></DT
><DT
>16-121. <A
HREF="#TBL-LIBSTDCXX-STRUI-DATA"
>libstdcxx - struct numeric_limits&#60;short&#62; Data Interfaces</A
></DT
><DT
>16-122. <A
HREF="#TBL-LIBSTDCXX-STRUJ-DATA"
>libstdcxx - struct numeric_limits&#60;unsigned short&#62; Data Interfaces</A
></DT
><DT
>16-123. <A
HREF="#TBL-LIBSTDCXX-STRUK-DATA"
>libstdcxx - struct numeric_limits&#60;int&#62; Data Interfaces</A
></DT
><DT
>16-124. <A
HREF="#TBL-LIBSTDCXX-STRUL-DATA"
>libstdcxx - struct numeric_limits&#60;unsigned int&#62; Data Interfaces</A
></DT
><DT
>16-125. <A
HREF="#TBL-LIBSTDCXX-STRUM-DATA"
>libstdcxx - struct numeric_limits&#60;long&#62; Data Interfaces</A
></DT
><DT
>16-126. <A
HREF="#TBL-LIBSTDCXX-STRUN-DATA"
>libstdcxx - struct numeric_limits&#60;unsigned long&#62; Data Interfaces</A
></DT
><DT
>16-127. <A
HREF="#TBL-LIBSTDCXX-STRUO-DATA"
>libstdcxx - struct numeric_limits&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-128. <A
HREF="#TBL-LIBSTDCXX-STRUP-DATA"
>libstdcxx - struct numeric_limits&#60;unsigned char&#62; Data Interfaces</A
></DT
><DT
>16-129. <A
HREF="#TBL-LIBSTDCXX-STRUQ-DATA"
>libstdcxx - struct numeric_limits&#60;signed char&#62; Data Interfaces</A
></DT
><DT
>16-130. <A
HREF="#TBL-LIBSTDCXX-STRUR-DATA"
>libstdcxx - struct numeric_limits&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-131. <A
HREF="#TBL-LIBSTDCXX-STRUS-DATA"
>libstdcxx - struct numeric_limits&#60;bool&#62; Data Interfaces</A
></DT
><DT
>16-132. <A
HREF="#RTTI-24006"
>typeinfo for ctype_base</A
></DT
><DT
>16-133. <A
HREF="#TBL-LIBSTDCXX-CLATW-DATA"
>libstdcxx - Class ctype_base Data Interfaces</A
></DT
><DT
>16-134. <A
HREF="#CLS-24301-0"
>Primary vtable for __ctype_abstract_base&#60;char&#62;</A
></DT
><DT
>16-135. <A
HREF="#TBL-LIBSTDCXX-CLATX-DATA"
>libstdcxx - Class __ctype_abstract_base&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-136. <A
HREF="#CLS-24300-0"
>Primary vtable for __ctype_abstract_base&#60;wchar_t&#62;</A
></DT
><DT
>16-137. <A
HREF="#TBL-LIBSTDCXX-CLATY-DATA"
>libstdcxx - Class __ctype_abstract_base&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-138. <A
HREF="#CLS-24230-0"
>Primary vtable for ctype&#60;char&#62;</A
></DT
><DT
>16-139. <A
HREF="#TBL-LIBSTDCXX-CLATZ-INTS"
>libstdcxx - Class ctype&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-140. <A
HREF="#TBL-LIBSTDCXX-CLATZ-DATA"
>libstdcxx - Class ctype&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-141. <A
HREF="#CLS-24229-0"
>Primary vtable for ctype&#60;wchar_t&#62;</A
></DT
><DT
>16-142. <A
HREF="#RTTI-24008"
>typeinfo for ctype&#60;wchar_t&#62;</A
></DT
><DT
>16-143. <A
HREF="#TBL-LIBSTDCXX-CLAUA-INTS"
>libstdcxx - Class ctype&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-144. <A
HREF="#TBL-LIBSTDCXX-CLAUA-DATA"
>libstdcxx - Class ctype&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-145. <A
HREF="#CLS-24299-0"
>Primary vtable for ctype_byname&#60;char&#62;</A
></DT
><DT
>16-146. <A
HREF="#RTTI-24087"
>typeinfo for ctype_byname&#60;char&#62;</A
></DT
><DT
>16-147. <A
HREF="#TBL-LIBSTDCXX-CLAUB-INTS"
>libstdcxx - Class ctype_byname&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-148. <A
HREF="#TBL-LIBSTDCXX-CLAUB-DATA"
>libstdcxx - Class ctype_byname&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-149. <A
HREF="#CLS-24298-0"
>Primary vtable for ctype_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-150. <A
HREF="#RTTI-24086"
>typeinfo for ctype_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-151. <A
HREF="#TBL-LIBSTDCXX-CLAUC-INTS"
>libstdcxx - Class ctype_byname&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-152. <A
HREF="#TBL-LIBSTDCXX-CLAUC-DATA"
>libstdcxx - Class ctype_byname&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-153. <A
HREF="#TBL-LIBSTDCXX-CLAUD-INTS"
>libstdcxx - Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-154. <A
HREF="#TBL-LIBSTDCXX-CLAUD-DATA"
>libstdcxx - Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-155. <A
HREF="#TBL-LIBSTDCXX-CLAUE-INTS"
>libstdcxx - Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-156. <A
HREF="#TBL-LIBSTDCXX-CLAUE-DATA"
>libstdcxx - Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-157. <A
HREF="#VTT-24742"
>VTT for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16-158. <A
HREF="#TBL-LIBSTDCXX-CLAUF-INTS"
>libstdcxx - Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-159. <A
HREF="#TBL-LIBSTDCXX-CLAUF-DATA"
>libstdcxx - Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-160. <A
HREF="#VTT-24743"
>VTT for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-161. <A
HREF="#TBL-LIBSTDCXX-CLAUG-INTS"
>libstdcxx - Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-162. <A
HREF="#TBL-LIBSTDCXX-CLAUG-DATA"
>libstdcxx - Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-163. <A
HREF="#VTT-24394"
>VTT for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16-164. <A
HREF="#TBL-LIBSTDCXX-CLAUH-INTS"
>libstdcxx - Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-165. <A
HREF="#TBL-LIBSTDCXX-CLAUH-DATA"
>libstdcxx - Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-166. <A
HREF="#VTT-24395"
>VTT for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-167. <A
HREF="#TBL-LIBSTDCXX-CLAUI-INTS"
>libstdcxx - Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-168. <A
HREF="#TBL-LIBSTDCXX-CLAUI-DATA"
>libstdcxx - Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-169. <A
HREF="#VTT-24396"
>VTT for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16-170. <A
HREF="#TBL-LIBSTDCXX-CLAUJ-INTS"
>libstdcxx - Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-171. <A
HREF="#TBL-LIBSTDCXX-CLAUJ-DATA"
>libstdcxx - Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-172. <A
HREF="#VTT-24397"
>VTT for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-173. <A
HREF="#TBL-LIBSTDCXX-CLAUK-INTS"
>libstdcxx - Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-174. <A
HREF="#TBL-LIBSTDCXX-CLAUK-DATA"
>libstdcxx - Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-175. <A
HREF="#CLS-24311-0"
>Primary vtable for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16-176. <A
HREF="#RTTI-24089"
>typeinfo for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16-177. <A
HREF="#TBL-LIBSTDCXX-CLAUL-INTS"
>libstdcxx - Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-178. <A
HREF="#TBL-LIBSTDCXX-CLAUL-DATA"
>libstdcxx - Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-179. <A
HREF="#CLS-24307-0"
>Primary vtable for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-180. <A
HREF="#RTTI-24088"
>typeinfo for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-181. <A
HREF="#TBL-LIBSTDCXX-CLAUM-INTS"
>libstdcxx - Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-182. <A
HREF="#TBL-LIBSTDCXX-CLAUM-DATA"
>libstdcxx - Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-183. <A
HREF="#VTT-24660"
>VTT for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-184. <A
HREF="#TBL-LIBSTDCXX-CLAUN-INTS"
>libstdcxx - Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-185. <A
HREF="#TBL-LIBSTDCXX-CLAUN-DATA"
>libstdcxx - Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-186. <A
HREF="#VTT-24661"
>VTT for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-187. <A
HREF="#TBL-LIBSTDCXX-CLAUO-INTS"
>libstdcxx - Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-188. <A
HREF="#TBL-LIBSTDCXX-CLAUO-DATA"
>libstdcxx - Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-189. <A
HREF="#VTT-24999"
>VTT for basic_istream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-190. <A
HREF="#TBL-LIBSTDCXX-CLAUP-INTS"
>libstdcxx - Class basic_istream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-191. <A
HREF="#TBL-LIBSTDCXX-CLAUP-DATA"
>libstdcxx - Class basic_istream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-192. <A
HREF="#VTT-25001"
>VTT for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-193. <A
HREF="#TBL-LIBSTDCXX-CLAUQ-INTS"
>libstdcxx - Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-194. <A
HREF="#TBL-LIBSTDCXX-CLAUQ-DATA"
>libstdcxx - Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-195. <A
HREF="#TBL-LIBSTDCXX-CLAUR-INTS"
>libstdcxx - Class istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-196. <A
HREF="#TBL-LIBSTDCXX-CLAUS-INTS"
>libstdcxx - Class istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-197. <A
HREF="#VTT-25000"
>VTT for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-198. <A
HREF="#TBL-LIBSTDCXX-CLAUT-INTS"
>libstdcxx - Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-199. <A
HREF="#TBL-LIBSTDCXX-CLAUT-DATA"
>libstdcxx - Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-200. <A
HREF="#VTT-25002"
>VTT for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-201. <A
HREF="#TBL-LIBSTDCXX-CLAUU-INTS"
>libstdcxx - Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-202. <A
HREF="#TBL-LIBSTDCXX-CLAUU-DATA"
>libstdcxx - Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-203. <A
HREF="#VTT-24740"
>VTT for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-204. <A
HREF="#TBL-LIBSTDCXX-CLAUV-INTS"
>libstdcxx - Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-205. <A
HREF="#TBL-LIBSTDCXX-CLAUV-DATA"
>libstdcxx - Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-206. <A
HREF="#VTT-24741"
>VTT for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-207. <A
HREF="#TBL-LIBSTDCXX-CLAUW-INTS"
>libstdcxx - Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-208. <A
HREF="#TBL-LIBSTDCXX-CLAUW-DATA"
>libstdcxx - Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-209. <A
HREF="#VTT-24390"
>VTT for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-210. <A
HREF="#TBL-LIBSTDCXX-CLAUX-INTS"
>libstdcxx - Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-211. <A
HREF="#TBL-LIBSTDCXX-CLAUX-DATA"
>libstdcxx - Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-212. <A
HREF="#VTT-24391"
>VTT for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-213. <A
HREF="#TBL-LIBSTDCXX-CLAUY-INTS"
>libstdcxx - Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-214. <A
HREF="#TBL-LIBSTDCXX-CLAUY-DATA"
>libstdcxx - Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-215. <A
HREF="#VTT-24392"
>VTT for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-216. <A
HREF="#TBL-LIBSTDCXX-CLAUZ-INTS"
>libstdcxx - Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-217. <A
HREF="#TBL-LIBSTDCXX-CLAUZ-DATA"
>libstdcxx - Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-218. <A
HREF="#VTT-24393"
>VTT for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-219. <A
HREF="#TBL-LIBSTDCXX-CLAVA-INTS"
>libstdcxx - Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-220. <A
HREF="#TBL-LIBSTDCXX-CLAVA-DATA"
>libstdcxx - Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-221. <A
HREF="#CLS-24315-0"
>Primary vtable for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-222. <A
HREF="#RTTI-23990"
>typeinfo for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-223. <A
HREF="#TBL-LIBSTDCXX-CLAVB-INTS"
>libstdcxx - Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-224. <A
HREF="#TBL-LIBSTDCXX-CLAVB-DATA"
>libstdcxx - Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-225. <A
HREF="#CLS-24314-0"
>Primary vtable for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-226. <A
HREF="#RTTI-23991"
>typeinfo for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-227. <A
HREF="#TBL-LIBSTDCXX-CLAVC-INTS"
>libstdcxx - Class basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-228. <A
HREF="#CLS-24240-0"
>Primary vtable for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-229. <A
HREF="#RTTI-23988"
>typeinfo for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-230. <A
HREF="#TBL-LIBSTDCXX-CLAVD-INTS"
>libstdcxx - Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-231. <A
HREF="#TBL-LIBSTDCXX-CLAVD-DATA"
>libstdcxx - Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-232. <A
HREF="#CLS-24239-0"
>Primary vtable for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-233. <A
HREF="#RTTI-23989"
>typeinfo for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-234. <A
HREF="#TBL-LIBSTDCXX-CLAVE-INTS"
>libstdcxx - Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-235. <A
HREF="#TBL-LIBSTDCXX-CLAVE-DATA"
>libstdcxx - Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-236. <A
HREF="#CLS-29891-0"
>Primary vtable for ios_base</A
></DT
><DT
>16-237. <A
HREF="#RTTI-24001"
>typeinfo for ios_base</A
></DT
><DT
>16-238. <A
HREF="#TBL-LIBSTDCXX-CLAVF-INTS"
>libstdcxx - Class ios_base Function Interfaces</A
></DT
><DT
>16-239. <A
HREF="#TBL-LIBSTDCXX-CLAVF-DATA"
>libstdcxx - Class ios_base Data Interfaces</A
></DT
><DT
>16-240. <A
HREF="#CLS-24251-0"
>Primary vtable for basic_ios&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16-241. <A
HREF="#TBL-LIBSTDCXX-CLAVG-INTS"
>libstdcxx - Class basic_ios&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</A
></DT
><DT
>16-242. <A
HREF="#TBL-LIBSTDCXX-CLAVG-DATA"
>libstdcxx - Class basic_ios&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</A
></DT
><DT
>16-243. <A
HREF="#CLS-24250-0"
>Primary vtable for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-244. <A
HREF="#RTTI-24004"
>typeinfo for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16-245. <A
HREF="#TBL-LIBSTDCXX-CLAVH-INTS"
>libstdcxx - Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</A
></DT
><DT
>16-246. <A
HREF="#TBL-LIBSTDCXX-CLAVH-DATA"
>libstdcxx - Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</A
></DT
><DT
>16-247. <A
HREF="#CLS-24252-0"
>Primary vtable for ios_base::failure</A
></DT
><DT
>16-248. <A
HREF="#RTTI-24059"
>typeinfo for ios_base::failure</A
></DT
><DT
>16-249. <A
HREF="#TBL-LIBSTDCXX-CLAVI-INTS"
>libstdcxx - Class ios_base::failure Function Interfaces</A
></DT
><DT
>16-250. <A
HREF="#TBL-LIBSTDCXX-CLAVI-DATA"
>libstdcxx - Class ios_base::failure Data Interfaces</A
></DT
><DT
>16-251. <A
HREF="#CLS-24291-0"
>Primary vtable for __timepunct&#60;char&#62;</A
></DT
><DT
>16-252. <A
HREF="#RTTI-24085"
>typeinfo for __timepunct&#60;char&#62;</A
></DT
><DT
>16-253. <A
HREF="#TBL-LIBSTDCXX-CLAVJ-INTS"
>libstdcxx - Class __timepunct&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-254. <A
HREF="#TBL-LIBSTDCXX-CLAVJ-DATA"
>libstdcxx - Class __timepunct&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-255. <A
HREF="#CLS-24290-0"
>Primary vtable for __timepunct&#60;wchar_t&#62;</A
></DT
><DT
>16-256. <A
HREF="#RTTI-24084"
>typeinfo for __timepunct&#60;wchar_t&#62;</A
></DT
><DT
>16-257. <A
HREF="#TBL-LIBSTDCXX-CLAVK-INTS"
>libstdcxx - Class __timepunct&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-258. <A
HREF="#TBL-LIBSTDCXX-CLAVK-DATA"
>libstdcxx - Class __timepunct&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-259. <A
HREF="#RTTI-24011"
>typeinfo for messages_base</A
></DT
><DT
>16-260. <A
HREF="#TBL-LIBSTDCXX-CLAVL-DATA"
>libstdcxx - Class messages_base Data Interfaces</A
></DT
><DT
>16-261. <A
HREF="#CLS-24285-0"
>Primary vtable for messages&#60;char&#62;</A
></DT
><DT
>16-262. <A
HREF="#TBL-LIBSTDCXX-CLAVM-INTS"
>libstdcxx - Class messages&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-263. <A
HREF="#TBL-LIBSTDCXX-CLAVM-DATA"
>libstdcxx - Class messages&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-264. <A
HREF="#CLS-24284-0"
>Primary vtable for messages&#60;wchar_t&#62;</A
></DT
><DT
>16-265. <A
HREF="#TBL-LIBSTDCXX-CLAVN-INTS"
>libstdcxx - Class messages&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-266. <A
HREF="#TBL-LIBSTDCXX-CLAVN-DATA"
>libstdcxx - Class messages&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-267. <A
HREF="#CLS-24272-0"
>Primary vtable for messages_byname&#60;char&#62;</A
></DT
><DT
>16-268. <A
HREF="#RTTI-24074"
>typeinfo for messages_byname&#60;char&#62;</A
></DT
><DT
>16-269. <A
HREF="#TBL-LIBSTDCXX-CLAVO-INTS"
>libstdcxx - Class messages_byname&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-270. <A
HREF="#TBL-LIBSTDCXX-CLAVO-DATA"
>libstdcxx - Class messages_byname&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-271. <A
HREF="#CLS-24258-0"
>Primary vtable for messages_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-272. <A
HREF="#RTTI-24062"
>typeinfo for messages_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-273. <A
HREF="#TBL-LIBSTDCXX-CLAVP-INTS"
>libstdcxx - Class messages_byname&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-274. <A
HREF="#TBL-LIBSTDCXX-CLAVP-DATA"
>libstdcxx - Class messages_byname&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-275. <A
HREF="#CLS-24295-0"
>Primary vtable for numpunct&#60;char&#62;</A
></DT
><DT
>16-276. <A
HREF="#RTTI-24014"
>typeinfo for numpunct&#60;char&#62;</A
></DT
><DT
>16-277. <A
HREF="#TBL-LIBSTDCXX-CLAVQ-INTS"
>libstdcxx - Class numpunct&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-278. <A
HREF="#TBL-LIBSTDCXX-CLAVQ-DATA"
>libstdcxx - Class numpunct&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-279. <A
HREF="#CLS-24294-0"
>Primary vtable for numpunct&#60;wchar_t&#62;</A
></DT
><DT
>16-280. <A
HREF="#RTTI-24024"
>typeinfo for numpunct&#60;wchar_t&#62;</A
></DT
><DT
>16-281. <A
HREF="#TBL-LIBSTDCXX-CLAVR-INTS"
>libstdcxx - Class numpunct&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-282. <A
HREF="#TBL-LIBSTDCXX-CLAVR-DATA"
>libstdcxx - Class numpunct&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-283. <A
HREF="#CLS-24279-0"
>Primary vtable for numpunct_byname&#60;char&#62;</A
></DT
><DT
>16-284. <A
HREF="#RTTI-24079"
>typeinfo for numpunct_byname&#60;char&#62;</A
></DT
><DT
>16-285. <A
HREF="#TBL-LIBSTDCXX-CLAVS-INTS"
>libstdcxx - Class numpunct_byname&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-286. <A
HREF="#TBL-LIBSTDCXX-CLAVS-DATA"
>libstdcxx - Class numpunct_byname&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-287. <A
HREF="#CLS-24265-0"
>Primary vtable for numpunct_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-288. <A
HREF="#RTTI-24067"
>typeinfo for numpunct_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-289. <A
HREF="#TBL-LIBSTDCXX-CLAVT-INTS"
>libstdcxx - Class numpunct_byname&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-290. <A
HREF="#TBL-LIBSTDCXX-CLAVT-DATA"
>libstdcxx - Class numpunct_byname&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-291. <A
HREF="#CLS-24297-0"
>Primary vtable for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16-292. <A
HREF="#TBL-LIBSTDCXX-CLAVU-DATA"
>libstdcxx - Class __codecvt_abstract_base&#60;char, char, __mbstate_t&#62; Data Interfaces</A
></DT
><DT
>16-293. <A
HREF="#CLS-24296-0"
>Primary vtable for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16-294. <A
HREF="#TBL-LIBSTDCXX-CLAVV-DATA"
>libstdcxx - Class __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62; Data Interfaces</A
></DT
><DT
>16-295. <A
HREF="#RTTI-24009"
>typeinfo for codecvt_base</A
></DT
><DT
>16-296. <A
HREF="#TBL-LIBSTDCXX-CLAVW-DATA"
>libstdcxx - Class codecvt_base Data Interfaces</A
></DT
><DT
>16-297. <A
HREF="#CLS-24228-0"
>Primary vtable for codecvt&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16-298. <A
HREF="#RTTI-24020"
>typeinfo for codecvt&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16-299. <A
HREF="#TBL-LIBSTDCXX-CLAVX-INTS"
>libstdcxx - Class codecvt&#60;char, char, __mbstate_t&#62; Function Interfaces</A
></DT
><DT
>16-300. <A
HREF="#TBL-LIBSTDCXX-CLAVX-DATA"
>libstdcxx - Class codecvt&#60;char, char, __mbstate_t&#62; Data Interfaces</A
></DT
><DT
>16-301. <A
HREF="#CLS-24227-0"
>Primary vtable for codecvt&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16-302. <A
HREF="#RTTI-24028"
>typeinfo for codecvt&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16-303. <A
HREF="#TBL-LIBSTDCXX-CLAVY-INTS"
>libstdcxx - Class codecvt&#60;wchar_t, char, __mbstate_t&#62; Function Interfaces</A
></DT
><DT
>16-304. <A
HREF="#TBL-LIBSTDCXX-CLAVY-DATA"
>libstdcxx - Class codecvt&#60;wchar_t, char, __mbstate_t&#62; Data Interfaces</A
></DT
><DT
>16-305. <A
HREF="#CLS-24271-0"
>Primary vtable for codecvt_byname&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16-306. <A
HREF="#RTTI-24073"
>typeinfo for codecvt_byname&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16-307. <A
HREF="#TBL-LIBSTDCXX-CLAVZ-INTS"
>libstdcxx - Class codecvt_byname&#60;char, char, __mbstate_t&#62; Function Interfaces</A
></DT
><DT
>16-308. <A
HREF="#TBL-LIBSTDCXX-CLAVZ-DATA"
>libstdcxx - Class codecvt_byname&#60;char, char, __mbstate_t&#62; Data Interfaces</A
></DT
><DT
>16-309. <A
HREF="#CLS-24257-0"
>Primary vtable for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16-310. <A
HREF="#RTTI-24061"
>typeinfo for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16-311. <A
HREF="#TBL-LIBSTDCXX-CLAWA-INTS"
>libstdcxx - Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; Function Interfaces</A
></DT
><DT
>16-312. <A
HREF="#TBL-LIBSTDCXX-CLAWA-DATA"
>libstdcxx - Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; Data Interfaces</A
></DT
><DT
>16-313. <A
HREF="#CLS-24293-0"
>Primary vtable for collate&#60;char&#62;</A
></DT
><DT
>16-314. <A
HREF="#RTTI-24021"
>typeinfo for collate&#60;char&#62;</A
></DT
><DT
>16-315. <A
HREF="#TBL-LIBSTDCXX-CLAWB-INTS"
>libstdcxx - Class collate&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-316. <A
HREF="#TBL-LIBSTDCXX-CLAWB-DATA"
>libstdcxx - Class collate&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-317. <A
HREF="#CLS-24292-0"
>Primary vtable for collate&#60;wchar_t&#62;</A
></DT
><DT
>16-318. <A
HREF="#RTTI-24029"
>typeinfo for collate&#60;wchar_t&#62;</A
></DT
><DT
>16-319. <A
HREF="#TBL-LIBSTDCXX-CLAWC-INTS"
>libstdcxx - Class collate&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-320. <A
HREF="#TBL-LIBSTDCXX-CLAWC-DATA"
>libstdcxx - Class collate&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-321. <A
HREF="#CLS-24270-0"
>Primary vtable for collate_byname&#60;char&#62;</A
></DT
><DT
>16-322. <A
HREF="#RTTI-24072"
>typeinfo for collate_byname&#60;char&#62;</A
></DT
><DT
>16-323. <A
HREF="#TBL-LIBSTDCXX-CLAWD-INTS"
>libstdcxx - Class collate_byname&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-324. <A
HREF="#TBL-LIBSTDCXX-CLAWD-DATA"
>libstdcxx - Class collate_byname&#60;char&#62; Data Interfaces</A
></DT
><DT
>16-325. <A
HREF="#CLS-24256-0"
>Primary vtable for collate_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-326. <A
HREF="#RTTI-24060"
>typeinfo for collate_byname&#60;wchar_t&#62;</A
></DT
><DT
>16-327. <A
HREF="#TBL-LIBSTDCXX-CLAWE-INTS"
>libstdcxx - Class collate_byname&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-328. <A
HREF="#TBL-LIBSTDCXX-CLAWE-DATA"
>libstdcxx - Class collate_byname&#60;wchar_t&#62; Data Interfaces</A
></DT
><DT
>16-329. <A
HREF="#RTTI-24016"
>typeinfo for time_base</A
></DT
><DT
>16-330. <A
HREF="#TBL-LIBSTDCXX-CLAWF-DATA"
>libstdcxx - Class time_base Data Interfaces</A
></DT
><DT
>16-331. <A
HREF="#CLS-24273-0"
>Primary vtable for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-332. <A
HREF="#RTTI-24075"
>typeinfo for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-333. <A
HREF="#TBL-LIBSTDCXX-CLAWG-INTS"
>libstdcxx - Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-334. <A
HREF="#TBL-LIBSTDCXX-CLAWG-DATA"
>libstdcxx - Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-335. <A
HREF="#CLS-24259-0"
>Primary vtable for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-336. <A
HREF="#RTTI-24063"
>typeinfo for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-337. <A
HREF="#TBL-LIBSTDCXX-CLAWH-INTS"
>libstdcxx - Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-338. <A
HREF="#TBL-LIBSTDCXX-CLAWH-DATA"
>libstdcxx - Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-339. <A
HREF="#CLS-24275-0"
>Primary vtable for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-340. <A
HREF="#RTTI-24076"
>typeinfo for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-341. <A
HREF="#TBL-LIBSTDCXX-CLAWI-INTS"
>libstdcxx - Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-342. <A
HREF="#TBL-LIBSTDCXX-CLAWI-DATA"
>libstdcxx - Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-343. <A
HREF="#CLS-24261-0"
>Primary vtable for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-344. <A
HREF="#RTTI-24064"
>typeinfo for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-345. <A
HREF="#TBL-LIBSTDCXX-CLAWJ-INTS"
>libstdcxx - Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-346. <A
HREF="#TBL-LIBSTDCXX-CLAWJ-DATA"
>libstdcxx - Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-347. <A
HREF="#CLS-24274-0"
>Primary vtable for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-348. <A
HREF="#TBL-LIBSTDCXX-CLAWK-INTS"
>libstdcxx - Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-349. <A
HREF="#TBL-LIBSTDCXX-CLAWK-DATA"
>libstdcxx - Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-350. <A
HREF="#CLS-24260-0"
>Primary vtable for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-351. <A
HREF="#TBL-LIBSTDCXX-CLAWL-INTS"
>libstdcxx - Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-352. <A
HREF="#TBL-LIBSTDCXX-CLAWL-DATA"
>libstdcxx - Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-353. <A
HREF="#CLS-24276-0"
>Primary vtable for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-354. <A
HREF="#RTTI-24017"
>typeinfo for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-355. <A
HREF="#TBL-LIBSTDCXX-CLAWM-INTS"
>libstdcxx - Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-356. <A
HREF="#TBL-LIBSTDCXX-CLAWM-DATA"
>libstdcxx - Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-357. <A
HREF="#CLS-24262-0"
>Primary vtable for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-358. <A
HREF="#RTTI-24025"
>typeinfo for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-359. <A
HREF="#TBL-LIBSTDCXX-CLAWN-INTS"
>libstdcxx - Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-360. <A
HREF="#TBL-LIBSTDCXX-CLAWN-DATA"
>libstdcxx - Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-361. <A
HREF="#CLS-24288-0"
>Primary vtable for moneypunct&#60;char, false&#62;</A
></DT
><DT
>16-362. <A
HREF="#TBL-LIBSTDCXX-CLAWO-INTS"
>libstdcxx - Class moneypunct&#60;char, false&#62; Function Interfaces</A
></DT
><DT
>16-363. <A
HREF="#TBL-LIBSTDCXX-CLAWO-DATA"
>libstdcxx - Class moneypunct&#60;char, false&#62; Data Interfaces</A
></DT
><DT
>16-364. <A
HREF="#CLS-24289-0"
>Primary vtable for moneypunct&#60;char, true&#62;</A
></DT
><DT
>16-365. <A
HREF="#TBL-LIBSTDCXX-CLAWP-INTS"
>libstdcxx - Class moneypunct&#60;char, true&#62; Function Interfaces</A
></DT
><DT
>16-366. <A
HREF="#TBL-LIBSTDCXX-CLAWP-DATA"
>libstdcxx - Class moneypunct&#60;char, true&#62; Data Interfaces</A
></DT
><DT
>16-367. <A
HREF="#CLS-24286-0"
>Primary vtable for moneypunct&#60;wchar_t, false&#62;</A
></DT
><DT
>16-368. <A
HREF="#TBL-LIBSTDCXX-CLAWQ-INTS"
>libstdcxx - Class moneypunct&#60;wchar_t, false&#62; Function Interfaces</A
></DT
><DT
>16-369. <A
HREF="#TBL-LIBSTDCXX-CLAWQ-DATA"
>libstdcxx - Class moneypunct&#60;wchar_t, false&#62; Data Interfaces</A
></DT
><DT
>16-370. <A
HREF="#CLS-24287-0"
>Primary vtable for moneypunct&#60;wchar_t, true&#62;</A
></DT
><DT
>16-371. <A
HREF="#TBL-LIBSTDCXX-CLAWR-INTS"
>libstdcxx - Class moneypunct&#60;wchar_t, true&#62; Function Interfaces</A
></DT
><DT
>16-372. <A
HREF="#TBL-LIBSTDCXX-CLAWR-DATA"
>libstdcxx - Class moneypunct&#60;wchar_t, true&#62; Data Interfaces</A
></DT
><DT
>16-373. <A
HREF="#CLS-24283-0"
>Primary vtable for moneypunct_byname&#60;char, false&#62;</A
></DT
><DT
>16-374. <A
HREF="#RTTI-24083"
>typeinfo for moneypunct_byname&#60;char, false&#62;</A
></DT
><DT
>16-375. <A
HREF="#TBL-LIBSTDCXX-CLAWS-INTS"
>libstdcxx - Class moneypunct_byname&#60;char, false&#62; Function Interfaces</A
></DT
><DT
>16-376. <A
HREF="#TBL-LIBSTDCXX-CLAWS-DATA"
>libstdcxx - Class moneypunct_byname&#60;char, false&#62; Data Interfaces</A
></DT
><DT
>16-377. <A
HREF="#CLS-24282-0"
>Primary vtable for moneypunct_byname&#60;char, true&#62;</A
></DT
><DT
>16-378. <A
HREF="#RTTI-24082"
>typeinfo for moneypunct_byname&#60;char, true&#62;</A
></DT
><DT
>16-379. <A
HREF="#TBL-LIBSTDCXX-CLAWT-INTS"
>libstdcxx - Class moneypunct_byname&#60;char, true&#62; Function Interfaces</A
></DT
><DT
>16-380. <A
HREF="#TBL-LIBSTDCXX-CLAWT-DATA"
>libstdcxx - Class moneypunct_byname&#60;char, true&#62; Data Interfaces</A
></DT
><DT
>16-381. <A
HREF="#CLS-24269-0"
>Primary vtable for moneypunct_byname&#60;wchar_t, false&#62;</A
></DT
><DT
>16-382. <A
HREF="#RTTI-24071"
>typeinfo for moneypunct_byname&#60;wchar_t, false&#62;</A
></DT
><DT
>16-383. <A
HREF="#TBL-LIBSTDCXX-CLAWU-INTS"
>libstdcxx - Class moneypunct_byname&#60;wchar_t, false&#62; Function Interfaces</A
></DT
><DT
>16-384. <A
HREF="#TBL-LIBSTDCXX-CLAWU-DATA"
>libstdcxx - Class moneypunct_byname&#60;wchar_t, false&#62; Data Interfaces</A
></DT
><DT
>16-385. <A
HREF="#CLS-24268-0"
>Primary vtable for moneypunct_byname&#60;wchar_t, true&#62;</A
></DT
><DT
>16-386. <A
HREF="#RTTI-24070"
>typeinfo for moneypunct_byname&#60;wchar_t, true&#62;</A
></DT
><DT
>16-387. <A
HREF="#TBL-LIBSTDCXX-CLAWV-INTS"
>libstdcxx - Class moneypunct_byname&#60;wchar_t, true&#62; Function Interfaces</A
></DT
><DT
>16-388. <A
HREF="#TBL-LIBSTDCXX-CLAWV-DATA"
>libstdcxx - Class moneypunct_byname&#60;wchar_t, true&#62; Data Interfaces</A
></DT
><DT
>16-389. <A
HREF="#RTTI-24010"
>typeinfo for money_base</A
></DT
><DT
>16-390. <A
HREF="#TBL-LIBSTDCXX-CLAWW-INTS"
>libstdcxx - Class money_base Function Interfaces</A
></DT
><DT
>16-391. <A
HREF="#TBL-LIBSTDCXX-CLAWW-DATA"
>libstdcxx - Class money_base Data Interfaces</A
></DT
><DT
>16-392. <A
HREF="#CLS-24281-0"
>Primary vtable for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-393. <A
HREF="#RTTI-24081"
>typeinfo for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-394. <A
HREF="#TBL-LIBSTDCXX-CLAWX-INTS"
>libstdcxx - Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-395. <A
HREF="#TBL-LIBSTDCXX-CLAWX-DATA"
>libstdcxx - Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-396. <A
HREF="#CLS-24267-0"
>Primary vtable for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-397. <A
HREF="#RTTI-24069"
>typeinfo for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-398. <A
HREF="#TBL-LIBSTDCXX-CLAWY-INTS"
>libstdcxx - Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-399. <A
HREF="#TBL-LIBSTDCXX-CLAWY-DATA"
>libstdcxx - Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-400. <A
HREF="#CLS-24280-0"
>Primary vtable for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-401. <A
HREF="#RTTI-24080"
>typeinfo for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-402. <A
HREF="#TBL-LIBSTDCXX-CLAWZ-INTS"
>libstdcxx - Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-403. <A
HREF="#TBL-LIBSTDCXX-CLAWZ-DATA"
>libstdcxx - Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-404. <A
HREF="#CLS-24266-0"
>Primary vtable for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-405. <A
HREF="#RTTI-24068"
>typeinfo for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-406. <A
HREF="#TBL-LIBSTDCXX-CLAXA-INTS"
>libstdcxx - Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-407. <A
HREF="#TBL-LIBSTDCXX-CLAXA-DATA"
>libstdcxx - Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-408. <A
HREF="#TBL-LIBSTDCXX-CLAXB-INTS"
>libstdcxx - Class locale Function Interfaces</A
></DT
><DT
>16-409. <A
HREF="#TBL-LIBSTDCXX-CLAXB-DATA"
>libstdcxx - Class locale Data Interfaces</A
></DT
><DT
>16-410. <A
HREF="#CLS-24255-0"
>Primary vtable for locale::facet</A
></DT
><DT
>16-411. <A
HREF="#RTTI-24005"
>typeinfo for locale::facet</A
></DT
><DT
>16-412. <A
HREF="#TBL-LIBSTDCXX-CLAXC-INTS"
>libstdcxx - Class locale::facet Function Interfaces</A
></DT
><DT
>16-413. <A
HREF="#TBL-LIBSTDCXX-CLAXC-DATA"
>libstdcxx - Class locale::facet Data Interfaces</A
></DT
><DT
>16-414. <A
HREF="#TBL-LIBSTDCXX-FACET-INTS"
>libstdcxx - facet functions Function Interfaces</A
></DT
><DT
>16-415. <A
HREF="#TBL-LIBSTDCXX-CLAXD-INTS"
>libstdcxx - Class __num_base Function Interfaces</A
></DT
><DT
>16-416. <A
HREF="#TBL-LIBSTDCXX-CLAXD-DATA"
>libstdcxx - Class __num_base Data Interfaces</A
></DT
><DT
>16-417. <A
HREF="#CLS-24278-0"
>Primary vtable for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-418. <A
HREF="#RTTI-24078"
>typeinfo for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-419. <A
HREF="#TBL-LIBSTDCXX-CLAXE-INTS"
>libstdcxx - Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-420. <A
HREF="#TBL-LIBSTDCXX-CLAXE-DATA"
>libstdcxx - Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-421. <A
HREF="#CLS-24264-0"
>Primary vtable for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-422. <A
HREF="#RTTI-24066"
>typeinfo for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-423. <A
HREF="#TBL-LIBSTDCXX-CLAXF-INTS"
>libstdcxx - Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-424. <A
HREF="#TBL-LIBSTDCXX-CLAXF-DATA"
>libstdcxx - Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-425. <A
HREF="#CLS-24277-0"
>Primary vtable for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-426. <A
HREF="#RTTI-24077"
>typeinfo for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16-427. <A
HREF="#TBL-LIBSTDCXX-CLAXG-INTS"
>libstdcxx - Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-428. <A
HREF="#TBL-LIBSTDCXX-CLAXG-DATA"
>libstdcxx - Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-429. <A
HREF="#CLS-24263-0"
>Primary vtable for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-430. <A
HREF="#RTTI-24065"
>typeinfo for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16-431. <A
HREF="#TBL-LIBSTDCXX-CLAXH-INTS"
>libstdcxx - Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</A
></DT
><DT
>16-432. <A
HREF="#TBL-LIBSTDCXX-CLAXH-DATA"
>libstdcxx - Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</A
></DT
><DT
>16-433. <A
HREF="#TBL-LIBSTDCXX-CLAXI-INTS"
>libstdcxx - Class __basic_file&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-434. <A
HREF="#TBL-LIBSTDCXX-CLAXJ-INTS"
>libstdcxx - Class _List_node_base Function Interfaces</A
></DT
><DT
>16-435. <A
HREF="#TBL-LIBSTDCXX-CLAXK-INTS"
>libstdcxx - Class allocator&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-436. <A
HREF="#TBL-LIBSTDCXX-CLAXL-INTS"
>libstdcxx - Class allocator&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>16-437. <A
HREF="#TBL-LIBSTDCXX-CLAXM-INTS"
>libstdcxx - Class __gnu_cxx::__pool&#60;true&#62; Function Interfaces</A
></DT
><DT
>16-438. <A
HREF="#TBL-LIBSTDCXX-CLAXN-INTS"
>libstdcxx - Class __gnu_cxx::__pool&#60;false&#62; Function Interfaces</A
></DT
><DT
>16-439. <A
HREF="#TBL-LIBSTDCXX-CLAXO-INTS"
>libstdcxx - Class __gnu_cxx::free_list Function Interfaces</A
></DT
><DT
>16-440. <A
HREF="#TBL-LIBSTDCXX-CLAXP-INTS"
>libstdcxx - Class char_traits&#60;char&#62; Function Interfaces</A
></DT
><DT
>16-441. <A
HREF="#TBL-LIBSTDCXX-CLAXQ-INTS"
>libstdcxx - Class char_traits&#60;wchar_t&#62; Function Interfaces</A
></DT
><DT
>17-1. <A
HREF="#TBL-CMDS"
>Commands And Utilities</A
></DT
><DT
>17-2. <A
HREF="#TBL-BUILTINS"
>Built In Utilities</A
></DT
><DT
>17-1. <A
HREF="#AEN59659"
>Escape Sequences</A
></DT
><DT
>23-1. <A
HREF="#TBL-REQUIREDUSERS"
>Required User &#38; Group Names</A
></DT
><DT
>23-2. <A
HREF="#TBL-OPTUSERS"
>Optional User &#38; Group Names</A
></DT
><DT
>24-1. <A
HREF="#LIB-LIBNSPR4-DEF"
>libnspr4 Definition</A
></DT
><DT
>24-2. <A
HREF="#TBL-LIBNSPR4-NETSC-INTS"
>libnspr4 - Netscape Portable Runtime Function Interfaces</A
></DT
><DT
>24-3. <A
HREF="#LIB-LIBNSS3-DEF"
>libnss3 Definition</A
></DT
><DT
>24-4. <A
HREF="#TBL-LIBNSS3-NSS-U-INTS"
>libnss3 - NSS Utility Function Interfaces</A
></DT
><DT
>24-5. <A
HREF="#LIB-LIBSSL3-DEF"
>libssl3 Definition</A
></DT
><DT
>24-6. <A
HREF="#TBL-LIBSSL3-NSS-S-INTS"
>libssl3 - NSS SSL Function Interfaces</A
></DT
><DT
>25-1. <A
HREF="#AEN63052"
>RPM File Format</A
></DT
><DT
>25-2. <A
HREF="#AEN63123"
>Signature Format</A
></DT
><DT
>25-3. <A
HREF="#AEN63192"
>Index Type values</A
></DT
><DT
>25-4. <A
HREF="#AEN63273"
>Header Private Tag Values</A
></DT
><DT
>25-5. <A
HREF="#AEN63362"
>Signature Tag Values</A
></DT
><DT
>25-6. <A
HREF="#AEN63405"
>Signature Digest Tag Values</A
></DT
><DT
>25-7. <A
HREF="#AEN63448"
>Signature Signing Tag Values</A
></DT
><DT
>25-8. <A
HREF="#AEN63530"
>Package Info Tag Values</A
></DT
><DT
>25-9. <A
HREF="#AEN63875"
>Installation Tag Values</A
></DT
><DT
>25-10. <A
HREF="#AEN64014"
>File Info Tag Values</A
></DT
><DT
>25-11. <A
HREF="#AEN64259"
>File Flags</A
></DT
><DT
>25-12. <A
HREF="#AEN64363"
>Package Dependency Tag Values</A
></DT
><DT
>25-13. <A
HREF="#AEN64550"
>Index Type values</A
></DT
><DT
>25-14. <A
HREF="#AEN64594"
>Package Dependency Attributes</A
></DT
><DT
>25-15. <A
HREF="#AEN64666"
>Other Tag Values</A
></DT
><DT
>25-16. <A
HREF="#AEN64814"
>CPIO File Format</A
></DT
><DT
>A-1. <A
HREF="#AEN65023"
>libc Function Interfaces</A
></DT
><DT
>A-2. <A
HREF="#AEN67505"
>libc Data Interfaces</A
></DT
><DT
>A-3. <A
HREF="#AEN67537"
>libcrypt Function Interfaces</A
></DT
><DT
>A-4. <A
HREF="#AEN67564"
>libdl Function Interfaces</A
></DT
><DT
>A-5. <A
HREF="#AEN67589"
>libgcc_s Function Interfaces</A
></DT
><DT
>A-6. <A
HREF="#AEN67639"
>libm Function Interfaces</A
></DT
><DT
>A-7. <A
HREF="#AEN68357"
>libm Data Interfaces</A
></DT
><DT
>A-8. <A
HREF="#AEN68375"
>libncurses Function Interfaces</A
></DT
><DT
>A-9. <A
HREF="#AEN69022"
>libncurses Data Interfaces</A
></DT
><DT
>A-10. <A
HREF="#AEN69065"
>libncursesw Function Interfaces</A
></DT
><DT
>A-11. <A
HREF="#AEN69984"
>libncursesw Data Interfaces</A
></DT
><DT
>A-12. <A
HREF="#AEN70023"
>libpam Function Interfaces</A
></DT
><DT
>A-13. <A
HREF="#AEN70082"
>libpthread Function Interfaces</A
></DT
><DT
>A-14. <A
HREF="#AEN70472"
>librt Function Interfaces</A
></DT
><DT
>A-15. <A
HREF="#AEN70573"
>libutil Function Interfaces</A
></DT
><DT
>A-16. <A
HREF="#AEN70598"
>libz Function Interfaces</A
></DT
><DT
>A-17. <A
HREF="#AEN70726"
>libnspr4 Function Interfaces</A
></DT
><DT
>A-18. <A
HREF="#AEN70947"
>libnss3 Function Interfaces</A
></DT
><DT
>A-19. <A
HREF="#AEN71007"
>libssl3 Function Interfaces</A
></DT
></DL
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="OVERVIEW"
></A
>Foreword</H1
><P
>This is version 5.0 of the Linux Standard Base Core Specification, Generic Part.
This specification is one of a series of volumes under 
the collective title <I
CLASS="CITETITLE"
>Linux Standard Base</I
>:</P
><P
></P
><UL
><LI
><P
>Common</P
></LI
><LI
><P
>Core</P
></LI
><LI
><P
>Desktop</P
></LI
><LI
><P
>Languages</P
></LI
><LI
><P
>Imaging</P
></LI
></UL
><P
>Note that the Core and Desktop volumes consist of a generic volume 
augmented by an architecture-specific volume.</P
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="STATUS"
></A
>Status of this Document</H1
><P
>This is a released specification, version 5.0. 
Other documents may supersede or augment this specification. </P
><P
>A list of current released
Linux Standard Base (LSB) specifications is available at 
<A
HREF="http://refspecs.linuxbase.org/"
TARGET="_top"
>http://refspecs.linuxbase.org</A
>.</P
><P
>If you wish to make comments regarding this document
in a manner that is tracked by the LSB project, please submit them
using our public bug database at 
<A
HREF="http://bugs.linuxbase.org"
TARGET="_top"
>http://bugs.linuxbase.org</A
>.
Please enter your feedback, carefully indicating the title of the
section for which you are submitting feedback, and the volume and
version of the specification where you found the problem, quoting
the incorrect text if appropriate. If you are suggesting a new feature,
please indicate what the problem you are trying to solve is. That is
more important than the solution, in fact.  </P
><P
>If you do not have or wish to create a bug database account then you 
can also e-mail feedback to
<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:lsb-discuss@lists.linuxfoundation.org"
>lsb-discuss@lists.linuxfoundation.org</A
>&#62;</CODE
> (<A
HREF="http://lists.linuxfoundation.org/mailman/listinfo/lsb-discuss"
TARGET="_top"
>subscribe</A
>, <A
HREF="http://lists.linuxfoundation.org/pipermail/lsb-discuss/"
TARGET="_top"
>archives</A
>), and arrangements will be made to transpose the
comments to our public bug database.  </P
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="INTRO"
></A
>Introduction</H1
><P
>The LSB defines a binary interface for application programs that
are compiled and packaged for LSB-conforming implementations on many
different hardware architectures. A binary specification must include
information specific to the computer processor architecture for which
it is intended. To avoid the complexity of conditional descriptions,
the specification has instead been divided into generic parts which are
augmented by one of several architecture-specific parts, depending on
the target processor architecture; the generic part will indicate when
reference must be made to the architecture part, and vice versa.</P
><P
>This document should be used in conjunction with the documents it
references. This document enumerates the system components it includes,
but descriptions of those components may be included entirely or partly
in this document, partly in other documents, or entirely in other
reference documents. For example, the section that describes system
service routines includes a list of the system routines supported in
this interface, formal declarations of the data structures they use that
are visible to applications, and a pointer to the underlying referenced
specification for information about the syntax and semantics of each
call. Only those routines not described in standards referenced by
this document, or extensions to those standards, are described in the
detail. Information referenced in this way is as much a part of this
document as is the information explicitly included here.</P
><P
>The specification carries a version number of either the form
<TT
CLASS="REPLACEABLE"
><I
>x.y</I
></TT
> or <TT
CLASS="REPLACEABLE"
><I
>x.y.z</I
></TT
>. This
version number carries the following meaning:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The first number (<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>) is the major version
number. Versions sharing the same major version number shall be compatible
in a backwards direction; that is, a newer version shall be compatible
with an older version. Any deletion of a library results in a new major
version number. Interfaces marked as deprecated may be removed from the
specification at a major version change.</P
></LI
><LI
><P
>The second number (<TT
CLASS="REPLACEABLE"
><I
>y</I
></TT
>) is the minor
version number. Libraries and individual interfaces may be added, but
not removed. Interfaces may be marked as deprecated at a minor version
change. Other minor changes may be permitted at the discretion of the
LSB workgroup.</P
></LI
><LI
><P
>The third number (<TT
CLASS="REPLACEABLE"
><I
>z</I
></TT
>), if present, is
the editorial level. Only editorial changes should be included in such
versions.</P
></LI
></OL
><P
>Since this specification is a descriptive Application Binary Interface,
and not a source level API specification, it is not possible to make a
guarantee of 100% backward compatibility between major releases. However,
it is the intent that those parts of the binary interface that are
visible in the source level API will remain backward compatible from
version to version, except where a feature marked as "Deprecated" in one
release may be removed from a future release. Implementors are strongly
encouraged to make use of symbol versioning to permit simultaneous support
of applications conforming to different releases of this specification.</P
><P
>LSB is a trademark of the Linux Foundation. Developers of applications
or implementations interested in using the trademark should see the
Linux Foundation Certification Policy for details.  </P
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCINTRO"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>I. Introductory Elements</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#SCOPE"
>Scope</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#GENSCOPE"
>General</A
></DT
><DT
>1.2. <A
HREF="#MODSCOPE"
>Module Specific Scope</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#NORMATIVEREFS"
>References</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#NORMATIVEREFSSECT"
>Normative References</A
></DT
><DT
>2.2. <A
HREF="#INFORMATIVEREFS"
>Informative References/Bibliography</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#REQUIREMENTS"
>Requirements</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#RLIBRARIES"
>Relevant Libraries</A
></DT
><DT
>3.2. <A
HREF="#IMPLEMENTATION"
>LSB Implementation Conformance</A
></DT
><DT
>3.3. <A
HREF="#APPLICATION"
>LSB Application Conformance</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#DEFS"
>Terms and Definitions</A
></DT
><DT
>5. <A
HREF="#DOCCONV"
>Documentation Conventions</A
></DT
><DT
>6. <A
HREF="#POSIXCONFLICTS"
>Relationship To ISO/IEC 9945 POSIX</A
></DT
><DT
>7. <A
HREF="#RELTOLF"
>Relationship To Other Linux Foundation Specifications</A
></DT
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SCOPE"
></A
>Chapter 1. Scope</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="GENSCOPE"
>1.1. General</A
></H2
><P
>The Linux Standard Base (LSB) defines a system interface for compiled
applications and a minimal environment for support of installation scripts.
Its purpose is to enable a uniform industry standard environment for
high-volume applications conforming to the LSB.</P
><P
>These specifications are composed of two basic parts: a common part
describing those parts of the interface that
remain constant across all implementations of the LSB, and an
architecture-specific part describing the
parts of the interface that vary by processor architecture.
Together, the common part and the relevant
architecture-specific part for a single hardware architecture provide a
complete interface specification for compiled application programs on systems
that share a common hardware architecture.</P
><P
>The LSB contains both a set of Application Program Interfaces (APIs)
and Application Binary Interfaces (ABIs). APIs may appear in the
source code of portable applications, while the compiled binary of that
application may use the larger set of ABIs. A conforming implementation
provides all of the ABIs listed here. The compilation system may
replace (e.g. by macro definition) certain APIs with calls to one or
more of the underlying binary interfaces, and may insert calls to binary
interfaces as needed.</P
><P
>The LSB is primarily a binary interface
definition. Not all of the source level APIs available to applications
may be contained in this specification.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MODSCOPE"
>1.2. Module Specific Scope</A
></H2
><P
>&#13;This is the common part of the Core module of the Linux Standard Base (LSB),
LSB Core - Generic.
This module provides the fundamental system interfaces, libraries,
and runtime environment upon which all conforming applications and
libraries depend.</P
><P
>&#13;LSB Core - Generic, the common part, should be used in conjunction with an
architecture-specific part. Whenever a section of the common part
is supplemented by architecture-specific information, the common part
includes a reference to the architecture-specific part. 
Architecture-specific parts of the LSB Core Specification
may also contain additional information that is not referenced in the
common part.</P
><P
>Interfaces described in this part of the LSB Core Specification are mandatory except 
where explicitly listed otherwise.
Interfaces described in the LSB Core module
are supplemented by other LSB modules.
All other modules depend on the presence of LSB Core.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NORMATIVEREFS"
></A
>Chapter 2. References</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="NORMATIVEREFSSECT"
>2.1. Normative References</A
></H2
><P
>The following specifications are incorporated by reference into
this specification. For dated references, only the edition cited
applies. For undated references, the latest edition of the referenced
specification (including any amendments) applies.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Where copies of a referenced specification are available on the World Wide Web,
a Uniform Resource Locator (URL) is given, for informative purposes only.
Such URL might at any given time resolve to a more recent copy of the 
specification, or be out of date (not resolve). 
Reference copies of specifications at the revision level indicated 
may be found at the Linux Foundation's 
<A
HREF="http://refspecs.linuxbase.org"
TARGET="_top"
>Reference Specifications</A
> site.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="STD.BASE"
></A
><P
><B
>Table 2-1. Normative References</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Title</TH
><TH
>URL</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="STD.FHS"
></A
><TD
>Filesystem Hierarchy Standard</TD
><TD
>Filesystem Hierarchy Standard (FHS) 3.0</TD
><TD
><A
HREF="http://refspecs.linuxbase.org/fhs"
TARGET="_top"
>http://refspecs.linuxbase.org/fhs</A
></TD
></TR
><TR
><A
NAME="STD.ISOC99"
></A
><TD
>ISO C (1999)</TD
><TD
>ISO/IEC 9899:1999 - Programming Languages -- C</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.ISOCXX"
></A
><TD
>ISO/IEC 14882: 2003 C++ Language</TD
><TD
>ISO/IEC 14882: 2003 Programming languages --C++</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.CXXABI"
></A
><TD
>Itanium&#8482; C++ ABI</TD
><TD
>Itanium&#8482; C++ ABI (Revision 1.86)</TD
><TD
><A
HREF="http://refspecs.linuxfoundation.org/cxxabi-1.86.html"
TARGET="_top"
>http://refspecs.linuxfoundation.org/cxxabi-1.86.html</A
></TD
></TR
><TR
><A
NAME="STD.LFS"
></A
><TD
>Large File Support</TD
><TD
>Large File Support</TD
><TD
><A
HREF="http://www.UNIX-systems.org/version2/whatsnew/lfs20mar.html"
TARGET="_top"
>http://www.UNIX-systems.org/version2/whatsnew/lfs20mar.html</A
></TD
></TR
><TR
><A
NAME="STD.LIBNCURSESW"
></A
><TD
>Libncursesw API</TD
><TD
>Libncursesw API</TD
><TD
><A
HREF="http://invisible-island.net/ncurses/man/ncurses.3x.html"
TARGET="_top"
>http://invisible-island.net/ncurses/man/ncurses.3x.html</A
></TD
></TR
><TR
><A
NAME="STD.NCURSESW"
></A
><TD
>Libncursesw Placeholder</TD
><TD
>Libncursesw Specification Placeholder</TD
><TD
><A
HREF="http://refspecs.linux-foundation.org/libncursesw/libncurses.html"
TARGET="_top"
>http://refspecs.linux-foundation.org/libncursesw/libncurses.html</A
></TD
></TR
><TR
><A
NAME="STD.SUSV3"
></A
><TD
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</TD
><TD
><P
>ISO/IEC 9945-1:2003   Information technology -- Portable Operating System Interface (POSIX) -- Part 1: Base Definitions</P
><P
>ISO/IEC 9945-2:2003 Information technology -- Portable Operating System Interface (POSIX) -- Part 2: System Interfaces</P
><P
>ISO/IEC 9945-3:2003   Information technology -- Portable Operating System Interface (POSIX) -- Part 3: Shell and Utilities</P
><P
>ISO/IEC 9945-4:2003   Information technology -- Portable Operating System Interface (POSIX) -- Part 4: Rationale</P
><P
>Including Technical Cor. 1: 2004</P
></TD
><TD
><A
HREF="http://www.unix.org/version3/"
TARGET="_top"
>http://www.unix.org/version3/</A
></TD
></TR
><TR
><A
NAME="STD.SUSV4"
></A
><TD
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</TD
><TD
>Portable Operating System Interface (POSIX) 2008 Edition / The Open Group Technical Standard Base Specifications, Issue 7</TD
><TD
><A
HREF="http://www.unix.org/version4/"
TARGET="_top"
>http://www.unix.org/version4/</A
></TD
></TR
><TR
><A
NAME="STD.SUSV2"
></A
><TD
>SUSv2</TD
><TD
>CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</TD
><TD
><A
HREF="http://www.opengroup.org/publications/catalog/un.htm"
TARGET="_top"
>http://www.opengroup.org/publications/catalog/un.htm</A
></TD
></TR
><TR
><A
NAME="STD.SVID.3"
></A
><TD
>SVID Issue 3</TD
><TD
>American Telephone and Telegraph Company, System V Interface Definition, Issue 3; Morristown, NJ, UNIX Press, 1989. (ISBN 0201566524)</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.SVID.4"
></A
><TD
>SVID Issue 4</TD
><TD
>System V Interface Definition, Fourth Edition</TD
><TD
><A
HREF="http://refspecs.linuxfoundation.org/svid4/"
TARGET="_top"
>http://refspecs.linuxfoundation.org/svid4/</A
></TD
></TR
><TR
><A
NAME="STD.GABI41"
></A
><TD
>System V ABI</TD
><TD
>System V Application Binary Interface, Edition 4.1</TD
><TD
><A
HREF="http://www.sco.com/developers/devspecs/gabi41.pdf"
TARGET="_top"
>http://www.sco.com/developers/devspecs/gabi41.pdf</A
></TD
></TR
><TR
><A
NAME="STD.ABIUPDATE"
></A
><TD
>System V ABI Update</TD
><TD
>System V Application Binary Interface - DRAFT - 17 December 2003</TD
><TD
><A
HREF="http://www.sco.com/developers/gabi/2003-12-17/contents.html"
TARGET="_top"
>http://www.sco.com/developers/gabi/2003-12-17/contents.html</A
></TD
></TR
><TR
><A
NAME="STD.X.CURSES"
></A
><TD
>X/Open Curses, Issue 7</TD
><TD
>X/Open Curses, Issue 7 (ISBN: 1-931624-83-6, The Open Group, November 2009)</TD
><TD
><A
HREF="https://www2.opengroup.org/ogsys/catalog/C094"
TARGET="_top"
>https://www2.opengroup.org/ogsys/catalog/C094</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATIVEREFS"
>2.2. Informative References/Bibliography</A
></H2
><P
>The documents listed below provide essential background
information to implementors of this specification. These references are
included for information only, and do not represent normative parts
of this specification.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN217"
></A
><P
><B
>Table 2-2. Other References</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Title</TH
><TH
>URL</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="STD.DWARF4"
></A
><TD
>DWARF Debugging Information Format, Version 4</TD
><TD
>DWARF Debugging Information Format, Version 4 (June 10, 2010)</TD
><TD
><A
HREF="http://www.dwarfstd.org/doc/DWARF4.pdf"
TARGET="_top"
>http://www.dwarfstd.org/doc/DWARF4.pdf</A
></TD
></TR
><TR
><A
NAME="STD.FLTPNT"
></A
><TD
>IEC 60559/IEEE 754 Floating Point</TD
><TD
>IEC 60559:1989 Binary floating-point arithmetic for microprocessor systems</TD
><TD
><A
HREF="http://www.ieee.org/"
TARGET="_top"
>http://www.ieee.org/</A
></TD
></TR
><TR
><A
NAME="STD.TR14652"
></A
><TD
>ISO/IEC TR14652</TD
><TD
>ISO/IEC Technical Report 14652:2002 Specification method for cultural conventions</TD
><TD
><A
HREF=""
TARGET="_top"
></A
></TD
></TR
><TR
><A
NAME="STD.ITUV42"
></A
><TD
>ITU-T V.42</TD
><TD
>International Telecommunication Union Recommendation V.42 (2002): Error-correcting procedures for DCEs using asynchronous-to-synchronous conversionITUV</TD
><TD
><A
HREF="http://www.itu.int/rec/recommendation.asp?type=folders&#38;lang=e&#38;parent=T-REC-V.42"
TARGET="_top"
>http://www.itu.int/rec/recommendation.asp?type=folders&#38;lang=e&#38;parent=T-REC-V.42</A
></TD
></TR
><TR
><A
NAME="STD.LI18NUX"
></A
><TD
>Li18nux Globalization Specification</TD
><TD
>LI18NUX 2000 Globalization Specification, Version 1.0 with Amendment 4</TD
><TD
><A
HREF="http://www.openi18n.org/docs/html/LI18NUX-2000-amd4.htm"
TARGET="_top"
>http://www.openi18n.org/docs/html/LI18NUX-2000-amd4.htm</A
></TD
></TR
><TR
><A
NAME="STD.DEVICES"
></A
><TD
>Linux Allocated Device Registry</TD
><TD
>LINUX ALLOCATED DEVICES</TD
><TD
><A
HREF="http://www.lanana.org/docs/device-list/devices-2.6+.txt"
TARGET="_top"
>http://www.lanana.org/docs/device-list/devices-2.6+.txt</A
></TD
></TR
><TR
><A
NAME="STD.LANANA"
></A
><TD
>Linux Assigned Names And Numbers Authority</TD
><TD
>Linux Assigned Names And Numbers Authority</TD
><TD
><A
HREF="http://www.lanana.org/"
TARGET="_top"
>http://www.lanana.org/</A
></TD
></TR
><TR
><A
NAME="STD.NSS.SSL"
></A
><TD
>Mozilla's NSS SSL Reference</TD
><TD
>Mozilla's NSS SSL Reference</TD
><TD
><A
HREF="http://www.mozilla.org/projects/security/pki/nss/ref/ssl/"
TARGET="_top"
>http://www.mozilla.org/projects/security/pki/nss/ref/ssl/</A
></TD
></TR
><TR
><A
NAME="STD.NSPR"
></A
><TD
>NSPR Reference</TD
><TD
>Mozilla's NSPR Reference</TD
><TD
><A
HREF="http://refspecs.linuxfoundation.org/NSPR_API_Reference/NSPR_API.html"
TARGET="_top"
>http://refspecs.linuxfoundation.org/NSPR_API_Reference/NSPR_API.html</A
></TD
></TR
><TR
><A
NAME="STD.PAM"
></A
><TD
>PAM</TD
><TD
>Open Software Foundation, Request For Comments: 86.0 , October 1995, V. Samar &#38; R.Schemers (SunSoft)</TD
><TD
><A
HREF="http://www.opengroup.org/tech/rfc/mirror-rfc/rfc86.0.txt"
TARGET="_top"
>http://www.opengroup.org/tech/rfc/mirror-rfc/rfc86.0.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1321"
></A
><TD
>RFC 1321: The MD5 Message-Digest Algorithm</TD
><TD
>IETF RFC 1321: The MD5 Message-Digest Algorithm</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1321.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1321.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1833"
></A
><TD
>RFC 1833: Binding Protocols for ONC RPC Version 2</TD
><TD
>IETF RFC 1833: Binding Protocols for ONC RPC Version 2</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1833.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1833.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1950"
></A
><TD
>RFC 1950: ZLIB Compressed Data Format Specication</TD
><TD
>IETF RFC 1950: ZLIB Compressed Data Format Specification</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1950.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1950.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1951"
></A
><TD
>RFC 1951: DEFLATE Compressed Data Format Specification</TD
><TD
>IETF RFC 1951: DEFLATE Compressed Data Format Specification version 1.3</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1951.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1951.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC1952"
></A
><TD
>RFC 1952: GZIP File Format Specification</TD
><TD
>IETF RFC 1952: GZIP file format specification version 4.3</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc1952.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1952.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC2440"
></A
><TD
>RFC 2440: OpenPGP Message Format</TD
><TD
>IETF RFC 2440: OpenPGP Message Format</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc2440.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2440.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC2821"
></A
><TD
>RFC 2821:Simple Mail Transfer Protocol</TD
><TD
>IETF RFC 2821: Simple Mail Transfer Protocol</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc2821.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2821.txt</A
></TD
></TR
><TR
><A
NAME="STD.RFC2822"
></A
><TD
>RFC 2822:Internet Message Format</TD
><TD
>IETF RFC 2822: Internet Message Format</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc2822.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2822.txt</A
></TD
></TR
><TR
><A
NAME="STD.RPC.XDR"
></A
><TD
>RFC 5531/4506 RPC &#38; XDR</TD
><TD
>IETF RFC 5531 &#38; 4506</TD
><TD
><A
HREF="http://www.ietf.org/"
TARGET="_top"
>http://www.ietf.org/</A
></TD
></TR
><TR
><A
NAME="STD.RFC791"
></A
><TD
>RFC 791:Internet Protocol</TD
><TD
>IETF RFC 791: Internet Protocol Specification</TD
><TD
><A
HREF="http://www.ietf.org/rfc/rfc791.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc791.txt</A
></TD
></TR
><TR
><A
NAME="STD.RPM"
></A
><TD
>RPM Package Format</TD
><TD
>RPM Package Format V3.0</TD
><TD
><A
HREF="http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html"
TARGET="_top"
>http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html</A
></TD
></TR
><TR
><A
NAME="STD.ZLIB"
></A
><TD
>zlib Manual</TD
><TD
>zlib 1.2 Manual</TD
><TD
><A
HREF="http://www.gzip.org/zlib/"
TARGET="_top"
>http://www.gzip.org/zlib/</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="REQUIREMENTS"
></A
>Chapter 3. Requirements</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="RLIBRARIES"
>3.1. Relevant Libraries</A
></H2
><P
>&#13;
The libraries listed in <A
HREF="#TBL-GLSB-STDLIB"
>Table 3-1</A
> shall
be available on a Linux Standard Base system, with the specified
runtime names. The libraries listed in <A
HREF="#TBL-LSBGENERIC-ARCHLIB"
>Table 3-2</A
>
are architecture specific, but shall be available on all LSB
conforming systems. This list may be supplemented or amended by the relevant
architecture specific part of the LSB Core Specification.&#13;</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-GLSB-STDLIB"
></A
><P
><B
>Table 3-1. Standard Library Names</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Library</TH
><TH
>Runtime Name</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="LIB.LIBCRYPT"
></A
><TD
>libcrypt</TD
><TD
>libcrypt.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBDL"
></A
><TD
>libdl</TD
><TD
>libdl.so.2</TD
></TR
><TR
><A
NAME="LIB.LIBGCC.S"
></A
><TD
>libgcc_s</TD
><TD
>libgcc_s.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBNCURSES"
></A
><TD
>libncurses</TD
><TD
>libncurses.so.5</TD
></TR
><TR
><A
NAME="LIB.LIBNCURSESW"
></A
><TD
>libncursesw</TD
><TD
>libncursesw.so.5</TD
></TR
><TR
><A
NAME="LIB.LIBNSPR4"
></A
><TD
>libnspr4</TD
><TD
>libnspr4.so</TD
></TR
><TR
><A
NAME="LIB.LIBNSS3"
></A
><TD
>libnss3</TD
><TD
>libnss3.so</TD
></TR
><TR
><A
NAME="LIB.LIBPAM"
></A
><TD
>libpam</TD
><TD
>libpam.so.0</TD
></TR
><TR
><A
NAME="LIB.LIBPTHREAD"
></A
><TD
>libpthread</TD
><TD
>libpthread.so.0</TD
></TR
><TR
><A
NAME="LIB.LIBRT"
></A
><TD
>librt</TD
><TD
>librt.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBSSL3"
></A
><TD
>libssl3</TD
><TD
>libssl3.so</TD
></TR
><TR
><A
NAME="LIB.LIBSTDCXX"
></A
><TD
>libstdcxx</TD
><TD
>libstdc++.so.6</TD
></TR
><TR
><A
NAME="LIB.LIBUTIL"
></A
><TD
>libutil</TD
><TD
>libutil.so.1</TD
></TR
><TR
><A
NAME="LIB.LIBZ"
></A
><TD
>libz</TD
><TD
>libz.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LSBGENERIC-ARCHLIB"
></A
><P
><B
>Table 3-2. Standard Library Names defined in the Architecture Specific Parts of the LSB Core Specification</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Library</TH
><TH
>Runtime Name</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="LIB.LIBC"
></A
><TD
>libc</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><A
NAME="LIB.LIBM"
></A
><TD
>libm</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><A
NAME="LIB.PROGINTERP"
></A
><TD
>proginterp</TD
><TD
>See architecture specific part.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>These libraries will be in an implementation-defined directory which
the dynamic linker shall search by default.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="IMPLEMENTATION"
>3.2. LSB Implementation Conformance</A
></H2
><P
>A conforming implementation is necessarily architecture specific,
and must provide the interfaces specified by both the generic LSB Core
specification (LSB Core - Generic) and the relevant architecture specific part
of the LSB Core Specification.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>An implementation must provide <I
CLASS="EMPHASIS"
>at least</I
>
the interfaces specified in these specifications.
It may also provide additional interfaces.</P
></BLOCKQUOTE
></DIV
></P
><P
>A conforming implementation shall satisfy the following requirements:</P
><P
><P
></P
><UL
><LI
><P
>A processor architecture represents a family of related processors
which may not have identical feature sets. The architecture
specific parts of the LSB Core Specification that supplement this specification for a given target
processor architecture describe a minimum acceptable processor.
The implementation shall provide all features of this processor,
whether in hardware or through emulation transparent
to the application.</P
></LI
><LI
><P
>The implementation shall be capable of executing compiled applications
having the format and using the system interfaces described in this
specification.</P
></LI
><LI
><P
>The implementation shall provide libraries containing the interfaces
specified by this specification, and shall provide a dynamic linking
mechanism that allows these interfaces to be attached to applications
at runtime. All the interfaces shall behave as specified in
this specification.</P
></LI
><LI
><P
>The map of virtual memory provided by the implementation shall conform 
to the requirements of this specification. </P
></LI
><LI
><P
>The implementation's low-level behavior with respect to function call
linkage, system traps, signals, and other such activities shall conform
to the formats described in this specification.</P
></LI
><LI
><P
>The implementation shall provide all of the mandatory interfaces
in their entirety. </P
></LI
><LI
><P
>The implementation may provide one or more of the optional
interfaces. Each optional interface that is provided shall be provided
in its entirety. The product documentation shall state which optional
interfaces are provided.</P
></LI
><LI
><P
>The implementation shall provide all files and utilities specified as
part of this specification in the format defined here and in other documents
normatively included by reference.  
All commands and utilities shall behave as required by this specification. 
The implementation shall also provide all mandatory components of an 
application's runtime environment that are included or referenced in 
this specification.</P
></LI
><LI
><P
>The implementation, when provided with standard data formats and
values at a named interface, shall provide the behavior defined for
those values and data formats at that interface. However, a conforming
implementation may consist of components which are separately packaged
and/or sold. For example, a vendor of a conforming implementation
might sell the hardware, operating system, and windowing system as
separately packaged items.</P
></LI
><LI
><P
>The implementation may provide additional interfaces with different
names. It may also provide additional behavior corresponding to data
values outside the standard ranges, for standard named interfaces.</P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APPLICATION"
>3.3. LSB Application Conformance</A
></H2
><P
>A conforming application containing object files
is necessarily architecture specific, and must
conform to both the generic LSB Core specification (LSB Core - Generic) and the
relevant architecture specific part of the LSB Core Specification.
A conforming application which contains no object files may be
architecture neutral. Architecture neutral applications shall conform only to
the requirements of the generic LSB Core specification (LSB Core - Generic).</P
><P
>A conforming application shall satisfy the following requirements: </P
><P
></P
><UL
><LI
><P
>Executable files shall be either object files in the format defined 
in the Object Format section of this specification,
or script files in a scripting language where the interpreter is
required by this specification.</P
></LI
><LI
><P
>Object files shall participate in dynamic linking as defined in the 
Program Loading and Linking section of this specification.</P
></LI
><LI
><P
>Object files shall employ only the instructions, traps, and other low-level 
facilities defined as being for use by applications 
in the Low-Level System Information section of this specification </P
></LI
><LI
><P
>If the application requires any optional interface defined in this specification
in order to be installed or to execute successfully, the requirement for that
optional interface shall be stated in the application's documentation.</P
></LI
><LI
><P
>The application shall not use any interface or data format that is not
required to be provided by a conforming implementation, unless
such an interface or data format is supplied by another application
through direct invocation of that application during execution.
The other application must also be a conforming application,
and the use of such interface or data format, as well as its source
(in other words, the other conforming application), shall
be identified in the documentation of the application.</P
></LI
><LI
><P
>The application shall not use any values for a named interface that are 
reserved for vendor extensions.</P
></LI
></UL
><P
>A strictly conforming application shall not require or use any interface,
facility, or implementation-defined extension not defined in
this specification in order to be installed or to execute successfully.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DEFS"
></A
>Chapter 4. Terms and Definitions</H1
><P
>For the purposes of this document, the terms given in 
<I
CLASS="CITETITLE"
>ISO/IEC Directives, Part 2, Annex H</I
> 
and the following apply.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>archLSB</DT
><DD
><P
>Some LSB specification documents have both a generic, architecture-neutral part and an architecture-specific part.  The latter describes elements
whose definitions may be unique to a particular processor architecture.
The term archLSB may be used in the generic part to refer to the corresponding
section of the architecture-specific part.</P
></DD
><DT
>Binary Standard, ABI</DT
><DD
><P
>The total set of interfaces that are available to be used in the compiled
binary code of a conforming application, including the run-time details
such as calling conventions, binary format, C++ name mangling, etc.</P
></DD
><DT
>Implementation-defined</DT
><DD
><P
>Describes a value or behavior that is not defined by this document but
is selected by an implementor. The value or behavior may vary among
implementations that conform to this document. An application should
not rely on the existence of the value or behavior. An application
that relies on such a value or behavior cannot be assured to be
portable across conforming implementations.  The implementor shall
document such a value or behavior so that it can be used correctly by
an application.</P
></DD
><DT
>Shell Script</DT
><DD
><P
>A file that is read by an interpreter (e.g., awk). The first line of
the shell script includes a reference to its interpreter binary.</P
></DD
><DT
>Source Standard, API</DT
><DD
><P
>The total set of interfaces that are available to be used in the source
code of a conforming application.  Due to translations, the Binary
Standard and the Source Standard may contain some different interfaces.</P
></DD
><DT
>Undefined</DT
><DD
><P
>Describes the nature of a value or behavior not defined by this document
which results from use of an invalid program construct or invalid
data input.  The value or behavior may vary among implementations that
conform to this document. An application should not rely on the existence
or validity of the value or behavior. An application that relies on any
particular value or behavior cannot be assured to be portable across
conforming implementations.</P
></DD
><DT
>Unspecified</DT
><DD
><P
>Describes the nature of a value or behavior not specified by this document
which results from use of a valid program construct or valid data input.
The value or behavior may vary among implementations that conform to this
document. An application should not rely on the existence or validity
of the value or behavior. An application that relies on any particular
value or behavior cannot be assured to be portable across conforming
implementations.</P
></DD
></DL
></DIV
><P
>In addition, for the portions of this specification which
build on IEEE Std 1003.1-2001, the definitions given in
<I
CLASS="CITETITLE"
>IEEE Std 1003.1-2001, Base Definitions, Chapter 3</I
>
apply.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DOCCONV"
></A
>Chapter 5. Documentation Conventions</H1
><P
>Throughout this document, the following typographic conventions are used:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN498"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FUNCTION"
>function()</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the name of a function</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN503"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>command</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the name of a command or utility</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN508"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>CONSTANT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a constant value</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN513"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>parameter</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a parameter</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN518"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="VARNAME"
>variable</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a variable</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>Throughout this specification, 
several tables of interfaces are presented. Each entry in these tables
has the following format:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN525"
></A
><SPAN
STYLE="white-space: nowrap"
>name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the name of the interface</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN529"
></A
><SPAN
STYLE="white-space: nowrap"
>(symver)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An optional symbol version identifier, if required.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN533"
></A
><SPAN
STYLE="white-space: nowrap"
>[<TT
CLASS="REPLACEABLE"
><I
>refno</I
></TT
>]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A reference number indexing the table of referenced specifications
that follows this table.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>For example,
<DIV
CLASS="INFORMALTABLE"
><P
></P
><A
NAME="AEN539"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>forkpty(GLIBC_2.0) [SUSv4]</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
refers to the interface named <TT
CLASS="FUNCTION"
>forkpty()</TT
>
with symbol version <CODE
CLASS="CONSTANT"
>GLIBC_2.0</CODE
> that is defined in the
reference indicated by the tag <TT
CLASS="LITERAL"
>SUSv4</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>For symbols with versions which differ between architectures,
the symbol versions are defined in the architecture specific parts of 
of this module specification only. 
In the generic part, they will appear without symbol versions.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="POSIXCONFLICTS"
></A
>Chapter 6. Relationship To ISO/IEC 9945 POSIX</H1
><P
>This specification includes many interfaces described in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
Unless otherwise specified, such interfaces should behave exactly 
as described in that specification.
Any conflict between the requirements described here and the 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> standard is unintentional, 
except as explicitly noted otherwise.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In addition to the differences noted in this specification, a report,
<I
CLASS="CITETITLE"
>ISO/IEC TR 24715-Technical Report on the Conflicts Between the
ISO/IEC 9945 (POSIX) Standard and the Linux Standard Base Specification (LSB)</I
>,
identifies the differences between edition 3.1 of this specification and 
<I
CLASS="CITETITLE"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</I
> (more
precisely, POSIX 2001 plus the first two corrigenda, informally known as
the 2004 edition).
It is the long term plan of the Linux Foundation to converge the 
LSB Core specification with the ISO/IEC POSIX specification.</P
></BLOCKQUOTE
></DIV
><P
>The LSB Specification Authority is responsible for deciding the meaning
of conformance to normative referenced standards in the LSB context.
Problem reports regarding underlying or referenced standards in any
other context will be referred to the relevant maintenance body for 
that standard.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="RELTOLF"
></A
>Chapter 7. Relationship To Other Linux Foundation Specifications</H1
><P
>The LSB is the base for several other specification projects under
the umbrella of the Linux Foundation (LF). This specification is the
foundation, and other specifications build on the interfaces defined
here. However, beyond those specifications listed as Normative References,
this specification has no dependencies on other LF projects.</P
><P
>ISO/IEC 23360 corresponds to an earlier edition of this specification
(version 3.1), published
as an ISO/IEC standard in 2006 after submission by the Linux Foundation.
The ISO edition is also the subject of the technical report 
ISO/IEC TR 24715 referenced in the previous chapter.</P
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="ELF-GENERIC"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>II. Executable And Linking Format (ELF)</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>8. <A
HREF="#ELFINTRO"
>Introduction</A
></DT
><DT
>9. <A
HREF="#LOWLEVEL"
>Low Level System Information</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#OSINTERFACE"
>Operating System Interface</A
></DT
><DT
>9.2. <A
HREF="#MACHINEINTERFACE"
>Machine Interface</A
></DT
><DD
><DL
><DT
>9.2.1. <A
HREF="#DATAREPRESENTATION"
>Data Representation</A
></DT
></DL
></DD
></DL
></DD
><DT
>10. <A
HREF="#TOCOBJFORMAT"
>Object Format</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#OBJFMT"
>Object Files</A
></DT
><DT
>10.2. <A
HREF="#SECTIONS"
>Sections</A
></DT
><DD
><DL
><DT
>10.2.1. <A
HREF="#AEN623"
>Introduction</A
></DT
><DT
>10.2.2. <A
HREF="#ELFTYPES"
>Sections Types</A
></DT
></DL
></DD
><DT
>10.3. <A
HREF="#SPECIALSECTIONS"
>Special Sections</A
></DT
><DD
><DL
><DT
>10.3.1. <A
HREF="#ELFSPECIAL"
>Special Sections</A
></DT
></DL
></DD
><DT
>10.4. <A
HREF="#SYMMAP"
>Symbol Mapping</A
></DT
><DD
><DL
><DT
>10.4.1. <A
HREF="#AEN1086"
>Introduction</A
></DT
></DL
></DD
><DT
>10.5. <A
HREF="#DWARFEXT"
>DWARF Extensions</A
></DT
><DD
><DL
><DT
>10.5.1. <A
HREF="#DWARFEHENCODING"
>DWARF Exception Header Encoding</A
></DT
><DT
>10.5.2. <A
HREF="#DWARFCFIEXT"
>DWARF CFI Extensions</A
></DT
></DL
></DD
><DT
>10.6. <A
HREF="#EHFRAMECHPT"
>Exception Frames</A
></DT
><DD
><DL
><DT
>10.6.1. <A
HREF="#EHFRAME"
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section</A
></DT
><DT
>10.6.2. <A
HREF="#EHFRAMEHDR"
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section</A
></DT
></DL
></DD
><DT
>10.7. <A
HREF="#SYMVERSION"
>Symbol Versioning</A
></DT
><DD
><DL
><DT
>10.7.1. <A
HREF="#AEN1505"
>Introduction</A
></DT
><DT
>10.7.2. <A
HREF="#SYMVERTBL"
>Symbol Version Table</A
></DT
><DT
>10.7.3. <A
HREF="#SYMVERDEFS"
>Version Definitions</A
></DT
><DT
>10.7.4. <A
HREF="#SYMVERRQMTS"
>Version Requirements</A
></DT
><DT
>10.7.5. <A
HREF="#SYMSTARTSEQ"
>Startup Sequence</A
></DT
><DT
>10.7.6. <A
HREF="#SYMRESOLUTION"
>Symbol Resolution</A
></DT
></DL
></DD
><DT
>10.8. <A
HREF="#NOTEABITAG"
>ABI note tag</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#TOCDYNLNK"
>Dynamic Linking</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#DYNLNK"
>Program Loading and Dynamic Linking</A
></DT
><DT
>11.2. <A
HREF="#PROGHEADER"
>Program Header</A
></DT
><DT
>11.3. <A
HREF="#DYNAMICSECTION"
>Dynamic Entries</A
></DT
><DD
><DL
><DT
>11.3.1. <A
HREF="#AEN1782"
>Introduction</A
></DT
><DT
>11.3.2. <A
HREF="#DYNSECTENT"
>Dynamic Entries</A
></DT
></DL
></DD
></DL
></DD
><DT
>12. <A
HREF="#CXXCLASSES"
>C++ Class Representations</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#CXXDATAREPRESENTATION"
>C++ Data Representation</A
></DT
><DD
><DL
><DT
>12.1.1. <A
HREF="#CLASSES"
>Class Representation</A
></DT
></DL
></DD
></DL
></DD
><DT
>13. <A
HREF="#SYMMAP.CXX"
>Symbol Mapping</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#SYMMAPPING"
>Symbol Mapping</A
></DT
><DD
><DL
><DT
>13.1.1. <A
HREF="#AEN2155"
>C++ Language</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="ELFINTRO"
></A
>Chapter 8. Introduction</H1
><P
>Executable and Linking Format (ELF) defines the object format for compiled
applications. This specification supplements the information found in
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
> and is intended to document additions made
since the publication of that document.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOWLEVEL"
></A
>Chapter 9. Low Level System Information</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="OSINTERFACE"
>9.1. Operating System Interface</A
></H2
><P
>LSB-conforming applications shall assume that stack, heap and other allocated
memory regions will be non-executable. The application must take steps to
make them executable if needed.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MACHINEINTERFACE"
>9.2. Machine Interface</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="DATAREPRESENTATION"
>9.2.1. Data Representation</A
></H3
><P
>LSB-conforming applications shall use the data representation as defined in 
the Arcitecture specific ELF documents.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="FUNDAMENTALTYES"
>9.2.1.1. Fundamental Types</A
></H4
><P
>In addition to the fundamental types specified in the relevant architecture specific part of the LSB Core Specification,
a 1 byte data type is defined here.
<DIV
CLASS="TABLE"
><A
NAME="AEN582"
></A
><P
><B
>Table 9-1. Scalar Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Type</TH
><TH
>C</TH
><TH
>C++</TH
><TH
><SAMP
CLASS="COMPUTEROUTPUT"
>sizeof</SAMP
></TH
><TH
>Alignment (bytes)</TH
><TH
>Architecture Representation</TH
></TR
></THEAD
><TBODY
><TR
><TD
ROWSPAN="3"
VALIGN="MIDDLE"
>Integral</TD
><TD
>_Bool</TD
><TD
>bool</TD
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
><SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
></TD
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
>1</TD
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
>byte</TD
></TR
></TBODY
></TABLE
></DIV
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TOCOBJFORMAT"
></A
>Chapter 10. Object Format</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="OBJFMT"
>10.1. Object Files</A
></H2
><P
>LSB-conforming implementations shall support the 
Executable and Linking Format (ELF) object file format as 
defined by the following documents:
<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
><A
HREF="#STD.GABI41"
>System V ABI</A
></P
></LI
><LI
STYLE="list-style-type: disc"
><P
><A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
></P
></LI
><LI
STYLE="list-style-type: disc"
><P
>the relevant architecture specific ABI supplement.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>this specification</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>the relevant architecture specific part of the LSB Core Specification</P
></LI
></UL
>
Conforming implementations may also support other unspecified object file formats.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECTIONS"
>10.2. Sections</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN623"
>10.2.1. Introduction</A
></H3
><P
>As described in <A
HREF="#STD.GABI41"
>System V ABI</A
>,
an ELF object file contains a number of <I
CLASS="EMPHASIS"
>sections</I
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ELFTYPES"
>10.2.2. Sections Types</A
></H3
><P
>The section header table is an array of 
<TT
CLASS="STRUCTNAME"
>Elf32_Shdr</TT
> or 
<TT
CLASS="STRUCTNAME"
>Elf64_Shdr</TT
> structures as 
described in <A
HREF="#STD.GABI41"
>System V ABI</A
>. The 
<CODE
CLASS="STRUCTFIELD"
>sh_type</CODE
> member shall be either a value from
<A
HREF="#TBL.ABIUPDATE"
>Table 10-1</A
>, drawn from the System V 
ABI, or one of the additional values specified in <A
HREF="#TBL.LSB"
>Table 10-2</A
>.</P
><P
>A section header's <CODE
CLASS="STRUCTFIELD"
>sh_type</CODE
> member specifies the sections's semantics.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN639"
>10.2.2.1. ELF Section Types</A
></H4
><P
>The following section types are defined in the 
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and the
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>.
<DIV
CLASS="TABLE"
><A
NAME="TBL.ABIUPDATE"
></A
><P
><B
>Table 10-1. ELF Section Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Value</TH
><TH
ALIGN="CENTER"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="SECTTYPE.SHTDYNAMIC"
></A
><TD
>SHT_DYNAMIC</TD
><TD
>0x6</TD
><TD
>The section holds information for dynamic linking. Currently, an object file shall have only one dynamic section, but this restriction may be relaxed in the future. See `Dynamic Section' in Chapter 5 of System V ABI Update for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTDYNSYM"
></A
><TD
>SHT_DYNSYM</TD
><TD
>0xb</TD
><TD
>This section holds a minimal set of symbols adequate for dynamic linking. See 

also SHT_SYMTAB. Currently, an object file may have either a section of 

SHT_SYMTAB type or a section of SHT_DYNSYM type, but not both. This restriction 

may be relaxed in the future.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTFINIARRAY"
></A
><TD
>SHT_FINI_ARRAY</TD
><TD
>0xf</TD
><TD
>This section contains an array of pointers to termination functions, as described in `Initialization and Termination Functions' in Chapter 5 of System V ABI Update. Each pointer in the array is taken as a parameterless procedure with a void return.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTHASH"
></A
><TD
>SHT_HASH</TD
><TD
>0x5</TD
><TD
>The section holds a symbol hash table. Currently, an object file shall have only one hash table, but this restriction may be relaxed in the future. See `Hash Table' in Chapter 5 of System V ABI Update for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTINITARRAY"
></A
><TD
>SHT_INIT_ARRAY</TD
><TD
>0xe</TD
><TD
>This section contains an array of pointers to initialization functions, as described in `Initialization and Termination Functions' in Chapter 5 of System V ABI Update. Each pointer in the array is taken as a parameterless procedure with a void return.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTNOBITS"
></A
><TD
>SHT_NOBITS</TD
><TD
>0x8</TD
><TD
>A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTNOTE"
></A
><TD
>SHT_NOTE</TD
><TD
>0x7</TD
><TD
>The section holds information that marks the file in some way. See `Note Section' in Chapter 5 of System V ABI Update for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTNULL"
></A
><TD
>SHT_NULL</TD
><TD
>0x0</TD
><TD
>This value marks the section header as inactive; it does not have an associated section. Other members of the section header have undefined values.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTPREINITARRAY"
></A
><TD
>SHT_PREINIT_ARRAY</TD
><TD
>0x10</TD
><TD
>This section contains an array of pointers to functions that are invoked before all other initialization functions, as described in `Initialization and Termination Functions' in Chapter 5 of System V ABI Update. Each pointer in the array is taken as a parameterless proceure with a void return.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTPROGBITS"
></A
><TD
>SHT_PROGBITS</TD
><TD
>0x1</TD
><TD
>The section holds information defined by the program, whose format and meaning are determined solely by the program.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTREL"
></A
><TD
>SHT_REL</TD
><TD
>0x9</TD
><TD
>The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files or type Elf64_Rel for the 64-bit class of object files. An object file may have multiple relocation sections. See `Relocation' in Chapter 4 of System V ABI Update for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTRELA"
></A
><TD
>SHT_RELA</TD
><TD
>0x4</TD
><TD
>The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files or type Elf64_Rela for the 64-bit class of object files. An object file may have multiple relocation sections. See `Relocation' in Chapter 4 of System V ABI Update for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTSTRTAB"
></A
><TD
>SHT_STRTAB</TD
><TD
>0x3</TD
><TD
>The section holds a string table. An object file may have multiple string table sections. See `String Table' in Chapter 4 of System V ABI Update for details.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTSYMTAB"
></A
><TD
>SHT_SYMTAB</TD
><TD
>0x2</TD
><TD
>This section holds a symbol table. Currently, an object file may have either a 

section of SHT_SYMTAB type or a section of SHT_DYNSYM type, but not both. This 

restriction may be relaxed in the future. Typically, SHT_SYMTAB provides 

symbols for link editing, though it may also be used for dynamic linking. As a 

complete symbol table, it may contain many symbols unnecessary for dynamic 

linking.</TD
></TR
></TBODY
></TABLE
></DIV
>&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN709"
>10.2.2.2. Additional Section Types</A
></H4
><P
>The following additional section types are defined here.

<DIV
CLASS="TABLE"
><A
NAME="TBL.LSB"
></A
><P
><B
>Table 10-2. Additional Section Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Value</TH
><TH
ALIGN="CENTER"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><A
NAME="SECTTYPE.SHTGNUVERDEF"
></A
><TD
>SHT_GNU_verdef</TD
><TD
>0x6ffffffd</TD
><TD
>This section contains the symbol versions that are provided.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTGNUVERNEED"
></A
><TD
>SHT_GNU_verneed</TD
><TD
>0x6ffffffe</TD
><TD
>This section contains the symbol versions that are required.</TD
></TR
><TR
><A
NAME="SECTTYPE.SHTGNUVERSYM"
></A
><TD
>SHT_GNU_versym</TD
><TD
>0x6fffffff</TD
><TD
>This section contains the Symbol Version Table.</TD
></TR
></TBODY
></TABLE
></DIV
>&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPECIALSECTIONS"
>10.3. Special Sections</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="ELFSPECIAL"
>10.3.1. Special Sections</A
></H3
><P
>Various sections hold program and control information. Sections in the lists below are used by the system and have the indicated types and attributes.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN738"
>10.3.1.1. ELF Special Sections</A
></H4
><P
>The following sections are defined in the
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and the
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>.
<DIV
CLASS="TABLE"
><A
NAME="AEN743"
></A
><P
><B
>Table 10-3. ELF Special Sections</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Attributes</TH
></TR
></THEAD
><TBODY
><TR
><TD
>.bss</TD
><TD
>SHT_NOBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.comment</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_MERGE+SHF_STRINGS</TD
></TR
><TR
><TD
>.data</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.data1</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.debug</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.dynamic</TD
><TD
>SHT_DYNAMIC</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.dynstr</TD
><TD
>SHT_STRTAB</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.dynsym</TD
><TD
>SHT_DYNSYM</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.fini</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_EXECINSTR</TD
></TR
><TR
><TD
>.fini_array</TD
><TD
>SHT_FINI_ARRAY</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.hash</TD
><TD
>SHT_HASH</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.init</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_EXECINSTR</TD
></TR
><TR
><TD
>.init_array</TD
><TD
>SHT_INIT_ARRAY</TD
><TD
> SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.interp</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.line</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.note</TD
><TD
>SHT_NOTE</TD
><TD
>0</TD
></TR
><TR
><TD
>.preinit_array</TD
><TD
>SHT_PREINIT_ARRAY</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.rodata</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_MERGE+SHF_STRINGS</TD
></TR
><TR
><TD
>.rodata1</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_MERGE+SHF_STRINGS</TD
></TR
><TR
><TD
>.shstrtab</TD
><TD
>SHT_STRTAB</TD
><TD
>0</TD
></TR
><TR
><TD
>.strtab</TD
><TD
>SHT_STRTAB</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.symtab</TD
><TD
>SHT_SYMTAB</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.tbss</TD
><TD
>SHT_NOBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE+SHF_TLS</TD
></TR
><TR
><TD
>.tdata</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE+SHF_TLS</TD
></TR
><TR
><TD
>.text</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_EXECINSTR</TD
></TR
></TBODY
></TABLE
></DIV
>
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN853"
></A
><SPAN
STYLE="white-space: nowrap"
>.bss</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds data that contributes to the program's memory image. The 

program may treat this data as uninitialized. However, the system shall 

initialize this data with zeroes when the program begins to run.

The section occupies no file space, as indicated by the section type, SHT_NOBITS.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN857"
></A
><SPAN
STYLE="white-space: nowrap"
>.comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds version control information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN861"
></A
><SPAN
STYLE="white-space: nowrap"
>.data</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized data that contribute to the program's memory image.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN865"
></A
><SPAN
STYLE="white-space: nowrap"
>.data1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized data that contribute to the program's memory image.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN869"
></A
><SPAN
STYLE="white-space: nowrap"
>.debug</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds information for symbolic debugging. The contents are unspecified. All section names with the prefix .debug hold information for symbolic debugging. The contents of these sections are unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN873"
></A
><SPAN
STYLE="white-space: nowrap"
>.dynamic</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds dynamic linking information. The section's attributes will include the SHF_ALLOC bit. Whether the SHF_WRITE bit is set is processor specific. See Chapter 5 of System V ABI Update for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN877"
></A
><SPAN
STYLE="white-space: nowrap"
>.dynstr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds strings needed for dynamic linking, most commonly the strings that represent the names associated with symbol table entries. See Chapter 5 of System V ABI Update for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN881"
></A
><SPAN
STYLE="white-space: nowrap"
>.dynsym</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the dynamic linking symbol table, as described in `Symbol Table' of System V ABI Update.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN885"
></A
><SPAN
STYLE="white-space: nowrap"
>.fini</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN889"
></A
><SPAN
STYLE="white-space: nowrap"
>.fini_array</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds an array of function pointers that contributes to a single termination array for the executable or shared object containing the section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN893"
></A
><SPAN
STYLE="white-space: nowrap"
>.hash</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds a symbol hash table. See `Hash Table' in Chapter 5 of System V ABI Update for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN897"
></A
><SPAN
STYLE="white-space: nowrap"
>.init</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds executable instructions that contribute to the process initialization code. When a program starts to run, the system arranges to execute the code in this section before calling the main program entry point (called main for C programs).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN901"
></A
><SPAN
STYLE="white-space: nowrap"
>.init_array</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds an array of function pointers that contributes to a single initialization array for the executable or shared object containing the section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN905"
></A
><SPAN
STYLE="white-space: nowrap"
>.interp</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the path name of a program interpreter. If the file has a loadable segment that includes relocation, the sections' attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. See Chapter 5 of System V ABI Update for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN909"
></A
><SPAN
STYLE="white-space: nowrap"
>.line</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds line number information for symbolic debugging, which describes the correspondence between the source program and the machine code. The contents are unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN913"
></A
><SPAN
STYLE="white-space: nowrap"
>.note</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds information in the format that `Note Section' in Chapter 5 of System V ABI Update describes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN917"
></A
><SPAN
STYLE="white-space: nowrap"
>.preinit_array</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds an array of function pointers that contributes to a single pre-initialization array for the executable or shared object containing the section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN921"
></A
><SPAN
STYLE="white-space: nowrap"
>.rodata</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds read-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 of System V ABI Update for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN925"
></A
><SPAN
STYLE="white-space: nowrap"
>.rodata1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds read-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 of System V ABI Update for more information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN929"
></A
><SPAN
STYLE="white-space: nowrap"
>.shstrtab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds section names.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN933"
></A
><SPAN
STYLE="white-space: nowrap"
>.strtab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds strings, most commonly the strings that represent the names associated with symbol table entries. If the file has a loadable segment that includes the symbol string table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN937"
></A
><SPAN
STYLE="white-space: nowrap"
>.symtab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds a symbol table, as `Symbol Table' in Chapter 4 of System V ABI Update describes. If the file has a loadable segment that includes the symbol table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN941"
></A
><SPAN
STYLE="white-space: nowrap"
>.tbss</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds uninitialized thread-local data that contribute to the program's memory image. By definition, the system initializes the data with zeros when the data is instantiated for each new execution flow. The section occupies no file space, as indicated by the section type, SHT_NOBITS. Implementations need not support thread-local storage.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN945"
></A
><SPAN
STYLE="white-space: nowrap"
>.tdata</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized thread-local data that contributes to the program's memory image. A copy of its contents is instantiated by the system for each new execution flow. Implementations need not support thread-local storage.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN949"
></A
><SPAN
STYLE="white-space: nowrap"
>.text</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the `text', or executable instructions, of a program.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN953"
>10.3.1.2. Additional Special Sections</A
></H4
><P
>Object files in an LSB conforming application may also contain one or more of 
the additional special sections described below.
<DIV
CLASS="TABLE"
><A
NAME="AEN956"
></A
><P
><B
>Table 10-4. Additional Special Sections</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Attributes</TH
></TR
></THEAD
><TBODY
><TR
><TD
>.ctors</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.data.rel.ro</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.dtors</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.eh_frame</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.eh_frame_hdr</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gcc_except_table</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gnu.version</TD
><TD
>SHT_GNU_versym</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gnu.version_d</TD
><TD
>SHT_GNU_verdef</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.gnu.version_r</TD
><TD
>SHT_GNU_verneed</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.got.plt</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.jcr</TD
><TD
>SHT_PROGBITS</TD
><TD
>SHF_ALLOC+SHF_WRITE</TD
></TR
><TR
><TD
>.note.ABI-tag</TD
><TD
>SHT_NOTE</TD
><TD
>SHF_ALLOC</TD
></TR
><TR
><TD
>.stab</TD
><TD
>SHT_PROGBITS</TD
><TD
>0</TD
></TR
><TR
><TD
>.stabstr</TD
><TD
>SHT_STRTAB</TD
><TD
>0</TD
></TR
></TBODY
></TABLE
></DIV
>
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1022"
></A
><SPAN
STYLE="white-space: nowrap"
>.ctors</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains a list of global constructor function pointers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1026"
></A
><SPAN
STYLE="white-space: nowrap"
>.data.rel.ro</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds initialized data that contribute to the program's memory image. This section may be made read-only after relocations have been applied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1030"
></A
><SPAN
STYLE="white-space: nowrap"
>.dtors</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains a list of global destructor function pointers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1034"
></A
><SPAN
STYLE="white-space: nowrap"
>.eh_frame</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains information necessary for frame unwinding during exception handling. See <A
HREF="#EHFRAME"
>Section 10.6.1</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1039"
></A
><SPAN
STYLE="white-space: nowrap"
>.eh_frame_hdr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains a pointer to the .eh_frame section which is accessible to the runtime support code of a C++ application. This section may also contain a binary search table which may be used by the runtime support code to more efficiently access records in the .eh_frame section. See <A
HREF="#EHFRAMEHDR"
>Section 10.6.2</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1044"
></A
><SPAN
STYLE="white-space: nowrap"
>.gcc_except_table</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds Language Specific Data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1048"
></A
><SPAN
STYLE="white-space: nowrap"
>.gnu.version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains the Symbol Version Table. See <A
HREF="#SYMVERTBL"
>Section 10.7.2</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1053"
></A
><SPAN
STYLE="white-space: nowrap"
>.gnu.version_d</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains the Version Definitions. See <A
HREF="#SYMVERDEFS"
>Section 10.7.3</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1058"
></A
><SPAN
STYLE="white-space: nowrap"
>.gnu.version_r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains the Version Requirements. See <A
HREF="#SYMVERRQMTS"
>Section 10.7.4</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1063"
></A
><SPAN
STYLE="white-space: nowrap"
>.got.plt</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section holds the read-only portion of the GLobal Offset Table. This section may be made read-only after relocations have been applied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1067"
></A
><SPAN
STYLE="white-space: nowrap"
>.jcr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains information necessary for registering compiled

Java classes. The contents are compiler-specific and used by compiler

initialization functions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1071"
></A
><SPAN
STYLE="white-space: nowrap"
>.note.ABI-tag</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specify ABI details. See <A
HREF="#NOTEABITAG"
>Section 10.8</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1076"
></A
><SPAN
STYLE="white-space: nowrap"
>.stab</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains debugging information. The contents are not specified as part of the LSB.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1080"
></A
><SPAN
STYLE="white-space: nowrap"
>.stabstr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section contains strings associated with the debugging infomation contained in the .stab section.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYMMAP"
>10.4. Symbol Mapping</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1086"
>10.4.1. Introduction</A
></H3
><P
>Symbols in a source program are translated by the compilation system into
symbols that exist in the object file. </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1089"
>10.4.1.1. C Language</A
></H4
><P
>External C symbols shall be unchanged in an object file's symbol table.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DWARFEXT"
>10.5. DWARF Extensions</A
></H2
><P
>The LSB does not specify debugging information, however, some additional
sections contain information which is encoded using the the encoding as
specified by <A
HREF="#STD.DWARF4"
>DWARF Debugging Information Format, Version 4</A
> with extensions defined here.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DWARFEHENCODING"
>10.5.1. DWARF Exception Header Encoding</A
></H3
><P
>The DWARF Exception Header Encoding is used to describe the type of data used
in the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
>  and
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section. The upper 4
bits indicate how the value is to be applied. The lower 4 bits indicate the
format of the data.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1101"
></A
><P
><B
>Table 10-5. DWARF Exception Header value format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DW_EH_PE_absptr</TD
><TD
>0x00</TD
><TD
>The Value is a literal pointer whose size is determined by the architecture.</TD
></TR
><TR
><TD
>DW_EH_PE_uleb128</TD
><TD
>0x01</TD
><TD
>Unsigned value is encoded using the Little Endian Base 128 (LEB128)
as defined by <A
HREF="#STD.DWARF4"
>DWARF Debugging Information Format, Version 4</A
>.</TD
></TR
><TR
><TD
>DW_EH_PE_udata2</TD
><TD
>0x02</TD
><TD
>A 2 bytes unsigned value.</TD
></TR
><TR
><TD
>DW_EH_PE_udata4</TD
><TD
>0x03</TD
><TD
>A 4 bytes unsigned value.</TD
></TR
><TR
><TD
>DW_EH_PE_udata8</TD
><TD
>0x04</TD
><TD
>An 8 bytes unsigned value.</TD
></TR
><TR
><TD
>DW_EH_PE_sleb128</TD
><TD
>0x09</TD
><TD
>Signed value is encoded using the Little Endian Base 128 (LEB128)
as defined by <A
HREF="#STD.DWARF4"
>DWARF Debugging Information Format, Version 4</A
>.</TD
></TR
><TR
><TD
>DW_EH_PE_sdata2</TD
><TD
>0x0A</TD
><TD
>A 2 bytes signed value.</TD
></TR
><TR
><TD
>DW_EH_PE_sdata4</TD
><TD
>0x0B</TD
><TD
>A 4 bytes signed value.</TD
></TR
><TR
><TD
>DW_EH_PE_sdata8</TD
><TD
>0x0C</TD
><TD
>An 8 bytes signed value.</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN1148"
></A
><P
><B
>Table 10-6. DWARF Exception Header application</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DW_EH_PE_pcrel</TD
><TD
>0x10</TD
><TD
>Value is relative to the current program counter.</TD
></TR
><TR
><TD
>DW_EH_PE_textrel</TD
><TD
>0x20</TD
><TD
>Value is relative to the beginning of the .text section.</TD
></TR
><TR
><TD
>DW_EH_PE_datarel</TD
><TD
>0x30</TD
><TD
>Value is relative to the beginning of the .got or .eh_frame_hdr section.</TD
></TR
><TR
><TD
>DW_EH_PE_funcrel</TD
><TD
>0x40</TD
><TD
>Value is relative to the beginning of the function.</TD
></TR
><TR
><TD
>DW_EH_PE_aligned</TD
><TD
>0x50</TD
><TD
>Value is aligned to an address unit sized boundary.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>One special encoding, 0xff (DW_EH_PE_omit), shall be used to indicate that no value ispresent.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DWARFCFIEXT"
>10.5.2. DWARF CFI Extensions</A
></H3
><P
>In addition to the Call Frame Instructions defined in section 6.4.2 of <A
HREF="#STD.DWARF4"
>DWARF Debugging Information Format, Version 4</A
>,
the following additional Call Frame Instructions may also be used.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1182"
></A
><P
><B
>Table 10-7. Additional DWARF Call Frame Instructions</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>DW_CFA_GNU_args_size</TD
><TD
>0x2e</TD
><TD
>The DW_CFA_GNU_args_size instruction takes an unsigned LEB128 operand
representing an argument size. This instruction specifies the total of the
size of the arguments which have been pushed onto the stack.</TD
></TR
><TR
><TD
>DW_CFA_GNU_negative_offset_extended</TD
><TD
>0x2f</TD
><TD
>The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128 value representing a register
number and an unsigned LEB128 which represents the magnitude of the offset. This instruction is identical
to DW_CFA_offset_extended_sf except that the operand is subtracted to produce the offset. This
instructions is obsoleted by DW_CFA_offset_extended_sf.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="EHFRAMECHPT"
>10.6. Exception Frames</A
></H2
><P
>When using languages that support exceptions, such as C++, additional
information must be provided to the runtime environment that describes
the call frames that must be unwound during the processing of an exception.
This information is contained in the special sections
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> and
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_framehdr</SAMP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The format of the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section is similar
in format and purpose to the <SAMP
CLASS="COMPUTEROUTPUT"
>.debug_frame</SAMP
>
section which is specified in <A
HREF="#STD.DWARF4"
>DWARF Debugging Information Format, Version 4</A
>.
Readers are advised that there are some subtle difference,
and care should be taken when comparing the two sections.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EHFRAME"
>10.6.1. The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section</A
></H3
><P
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section shall contain 1 or more
Call Frame Information (CFI) records. The number of records present shall be
determined by size of the section as contained in the section header.
Each CFI record contains a Common Information Entry (CIE) record followed by
1 or more Frame Description Entry (FDE) records. Both CIEs and FDEs shall
be aligned to an addressing unit sized boundary.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1214"
></A
><P
><B
>Table 10-8. Call Frame Information Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Common Information Entry Record</TD
></TR
><TR
><TD
>Frame Description Entry Record(s)</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1222"
>10.6.1.1. The Common Information Entry Format</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="AEN1224"
></A
><P
><B
>Table 10-9. Common Information Entry Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Length</TD
><TD
>Required</TD
></TR
><TR
><TD
>Extended Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>CIE ID</TD
><TD
>Required</TD
></TR
><TR
><TD
>Version</TD
><TD
>Required</TD
></TR
><TR
><TD
>Augmentation String</TD
><TD
>Required</TD
></TR
><TR
><TD
>Code Alignment Factor</TD
><TD
>Required</TD
></TR
><TR
><TD
>Data Alignment Factor</TD
><TD
>Required</TD
></TR
><TR
><TD
>Return Address Register</TD
><TD
>Required</TD
></TR
><TR
><TD
>Augmentation Data Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Augmentation Data</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Initial Instructions</TD
><TD
>Required</TD
></TR
><TR
><TD
>Padding</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="STRUCTFIELD"
>Length</CODE
></DT
><DD
><P
>A 4 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field itself. If
<CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0xffffffff, then the
length is contained in the <CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> field.
If <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0, then this CIE shall
be considered a terminator and processing shall end.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
></DT
><DD
><P
>A 8 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> fields themselves.
This field is not present unless the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field
contains the value 0xffffffff.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>CIE ID</CODE
></DT
><DD
><P
>A 4 byte unsigned value that is used to distinguish CIE records from FDE
records.  This value shall always be 0, which indicates this record is a CIE.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Version</CODE
></DT
><DD
><P
>A 1 byte value that identifies the version number of the frame information
structure. This value shall be 1.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation String</CODE
></DT
><DD
><P
>This value is a NUL terminated string that identifies the augmentation to
the CIE or to the FDEs associated with this CIE. A zero length string
indicates that no augmentation data is present.  The augmentation string
is case sensitive and shall be interpreted as described below.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Code Alignment Factor</CODE
></DT
><DD
><P
>An unsigned LEB128 encoded value that is factored out of all advance location
instructions that are associated with this CIE or its FDEs. This value shall be
multiplied by the delta argument of an adavance location instruction to obtain
the new location value.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Data Alignment Factor</CODE
></DT
><DD
><P
>A signed LEB128 encoded value that is factored out of all offset instructions
that are associated with this CIE or its FDEs. This value shall be multiplied
by the register offset argument of an offset instruction to obtain
the new offset value.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Length</CODE
></DT
><DD
><P
>An unsigned LEB128 encoded value indicating the length in bytes of the
Augmentation Data. This field is only present if the Augmentation String
contains the character 'z'.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Data</CODE
></DT
><DD
><P
>A block of data whose contents are defined by the contents of the
Augmentation String as described below. This field is only present if the
Augmentation String contains the character 'z'. The size of this data is given
by the Augentation Length.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Initial Instructions</CODE
></DT
><DD
><P
>Initial set of Call Frame Instructions. The number of instructions is
determined by the remaining space in the CIE record.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Padding</CODE
></DT
><DD
><P
>Extra bytes to align the CIE structure to an addressing unit size boundary.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN1326"
>10.6.1.1.1. Augmentation String Format</A
></H5
><P
>The Agumentation String indicates the presence of some optional fields, and
how those fields should be intepreted. This string is case sensitive.  Each
character in the augmentation string in the CIE can be interpreted as below:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1330"
></A
><SPAN
STYLE="white-space: nowrap"
>'z'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'z' may be present as the first character of the string. If present, the
Augmentation Data field shall be present. The contents of the Augmentation Data
shall be intepreted according to other characters in the Augmentation String.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1334"
></A
><SPAN
STYLE="white-space: nowrap"
>'L'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'L' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, it
indicates the presence of one argument in the Augmentation Data of the CIE,
and a corresponding argument in the Augmentation Data of the FDE.
The argument in the Augmentation Data of the CIE is 1-byte and represents the
pointer encoding used for the argument in the Augmentation Data of the FDE,
which is the address of a language-specific data area (LSDA).
The size of the LSDA pointer is specified by the pointer encoding used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1338"
></A
><SPAN
STYLE="white-space: nowrap"
>'P'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'P' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, it
indicates the presence of two arguments in the Augmentation Data of the CIE.
The first argument is 1-byte and represents the pointer encoding used for the
second argument, which is the address of a 
<I
CLASS="FIRSTTERM"
>personality routine</I
> handler. 
The personality routine is used to handle language and 
vendor-specific tasks. The system unwind library interface accesses the 
language-specific exception handling semantics via the pointer to the 
personality routine. The personality routine does not have an ABI-specific 
name.
The size of the personality routine pointer is specified by the pointer encoding
used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1343"
></A
><SPAN
STYLE="white-space: nowrap"
>'R'</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A 'R' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, The
Augmentation Data shall include a 1 byte argument that represents the pointer
encoding for the address pointers used in the FDE.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1347"
>10.6.1.2. The Frame Description Entry Format</A
></H4
><DIV
CLASS="TABLE"
><A
NAME="AEN1349"
></A
><P
><B
>Table 10-10. Frame Description Entry Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Length</TD
><TD
>Required</TD
></TR
><TR
><TD
>Extended Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>FDE Pointer</TD
><TD
>Required</TD
></TR
><TR
><TD
>PC Begin</TD
><TD
>Required</TD
></TR
><TR
><TD
>PC Range</TD
><TD
>Required</TD
></TR
><TR
><TD
>Augmentation Data Length</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Augmentation Data</TD
><TD
>Optional</TD
></TR
><TR
><TD
>Call Frame Instructions</TD
><TD
>Required</TD
></TR
><TR
><TD
>Padding</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="STRUCTFIELD"
>Length</CODE
></DT
><DD
><P
>A 4 byte unsigned value indicating the length in bytes of the FDE structure,
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field itself. If
<CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0xffffffff, then the
length is contained the <CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> field.
If <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> contains the value 0, then this FDE shall
be considered a terminator and processing shall end.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
></DT
><DD
><P
>A 8 byte unsigned value indicating the length in bytes of the FDE structure, 
not including the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> or
<CODE
CLASS="STRUCTFIELD"
>Extended Length</CODE
> field themselves. 
This field is not present unless the <CODE
CLASS="STRUCTFIELD"
>Length</CODE
> field
contains the value 0xffffffff.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>CIE Pointer</CODE
></DT
><DD
><P
>A 4 byte unsigned value that when subtracted from the offset of 
the CIE Pointer in the current FDE yields the offset of the start of
the associated CIE.  This value shall never be 0.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>PC Begin</CODE
></DT
><DD
><P
>An encoded value that indicates the address of the initial location
associated with this FDE. The encoding format is specified in the
Augmentation Data.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>PC Range</CODE
></DT
><DD
><P
>An absolute value that indicates the number of bytes of instructions 
associated with this FDE.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Length</CODE
></DT
><DD
><P
>An unsigned LEB128 encoded value indicating the length in bytes of the
Augmentation Data. This field is only present if the Augmentation String
in the associated CIE contains the character 'z'.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Augmentation Data</CODE
></DT
><DD
><P
>A block of data whose contents are defined by the contents of the
Augmentation String in the associated CIE as described above.
This field is only present if the Augmentation String in the associated CIE
contains the character 'z'. The size of this data is given by the
Augentation Length.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Call Frame Instructions</CODE
></DT
><DD
><P
>A set of Call Frame Instructions.</P
></DD
><DT
><CODE
CLASS="STRUCTFIELD"
>Padding</CODE
></DT
><DD
><P
>Extra bytes to align the FDE structure to an addressing unit size boundary.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EHFRAMEHDR"
>10.6.2. The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section</A
></H3
><P
>The <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> section contains additional
information about the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section.
A pointer to the start of the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> data,
and optionally, a binary search table of pointers to the
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> records are found in this section.</P
><P
>Data in this section is encoded according to <A
HREF="#DWARFEHENCODING"
>Section 10.5.1</A
>.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1442"
></A
><P
><B
>Table 10-11. <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> Section Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Encoding</TH
><TH
>Field</TH
></TR
></THEAD
><TBODY
><TR
><TD
>unsigned byte</TD
><TD
>version</TD
></TR
><TR
><TD
>unsigned byte</TD
><TD
>eh_frame_ptr_enc</TD
></TR
><TR
><TD
>unsigned byte</TD
><TD
>fde_count_enc</TD
></TR
><TR
><TD
>unsigned byte</TD
><TD
>table_enc</TD
></TR
><TR
><TD
>encoded</TD
><TD
>eh_frame_ptr</TD
></TR
><TR
><TD
>encoded</TD
><TD
>fde_count</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>binary search table</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1473"
></A
><SPAN
STYLE="white-space: nowrap"
>version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version of the <SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame_hdr</SAMP
> format. This
value shall be 1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1478"
></A
><SPAN
STYLE="white-space: nowrap"
>eh_frame_ptr_enc</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoding format of the eh_frame_ptr field.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1482"
></A
><SPAN
STYLE="white-space: nowrap"
>fde_count_enc</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoding format of the fde_count field.
A value of DW_EH_PE_omit indicates the binary search table is not present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1486"
></A
><SPAN
STYLE="white-space: nowrap"
>table_enc</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoding format of the entries in the binary search table.
A value of DW_EH_PE_omit indicates the binary search table is not present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1490"
></A
><SPAN
STYLE="white-space: nowrap"
>eh_frame_ptr</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoded value of the pointer to the start of the
<SAMP
CLASS="COMPUTEROUTPUT"
>.eh_frame</SAMP
> section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1495"
></A
><SPAN
STYLE="white-space: nowrap"
>fde_count</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The encoded value of the count of entries in the binary search table.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1499"
></A
><SPAN
STYLE="white-space: nowrap"
>binary search table</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A binary search table containing fde_count entries. Each entry of the table
consist of two encoded values, the initial location, and the address.
The entries are sorted in an increasing order by the initial location value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYMVERSION"
>10.7. Symbol Versioning</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1505"
>10.7.1. Introduction</A
></H3
><P
>This chapter describes the Symbol Versioning mechanism. All ELF objects may
provide or depend on versioned symbols. Symbol Versioning is implemented by 3
section types: 
<TT
CLASS="SYMBOL"
>SHT_GNU_versym</TT
>, <TT
CLASS="SYMBOL"
>SHT_GNU_verdef</TT
>, and <TT
CLASS="SYMBOL"
>SHT_GNU_verneed</TT
>.</P
><P
>The prefix <TT
CLASS="SYMBOL"
>Elfxx</TT
> in the following descriptions and code fragments stands for 
either "<TT
CLASS="SYMBOL"
>Elf32</TT
>" or "<TT
CLASS="SYMBOL"
>Elf64</TT
>", depending on the architecture.</P
><P
>Versions are described by strings. The structures that are used for symbol
versions also contain a member that holds the ELF hashing values of the
strings. This allows for more efficient processing.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMVERTBL"
>10.7.2. Symbol Version Table</A
></H3
><P
>The special section <TT
CLASS="SYMBOL"
>.gnu.version</TT
>
which has a section type of <TT
CLASS="SYMBOL"
>SHT_GNU_versym</TT
>
shall contain the Symbol Version Table. This section shall have the same number 
of entries as the Dynamic Symbol Table in the <TT
CLASS="SYMBOL"
>.dynsym</TT
> section.</P
><P
>The <TT
CLASS="SYMBOL"
>.gnu.version</TT
> section shall contain an array of elements of type 
<TT
CLASS="SYMBOL"
>Elfxx_Half</TT
>.
Each entry specifies the version defined for or required by the corresponding 
symbol in the Dynamic Symbol Table.</P
><P
>The values in the Symbol Version Table are specific to the object in which they 
are located. These values are identifiers that are provided by the the 
<CODE
CLASS="STRUCTFIELD"
>vna_other</CODE
> member of the 
<TT
CLASS="STRUCTNAME"
>Elfxx_Vernaux</TT
> structure or the 
<CODE
CLASS="STRUCTFIELD"
>vd_ndx</CODE
> member of the 
<TT
CLASS="STRUCTNAME"
>Elfxx_Verdef</TT
> structure.</P
><P
>The values 0 and 1 are reserved.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1536"
></A
><SPAN
STYLE="white-space: nowrap"
>0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The symbol is local, not available outside the object.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1540"
></A
><SPAN
STYLE="white-space: nowrap"
>1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The symbol is defined in this object and is globally available.</P
></TD
></TR
></TBODY
></TABLE
><P
>All other values are used to identify version strings located in one of the
other Symbol Version sections. The value itself is not the version associated
with the symbol. The string identified by the value defines the version of
the symbol.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMVERDEFS"
>10.7.3. Version Definitions</A
></H3
><P
>The special section <TT
CLASS="SYMBOL"
>.gnu.version_d</TT
> which has a section type of 
<TT
CLASS="SYMBOL"
>SHT_GNU_verdef </TT
>
shall contain symbol version definitions. The number of entries in this section 
shall be contained in the <TT
CLASS="SYMBOL"
>DT_VERDEFNUM</TT
> entry of the Dynamic Section 
<TT
CLASS="SYMBOL"
>.dynamic</TT
>. 
The <TT
CLASS="SYMBOL"
>sh_link</TT
> member of the section header (see figure 4-8 in the 
<A
HREF="#STD.GABI41"
>System V ABI</A
>) 
shall point to the section that contains the strings referenced by this section.</P
><P
>The section shall contain an array of <TT
CLASS="SYMBOL"
>Elfxx_Verdef</TT
> structures, as described in 
<A
HREF="#VERDEFENTRIES"
>Figure 10-1</A
>, optionally followed by an array of <TT
CLASS="SYMBOL"
>Elfxx_Verdaux</TT
> structures, as 
defined in <A
HREF="#VERDEFEXTS"
>Figure 10-2</A
>.</P
><DIV
CLASS="FIGURE"
><A
NAME="VERDEFENTRIES"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Half    vd_version;
	Elfxx_Half    vd_flags;
	Elfxx_Half    vd_ndx;
	Elfxx_Half    vd_cnt;
	Elfxx_Word    vd_hash;
	Elfxx_Word    vd_aux;
	Elfxx_Word    vd_next;
} Elfxx_Verdef;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 10-1. Version Definition Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1563"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_version</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version revision. This field shall be set to <TT
CLASS="LITERAL"
>1</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1569"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_flags</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version information flag bitmask.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1574"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_ndx</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version index numeric value referencing the SHT_GNU_versym section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1579"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_cnt</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of associated verdaux array entries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1584"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_hash</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version name hash value (ELF hash function).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1589"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_aux</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset in bytes to a corresponding entry in an array
of <TT
CLASS="SYMBOL"
>Elfxx_Verdaux</TT
> structures as defined in
<A
HREF="#VERDEFEXTS"
>Figure 10-2</A
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1596"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vd_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next verdef entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="FIGURE"
><A
NAME="VERDEFEXTS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Word    vda_name;
	Elfxx_Word    vda_next;
} Elfxx_Verdaux;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 10-2. Version Definition Auxiliary Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1605"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vda_name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the version or dependency name string in the section header, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1610"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vda_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next verdaux entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMVERRQMTS"
>10.7.4. Version Requirements</A
></H3
><P
>The special section <TT
CLASS="SYMBOL"
>.gnu.version_r</TT
> which has a section type of 
<TT
CLASS="SYMBOL"
>SHT_GNU_verneed</TT
>
shall contain required symbol version definitions. The number of entries in 
this section shall be contained in the <TT
CLASS="SYMBOL"
>DT_VERNEEDNUM</TT
> entry of the Dynamic 
Section <TT
CLASS="SYMBOL"
>.dynamic</TT
>. 
The <CODE
CLASS="STRUCTFIELD"
>sh_link</CODE
> member of the section header (see figure 4-8 in 
<A
HREF="#STD.GABI41"
>System V ABI</A
>)
shall point to the section that contains the strings referenced by this section.</P
><P
>The section shall contain an array of <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> structures, as described in 
<A
HREF="#VERNEEDFIG"
>Figure 10-3</A
>, optionally followed by an array of 
<TT
CLASS="SYMBOL"
>Elfxx_Vernaux</TT
> structures, as 
defined in <A
HREF="#VERNEEDEXTFIG"
>Figure 10-4</A
>.</P
><DIV
CLASS="FIGURE"
><A
NAME="VERNEEDFIG"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Half    vn_version;
	Elfxx_Half    vn_cnt;
	Elfxx_Word    vn_file;
	Elfxx_Word    vn_aux;
	Elfxx_Word    vn_next;
} Elfxx_Verneed;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 10-3. Version Needed Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1633"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_version</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Version of structure. This value is currently set to 1, and will be reset if the versioning implementation is incompatibly altered.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1638"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_cnt</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of associated verneed array entries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1643"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_file</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the file name string in the section header, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1648"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_aux</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to a corresponding entry in the vernaux array, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1653"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vn_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next verneed entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="FIGURE"
><A
NAME="VERNEEDEXTFIG"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elfxx_Word    vna_hash;
	Elfxx_Half    vna_flags;
	Elfxx_Half    vna_other;
	Elfxx_Word    vna_name;
	Elfxx_Word    vna_next;
} Elfxx_Vernaux;</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 10-4. Version Needed Auxiliary Entries</B
></P
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1662"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_hash</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Dependency name hash value (ELF hash function).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1667"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_flags</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Dependency information flag bitmask.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1672"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_other</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Object file version identifier used in the .gnu.version symbol version array. Bit number 15 controls whether or not the object is hidden; if this bit is set, the object cannot be used and the static linker will ignore the symbol's presence in the object.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1677"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the dependency name string in the section header, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1682"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>vna_next</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Offset to the next vernaux entry, in bytes.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMSTARTSEQ"
>10.7.5. Startup Sequence</A
></H3
><P
>When loading a sharable object the system shall analyze version definition data 
from the loaded object to assure that it meets the version requirements of the 
calling object. This step is referred to as definition testing. The dynamic 
loader shall retrieve the entries in the caller's <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> array and 
attempt to find matching definition information in the loaded <TT
CLASS="SYMBOL"
>Elfxx_Verdef</TT
>
table.</P
><P
>Each object and dependency shall be tested in turn. If a symbol definition is 
missing and the <TT
CLASS="SYMBOL"
>vna_flags</TT
> bit for <TT
CLASS="SYMBOL"
>VER_FLG_WEAK</TT
> is not set, the loader shall 
return an error and exit. If the <TT
CLASS="SYMBOL"
>vna_flags</TT
> bit for <TT
CLASS="SYMBOL"
>VER_FLG_WEAK</TT
> is set in the 
<TT
CLASS="SYMBOL"
>Elfxx_Vernaux</TT
> entry, and the loader shall issue a warning and continue 
operation.</P
><P
>When the versions referenced by undefined symbols in the loaded object are 
found, version availability is certified. The test completes without error and 
the object shall be made available.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYMRESOLUTION"
>10.7.6. Symbol Resolution</A
></H3
><P
>When symbol versioning is used in an object, relocations extend 
definition testing beyond the simple match of symbol
name strings: the version of the reference shall also equal the name of
the definition. </P
><P
>The same index that is used in the symbol table can be
referenced in the <TT
CLASS="SYMBOL"
>SHT_GNU_versym</TT
> section, and the value of this index is
then used to acquire name data. The corresponding requirement string is
retrieved from the <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> array, and likewise, the corresponding
definition string from the <TT
CLASS="SYMBOL"
>Elfxx_Verdef</TT
> table.</P
><P
>If the high order bit (bit number 15)
of the version symbolis set, the object cannot be used
and the static linker shall ignore the symbol's presence in the object.</P
><P
>When an object with a reference and an object with the definition are being 
linked, the following rules shall govern the result:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>The object with the reference and the object with the definitions both use 
versioning. All described matching is processed in this case. A fatal error 
shall be triggered when no matching definition can be found in the object whose 
name is the one referenced by the <CODE
CLASS="STRUCTFIELD"
>vn_name</CODE
> element in the 
<TT
CLASS="STRUCTNAME"
>Elfxx_Verneed</TT
> entry.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The object with the reference does not use versioning, while the object with 
the definitions does. In this instance, only the definitions with index numbers 
1 and 2 will be used in the reference match, the same identified by the static 
linker as the base definition. In cases where the static linker was not used, 
such as in calls to <TT
CLASS="FUNCTION"
>dlopen()</TT
>, a version that does not have the base definition 
index shall be acceptable if it is the only version for which the symbol is 
defined.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The object with the reference uses versioning, but the object with the 
definitions specifies none. A matching symbol shall be accepted in this case. A 
fatal error shall be triggered if a corruption in the required symbols list 
obscures an outdated object file and causes a match on the object filename in 
the <TT
CLASS="SYMBOL"
>Elfxx_Verneed</TT
> entry.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>Neither the object with the reference nor the object with the definitions use 
versioning. The behavior in this instance shall default to pre-existing symbol 
rules.</P
></LI
></UL
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="NOTEABITAG"
>10.8. ABI note tag</A
></H2
><P
>Every executable shall contain a section named
<SAMP
CLASS="COMPUTEROUTPUT"
>.note.ABI-tag</SAMP
> of type
<SAMP
CLASS="COMPUTEROUTPUT"
>SHT_NOTE</SAMP
>.  This section is structured
as a note section as documented in the ELF spec.  The section shall
contain at least the following entry.  The
<SAMP
CLASS="COMPUTEROUTPUT"
>name</SAMP
> field
(<SAMP
CLASS="COMPUTEROUTPUT"
>namesz</SAMP
>/<SAMP
CLASS="COMPUTEROUTPUT"
>name</SAMP
>)
contains the string "<SAMP
CLASS="COMPUTEROUTPUT"
>GNU</SAMP
>".  The
<SAMP
CLASS="COMPUTEROUTPUT"
>type</SAMP
> field shall be 1.  The
<SAMP
CLASS="COMPUTEROUTPUT"
>descsz</SAMP
> field shall be at least 16,
and the first 16 bytes of the <SAMP
CLASS="COMPUTEROUTPUT"
>desc</SAMP
>
field shall be as follows.</P
><P
>The first 32-bit word of the <SAMP
CLASS="COMPUTEROUTPUT"
>desc</SAMP
>
field shall be 0 (this signifies a Linux executable).  The second,
third, and fourth 32-bit words of the
<SAMP
CLASS="COMPUTEROUTPUT"
>desc</SAMP
> field contain the earliest
compatible kernel version.  For example, if the 3 words are 2, 2, and
5, this signifies a 2.2.5 kernel.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TOCDYNLNK"
></A
>Chapter 11. Dynamic Linking</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="DYNLNK"
>11.1. Program Loading and Dynamic Linking</A
></H2
><P
>LSB-conforming implementations shall support the object file information and
system actions that create running programs as specified in the
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>
and as further required by this specification and the relevant architecture specific part of the LSB Core Specification.</P
><P
>Any shared object that is loaded shall contain sufficient DT_NEEDED records to
satisfy the symbols on the shared library.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROGHEADER"
>11.2. Program Header</A
></H2
><P
>In addition to the Segment Types defined in the
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>
the following Segment Types shall also be supported.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN1749"
></A
><P
><B
>Table 11-1. Linux Segment Types</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Value</TH
></TR
></THEAD
><TBODY
><TR
><TD
>PT_GNU_EH_FRAME</TD
><TD
>0x6474e550</TD
></TR
><TR
><TD
>PT_GNU_STACK</TD
><TD
>0x6474e551</TD
></TR
><TR
><TD
>PT_GNU_RELRO</TD
><TD
>0x6474e552</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1767"
></A
><SPAN
STYLE="white-space: nowrap"
>PT_GNU_EH_FRAME</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The array element specifies the location and size of the exception handling
information as defined by the .eh_frame_hdr section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1771"
></A
><SPAN
STYLE="white-space: nowrap"
>PT_GNU_STACK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <CODE
CLASS="STRUCTFIELD"
>p_flags</CODE
> member specifies the permissions
on the segment containing the stack and is used to indicate wether the
stack should be executable. The absense of this header indicates that
the stack will be executable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1776"
></A
><SPAN
STYLE="white-space: nowrap"
>PT_GNU_RELRO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the array element specifies the location and size of a segment which
may be made read-only after relocations have been processed.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DYNAMICSECTION"
>11.3. Dynamic Entries</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1782"
>11.3.1. Introduction</A
></H3
><P
>As described in <A
HREF="#STD.GABI41"
>System V ABI</A
>, if an object file
participates in dynamic linking, its program header table shall have
an element of type <TT
CLASS="SYMBOL"
>PT_DYNAMIC</TT
>.  This `segment'
contains the <TT
CLASS="SYMBOL"
>.dynamic</TT
> section. A special symbol,
<TT
CLASS="SYMBOL"
>_DYNAMIC</TT
>, labels the section, which contains an array
of the following structures.
<DIV
CLASS="FIGURE"
><A
NAME="AEN1789"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	Elf32_Sword	d_tag;
   	union {
   		Elf32_Word	d_val;
   		Elf32_Addr	d_ptr;
	} d_un;
} Elf32_Dyn;

extern Elf32_Dyn	_DYNAMIC[];

typedef struct {
	Elf64_Sxword	d_tag;
   	union {
   		Elf64_Xword	d_val;
   		Elf64_Addr	d_ptr;
	} d_un;
} Elf64_Dyn;

extern Elf64_Dyn	_DYNAMIC[];</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 11-1. Dynamic Structure</B
></P
></DIV
></P
><P
>For each object with this type, <CODE
CLASS="STRUCTFIELD"
>d_tag</CODE
>
controls the interpretation of <CODE
CLASS="STRUCTFIELD"
>d_un</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DYNSECTENT"
>11.3.2. Dynamic Entries</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1798"
>11.3.2.1. ELF Dynamic Entries</A
></H4
><P
>The following dynamic entries are defined in the 
<A
HREF="#STD.GABI41"
>System V ABI</A
>
and
<A
HREF="#STD.ABIUPDATE"
>System V ABI Update</A
>.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1804"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_BIND_NOW</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Process relocations of object</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1808"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_DEBUG</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>For debugging; unspecified</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1812"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FINI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of termination function</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1816"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FINI_ARRAY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The address of an array of pointers to termination functions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1820"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FINI_ARRAYSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of DT_FINI_ARRAY</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1824"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FLAGS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Flag values specific to the object being loaded</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1828"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_HASH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of symbol hash table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1832"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_HIPROC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>End of processor-specific</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1836"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_INIT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of init function</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1840"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_INIT_ARRAY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The address of an array of pointers to initialization functions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1844"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_INIT_ARRAYSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of DT_INIT_ARRAY</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1848"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_JMPREL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of PLT relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1852"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_LOPROC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Start of processor-specific</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1856"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_NEEDED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Name of needed library</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1860"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_NULL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Marks end of dynamic section</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1864"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_PLTREL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Type of reloc in PLT</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1868"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_PLTRELSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of PLT relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1872"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_PREINIT_ARRAY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Array with addresses of preinit functions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1876"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_PREINIT_ARRAYSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size in bytes of DT_PREINIT_ARRAY</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1880"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_REL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of Rel relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1884"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELA</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of Rela relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1888"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELAENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of one Rela reloc</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1892"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELASZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Total size of Rela relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1896"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of one Rel reloc</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1900"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Total size of Rel relocs</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1904"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RPATH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Library search path</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1908"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RUNPATH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>null-terminated library search path string</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1912"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SONAME</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Name of shared object</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1916"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_STRSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of string table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1920"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_STRTAB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of string table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1924"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMBOLIC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Start symbol search here</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1928"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of one symbol table entry</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1932"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMTAB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of symbol table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1936"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_TEXTREL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Reloc might modify .text</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1940"
>11.3.2.2. Additional Dynamic Entries</A
></H4
><P
>An LSB conforming object may also use the following additional Dynamic Entry
types.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1944"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_ADDRRNGHI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_ADDRRNGLO through DT_ADDRRNGHI are reserved for definition by an architecture specific part.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1948"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_ADDRRNGLO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_ADDRRNGLO through DT_ADDRRNGHI are reserved for definition by an architecture specific part.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1952"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_AUXILIARY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shared object to load before self</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1956"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_FILTER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shared object to get values from</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1960"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_HIOS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_LOOS through DT_HIOS are reserved for definition by specific operating systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1964"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_LOOS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Values from DT_LOOS through DT_HIOS are reserved for definition by specific operating systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1968"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_NUM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of dynamic entry tags defined (excepting reserved ranges).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1972"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_POSFLAG_1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Flags for DT_* entries, effecting the following DT_* entry</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1976"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_RELCOUNT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>All Elf32_Rel R_*_RELATIVE relocations have been placed into a single block and this entry specifies the number of entries in that block. This permits ld.so.1 to streamline the processing of RELATIVE relocations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1980"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMINENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Entry size of syminfo</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1984"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMINFO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of the Syminfo table.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1988"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_SYMINSZ</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of syminfo table (in bytes)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1992"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VALRNGHI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Entries which fall between DT_VALRNGHI &#38; DT_VALRNGLO use the Dyn.d_un.d_val field of the Elf*_Dyn structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1996"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VALRNGLO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Entries which fall between DT_VALRNGHI &#38; DT_VALRNGLO use the Dyn.d_un.d_val field of the Elf*_Dyn structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN2000"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERDEF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of version definition table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN2004"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERDEFNUM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of version definitions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN2008"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERNEED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of table with needed versions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN2012"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERNEEDNUM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Number of needed versions</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN2016"
></A
><SPAN
STYLE="white-space: nowrap"
>DT_VERSYM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Address of the table provided by the .gnu.version section.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CXXCLASSES"
></A
>Chapter 12. C++ Class Representations</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="CXXDATAREPRESENTATION"
>12.1. C++ Data Representation</A
></H2
><P
>Support for the C++ language shall be as specified in
<A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This document, although containing a few architecture specific
matters, is written as a generic specification, to be usable by C++
implementations on a variety of architectures.</P
></BLOCKQUOTE
></DIV
>
This section provides additional information to
supplement <A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>. Many of the definitions
in that document are
made in terms of C++. This section provides addition explanations
using C terms to avoid self-referential problems.</P
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLASSES"
>12.1.1. Class Representation</A
></H3
><P
>An object file generated by the compilation process for a C++ program shall
contain several closely related internal objects, or Class Components, to
represent each C++ Class. Such objects are not a visible part of the source
code. <A
HREF="#TBL-CXX-CLASSREP"
>Table 12-1</A
>
describes these Class Components at a high level.
<DIV
CLASS="TABLE"
><A
NAME="TBL-CXX-CLASSREP"
></A
><P
><B
>Table 12-1. Class Components</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Object</TH
><TH
>Contains</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Class Data</TD
><TD
>All non-static Class members</TD
></TR
><TR
><TD
>Virtual Table</TD
><TD
>Information needed to dispatch virtual functions, access virtual base class subobjects and to access the RTTI information</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>Run-Time Type Information used by the typeid and dynamic_cast operators, and exception handlers</TD
></TR
><TR
><TD
>Typeinfo Name</TD
><TD
>String representation of Class name</TD
></TR
><TR
><TD
>Construction Virtual Table</TD
><TD
>Information needed during construction and destruction of Classes with non-trivial inheritance relationships.</TD
></TR
><TR
><TD
>VTT</TD
><TD
>A table of virtual table pointers which holds the addresses of construction and non-construction virtual tables.</TD
></TR
></TBODY
></TABLE
></DIV
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="VIRTUALTABLE"
>12.1.1.1. Virtual Table</A
></H4
><P
>Virtual tables are specified in Section 2.5.3 of <A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>.</P
><P
>Of the various categories of virtual table described in that specification,
Category 1 (Leaf) is further described in <A
HREF="#CXX-VIRTUALTABLE-CAT1"
>Figure 12-1</A
> and
Category 2 (Non-virtual bases only) is further described in
<A
HREF="#CXX-VIRTUALTABLE-CAT2"
>Figure 12-2</A
>. 
LSB conforming systems shall support these
categories.</P
><DIV
CLASS="FIGURE"
><A
NAME="CXX-VIRTUALTABLE-CAT1"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
        ptrdiff_t       baseobject;
        const char      *typeinfo;
        fptr            virtfuncs[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-1. Category 1 Virtual Table</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="CXX-VIRTUALTABLE-CAT2"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
        unsigned long   vcalloffset;
        ptrdiff_t       baseobject;
        const char      *typeinfo;
        fptr            virtfuncs[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-2. Category 2 Virtual Table</B
></P
></DIV
><P
>This specification describes requirements for virtual tables of C++ classes
using tables of the following form:</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-CXX-VTABLE"
></A
><P
><B
>Table 12-2. Primary vtable for K (example)</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for K</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>K::~K()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>K::~K()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>K::m1(int*)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>X::m2()</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
><TT
CLASS="FUNCTION"
>__cxa_pure_virtual()</TT
></TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>NULL or X::m4(int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Each row starting from 'vfunc[i]:' refers to a vtable entry 'vfunc[i]' of a
class K, which is an entry for a virtual function A::m, where A is a base class
of the class K as described in the <A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>.
This specification requires implementations to interpret the vtable
entry information in the following way:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>A conforming implementation shall contain a vtable of the class K
in the specified shared library;</P
></LI
><LI
><P
>The corresponding entry of this vtable 'vfunc[i]'
shall be an entry for the virtual function A::m;</P
></LI
><LI
><P
>If the second column of the row contains <TT
CLASS="FUNCTION"
>__cxa_pure_virtual()</TT
>
the corresponding vtable entry of a LSB-conforming implementation
shall contain <TT
CLASS="FUNCTION"
>__cxa_pure_virtual()</TT
> or 'Y::m',
where Y is the class K, the class A or
a base class of the class K derived from the class A.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In this case virtual function A::m in class K is considered
to be specified as pure virtual by this specification.</P
></BLOCKQUOTE
></DIV
></P
></LI
><LI
><P
>If the second column of the row contains 'X::m'
the corresponding vtable entry of a LSB-conforming implementation
shall contain 'Y::m', where Y is the class K, the class X
or a base class of the class K derived from the class X.</P
></LI
><LI
><P
>If the second column of the row contains 'NULL or X::m'
the corresponding vtable entry of a LSB-conforming implementation
shall contain NULL or 'Y::m', where Y is the class K, the class X
or a base class of the class K derived from the class X.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In this case virtual function A::m in class K is considered
to be specified as inline by this specification.</P
></BLOCKQUOTE
></DIV
></P
></LI
></OL
><P
>An application may use any non-pure virtual function
specified in this specification, and can expect the
specified behavior irrespective of which particular
method implements this functionality.
An application may not use inline virtual functions at the
binary level since its vtable entry may be <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="RTTI"
>12.1.1.2. Run-Time Type Information</A
></H4
><P
>Each type used in a C++ program has a data structure associated with it that
provide information about the type which is used at runtime. This Run Time
Type Information (RTTI) is defined in section 2.9.5 in
<A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>. Additional details about the layout of this
data is provided here.</P
><DIV
CLASS="FIGURE"
><A
NAME="CXX-RTTI"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
       void      *basevtable;
       char      *name;
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-3. Run-Time Type Information Prefix</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="CXX-RTTI-CLASS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
       void      *basevtable;
       char      *name;
       void      *basetypeinfo[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-4. Run-Time Type Information For Classes with no base class</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="CXX-RTTI-SICLASS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
       void      *basevtable;
       char      *name;
       void      *basetype;
       void      *basetypeinfo[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-5. Run-Time Type Information for Classes with a single base class</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="CXX-RTTI-VMICLASS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct base_type_info {
       char    *base_type;
       unsigned long   offset_flags;
};

struct {
       void    *basevtable;
       char    *name;
       unsigned int    flags;
       unsigned int    base_count;
       struct base_type_info base_info[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-6. Run-Time Type Information for classes with multiple inheritance</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="CXX-RTTI-POINTERCLASS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
       void    *basevtable;
       char    *name;
       unsigned int    flags;
       void    *pointee;
       void    *basetypeinfo[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-7. Run-Time Type Information for pointer types</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="CXX-RTTI-PTOMEMBERCLASS"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>struct {
       void    *basevtable;
       char    *name;
       unsigned int    flags;
       void    *pointee;
       void    *context;
       void    *basetypeinfo[0];
};</PRE
></TD
></TR
></TABLE
><P
><B
>Figure 12-8. Run-Time Type Information for pointer to member types</B
></P
></DIV
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYMMAP.CXX"
></A
>Chapter 13. Symbol Mapping</H1
><P
>This chapter defines how names are mapped from the source symbol to
the object symbol.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYMMAPPING"
>13.1. Symbol Mapping</A
></H2
><P
>Symbols in a source program are translated by the compilation system into
symbols that exist in the object file. The rules for this translation are
defined here.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2155"
>13.1.1. C++ Language</A
></H3
><P
>&#13;External symbol names in a C++ object file shall be encoded according to 
the "name mangling" rules described in the <A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCBASELIB"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>III. Base Libraries</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>14. <A
HREF="#BASELIB"
>Base Libraries</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN2163"
>Introduction</A
></DT
><DT
>14.2. <A
HREF="#PROGINTERP"
>Program Interpreter</A
></DT
><DT
>14.3. <A
HREF="#LIBC"
>Interfaces for libc</A
></DT
><DD
><DL
><DT
>14.3.1. <A
HREF="#AEN2220"
>RPC</A
></DT
><DT
>14.3.2. <A
HREF="#AEN2533"
>Epoll</A
></DT
><DT
>14.3.3. <A
HREF="#AEN2558"
>System Calls</A
></DT
><DT
>14.3.4. <A
HREF="#AEN3333"
>Standard I/O</A
></DT
><DT
>14.3.5. <A
HREF="#AEN3796"
>Signal Handling</A
></DT
><DT
>14.3.6. <A
HREF="#AEN3987"
>Localization Functions</A
></DT
><DT
>14.3.7. <A
HREF="#AEN4108"
>Posix Spawn Option</A
></DT
><DT
>14.3.8. <A
HREF="#AEN4212"
>Posix Advisory Option</A
></DT
><DT
>14.3.9. <A
HREF="#AEN4240"
>Socket Interface</A
></DT
><DT
>14.3.10. <A
HREF="#AEN4401"
>Wide Characters</A
></DT
><DT
>14.3.11. <A
HREF="#AEN4990"
>String Functions</A
></DT
><DT
>14.3.12. <A
HREF="#AEN5374"
>IPC Functions</A
></DT
><DT
>14.3.13. <A
HREF="#AEN5436"
>Regular Expressions</A
></DT
><DT
>14.3.14. <A
HREF="#AEN5464"
>Character Type Functions</A
></DT
><DT
>14.3.15. <A
HREF="#AEN5679"
>Time Manipulation</A
></DT
><DT
>14.3.16. <A
HREF="#AEN5783"
>Terminal Interface Functions</A
></DT
><DT
>14.3.17. <A
HREF="#AEN5859"
>System Database Interface</A
></DT
><DT
>14.3.18. <A
HREF="#AEN6124"
>Language Support</A
></DT
><DT
>14.3.19. <A
HREF="#AEN6146"
>Large File Support</A
></DT
><DT
>14.3.20. <A
HREF="#AEN6320"
>Inotify</A
></DT
><DT
>14.3.21. <A
HREF="#AEN6345"
>Standard Library</A
></DT
><DT
>14.3.22. <A
HREF="#AEN7310"
>GNU Extensions for libc</A
></DT
></DL
></DD
><DT
>14.4. <A
HREF="#LIBC-DDEFS"
>Data Definitions for libc</A
></DT
><DD
><DL
><DT
>14.4.1. <A
HREF="#AEN7338"
>argz.h</A
></DT
><DT
>14.4.2. <A
HREF="#AEN7342"
>arpa/inet.h</A
></DT
><DT
>14.4.3. <A
HREF="#AEN7346"
>assert.h</A
></DT
><DT
>14.4.4. <A
HREF="#AEN7350"
>cpio.h</A
></DT
><DT
>14.4.5. <A
HREF="#AEN7354"
>ctype.h</A
></DT
><DT
>14.4.6. <A
HREF="#AEN7358"
>dirent.h</A
></DT
><DT
>14.4.7. <A
HREF="#AEN7362"
>elf.h</A
></DT
><DT
>14.4.8. <A
HREF="#AEN7366"
>endian.h</A
></DT
><DT
>14.4.9. <A
HREF="#AEN7370"
>envz.h</A
></DT
><DT
>14.4.10. <A
HREF="#AEN7374"
>err.h</A
></DT
><DT
>14.4.11. <A
HREF="#AEN7378"
>errno.h</A
></DT
><DT
>14.4.12. <A
HREF="#AEN7382"
>error.h</A
></DT
><DT
>14.4.13. <A
HREF="#AEN7386"
>execinfo.h</A
></DT
><DT
>14.4.14. <A
HREF="#AEN7390"
>fcntl.h</A
></DT
><DT
>14.4.15. <A
HREF="#AEN7394"
>fmtmsg.h</A
></DT
><DT
>14.4.16. <A
HREF="#AEN7398"
>fnmatch.h</A
></DT
><DT
>14.4.17. <A
HREF="#AEN7402"
>ftw.h</A
></DT
><DT
>14.4.18. <A
HREF="#AEN7406"
>getopt.h</A
></DT
><DT
>14.4.19. <A
HREF="#AEN7410"
>glob.h</A
></DT
><DT
>14.4.20. <A
HREF="#AEN7414"
>gnu/libc-version.h</A
></DT
><DT
>14.4.21. <A
HREF="#AEN7418"
>grp.h</A
></DT
><DT
>14.4.22. <A
HREF="#AEN7422"
>iconv.h</A
></DT
><DT
>14.4.23. <A
HREF="#AEN7426"
>ifaddrs.h</A
></DT
><DT
>14.4.24. <A
HREF="#AEN7430"
>inttypes.h</A
></DT
><DT
>14.4.25. <A
HREF="#AEN7434"
>langinfo.h</A
></DT
><DT
>14.4.26. <A
HREF="#AEN7438"
>libgen.h</A
></DT
><DT
>14.4.27. <A
HREF="#AEN7442"
>libintl.h</A
></DT
><DT
>14.4.28. <A
HREF="#AEN7446"
>limits.h</A
></DT
><DT
>14.4.29. <A
HREF="#AEN7450"
>link.h</A
></DT
><DT
>14.4.30. <A
HREF="#AEN7454"
>locale.h</A
></DT
><DT
>14.4.31. <A
HREF="#AEN7458"
>lsb/time.h</A
></DT
><DT
>14.4.32. <A
HREF="#AEN7462"
>lsb/types.h</A
></DT
><DT
>14.4.33. <A
HREF="#AEN7466"
>lsb/wchar.h</A
></DT
><DT
>14.4.34. <A
HREF="#AEN7470"
>monetary.h</A
></DT
><DT
>14.4.35. <A
HREF="#AEN7474"
>net/if.h</A
></DT
><DT
>14.4.36. <A
HREF="#AEN7478"
>netdb.h</A
></DT
><DT
>14.4.37. <A
HREF="#AEN7482"
>netinet/icmp6.h</A
></DT
><DT
>14.4.38. <A
HREF="#AEN7486"
>netinet/igmp.h</A
></DT
><DT
>14.4.39. <A
HREF="#AEN7490"
>netinet/in.h</A
></DT
><DT
>14.4.40. <A
HREF="#AEN7494"
>netinet/in_systm.h</A
></DT
><DT
>14.4.41. <A
HREF="#AEN7498"
>netinet/ip.h</A
></DT
><DT
>14.4.42. <A
HREF="#AEN7502"
>netinet/ip6.h</A
></DT
><DT
>14.4.43. <A
HREF="#AEN7506"
>netinet/ip_icmp.h</A
></DT
><DT
>14.4.44. <A
HREF="#AEN7510"
>netinet/tcp.h</A
></DT
><DT
>14.4.45. <A
HREF="#AEN7514"
>netinet/udp.h</A
></DT
><DT
>14.4.46. <A
HREF="#AEN7518"
>nl_types.h</A
></DT
><DT
>14.4.47. <A
HREF="#AEN7522"
>poll.h</A
></DT
><DT
>14.4.48. <A
HREF="#AEN7526"
>pwd.h</A
></DT
><DT
>14.4.49. <A
HREF="#AEN7530"
>regex.h</A
></DT
><DT
>14.4.50. <A
HREF="#AEN7534"
>rpc/auth.h</A
></DT
><DT
>14.4.51. <A
HREF="#AEN7538"
>rpc/clnt.h</A
></DT
><DT
>14.4.52. <A
HREF="#AEN7542"
>rpc/pmap_clnt.h</A
></DT
><DT
>14.4.53. <A
HREF="#AEN7546"
>rpc/rpc_msg.h</A
></DT
><DT
>14.4.54. <A
HREF="#AEN7550"
>rpc/svc.h</A
></DT
><DT
>14.4.55. <A
HREF="#AEN7554"
>rpc/types.h</A
></DT
><DT
>14.4.56. <A
HREF="#AEN7558"
>rpc/xdr.h</A
></DT
><DT
>14.4.57. <A
HREF="#AEN7562"
>sched.h</A
></DT
><DT
>14.4.58. <A
HREF="#AEN7566"
>search.h</A
></DT
><DT
>14.4.59. <A
HREF="#AEN7570"
>setjmp.h</A
></DT
><DT
>14.4.60. <A
HREF="#AEN7574"
>signal.h</A
></DT
><DT
>14.4.61. <A
HREF="#AEN7578"
>spawn.h</A
></DT
><DT
>14.4.62. <A
HREF="#AEN7582"
>stddef.h</A
></DT
><DT
>14.4.63. <A
HREF="#AEN7586"
>stdint.h</A
></DT
><DT
>14.4.64. <A
HREF="#AEN7590"
>stdio.h</A
></DT
><DT
>14.4.65. <A
HREF="#AEN7594"
>stdlib.h</A
></DT
><DT
>14.4.66. <A
HREF="#AEN7598"
>string.h</A
></DT
><DT
>14.4.67. <A
HREF="#AEN7602"
>strings.h</A
></DT
><DT
>14.4.68. <A
HREF="#AEN7606"
>sys/epoll.h</A
></DT
><DT
>14.4.69. <A
HREF="#AEN7610"
>sys/file.h</A
></DT
><DT
>14.4.70. <A
HREF="#AEN7614"
>sys/inotify.h</A
></DT
><DT
>14.4.71. <A
HREF="#AEN7618"
>sys/ioctl.h</A
></DT
><DT
>14.4.72. <A
HREF="#AEN7622"
>sys/ipc.h</A
></DT
><DT
>14.4.73. <A
HREF="#AEN7626"
>sys/mman.h</A
></DT
><DT
>14.4.74. <A
HREF="#AEN7630"
>sys/msg.h</A
></DT
><DT
>14.4.75. <A
HREF="#AEN7634"
>sys/param.h</A
></DT
><DT
>14.4.76. <A
HREF="#AEN7638"
>sys/poll.h</A
></DT
><DT
>14.4.77. <A
HREF="#AEN7642"
>sys/ptrace.h</A
></DT
><DT
>14.4.78. <A
HREF="#AEN7646"
>sys/resource.h</A
></DT
><DT
>14.4.79. <A
HREF="#AEN7650"
>sys/select.h</A
></DT
><DT
>14.4.80. <A
HREF="#AEN7654"
>sys/sem.h</A
></DT
><DT
>14.4.81. <A
HREF="#AEN7658"
>sys/sendfile.h</A
></DT
><DT
>14.4.82. <A
HREF="#AEN7662"
>sys/shm.h</A
></DT
><DT
>14.4.83. <A
HREF="#AEN7666"
>sys/socket.h</A
></DT
><DT
>14.4.84. <A
HREF="#AEN7670"
>sys/stat.h</A
></DT
><DT
>14.4.85. <A
HREF="#AEN7674"
>sys/statfs.h</A
></DT
><DT
>14.4.86. <A
HREF="#AEN7678"
>sys/statvfs.h</A
></DT
><DT
>14.4.87. <A
HREF="#AEN7682"
>sys/sysinfo.h</A
></DT
><DT
>14.4.88. <A
HREF="#AEN7686"
>sys/time.h</A
></DT
><DT
>14.4.89. <A
HREF="#AEN7690"
>sys/timeb.h</A
></DT
><DT
>14.4.90. <A
HREF="#AEN7694"
>sys/times.h</A
></DT
><DT
>14.4.91. <A
HREF="#AEN7698"
>sys/types.h</A
></DT
><DT
>14.4.92. <A
HREF="#AEN7702"
>sys/uio.h</A
></DT
><DT
>14.4.93. <A
HREF="#AEN7706"
>sys/un.h</A
></DT
><DT
>14.4.94. <A
HREF="#AEN7710"
>sys/utsname.h</A
></DT
><DT
>14.4.95. <A
HREF="#AEN7714"
>sys/wait.h</A
></DT
><DT
>14.4.96. <A
HREF="#AEN7718"
>sysexits.h</A
></DT
><DT
>14.4.97. <A
HREF="#AEN7722"
>syslog.h</A
></DT
><DT
>14.4.98. <A
HREF="#AEN7726"
>tar.h</A
></DT
><DT
>14.4.99. <A
HREF="#AEN7730"
>termios.h</A
></DT
><DT
>14.4.100. <A
HREF="#AEN7734"
>time.h</A
></DT
><DT
>14.4.101. <A
HREF="#AEN7738"
>ucontext.h</A
></DT
><DT
>14.4.102. <A
HREF="#AEN7742"
>ulimit.h</A
></DT
><DT
>14.4.103. <A
HREF="#AEN7746"
>unistd.h</A
></DT
><DT
>14.4.104. <A
HREF="#AEN7750"
>utime.h</A
></DT
><DT
>14.4.105. <A
HREF="#AEN7754"
>utmp.h</A
></DT
><DT
>14.4.106. <A
HREF="#AEN7758"
>utmpx.h</A
></DT
><DT
>14.4.107. <A
HREF="#AEN7762"
>wchar.h</A
></DT
><DT
>14.4.108. <A
HREF="#AEN7766"
>wctype.h</A
></DT
><DT
>14.4.109. <A
HREF="#AEN7770"
>wordexp.h</A
></DT
></DL
></DD
><DT
>14.5. <A
HREF="#LIBCMAN"
>Interface Definitions for libc</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB--IO-FEOF-3"
>_IO_feof</A
>&nbsp;--&nbsp;alias for feof</DT
><DT
><A
HREF="#BASELIB--IO-GETC-3"
>_IO_getc</A
>&nbsp;--&nbsp;alias for getc</DT
><DT
><A
HREF="#BASELIB--IO-PUTC-3"
>_IO_putc</A
>&nbsp;--&nbsp;alias for putc</DT
><DT
><A
HREF="#BASELIB--IO-PUTS-3"
>_IO_puts</A
>&nbsp;--&nbsp;alias for puts</DT
><DT
><A
HREF="#BASELIB---ASSERT-FAIL-1"
>__assert_fail</A
>&nbsp;--&nbsp;abort the program after false assertion</DT
><DT
><A
HREF="#BASELIB---CHK-FAIL-1"
>__chk_fail</A
>&nbsp;--&nbsp;terminate a function in case of buffer overflow</DT
><DT
><A
HREF="#BASELIB---CONFSTR-CHK-1"
>__confstr_chk</A
>&nbsp;--&nbsp;get configuration dependent string variables, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---CTYPE-B-LOC"
>__ctype_b_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b array for ctype functions</DT
><DT
><A
HREF="#BASELIB---CTYPE-GET-MB-CUR-MAX-1"
>__ctype_get_mb_cur_max</A
>&nbsp;--&nbsp;maximum length of a multibyte character in the current locale</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOLOWER-LOC"
>__ctype_tolower_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b_tolower array for ctype tolower() function</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOUPPER-LOC"
>__ctype_toupper_loc</A
>&nbsp;--&nbsp;accessor function for <TT
CLASS="FUNCTION"
>__ctype_b_toupper()</TT
>
array for ctype <TT
CLASS="FUNCTION"
>toupper()</TT
> function</DT
><DT
><A
HREF="#BASELIB---CXA-ATEXIT"
>__cxa_atexit</A
>&nbsp;--&nbsp;register a function to be called by exit or when a shared library is unloaded</DT
><DT
><A
HREF="#BASELIB---CXA-FINALIZE"
>__cxa_finalize</A
>&nbsp;--&nbsp;call destructors of global (or local static) C++
objects and exit functions registered with atexit</DT
><DT
><A
HREF="#BASELIB---DAYLIGHT"
>__daylight</A
>&nbsp;--&nbsp;external daylight savings time flag</DT
><DT
><A
HREF="#BASELIB---ENVIRON"
>__environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB---ERRNO-LOCATION"
>__errno_location</A
>&nbsp;--&nbsp;address of errno variable</DT
><DT
><A
HREF="#BASELIB---FGETS-CHK-1"
>__fgets_chk</A
>&nbsp;--&nbsp;string input, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---FGETS-UNLOCKED-CHK-1"
>__fgets_unlocked_chk</A
>&nbsp;--&nbsp;non-locking string input, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---FGETWS-CHK-1"
>__fgetws_chk</A
>&nbsp;--&nbsp;read a wide-character string from a FILE stream, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---FGETWS-UNLOCKED-CHK-1"
>__fgetws_unlocked_chk</A
>&nbsp;--&nbsp;read a wide-character string from a FILE stream in a non-locking manner, with stack checking</DT
><DT
><A
HREF="#BASELIB---FPENDING"
>__fpending</A
>&nbsp;--&nbsp;returns in bytes the amount of output pending on a stream</DT
><DT
><A
HREF="#BASELIB---FPRINTF-CHK-1"
>__fprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---FWPRINTF-CHK-1"
>__fwprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---FXSTATAT-1"
>__fxstatat</A
>&nbsp;--&nbsp;get file status relative to directory file descriptor</DT
><DT
><A
HREF="#BASELIB---FXSTATAT64-1"
>__fxstatat64, fstatat64</A
>&nbsp;--&nbsp;get file status relative to a directory file descriptor (Large File Support)</DT
><DT
><A
HREF="#BASELIB---GETCWD-CHK-1"
>__getcwd_chk</A
>&nbsp;--&nbsp;get current working directory, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---GETGROUPS-CHK-1"
>__getgroups_chk</A
>&nbsp;--&nbsp;get list of supplementary group IDs, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---GETHOSTNAME-CHK-1"
>__gethostname_chk</A
>&nbsp;--&nbsp;get host name, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---GETLOGIN-R-CHK-1"
>__getlogin_r_chk</A
>&nbsp;--&nbsp;get user name, with buffer overflow checking (reentrant)</DT
><DT
><A
HREF="#BASELIB---GETPAGESIZE"
>__getpagesize</A
>&nbsp;--&nbsp;alias for getpagesize - get current page size </DT
><DT
><A
HREF="#BASELIB---GETPGID-1"
>__getpgid</A
>&nbsp;--&nbsp;get the process group id</DT
><DT
><A
HREF="#BASELIB---H-ERRNO-LOCATION"
>__h_errno_location</A
>&nbsp;--&nbsp;address of h_errno variable</DT
><DT
><A
HREF="#BASELIB---ISINF"
>__isinf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFF"
>__isinff</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFL"
>__isinfl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNAN"
>__isnan</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANF"
>__isnanf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANL"
>__isnanl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMAX-1"
>__libc_current_sigrtmax</A
>&nbsp;--&nbsp;return number of available real-time signal with lowest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMIN-1"
>__libc_current_sigrtmin</A
>&nbsp;--&nbsp;return number of available real-time signal with highest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-START-MAIN-"
>__libc_start_main</A
>&nbsp;--&nbsp;initialization routine</DT
><DT
><A
HREF="#BASELIB---MBSNRTOWCS-CHK-1"
>__mbsnrtowcs_chk</A
>&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MBSRTOWCS-CHK-1"
>__mbsrtowcs_chk</A
>&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MBSTOWCS-CHK-1"
>__mbstowcs_chk</A
>&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMCPY-CHK-1"
>__memcpy_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMMOVE-CHK-1"
>__memmove_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMPCPY"
>__mempcpy</A
>&nbsp;--&nbsp;copy given number of bytes of source to destination</DT
><DT
><A
HREF="#BASELIB---MEMPCPY-CHK-1"
>__mempcpy_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMSET-CHK-1"
>__memset_chk</A
>&nbsp;--&nbsp;fill memory with a constant byte, using buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---PREAD64-CHK-1"
>__pread64_chk</A
>&nbsp;--&nbsp;read from a file descriptor at a given offset, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---PREAD-CHK-1"
>__pread_chk</A
>&nbsp;--&nbsp;read from a file descriptor at a given offset, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---PRINTF-CHK-1"
>__printf_chk</A
>&nbsp;--&nbsp;format and print data, with stack checking</DT
><DT
><A
HREF="#BASELIB---RAWMEMCHR"
>__rawmemchr</A
>&nbsp;--&nbsp;scan memory</DT
><DT
><A
HREF="#BASELIB---READ-CHK-1"
>__read_chk</A
>&nbsp;--&nbsp;read from a file descriptor, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---READLINK-CHK-1"
>__readlink_chk</A
>&nbsp;--&nbsp;display value of a symbolic link, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---REALPATH-CHK-1"
>__realpath_chk</A
>&nbsp;--&nbsp;return the canonicalized absolute pathname, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---RECV-CHK-1"
>__recv_chk</A
>&nbsp;--&nbsp;receive a message from a socket, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---RECVFROM-CHK-1"
>__recvfrom_chk</A
>&nbsp;--&nbsp;receive a message from a socket, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---REGISTER-ATFORK"
>__register_atfork</A
>&nbsp;--&nbsp;alias for register_atfork</DT
><DT
><A
HREF="#BASELIB---SIGSETJMP-1"
>__sigsetjmp</A
>&nbsp;--&nbsp;save stack context for non-local goto</DT
><DT
><A
HREF="#BASELIB---SNPRINTF-CHK-1"
>__snprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---SPRINTF-CHK-1"
>__sprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---STACK-CHK-FAIL-1"
>__stack_chk_fail</A
>&nbsp;--&nbsp;terminate a function in case of stack overflow</DT
><DT
><A
HREF="#LIBUTIL---STPCPY-2"
>__stpcpy</A
>&nbsp;--&nbsp;alias for stpcpy</DT
><DT
><A
HREF="#BASELIB---STPCPY-CHK-1"
>__stpcpy_chk</A
>&nbsp;--&nbsp;copy a string returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STPNCPY-CHK-1"
>__stpncpy_chk</A
>&nbsp;--&nbsp;copy a fixed-size string, returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRCAT-CHK-1"
>__strcat_chk</A
>&nbsp;--&nbsp;concatenate two strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRCPY-CHK-1"
>__strcpy_chk</A
>&nbsp;--&nbsp;copy a string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRDUP-1"
>__strdup</A
>&nbsp;--&nbsp;alias for strdup</DT
><DT
><A
HREF="#BASELIB---STRNCAT-CHK-1"
>__strncat_chk</A
>&nbsp;--&nbsp;concatenate two strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRNCPY-CHK-1"
>__strncpy_chk</A
>&nbsp;--&nbsp;copy a string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRTOD-INTERNAL-1"
>__strtod_internal</A
>&nbsp;--&nbsp;underlying function for strtod</DT
><DT
><A
HREF="#BASELIB---STRTOF-INTERNAL"
>__strtof_internal</A
>&nbsp;--&nbsp;underlying function for strtof</DT
><DT
><A
HREF="#BASELIB---STRTOK-R-1"
>__strtok_r</A
>&nbsp;--&nbsp;alias for strtok_r</DT
><DT
><A
HREF="#BASELIB---STRTOL-INTERNAL-1"
>__strtol_internal</A
>&nbsp;--&nbsp;alias for strtol</DT
><DT
><A
HREF="#BASELIB---STRTOLD-INTERNAL-1"
>__strtold_internal</A
>&nbsp;--&nbsp;underlying function for strtold</DT
><DT
><A
HREF="#BASELIB---STRTOLL-INTERNAL-1"
>__strtoll_internal</A
>&nbsp;--&nbsp;underlying function for strtoll</DT
><DT
><A
HREF="#BASELIB---STRTOUL-INTERNAL"
>__strtoul_internal</A
>&nbsp;--&nbsp;underlying function for strtoul</DT
><DT
><A
HREF="#BASELIB---STRTOULL-INTERNAL-1"
>__strtoull_internal</A
>&nbsp;--&nbsp;underlying function for strtoull</DT
><DT
><A
HREF="#BASELIB---SWPRINTF-CHK-1"
>__swprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---SYSCONF"
>__sysconf</A
>&nbsp;--&nbsp;get configuration information at runtime</DT
><DT
><A
HREF="#BASELIB---SYSLOG-CHK-1"
>__syslog_chk</A
>&nbsp;--&nbsp;send messages to the system logger, with stack checking</DT
><DT
><A
HREF="#BASELIB---SYSV-SIGNAL-1"
>__sysv_signal</A
>&nbsp;--&nbsp;signal handling</DT
><DT
><A
HREF="#BASELIB---TIMEZONE"
>__timezone</A
>&nbsp;--&nbsp;external variable containing timezone</DT
><DT
><A
HREF="#BASELIB---TTYNAME-R-CHK-1"
>__ttyname_r_chk</A
>&nbsp;--&nbsp;return name of a terminal, with buffer overflow checking (reentrant)</DT
><DT
><A
HREF="#BASELIB---TZNAME"
>__tzname</A
>&nbsp;--&nbsp;external variable containing the timezone names</DT
><DT
><A
HREF="#BASELIB---VFPRINTF-CHK-1"
>__vfprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VFWPRINTF-CHK-1"
>__vfwprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VPRINTF-CHK-1"
>__vprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSNPRINTF-CHK-1"
>__vsnprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSPRINTF-CHK-1"
>__vsprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSWPRINTF-CHK-1"
>__vswprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSYSLOG-CHK-1"
>__vsyslog_chk</A
>&nbsp;--&nbsp;send messages to the system logger, with stack checking</DT
><DT
><A
HREF="#BASELIB---VWPRINTF-CHK-1"
>__vwprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---WCPCPY-CHK-1"
>__wcpcpy_chk</A
>&nbsp;--&nbsp;copy a wide-character string, returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCPNCPY-CHK-1"
>__wcpncpy_chk</A
>&nbsp;--&nbsp;copy a fixed-size string of wide characters, returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCRTOMB-CHK-1"
>__wcrtomb_chk</A
>&nbsp;--&nbsp;convert a wide character to a multibyte sequence, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSCAT-CHK-1"
>__wcscat_chk</A
>&nbsp;--&nbsp;concatenate two wide-character strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSCPY-CHK-1"
>__wcscpy_chk</A
>&nbsp;--&nbsp;copy a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSNCAT-CHK-1"
>__wcsncat_chk</A
>&nbsp;--&nbsp;concatenate two wide-character strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSNCPY-CHK-1"
>__wcsncpy_chk</A
>&nbsp;--&nbsp;copy a fixed-size string of wide characters, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSNRTOMBS-CHK-1"
>__wcsnrtombs_chk</A
>&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSRTOMBS-CHK-1"
>__wcsrtombs_chk</A
>&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSTOD-INTERNAL-1"
>__wcstod_internal</A
>&nbsp;--&nbsp;underlying function for wcstod</DT
><DT
><A
HREF="#BASELIB---WCSTOF-INTERNAL-1"
>__wcstof_internal</A
>&nbsp;--&nbsp;underlying function for wcstof</DT
><DT
><A
HREF="#BASELIB---WCSTOL-INTERNAL-1"
>__wcstol_internal</A
>&nbsp;--&nbsp;underlying function for wcstol</DT
><DT
><A
HREF="#BASELIB---WCSTOLD-INTERNAL-1"
>__wcstold_internal</A
>&nbsp;--&nbsp;underlying function for wcstold</DT
><DT
><A
HREF="#BASELIB---WCSTOMBS-CHK-1"
>__wcstombs_chk</A
>&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSTOUL-INTERNAL-1"
>__wcstoul_internal</A
>&nbsp;--&nbsp;underlying function for wcstoul</DT
><DT
><A
HREF="#BASELIB---WCTOMB-CHK-1"
>__wctomb_chk</A
>&nbsp;--&nbsp;convert a wide character to a multibyte sequence, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMCPY-CHK-1"
>__wmemcpy_chk</A
>&nbsp;--&nbsp;copy an array of wide-characters, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMMOVE-CHK-1"
>__wmemmove_chk</A
>&nbsp;--&nbsp;copy an array of wide-characters, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMPCPY-CHK-1"
>__wmempcpy_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMSET-CHK-1"
>__wmemset_chk</A
>&nbsp;--&nbsp;fill an array of wide-characters with a constant wide character, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WPRINTF-CHK-1"
>__wprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---XMKNOD-1"
>__xmknod</A
>&nbsp;--&nbsp;make a special file</DT
><DT
><A
HREF="#BASELIB---XMKNODAT-1"
>__xmknodat</A
>&nbsp;--&nbsp;make a special file relative to a directory file descriptor</DT
><DT
><A
HREF="#BASELIB---XPG-BASENAME"
>__xpg_basename</A
>&nbsp;--&nbsp;return the last component of a file name</DT
><DT
><A
HREF="#BASELIB---XPG-SIGPAUSE"
>__xpg_sigpause</A
>&nbsp;--&nbsp;remove a signal from the signal mask and suspend the thread</DT
><DT
><A
HREF="#BASELIB---XPG-STRERROR-R"
>__xpg_strerror_r</A
>&nbsp;--&nbsp;return string describing error number</DT
><DT
><A
HREF="#BASELIB---XSTAT"
>__xstat</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB---XSTAT64"
>__xstat64</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB--ENVIRON"
>_environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB--NL-MSG-CAT-CNTR"
>_nl_msg_cat_cntr</A
>&nbsp;--&nbsp;new catalog load counter</DT
><DT
><A
HREF="#BASELIB--SYS-ERRLIST"
>_sys_errlist</A
>&nbsp;--&nbsp;array containing the "C" locale strings used by strerror()</DT
><DT
><A
HREF="#BASELIB--SYS-SIGLIST"
>_sys_siglist</A
>&nbsp;--&nbsp;array containing the names of the signal names</DT
><DT
><A
HREF="#BASELIB-ACCT-3"
>acct</A
>&nbsp;--&nbsp;switch process accounting on or off</DT
><DT
><A
HREF="#BASELIB-ADJTIME-2"
>adjtime</A
>&nbsp;--&nbsp;correct the time to allow synchronization of the system clock</DT
><DT
><A
HREF="#BASELIB-ALPHASORT64-1"
>alphasort64</A
>&nbsp;--&nbsp;Comparison function for directory scanning (Large File Support)</DT
><DT
><A
HREF="#BASELIB-ARGZ-ADD"
>argz_add,
argz_add_sep,
argz_append,
argz_count,
argz_create,
argz_create_sep,
argz_delete,
argz_extract,
argz_insert,
argz_next,
argz_replace,
argz_stringify</A
>&nbsp;--&nbsp;Operate on argz vectors</DT
><DT
><A
HREF="#BASELIB-ASPRINTF"
>asprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-BACKTRACE-1"
>backtrace, backtrace_symbols, backtrace_symbols_fd</A
>&nbsp;--&nbsp;runtime stack back tracing</DT
><DT
><A
HREF="#BASELIB-BASENAME-3"
>basename</A
>&nbsp;--&nbsp;return the last component of a file name</DT
><DT
><A
HREF="#BASELIB-BIND-TEXTDOMAIN-CODESET"
>bind_textdomain_codeset</A
>&nbsp;--&nbsp;specify encoding for message retrieval</DT
><DT
><A
HREF="#BASELIB-BINDRESVPORT-3"
>bindresvport</A
>&nbsp;--&nbsp;bind socket to privileged IP port</DT
><DT
><A
HREF="#BASELIB-BINDTEXTDOMAIN"
>bindtextdomain</A
>&nbsp;--&nbsp;specify the location of a message catalog</DT
><DT
><A
HREF="#BASELIB-CFMAKERAW-3"
>cfmakeraw</A
>&nbsp;--&nbsp;get and set terminal attributes</DT
><DT
><A
HREF="#BASELIB-CFSETSPEED-3"
>cfsetspeed</A
>&nbsp;--&nbsp;set terminal input and output data rate</DT
><DT
><A
HREF="#BASELIB-CLEARERR-UNLOCKED-1"
>clearerr_unlocked</A
>&nbsp;--&nbsp;non-thread-safe clearerr</DT
><DT
><A
HREF="#BASELIB-DAEMON-3"
>daemon</A
>&nbsp;--&nbsp;run in the background</DT
><DT
><A
HREF="#BASELIB-DCGETTEXT"
>dcgettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog</DT
><DT
><A
HREF="#BASELIB-DCNGETTEXT"
>dcngettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog
with plural</DT
><DT
><A
HREF="#BASELIB-DGETTEXT"
>dgettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current LC_MESSAGES locale</DT
><DT
><A
HREF="#BASELIB-DL-ITERATE-PHDR-1"
>dl_iterate_phdr</A
>&nbsp;--&nbsp;iterate over a program's loaded shared objects</DT
><DT
><A
HREF="#BASELIB-DNGETTEXT"
>dngettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current locale</DT
><DT
><A
HREF="#BASELIB-DRAND48-R-1"
>drand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-ENDUTENT-3"
>endutent</A
>&nbsp;--&nbsp;access utmp file entries</DT
><DT
><A
HREF="#BASELIB-ENVZ-ADD"
>envz_add,
envz_entry,
envz_get,
envz_merge,
envz_remove,
envz_strip</A
>&nbsp;--&nbsp;Operate on environment vectors</DT
><DT
><A
HREF="#BASELIB-EPOLL-CREATE-1"
>epoll_create</A
>&nbsp;--&nbsp;open an epoll file descriptor</DT
><DT
><A
HREF="#BASELIB-EPOLL-CTL-1"
>epoll_ctl</A
>&nbsp;--&nbsp;control an epoll file descriptor</DT
><DT
><A
HREF="#BASELIB-EPOLL-WAIT-1"
>epoll_wait</A
>&nbsp;--&nbsp;wait for I/O events on an epoll file descriptor</DT
><DT
><A
HREF="#BASELIB-ERAND48-R-1"
>erand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-ERR-3"
>err</A
>&nbsp;--&nbsp;display formatted error messages</DT
><DT
><A
HREF="#BASELIB-ERROR-N"
>error</A
>&nbsp;--&nbsp;print error message</DT
><DT
><A
HREF="#BASELIB-ERRX-3"
>errx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-FCNTL-3"
>fcntl</A
>&nbsp;--&nbsp;file control</DT
><DT
><A
HREF="#BASELIB-FEOF-UNLOCKED-1"
>feof_unlocked</A
>&nbsp;--&nbsp;non-thread-safe feof</DT
><DT
><A
HREF="#BASELIB-FERROR-UNLOCKED-1"
>ferror_unlocked</A
>&nbsp;--&nbsp;non-thread-safe ferror</DT
><DT
><A
HREF="#BASELIB-FFLUSH-UNLOCKED-1"
>fflush_unlocked</A
>&nbsp;--&nbsp;non thread safe fflush</DT
><DT
><A
HREF="#BASELIB-FGETC-UNLOCKED-1"
>fgetc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fgetc</DT
><DT
><A
HREF="#BASELIB-FGETS-UNLOCKED-1"
>fgets_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fgets</DT
><DT
><A
HREF="#BASELIB-FGETWC-UNLOCKED-1"
>fgetwc_unlocked</A
>&nbsp;--&nbsp;non thread safe fgetwc</DT
><DT
><A
HREF="#BASELIB-FGETWS-UNLOCKED-1"
>fgetws_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fgetws</DT
><DT
><A
HREF="#BASELIB-FILENO-UNLOCKED-1"
>fileno_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fileno</DT
><DT
><A
HREF="#BASELIB-FLOCK-2"
>flock</A
>&nbsp;--&nbsp;apply or remove an advisory lock on an open file</DT
><DT
><A
HREF="#BASELIB-FNMATCH-3"
>fnmatch</A
>&nbsp;--&nbsp;match a filename or a pathname</DT
><DT
><A
HREF="#BASELIB-FPUTC-UNLOCKED-1"
>fputc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputc</DT
><DT
><A
HREF="#BASELIB-FPUTS-UNLOCKED-1"
>fputs_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputs</DT
><DT
><A
HREF="#BASELIB-FPUTWC-UNLOCKED-1"
>fputwc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputwc</DT
><DT
><A
HREF="#BASELIB-FPUTWS-UNLOCKED-1"
>fputws_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputws</DT
><DT
><A
HREF="#BASELIB-FREAD-UNLOCKED-1"
>fread_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fread</DT
><DT
><A
HREF="#BASELIB-FSCANF"
>fscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-FSTATFS-2"
>fstatfs</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-FSTATFS64"
>fstatfs64</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-FUTIMES"
>futimes</A
>&nbsp;--&nbsp;set file access and modification times</DT
><DT
><A
HREF="#BASELIB-FWRITE-UNLOCKED-1"
>fwrite_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fwrite</DT
><DT
><A
HREF="#BASELIB-FWSCANF"
>fwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-GETCWD"
>getcwd</A
>&nbsp;--&nbsp;get the pathname of the current working directory</DT
><DT
><A
HREF="#BASELIB-GETDOMAINNAME"
>getdomainname</A
>&nbsp;--&nbsp;get NIS domain name (DEPRECATED).</DT
><DT
><A
HREF="#BASELIB-GETDTABLESIZE"
>getdtablesize</A
>&nbsp;--&nbsp;get file descriptor table size (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETGRENT-R-1"
>getgrent_r</A
>&nbsp;--&nbsp;reentrantly get entry in group file</DT
><DT
><A
HREF="#BASELIB-GETGROUPLIST-3"
>getgrouplist</A
>&nbsp;--&nbsp;get groups a user belongs to</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYADDR-R-3"
>gethostbyaddr_r</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYNAME2-3"
>gethostbyname2</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYNAME2-R-3"
>gethostbyname2_r</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYNAME-R-3"
>gethostbyname_r</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETIFADDRS"
>getifaddrs</A
>&nbsp;--&nbsp;get interface addresses</DT
><DT
><A
HREF="#BASELIB-GETLOADAVG-3"
>getloadavg</A
>&nbsp;--&nbsp;get system load averages</DT
><DT
><A
HREF="#LIBUTIL-GETOPT-3"
>getopt</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-3"
>getopt_long</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-ONLY-3"
>getopt_long_only</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETPAGESIZE"
>getpagesize</A
>&nbsp;--&nbsp;get memory page size (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETPROTOBYNAME-R"
>getprotobyname_r</A
>&nbsp;--&nbsp;retrieve information from the network protocol database by protocol name, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETPROTOBYNUMBER-R"
>getprotobynumber_r</A
>&nbsp;--&nbsp;retrieve information from the network protocol database by protocol number, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETPROTOENT-R"
>getprotoent_r</A
>&nbsp;--&nbsp;read the next entry of the protocol database, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETPWENT-R-1"
>getpwent_r</A
>&nbsp;--&nbsp;reentrantly get entry in passwd file</DT
><DT
><A
HREF="#BASELIB-GETRLIMIT-1"
>getrlimit, setrlimit</A
>&nbsp;--&nbsp;get resource consumption limits</DT
><DT
><A
HREF="#BASELIB-GETSERVBYNAME-R"
>getservbyname_r</A
>&nbsp;--&nbsp;retrieve information from the network services database by service name, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETSERVBYPORT-R"
>getservbyport_r</A
>&nbsp;--&nbsp;retrieve information from the network services database by service port, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETSERVENT-R"
>getservent_r</A
>&nbsp;--&nbsp;read the next entry of the network services database, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETSOCKOPT-1"
>getsockopt</A
>&nbsp;--&nbsp;get socket options</DT
><DT
><A
HREF="#BASELIB-GETTEXT"
>gettext</A
>&nbsp;--&nbsp;search message catalogs for a string</DT
><DT
><A
HREF="#BASELIB-GETUTENT-3"
>getutent</A
>&nbsp;--&nbsp;access user accounting database entries	</DT
><DT
><A
HREF="#BASELIB-GETUTENT-R-3"
>getutent_r</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-GETWC-UNLOCKED-1"
>getwc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe getwc</DT
><DT
><A
HREF="#BASELIB-GETWCHAR-UNLOCKED-1"
>getwchar_unlocked</A
>&nbsp;--&nbsp;non-thread-safe getwchar</DT
><DT
><A
HREF="#BASELIB-GLOB64"
>glob64</A
>&nbsp;--&nbsp;find pathnames matching a pattern  (Large File Support)</DT
><DT
><A
HREF="#BASELIB-GLOBFREE64"
>globfree64</A
>&nbsp;--&nbsp;free memory from glob64() (Large File Support)</DT
><DT
><A
HREF="#BASELIB-GNU-GET-LIBC-VERSION-1"
>gnu_get_libc_version, gnu_get_libc_release</A
>&nbsp;--&nbsp;get glibc-specific version and release</DT
><DT
><A
HREF="#BASELIB-HCREATE-R"
>hcreate_r</A
>&nbsp;--&nbsp;allocate space for a hash search table, reentrantly</DT
><DT
><A
HREF="#BASELIB-HDESTROY-R"
>hdestroy_r</A
>&nbsp;--&nbsp;dispose of a hash search table, reentrantly</DT
><DT
><A
HREF="#BASELIB-HSEARCH-R"
>hsearch_r</A
>&nbsp;--&nbsp;search a hash table, reentrantly</DT
><DT
><A
HREF="#BASELIB-INET-ATON-3"
>inet_aton</A
>&nbsp;--&nbsp;Internet address manipulation routine</DT
><DT
><A
HREF="#BASELIB-INITGROUPS-3"
>initgroups</A
>&nbsp;--&nbsp;initialize the supplementary group access list</DT
><DT
><A
HREF="#BASELIB-INITSTATE-R-1"
>initstate_r</A
>&nbsp;--&nbsp;reentrantly initialize a state array for random number generator functions</DT
><DT
><A
HREF="#BASELIB-INOTIFY-ADD-WATCH"
>inotify_add_watch</A
>&nbsp;--&nbsp;add a watch to a watch list</DT
><DT
><A
HREF="#BASELIB-INOTIFY-INIT"
>inotify_init</A
>&nbsp;--&nbsp;instantiate inotify</DT
><DT
><A
HREF="#BASELIB-INOTIFY-RM-WATCH"
>inotify_rm_watch</A
>&nbsp;--&nbsp;remove a watch from an inotify watch list</DT
><DT
><A
HREF="#BASELIB-IOCTL-2"
>ioctl</A
>&nbsp;--&nbsp;control device</DT
><DT
><A
HREF="#BASELIB-SOCKIO-2"
>sockio</A
>&nbsp;--&nbsp;socket ioctl commands</DT
><DT
><A
HREF="#BASELIB-TTYIO-2"
>ttyio</A
>&nbsp;--&nbsp;tty ioctl commands</DT
><DT
><A
HREF="#BASELIB-JRAND48-R-1"
>jrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-KILL-3"
>kill</A
>&nbsp;--&nbsp;send a signal</DT
><DT
><A
HREF="#BASELIB-LCONG48-R-1"
>lcong48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-LINK-1"
>link</A
>&nbsp;--&nbsp;create a link to a file</DT
><DT
><A
HREF="#BASELIB-LRAND48-R-1"
>lrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-MEMMEM-3"
>memmem</A
>&nbsp;--&nbsp;locate bytes</DT
><DT
><A
HREF="#BASELIB-MEMRCHR"
>memrchr</A
>&nbsp;--&nbsp;scan memory for a character</DT
><DT
><A
HREF="#BASELIB-MKSTEMP64"
>mkstemp64</A
>&nbsp;--&nbsp;create a unique temporary file (Large File Support)</DT
><DT
><A
HREF="#BASELIB-MRAND48-R-1"
>mrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-MREMAP"
>mremap</A
>&nbsp;--&nbsp;remap a virtual memory address</DT
><DT
><A
HREF="#BASELIB-NGETTEXT"
>ngettext</A
>&nbsp;--&nbsp;search message catalogs for plural string</DT
><DT
><A
HREF="#BASELIB-NRAND48-R-1"
>nrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-OPENAT64"
>openat64</A
>&nbsp;--&nbsp;open a file relative to a directory file descriptor (Large File Support)</DT
><DT
><A
HREF="#BASELIB-PMAP-GETPORT-3"
>pmap_getport</A
>&nbsp;--&nbsp;find the port number assigned to a service registered with a
portmapper.</DT
><DT
><A
HREF="#BASELIB-PMAP-SET-3"
>pmap_set</A
>&nbsp;--&nbsp;establishes mapping to machine's RPC Bind service.</DT
><DT
><A
HREF="#BASELIB-PMAP-UNSET-3"
>pmap_unset</A
>&nbsp;--&nbsp;
destroys RPC Binding&#13;</DT
><DT
><A
HREF="#BASELIB-POSIX-FADVISE64"
>posix_fadvise64</A
>&nbsp;--&nbsp;File advisory information (Large File Support)</DT
><DT
><A
HREF="#BASELIB-POSIX-FALLOCATE64"
>posix_fallocate64</A
>&nbsp;--&nbsp;file space control (Large File Support)</DT
><DT
><A
HREF="#BASELIB-PREAD64"
>pread64</A
>&nbsp;--&nbsp;read from a file (Large File Support)</DT
><DT
><A
HREF="#BASELIB-PTRACE-1"
>ptrace</A
>&nbsp;--&nbsp;process trace</DT
><DT
><A
HREF="#BASELIB-PUTWC-UNLOCKED-1"
>putwc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe putwc</DT
><DT
><A
HREF="#BASELIB-PUTWCHAR-UNLOCKED-1"
>putwchar_unlocked</A
>&nbsp;--&nbsp;non-thread-safe putwchar</DT
><DT
><A
HREF="#BASELIB-PWRITE64"
>pwrite64</A
>&nbsp;--&nbsp;write on a file (Large File Support)</DT
><DT
><A
HREF="#BASELIB-RANDOM-R-1"
>random_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-READDIR64-R"
>readdir64_r</A
>&nbsp;--&nbsp;read a directory (Large File Support)</DT
><DT
><A
HREF="#BASELIB-REGEXEC-2"
>regexec</A
>&nbsp;--&nbsp;regular expression matching</DT
><DT
><A
HREF="#BASELIB-SCANDIR64-1"
>scandir64</A
>&nbsp;--&nbsp;scan a directory (Large File Support)</DT
><DT
><A
HREF="#BASELIB-SCANF"
>scanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SCHED-GETAFFINITY"
>sched_getaffinity</A
>&nbsp;--&nbsp;retrieve the affinity mask of a process</DT
><DT
><A
HREF="#BASELIB-SCHED-SETAFFINITY"
>sched_setaffinity</A
>&nbsp;--&nbsp;set the CPU affinity mask for a process</DT
><DT
><A
HREF="#BASELIB-SCHED-SETSCHEDULER"
>sched_setscheduler</A
>&nbsp;--&nbsp;set scheduling policy and parameters</DT
><DT
><A
HREF="#BASELIB-SEED48-R-1"
>seed48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-SENDFILE"
>sendfile</A
>&nbsp;--&nbsp;transfer data between two file descriptors</DT
><DT
><A
HREF="#BASELIB-SENDFILE64"
>sendfile64</A
>&nbsp;--&nbsp;transfer data between two file descriptors (Large File Support)</DT
><DT
><A
HREF="#BASELIB-SETBUFFER-3"
>setbuffer</A
>&nbsp;--&nbsp;stream buffering operation</DT
><DT
><A
HREF="#BASELIB-SETGROUPS-2"
>setgroups</A
>&nbsp;--&nbsp;set list of supplementary group IDs</DT
><DT
><A
HREF="#BASELIB-SETHOSTNAME-2"
>sethostname</A
>&nbsp;--&nbsp;set host name</DT
><DT
><A
HREF="#BASELIB-SETSOCKOPT-2"
>setsockopt</A
>&nbsp;--&nbsp;set socket options</DT
><DT
><A
HREF="#BASELIB-SETSTATE-R-1"
>setstate_r</A
>&nbsp;--&nbsp;reentrantly change the state array used by random number generator functions</DT
><DT
><A
HREF="#BASELIB-SETUTENT-3"
>setutent</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-SIGANDSET"
>sigandset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical AND</DT
><DT
><A
HREF="#BASELIB-SIGISEMPTYSET"
>sigisemptyset</A
>&nbsp;--&nbsp;check for empty signal set</DT
><DT
><A
HREF="#BASELIB-SIGORSET"
>sigorset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical OR</DT
><DT
><A
HREF="#BASELIB-SIGPAUSE-3"
>sigpause</A
>&nbsp;--&nbsp;remove a signal from the signal mask and suspend the thread (deprecated)</DT
><DT
><A
HREF="#BASELIB-SIGRETURN-2"
>sigreturn</A
>&nbsp;--&nbsp;return from signal handler and cleanup stack frame</DT
><DT
><A
HREF="#BASELIB-SRAND48-R-1"
>srand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-SRANDOM-R-1"
>srandom_r</A
>&nbsp;--&nbsp;reentrantly set the seed for a new sequence of pseudorandom numbers</DT
><DT
><A
HREF="#BASELIB-SSCANF"
>sscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-STATFS-2"
>statfs</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-STATFS64"
>statfs64</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-STIME-2"
>stime</A
>&nbsp;--&nbsp;set time</DT
><DT
><A
HREF="#BASELIB-STRCASESTR"
>strcasestr</A
>&nbsp;--&nbsp;locate a substring ignoring case</DT
><DT
><A
HREF="#BASELIB-STRERROR-R"
>strerror_r</A
>&nbsp;--&nbsp;return string describing error number</DT
><DT
><A
HREF="#BASELIB-STRPTIME-3"
>strptime</A
>&nbsp;--&nbsp;parse a time string</DT
><DT
><A
HREF="#BASELIB-STRSEP-3"
>strsep</A
>&nbsp;--&nbsp;extract token from string</DT
><DT
><A
HREF="#BASELIB-STRTOQ-3"
>strtoq</A
>&nbsp;--&nbsp;convert string value to a long or quad_t integer</DT
><DT
><A
HREF="#BASELIB-STRTOUQ-3"
>strtouq</A
>&nbsp;--&nbsp;convert a string to an unsigned long long</DT
><DT
><A
HREF="#BASELIB-SVC-REGISTER-3"
>svc_register</A
>&nbsp;--&nbsp;register Remote Procedure Call interface</DT
><DT
><A
HREF="#BASELIB-SVC-RUN-3"
>svc_run</A
>&nbsp;--&nbsp;waits for RPC requests to arrive and calls service procedure</DT
><DT
><A
HREF="#BASELIB-SVC-SENDREPLY-3"
>svc_sendreply</A
>&nbsp;--&nbsp;called by RPC service's dispatch routine</DT
><DT
><A
HREF="#BASELIB-SVCTCP-CREATE-3"
>svctcp_create</A
>&nbsp;--&nbsp;create a TCP/IP-based RPC service transport</DT
><DT
><A
HREF="#BASELIB-SVCUDP-CREATE-3"
>svcudp_create</A
>&nbsp;--&nbsp;		create a UDP-based RPC service transport
		</DT
><DT
><A
HREF="#BASELIB-SWSCANF"
>swscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SYSCONF"
>sysconf</A
>&nbsp;--&nbsp;Get configuration information at runtime</DT
><DT
><A
HREF="#BASELIB-SYSINFO-1"
>sysinfo</A
>&nbsp;--&nbsp;return system information</DT
><DT
><A
HREF="#BASELIB-SYSTEM-3"
>system</A
>&nbsp;--&nbsp;execute a shell command</DT
><DT
><A
HREF="#BASELIB-TEXTDOMAIN"
>textdomain</A
>&nbsp;--&nbsp;set the current default message domain</DT
><DT
><A
HREF="#BASELIB-UNLINK-3"
>unlink</A
>&nbsp;--&nbsp;remove a directory entry</DT
><DT
><A
HREF="#BASELIB-UTMPNAME-3"
>utmpname</A
>&nbsp;--&nbsp;set user accounting database</DT
><DT
><A
HREF="#BASELIB-VASPRINTF"
>vasprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-VERRX-3"
>verrx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-VFSCANF"
>vfscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VFWSCANF"
>vfwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSCANF"
>vscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSSCANF"
>vsscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSWSCANF"
>vswscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSYSLOG-3"
>vsyslog</A
>&nbsp;--&nbsp;log to system log</DT
><DT
><A
HREF="#BASELIB-VWSCANF"
>vwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-WAIT4-2"
>wait4</A
>&nbsp;--&nbsp;wait for process termination, BSD style</DT
><DT
><A
HREF="#BASELIB-WARN-3"
>warn</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WARNX-3"
>warnx</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WCSTOQ"
>wcstoq</A
>&nbsp;--&nbsp;convert wide string to long long int representation</DT
><DT
><A
HREF="#BASELIB-WCSTOUQ"
>wcstouq</A
>&nbsp;--&nbsp;convert wide string to unsigned long long int representation</DT
><DT
><A
HREF="#BASELIB-WSCANF"
>wscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-XDR-U-INT-3"
>xdr_u_int</A
>&nbsp;--&nbsp;library routines for external data representation</DT
><DT
><A
HREF="#BASELIB-XDRSTDIO-CREATE-3"
>xdrstdio_create</A
>&nbsp;--&nbsp;library routines for external data representation</DT
></DL
></DD
><DT
>14.6. <A
HREF="#LIBM"
>Interfaces for libm</A
></DT
><DD
><DL
><DT
>14.6.1. <A
HREF="#AEN21464"
>Math</A
></DT
></DL
></DD
><DT
>14.7. <A
HREF="#LIBM-DDEFS"
>Data Definitions for libm</A
></DT
><DD
><DL
><DT
>14.7.1. <A
HREF="#AEN22851"
>complex.h</A
></DT
><DT
>14.7.2. <A
HREF="#AEN22855"
>fenv.h</A
></DT
><DT
>14.7.3. <A
HREF="#AEN22859"
>math.h</A
></DT
></DL
></DD
><DT
>14.8. <A
HREF="#LIBMMAN"
>Interface Definitions for libm</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB---FINITE"
>__finite</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---FINITEF"
>__finitef</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---FINITEL"
>__finitel</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---FPCLASSIFY"
>__fpclassify</A
>&nbsp;--&nbsp;Classify real floating type</DT
><DT
><A
HREF="#BASELIB---FPCLASSIFYF"
>__fpclassifyf</A
>&nbsp;--&nbsp;Classify real floating type</DT
><DT
><A
HREF="#BASELIB---SIGNBIT"
>__signbit</A
>&nbsp;--&nbsp;test sign of floating point value</DT
><DT
><A
HREF="#BASELIB---SIGNBITF"
>__signbitf</A
>&nbsp;--&nbsp;test sign of floating point value</DT
><DT
><A
HREF="#BASELIB---CLOG10"
>clog10</A
>&nbsp;--&nbsp;Logarithm of a Complex Number</DT
><DT
><A
HREF="#BASELIB---CLOG10F"
>clog10f</A
>&nbsp;--&nbsp;Logarithm of a Complex Number</DT
><DT
><A
HREF="#BASELIB---CLOG10L"
>clog10l</A
>&nbsp;--&nbsp;Logarithm of a Complex Number</DT
><DT
><A
HREF="#BASELIB-DREM"
>drem</A
>&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-DREMF"
>dremf</A
>&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-DREML"
>dreml</A
>&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-EXP10"
>exp10</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-EXP10F"
>exp10f</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-EXP10L"
>exp10l</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-FEDISABLEEXCEPT"
>fedisableexcept</A
>&nbsp;--&nbsp;disable floating point exceptions</DT
><DT
><A
HREF="#BASELIB-FEENABLEEXCEPT"
>feenableexcept</A
>&nbsp;--&nbsp;enable floating point exceptions</DT
><DT
><A
HREF="#BASELIB-FEGETEXCEPT"
>fegetexcept</A
>&nbsp;--&nbsp;query floating point exception handling state</DT
><DT
><A
HREF="#BASELIB-FINITE"
>finite</A
>&nbsp;--&nbsp;test for infinity (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-FINITEF"
>finitef</A
>&nbsp;--&nbsp;test for infinity (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-FINITEL"
>finitel</A
>&nbsp;--&nbsp;test for infinity (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GAMMA"
>gamma</A
>&nbsp;--&nbsp;log gamma function (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GAMMAF"
>gammaf</A
>&nbsp;--&nbsp;log gamma function (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GAMMAL"
>gammal</A
>&nbsp;--&nbsp;log gamma function (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-J0F"
>j0f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-J0L"
>j0l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-J1F"
>j1f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-J1L"
>j1l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-JNF"
>jnf</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-JNL"
>jnl</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-LGAMMA-R"
>lgamma_r</A
>&nbsp;--&nbsp;log gamma functions</DT
><DT
><A
HREF="#BASELIB-LGAMMAF-R"
>lgammaf_r</A
>&nbsp;--&nbsp;log gamma functions</DT
><DT
><A
HREF="#BASELIB-LGAMMAL-R"
>lgammal_r</A
>&nbsp;--&nbsp;log gamma functions</DT
><DT
><A
HREF="#BASELIB-MATHERR-1"
>matherr</A
>&nbsp;--&nbsp;math library exception handling</DT
><DT
><A
HREF="#BASELIB-POW10"
>pow10</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-POW10F"
>pow10f</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-POW10L"
>pow10l</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-SCALBF"
>scalbf</A
>&nbsp;--&nbsp;load exponent of radix-independent floating point number</DT
><DT
><A
HREF="#BASELIB-SCALBL"
>scalbl</A
>&nbsp;--&nbsp;load exponent of radix-independent floating point number</DT
><DT
><A
HREF="#BASELIB-SIGNIFICAND"
>significand</A
>&nbsp;--&nbsp;floating point mantissa</DT
><DT
><A
HREF="#BASELIB-SIGNIFICANDF"
>significandf</A
>&nbsp;--&nbsp;floating point mantissa</DT
><DT
><A
HREF="#BASELIB-SIGNIFICANDL"
>significandl</A
>&nbsp;--&nbsp;floating point mantissa</DT
><DT
><A
HREF="#BASELIB-SINCOS"
>sincos</A
>&nbsp;--&nbsp;trigonometric functions</DT
><DT
><A
HREF="#BASELIB-SINCOSF"
>sincosf</A
>&nbsp;--&nbsp;trigonometric functions</DT
><DT
><A
HREF="#BASELIB-SINCOSL"
>sincosl</A
>&nbsp;--&nbsp;trigonometric functions</DT
><DT
><A
HREF="#BASELIB-Y0F"
>y0f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-Y0L"
>y0l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-Y1F"
>y1f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-Y1L"
>y1l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-YNF"
>ynf</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-YNL"
>ynl</A
>&nbsp;--&nbsp;Bessel functions</DT
></DL
></DD
><DT
>14.9. <A
HREF="#LIBPTHREAD"
>Interfaces for libpthread</A
></DT
><DD
><DL
><DT
>14.9.1. <A
HREF="#AEN25089"
>Realtime Threads</A
></DT
><DT
>14.9.2. <A
HREF="#AEN25165"
>Advanced Realtime Threads</A
></DT
><DT
>14.9.3. <A
HREF="#AEN25235"
>Posix Threads</A
></DT
><DT
>14.9.4. <A
HREF="#AEN25630"
>Thread aware versions of libc interfaces</A
></DT
><DT
>14.9.5. <A
HREF="#AEN25669"
>GNU Extensions for libpthread</A
></DT
><DT
>14.9.6. <A
HREF="#AEN25708"
>System Calls</A
></DT
><DT
>14.9.7. <A
HREF="#AEN25781"
>Standard I/O</A
></DT
><DT
>14.9.8. <A
HREF="#AEN25800"
>Signal Handling</A
></DT
><DT
>14.9.9. <A
HREF="#AEN25839"
>Standard Library</A
></DT
><DT
>14.9.10. <A
HREF="#AEN25875"
>Socket Interface</A
></DT
><DT
>14.9.11. <A
HREF="#AEN25928"
>Terminal Interface Functions</A
></DT
></DL
></DD
><DT
>14.10. <A
HREF="#LIBPTHREAD-DDEFS"
>Data Definitions for libpthread</A
></DT
><DD
><DL
><DT
>14.10.1. <A
HREF="#AEN25953"
>lsb/pthread.h</A
></DT
><DT
>14.10.2. <A
HREF="#AEN25957"
>pthread.h</A
></DT
><DT
>14.10.3. <A
HREF="#AEN25961"
>semaphore.h</A
></DT
></DL
></DD
><DT
>14.11. <A
HREF="#LIBPTHREADMAN"
>Interface Definitions for libpthread</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-POP"
>_pthread_cleanup_pop</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-PUSH"
>_pthread_cleanup_push</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
><DT
><A
HREF="#BASELIB-PTHREAD-GETATTR-NP-1"
>pthread_getattr_np</A
>&nbsp;--&nbsp;get thread attributes</DT
><DT
><A
HREF="#BASELIB-PTHREAD-MUTEX-CONSISTENT-NP-1"
>pthread_mutex_consistent_np</A
>&nbsp;--&nbsp;mark state protected by robust mutex as consistent</DT
><DT
><A
HREF="#BASELIB-PTHREAD-MUTEXATTR-GETROBUST-NP-1"
>pthread_mutexattr_getrobust_np, pthread_mutexattr_setrobust_np</A
>&nbsp;--&nbsp;get and set the mutex robust attribute</DT
><DT
><A
HREF="#BASELIB-PTHREAD-RWLOCKATTR-GETKIND-NP-1"
>pthread_rwlockattr_getkind_np, pthread_rwlockattr_setkind_np</A
>&nbsp;--&nbsp;get/set the read-write lock kind of the thread read-write lock attribute object</DT
><DT
><A
HREF="#BASELIB-WAITPID-3"
>waitpid</A
>&nbsp;--&nbsp;wait for child process</DT
></DL
></DD
><DT
>14.12. <A
HREF="#LIBGCC-S"
>Interfaces for libgcc_s</A
></DT
><DD
><DL
><DT
>14.12.1. <A
HREF="#AEN26258"
>Unwind Library</A
></DT
></DL
></DD
><DT
>14.13. <A
HREF="#LIBGCC-S-DDEFS"
>Data Definitions for libgcc_s</A
></DT
><DD
><DL
><DT
>14.13.1. <A
HREF="#AEN26340"
>unwind.h</A
></DT
></DL
></DD
><DT
>14.14. <A
HREF="#LIBGCC-SMAN"
>Interface Definitions for libgcc_s</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB--UNWIND-BACKTRACE"
>_Unwind_Backtrace</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-DELETEEXCEPTION"
>_Unwind_DeleteException</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-FINDENCLOSINGFUNCTION"
>_Unwind_FindEnclosingFunction</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-FORCEDUNWIND-1"
>_Unwind_ForcedUnwind</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETCFA"
>_Unwind_GetCFA</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETGR"
>_Unwind_GetGR</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETIP"
>_Unwind_GetIP</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETIPINFO"
>_Unwind_GetIPInfo</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETLANGUAGESPECIFICDATA-1"
>_Unwind_GetLanguageSpecificData</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETREGIONSTART"
>_Unwind_GetRegionStart</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-RAISEEXCEPTION"
>_Unwind_RaiseException</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-RESUME"
>_Unwind_Resume</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-RESUME-OR-RETHROW"
>_Unwind_Resume_or_Rethrow</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-SETGR"
>_Unwind_SetGR</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-SETIP-1"
>_Unwind_SetIP</A
>&nbsp;--&nbsp;private C++ error handling method</DT
></DL
></DD
><DT
>14.15. <A
HREF="#LIBDL"
>Interfaces for libdl</A
></DT
><DD
><DL
><DT
>14.15.1. <A
HREF="#AEN26806"
>Dynamic Loader</A
></DT
></DL
></DD
><DT
>14.16. <A
HREF="#LIBDL-DDEFS"
>Data Definitions for libdl</A
></DT
><DD
><DL
><DT
>14.16.1. <A
HREF="#AEN26851"
>dlfcn.h</A
></DT
></DL
></DD
><DT
>14.17. <A
HREF="#LIBDLMAN"
>Interface Definitions for libdl</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB-DLADDR-3"
>dladdr</A
>&nbsp;--&nbsp;find the shared object containing a given address</DT
><DT
><A
HREF="#BASELIB-DLOPEN-1"
>dlopen</A
>&nbsp;--&nbsp;open dynamic object</DT
><DT
><A
HREF="#BASELIB-DLSYM-1"
>dlsym</A
>&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DT
><DT
><A
HREF="#BASELIB-DLVSYM-1"
>dlvsym</A
>&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DT
></DL
></DD
><DT
>14.18. <A
HREF="#LIBRT"
>Interfaces for librt</A
></DT
><DD
><DL
><DT
>14.18.1. <A
HREF="#AEN27085"
>Shared Memory Objects</A
></DT
><DT
>14.18.2. <A
HREF="#AEN27107"
>Asynchronous I/O</A
></DT
><DT
>14.18.3. <A
HREF="#AEN27186"
>Clock</A
></DT
><DT
>14.18.4. <A
HREF="#AEN27222"
>Timers</A
></DT
><DT
>14.18.5. <A
HREF="#AEN27258"
>Message Queues</A
></DT
></DL
></DD
><DT
>14.19. <A
HREF="#LIBRT-DDEFS"
>Data Definitions for librt</A
></DT
><DD
><DL
><DT
>14.19.1. <A
HREF="#AEN27320"
>aio.h</A
></DT
><DT
>14.19.2. <A
HREF="#AEN27324"
>mqueue.h</A
></DT
></DL
></DD
><DT
>14.20. <A
HREF="#LIBCRYPT"
>Interfaces for libcrypt</A
></DT
><DD
><DL
><DT
>14.20.1. <A
HREF="#AEN27348"
>Encryption</A
></DT
></DL
></DD
><DT
>14.21. <A
HREF="#LIBCRYPT-DDEFS"
>Data Definitions for libcrypt</A
></DT
><DD
><DL
><DT
>14.21.1. <A
HREF="#AEN27393"
>crypt.h</A
></DT
></DL
></DD
><DT
>14.22. <A
HREF="#LIBCRYPTMAN"
>Interface Definitions for libcrypt</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB-CRYPT-R-1"
>crypt_r</A
>&nbsp;--&nbsp;Cryptographic string encoding function</DT
><DT
><A
HREF="#BASELIB-ENCRYPT-R-1"
>encrypt_r</A
>&nbsp;--&nbsp;Cryptographic encoding function</DT
><DT
><A
HREF="#BASELIB-SETKEY-R-1"
>setkey_r</A
>&nbsp;--&nbsp;Set cryptographic encoding key</DT
></DL
></DD
><DT
>14.23. <A
HREF="#LIBPAM"
>Interfaces for libpam</A
></DT
><DD
><DL
><DT
>14.23.1. <A
HREF="#AEN27548"
>Pluggable Authentication API</A
></DT
></DL
></DD
><DT
>14.24. <A
HREF="#LIBPAM-DDEFS"
>Data Definitions for libpam</A
></DT
><DD
><DL
><DT
>14.24.1. <A
HREF="#AEN27644"
>security/_pam_types.h</A
></DT
><DT
>14.24.2. <A
HREF="#AEN27648"
>security/pam_appl.h</A
></DT
><DT
>14.24.3. <A
HREF="#AEN27652"
>security/pam_modules.h</A
></DT
></DL
></DD
><DT
>14.25. <A
HREF="#LIBPAMMAN"
>Interface Definitions for libpam</A
></DT
><DD
><DL
><DT
><A
HREF="#BASELIB-PAM-ACCT-MGMT"
>pam_acct_mgmt</A
>&nbsp;--&nbsp;establish the status of a user's account</DT
><DT
><A
HREF="#BASELIB-PAM-AUTHENTICATE"
>pam_authenticate</A
>&nbsp;--&nbsp;authenticate the user</DT
><DT
><A
HREF="#BASELIB-PAM-CHAUTHTOK"
>pam_chauthtok</A
>&nbsp;--&nbsp;change the authentication token for a given user</DT
><DT
><A
HREF="#BASELIB-PAM-CLOSE-SESSION"
>pam_close_session</A
>&nbsp;--&nbsp;indicate that an authenticated session has ended</DT
><DT
><A
HREF="#BASELIB-PAM-END"
>pam_end</A
>&nbsp;--&nbsp;terminate the use of the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-FAIL-DELAY"
>pam_fail_delay</A
>&nbsp;--&nbsp;specify delay time to use on authentication error</DT
><DT
><A
HREF="#BASELIB-PAM-GET-ITEM"
>pam_get_item</A
>&nbsp;--&nbsp;obtain the value of the indicated item.</DT
><DT
><A
HREF="#BASELIB-PAM-GETENV"
>pam_getenv</A
>&nbsp;--&nbsp;get a PAM environment variable</DT
><DT
><A
HREF="#BASELIB-PAM-GETENVLIST"
>pam_getenvlist</A
>&nbsp;--&nbsp;returns a pointer to the complete PAM environment.</DT
><DT
><A
HREF="#BASELIB-PAM-OPEN-SESSION"
>pam_open_session</A
>&nbsp;--&nbsp;indicate session has started</DT
><DT
><A
HREF="#BASELIB-PAM-PUTENV"
>pam_putenv</A
>&nbsp;--&nbsp;Add, replace or delete a PAM environment variable</DT
><DT
><A
HREF="#BASELIB-PAM-SET-ITEM"
>pam_set_item</A
>&nbsp;--&nbsp;(re)set the value of an item.</DT
><DT
><A
HREF="#BASELIB-PAM-SETCRED"
>pam_setcred</A
>&nbsp;--&nbsp;set the module-specific credentials of the user</DT
><DT
><A
HREF="#BASELIB-PAM-START"
>pam_start</A
>&nbsp;--&nbsp;initialize the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-STRERROR"
>pam_strerror</A
>&nbsp;--&nbsp;returns a string describing the PAM error</DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BASELIB"
></A
>Chapter 14. Base Libraries</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN2163"
>14.1. Introduction</A
></H2
><P
>An LSB-conforming implementation shall support the following
base libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.
<P
></P
><UL
><LI
><P
>libc</P
></LI
><LI
><P
>libm</P
></LI
><LI
><P
>libgcc_s</P
></LI
><LI
><P
>libdl</P
></LI
><LI
><P
>librt</P
></LI
><LI
><P
>libcrypt</P
></LI
><LI
><P
>libpam</P
></LI
></UL
></P
><P
>There are three main parts to the definition of each of these
libraries.</P
><P
>The "Interfaces" section defines the required library name and version,
and the required public symbols (interfaces and global data), as well
as symbol versions, if any.</P
><P
>The "Interface Definitions" section provides complete or partial
definitions of certain interfaces where either this specification is
the source specification, or where there are variations from the source
specification. If an interface definition requires one or more header 
files, one of those headers shall include the function 
prototype for the interface.</P
><P
>For source definitions of interfaces which include a reference to a
header file, the contents of such header files form a
part of the specification.  The "Data Definitions" section provides the
binary-level details for the header files from the source specifications,
such as values for macros and enumerated types, as well as structure layouts,
sizes and padding, etc.  These data definitions, although presented in the form
of header files for convenience, should not be taken a representing complete
header files, as they are a supplement to the source
specifications.  Application developers should follow the guidelines
of the source specifications when determining which header files need
to be included to completely resolve all references.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>While the Data Definitions supplement the source specifications,
this specification itself does not require conforming implementations
to supply any header files.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROGINTERP"
>14.2. Program Interpreter</A
></H2
><P
>The Program Interpreter is specified in the appropriate
architecture specific part of the LSB Core Specification.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBC"
>14.3. Interfaces for libc</A
></H2
><P
><A
HREF="#LIB-LIBC-DEF"
>Table 14-1</A
> defines the library name and shared object name
for the libc library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBC-DEF"
></A
><P
><B
>Table 14-1. libc Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libc</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>See architecture specific part.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBC.1"
></A
>[LFS] <A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.2"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.3"
></A
>[RPC + XDR] <A
HREF="#STD.RPC.XDR"
>RFC 5531/4506 RPC &#38; XDR</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.4"
></A
>[SUSv2] <A
HREF="#STD.SUSV2"
>SUSv2</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.5"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.6"
></A
>[SUSv4] <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBC.7"
></A
>[SVID.4] <A
HREF="#STD.SVID.4"
>SVID Issue 4</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2220"
>14.3.1. RPC</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2223"
>14.3.1.1. Interfaces for RPC</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for RPC specified in <A
HREF="#TBL-LIBC-RPC-INTS"
>Table 14-2</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-RPC-INTS"
></A
><P
><B
>Table 14-2. libc - RPC Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>authnone_create <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>callrpc <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>clnt_create <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>clnt_pcreateerror <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>clnt_perrno <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>clnt_perror <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>clnt_spcreateerror <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>clnt_sperrno <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>clnt_sperror <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>clntraw_create <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>clnttcp_create <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>clntudp_bufcreate <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
></TR
><TR
><TD
>clntudp_create <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>key_decryptsession <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>pmap_getport <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pmap_set <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>pmap_unset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>svc_getreqset <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>svc_register <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>svc_run <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>svc_sendreply <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>svcerr_auth <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>svcerr_decode <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>svcerr_noproc <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>svcerr_noprog <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>svcerr_progvers <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>svcerr_systemerr <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>svcerr_weakauth <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>svcfd_create <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>svcraw_create <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>svctcp_create <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>svcudp_create <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>xdr_accepted_reply <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_array <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_bool <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_bytes <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_callhdr <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_callmsg <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_char <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_double <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_enum <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_float <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_free <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_int <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_long <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_opaque <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_opaque_auth <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_pointer <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_reference <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_rejected_reply <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_replymsg <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_short <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_string <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_u_char <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_u_int <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>xdr_u_long <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_u_short <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_union <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_vector <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdr_void <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>xdr_wrapstring <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdrmem_create <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdrrec_create <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdrrec_endofrecord <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
></TR
><TR
><TD
>xdrrec_eof <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>xdrrec_skiprecord <A
HREF="#REFSTD.LIBC.3"
>[RPC + XDR]</A
></TD
><TD
>xdrstdio_create <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for RPC specified in <A
HREF="#TBL-LIBC-RPC-DEPINTS"
>Table 14-3</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-RPC-DEPINTS"
></A
><P
><B
>Table 14-3. libc - RPC Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>key_decryptsession <A
HREF="#REFSTD.LIBC.7"
>[SVID.4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2533"
>14.3.2. Epoll</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2536"
>14.3.2.1. Interfaces for Epoll</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Epoll specified in <A
HREF="#TBL-LIBC-EPOLL-INTS"
>Table 14-4</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-EPOLL-INTS"
></A
><P
><B
>Table 14-4. libc - Epoll Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>epoll_create(GLIBC_2.3.2) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>epoll_ctl(GLIBC_2.3.2) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>epoll_wait(GLIBC_2.3.2) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2558"
>14.3.3. System Calls</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2561"
>14.3.3.1. Interfaces for System Calls</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for System Calls specified in <A
HREF="#TBL-LIBC-SYSTE-INTS"
>Table 14-5</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SYSTE-INTS"
></A
><P
><B
>Table 14-5. libc - System Calls Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__chk_fail(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fxstat <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fxstatat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__getgroups_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__getpgid <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__lxstat <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__read_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__readlink_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__stack_chk_fail(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xmknod <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xmknodat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xstat <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>access <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>acct <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>alarm <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>backtrace <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>backtrace_symbols <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>backtrace_symbols_fd <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>brk <A
HREF="#REFSTD.LIBC.4"
>[SUSv2]</A
></TD
><TD
>chdir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>chmod <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>chown <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>chroot <A
HREF="#REFSTD.LIBC.4"
>[SUSv2]</A
></TD
><TD
>clock <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>close <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>closedir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>creat <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>dup <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dup2 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>execl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>execle <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>execlp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>execv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>execve <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>execvp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>exit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>faccessat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fchdir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fchmod <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fchmodat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fchown <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fchownat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fcntl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fdatasync <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fdopendir(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fexecve <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>flock <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fork <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fstatfs <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fstatvfs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fsync <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ftime <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ftruncate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>futimens(GLIBC_2.6) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>futimes(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getcontext <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>getdtablesize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getegid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>geteuid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getgid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getgroups <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getitimer <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getloadavg <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getpagesize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>getpgid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getpgrp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getpid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getppid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getpriority <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getrlimit <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getrusage <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getsid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getuid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getwd <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>initgroups <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>ioctl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>kill <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>killpg <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lchown <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>link <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>linkat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lockf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lseek <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lutimes(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>mkdir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mkdirat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mkfifo <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mkfifoat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mlock <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mlockall <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mmap <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mprotect <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mremap <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>msync <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>munlock <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>munlockall <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>munmap <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>nanosleep <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>nice <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>open <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>openat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>opendir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>pathconf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>pause <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pipe <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>poll <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>pread <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>pselect <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ptrace <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pwrite <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>read <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>readdir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>readdir_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>readlink <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>readlinkat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>readv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>rename <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>renameat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>rmdir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sbrk <A
HREF="#REFSTD.LIBC.4"
>[SUSv2]</A
></TD
></TR
><TR
><TD
>sched_get_priority_max <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sched_get_priority_min <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sched_getaffinity(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sched_getparam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sched_getscheduler <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sched_rr_get_interval <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sched_setaffinity(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sched_setparam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sched_setscheduler <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sched_yield <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>select <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setcontext <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>setegid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>seteuid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setgid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setitimer <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>setpgid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setpgrp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setpriority <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setregid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>setreuid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setrlimit <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setrlimit64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>setsid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>setuid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sleep <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>statfs <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>statvfs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>stime <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>symlink <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>symlinkat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sync <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sysconf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sysinfo <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>time <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>times <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>truncate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ulimit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>umask <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>uname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>unlink <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>unlinkat(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>utime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>utimensat(GLIBC_2.6) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>utimes <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vfork <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>wait <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wait4 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>waitid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>waitpid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>write <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>writev <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for System Calls specified in <A
HREF="#TBL-LIBC-SYSTE-DEPINTS"
>Table 14-6</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SYSTE-DEPINTS"
></A
><P
><B
>Table 14-6. libc - System Calls Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>fstatfs <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getdtablesize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getpagesize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getwd <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>statfs <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3333"
>14.3.4. Standard I/O</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3336"
>14.3.4.1. Interfaces for Standard I/O</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Standard I/O specified in <A
HREF="#TBL-LIBC-STAND-INTS"
>Table 14-7</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STAND-INTS"
></A
><P
><B
>Table 14-7. libc - Standard I/O Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_IO_feof <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_IO_getc <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_IO_putc <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_IO_puts <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fgets_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fgets_unlocked_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fgetws_unlocked_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__printf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__snprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__sprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__vfprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__vprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__vsnprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__vsprintf_chk <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>asprintf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>clearerr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>clearerr_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>ctermid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>dprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fclose <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fdopen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>feof <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>feof_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>ferror <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ferror_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fflush <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fflush_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>fgetc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fgetc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fgetpos <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fgets <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgets_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fgetwc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fgetws_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fileno <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fileno_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>flockfile <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fopen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fputc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fputs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fputs_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>fputwc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fputws_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fread <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fread_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>freopen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fseek <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fseeko <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fsetpos <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ftell <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ftello <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fwrite <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fwrite_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getc_unlocked <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getchar <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getchar_unlocked <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getdelim <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getline <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getw <A
HREF="#REFSTD.LIBC.4"
>[SUSv2]</A
></TD
></TR
><TR
><TD
>getwc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getwchar_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pclose <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>popen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>printf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>putc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>putc_unlocked <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>putchar <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>putchar_unlocked <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>puts <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>putw <A
HREF="#REFSTD.LIBC.4"
>[SUSv2]</A
></TD
><TD
>putwc_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>putwchar_unlocked <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>remove <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>rewind <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>rewinddir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>scanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>seekdir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setbuf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setbuffer <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>setvbuf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>snprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>telldir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tempnam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ungetc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vasprintf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>vdprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vfprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vsnprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>vsprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Standard I/O specified in <A
HREF="#TBL-LIBC-STAND-DEPINTS"
>Table 14-8</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STAND-DEPINTS"
></A
><P
><B
>Table 14-8. libc - Standard I/O Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>tempnam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Standard I/O specified in <A
HREF="#TBL-LIBC-STAND-DATA"
>Table 14-9</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STAND-DATA"
></A
><P
><B
>Table 14-9. libc - Standard I/O Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>stderr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>stdin <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>stdout <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3796"
>14.3.5. Signal Handling</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3799"
>14.3.5.1. Interfaces for Signal Handling</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Signal Handling specified in <A
HREF="#TBL-LIBC-SIGNA-INTS"
>Table 14-10</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SIGNA-INTS"
></A
><P
><B
>Table 14-10. libc - Signal Handling Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__libc_current_sigrtmax <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__libc_current_sigrtmin <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__sigsetjmp <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__sysv_signal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__xpg_sigpause <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>bsd_signal <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>psiginfo(GLIBC_2.10) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>psignal <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>raise <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigaction <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigaddset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigaltstack <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sigandset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sigdelset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigemptyset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigfillset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sighold <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigignore <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>siginterrupt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigisemptyset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>sigismember <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>siglongjmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>signal <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigorset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>sigpause <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sigpending <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigprocmask <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigqueue <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sigrelse <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigreturn <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sigset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigsuspend <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sigtimedwait <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigwait <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sigwaitinfo <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Signal Handling specified in <A
HREF="#TBL-LIBC-SIGNA-DEPINTS"
>Table 14-11</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SIGNA-DEPINTS"
></A
><P
><B
>Table 14-11. libc - Signal Handling Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>sigpause <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Signal Handling specified in <A
HREF="#TBL-LIBC-SIGNA-DATA"
>Table 14-12</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SIGNA-DATA"
></A
><P
><B
>Table 14-12. libc - Signal Handling Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_sys_siglist <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3987"
>14.3.6. Localization Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3990"
>14.3.6.1. Interfaces for Localization Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Localization Functions specified in <A
HREF="#TBL-LIBC-LOCAL-INTS"
>Table 14-13</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LOCAL-INTS"
></A
><P
><B
>Table 14-13. libc - Localization Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>bind_textdomain_codeset <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>bindtextdomain <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>catclose <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>catgets <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catopen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>dcgettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>dcngettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>dgettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>dngettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>duplocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>freelocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>gettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>iconv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iconv_close <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iconv_open <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>localeconv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>newlocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ngettext <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>nl_langinfo <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setlocale <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>textdomain <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>uselocale(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Localization Functions specified in <A
HREF="#TBL-LIBC-LOCAL-DATA"
>Table 14-14</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LOCAL-DATA"
></A
><P
><B
>Table 14-14. libc - Localization Functions Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_nl_msg_cat_cntr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4108"
>14.3.7. Posix Spawn Option</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4111"
>14.3.7.1. Interfaces for Posix Spawn Option</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Posix Spawn Option specified in <A
HREF="#TBL-LIBC-POSIX-INTS"
>Table 14-15</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-POSIX-INTS"
></A
><P
><B
>Table 14-15. libc - Posix Spawn Option Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>posix_spawn <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawn_file_actions_addclose <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawn_file_actions_adddup2 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawn_file_actions_addopen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>posix_spawn_file_actions_destroy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawn_file_actions_init <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_destroy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getflags <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>posix_spawnattr_getpgroup <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getschedparam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getschedpolicy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getsigdefault <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>posix_spawnattr_getsigmask <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_init <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setflags <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setpgroup <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>posix_spawnattr_setschedparam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setschedpolicy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setsigdefault <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setsigmask <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>posix_spawnp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4212"
>14.3.8. Posix Advisory Option</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4215"
>14.3.8.1. Interfaces for Posix Advisory Option</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Posix Advisory Option specified in <A
HREF="#TBL-LIBC-POSIY-INTS"
>Table 14-16</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-POSIY-INTS"
></A
><P
><B
>Table 14-16. libc - Posix Advisory Option Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>posix_fadvise <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_fallocate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_madvise <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_memalign <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4240"
>14.3.9. Socket Interface</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4243"
>14.3.9.1. Interfaces for Socket Interface</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Socket Interface specified in <A
HREF="#TBL-LIBC-SOCKE-INTS"
>Table 14-17</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SOCKE-INTS"
></A
><P
><B
>Table 14-17. libc - Socket Interface Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gethostname_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__h_errno_location <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__recv_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__recvfrom_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>accept <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>bind <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>bindresvport <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>connect <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>freeifaddrs(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>gethostname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getifaddrs(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>getpeername <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getsockname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getsockopt <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>if_freenameindex <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>if_indextoname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>if_nameindex <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>if_nametoindex <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>listen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>recv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>recvfrom <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>recvmsg <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>send <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sendmsg <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>sendto <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setsockopt <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>shutdown <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sockatmark <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>socket <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>socketpair <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Socket Interface specified in <A
HREF="#TBL-LIBC-SOCKE-DATA"
>Table 14-18</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SOCKE-DATA"
></A
><P
><B
>Table 14-18. libc - Socket Interface Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>in6addr_any <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>in6addr_loopback <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4401"
>14.3.10. Wide Characters</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4404"
>14.3.10.1. Interfaces for Wide Characters</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Wide Characters specified in <A
HREF="#TBL-LIBC-WIDE-INTS"
>Table 14-19</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-WIDE-INTS"
></A
><P
><B
>Table 14-19. libc - Wide Characters Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__fgetws_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fwprintf_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__mbsnrtowcs_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__mbsrtowcs_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__mbstowcs_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__swprintf_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__vfwprintf_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__vswprintf_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__vwprintf_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcpcpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcpncpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcrtomb_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcscat_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcscpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcsncat_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcsncpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcsnrtombs_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcsrtombs_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstod_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstof_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcstol_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstold_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstombs_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wcstoul_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wctomb_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wmemcpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wmemmove_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wmempcpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wmemset_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__wprintf_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>btowc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fgetwc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetws <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fputwc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fputws <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fwide <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fwprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fwscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getwc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getwchar <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswalnum_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswalpha_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswblank_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswcntrl_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswctype_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswdigit_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswgraph_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswlower_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswprint_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswpunct_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswspace_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswupper_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswxdigit_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mblen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mbrlen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mbrtowc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mbsinit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mbsnrtowcs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mbsrtowcs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mbstowcs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mbtowc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>putwc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>putwchar <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>swprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>swscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>towctrans <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>towctrans_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>towlower <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>towlower_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>towupper <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>towupper_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ungetwc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>vfwprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vfwscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vswprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vswscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>vwprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>vwscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcpcpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcpncpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcrtomb <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscasecmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscasecmp_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscat <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcschr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscoll <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscoll_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcscpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcscspn <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsdup <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsftime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcslen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsncasecmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsncasecmp_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsncat <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcsncmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsncpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsnlen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsnrtombs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcspbrk <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsrchr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsrtombs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsspn <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcsstr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstod <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstof <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstoimax <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcstok <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstol <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstold <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstoll <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcstombs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstoq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcstoul <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstoull <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcstoumax <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcstouq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wcswcs <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>wcswidth <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcsxfrm <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wcsxfrm_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wctob <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wctomb <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wctrans <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wctrans_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wctype <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wctype_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wcwidth <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wmemchr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wmemcmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wmemcpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>wmemmove <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wmemset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wprintf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4990"
>14.3.11. String Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN4993"
>14.3.11.1. Interfaces for String Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for String Functions specified in <A
HREF="#TBL-LIBC-STRIN-INTS"
>Table 14-20</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STRIN-INTS"
></A
><P
><B
>Table 14-20. libc - String Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__memcpy_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__memmove_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__mempcpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__mempcpy_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__memset_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__rawmemchr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__stpcpy <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__stpcpy_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__stpncpy_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strcat_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strcpy_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strdup <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strncat_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strncpy_chk(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtod_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtof_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strtok_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtol_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtold_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtoll_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strtoul_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__strtoull_internal <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xpg_strerror_r(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>bcmp <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>bcopy <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>bzero <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>ffs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>index <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>memccpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>memchr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>memcmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>memcpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>memmove <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>memrchr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>memset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>rindex <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>stpcpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>stpncpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strcasecmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strcasecmp_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strcasestr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strcat <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strchr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strcmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strcoll <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strcoll_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strcpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strcspn <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strdup <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strerror <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strerror_l(GLIBC_2.6) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strerror_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>strfmon <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strfmon_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strftime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strftime_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strlen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strncasecmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strncasecmp_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strncat <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strncmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strncpy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strndup <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strnlen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strpbrk <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strptime <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strrchr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strsep <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>strsignal <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strspn <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strstr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtof <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strtoimax <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtok <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtok_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtold <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strtoll <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtoq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strtoull <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtoumax <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>strtouq <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strxfrm <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strxfrm_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>swab <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for String Functions specified in <A
HREF="#TBL-LIBC-STRIN-DEPINTS"
>Table 14-21</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STRIN-DEPINTS"
></A
><P
><B
>Table 14-21. libc - String Functions Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>strerror_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5374"
>14.3.12. IPC Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5377"
>14.3.12.1. Interfaces for IPC Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for IPC Functions specified in <A
HREF="#TBL-LIBC-IPC-F-INTS"
>Table 14-22</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-IPC-F-INTS"
></A
><P
><B
>Table 14-22. libc - IPC Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ftok <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>msgctl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>msgget <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>msgrcv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>msgsnd <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>semctl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>semget <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>semop <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>shmat <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>shmctl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>shmdt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>shmget <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5436"
>14.3.13. Regular Expressions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5439"
>14.3.13.1. Interfaces for Regular Expressions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Regular Expressions specified in <A
HREF="#TBL-LIBC-REGUL-INTS"
>Table 14-23</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-REGUL-INTS"
></A
><P
><B
>Table 14-23. libc - Regular Expressions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>regcomp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>regerror <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>regexec <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>regfree <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5464"
>14.3.14. Character Type Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5467"
>14.3.14.1. Interfaces for Character Type Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Character Type Functions specified in <A
HREF="#TBL-LIBC-CHARA-INTS"
>Table 14-24</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-CHARA-INTS"
></A
><P
><B
>Table 14-24. libc - Character Type Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__ctype_b_loc(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ctype_get_mb_cur_max <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ctype_tolower_loc(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ctype_toupper_loc(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>_tolower <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>_toupper <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isalnum <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isalnum_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>isalpha <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isalpha_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isascii <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isblank_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iscntrl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iscntrl_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isdigit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isdigit_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>isgraph <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isgraph_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>islower <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>islower_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>isprint <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isprint_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ispunct <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ispunct_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>isspace <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isspace_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isupper <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isupper_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswalnum <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswalpha <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswblank <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswcntrl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswctype <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswdigit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswgraph <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswlower <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswprint <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswpunct <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswspace <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>iswupper <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>iswxdigit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isxdigit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isxdigit_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>toascii <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>tolower <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tolower_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>toupper <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>toupper_l(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5679"
>14.3.15. Time Manipulation</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5682"
>14.3.15.1. Interfaces for Time Manipulation</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Time Manipulation specified in <A
HREF="#TBL-LIBC-TIME-INTS"
>Table 14-25</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-TIME-INTS"
></A
><P
><B
>Table 14-25. libc - Time Manipulation Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>adjtime <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>asctime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>asctime_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ctime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ctime_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>difftime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>gmtime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>gmtime_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>localtime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>localtime_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mktime <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tzset <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ualarm <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Time Manipulation specified in <A
HREF="#TBL-LIBC-TIME-DATA"
>Table 14-26</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-TIME-DATA"
></A
><P
><B
>Table 14-26. libc - Time Manipulation Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__daylight <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__timezone <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__tzname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>daylight <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>timezone <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tzname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5783"
>14.3.16. Terminal Interface Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5786"
>14.3.16.1. Interfaces for Terminal Interface Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Terminal Interface Functions specified in <A
HREF="#TBL-LIBC-TERMI-INTS"
>Table 14-27</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-TERMI-INTS"
></A
><P
><B
>Table 14-27. libc - Terminal Interface Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>cfgetispeed <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>cfgetospeed <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>cfmakeraw <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>cfsetispeed <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cfsetospeed <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>cfsetspeed <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>tcdrain <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tcflow <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>tcflush <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tcgetattr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tcgetpgrp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tcgetsid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>tcsendbreak <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tcsetattr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tcsetpgrp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN5859"
>14.3.17. System Database Interface</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN5862"
>14.3.17.1. Interfaces for System Database Interface</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for System Database Interface specified in <A
HREF="#TBL-LIBC-SYSTF-INTS"
>Table 14-28</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SYSTF-INTS"
></A
><P
><B
>Table 14-28. libc - System Database Interface Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>endgrent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>endprotoent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>endpwent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>endservent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>endutent <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>endutxent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getgrent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getgrent_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>getgrgid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getgrgid_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getgrnam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getgrnam_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getgrouplist <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostbyaddr <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>gethostbyaddr_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostbyname <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>gethostbyname2 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostbyname2_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostbyname_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getprotobyname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getprotobyname_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getprotobynumber <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getprotobynumber_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getprotoent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getprotoent_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getpwent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getpwent_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getpwnam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getpwnam_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getpwuid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getpwuid_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getservbyname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getservbyname_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getservbyport <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getservbyport_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getservent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getservent_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getutent <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getutent_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getutxent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getutxid <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getutxline <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>pututxline <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setgrent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>setgroups <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setprotoent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setpwent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setservent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>setutent <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setutxent <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>utmpname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for System Database Interface specified in <A
HREF="#TBL-LIBC-SYSTF-DEPINTS"
>Table 14-29</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-SYSTF-DEPINTS"
></A
><P
><B
>Table 14-29. libc - System Database Interface Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>gethostbyaddr <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>gethostbyaddr_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostbyname <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>gethostbyname2 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>gethostbyname2_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gethostbyname_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6124"
>14.3.18. Language Support</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN6127"
>14.3.18.1. Interfaces for Language Support</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Language Support specified in <A
HREF="#TBL-LIBC-LANGU-INTS"
>Table 14-30</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LANGU-INTS"
></A
><P
><B
>Table 14-30. libc - Language Support Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__libc_start_main <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__register_atfork(GLIBC_2.3.2) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6146"
>14.3.19. Large File Support</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN6149"
>14.3.19.1. Interfaces for Large File Support</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Large File Support specified in <A
HREF="#TBL-LIBC-LARGE-INTS"
>Table 14-31</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LARGE-INTS"
></A
><P
><B
>Table 14-31. libc - Large File Support Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__fxstat64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fxstatat64(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__lxstat64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xstat64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>creat64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fgetpos64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fopen64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>freopen64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>fseeko64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fsetpos64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>fstatfs64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fstatvfs64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>ftello64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>ftruncate64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>ftw64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>getrlimit64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>lockf64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>lseek64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>mkstemp64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>mmap64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>nftw64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>open64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>openat64(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>posix_fadvise64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>posix_fallocate64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pread64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>pwrite64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>readdir64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>readdir64_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>statfs64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>statvfs64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>tmpfile64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>truncate64 <A
HREF="#REFSTD.LIBC.1"
>[LFS]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Large File Support specified in <A
HREF="#TBL-LIBC-LARGE-DEPINTS"
>Table 14-32</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-LARGE-DEPINTS"
></A
><P
><B
>Table 14-32. libc - Large File Support Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>fstatfs64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>statfs64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6320"
>14.3.20. Inotify</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN6323"
>14.3.20.1. Interfaces for Inotify</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Inotify specified in <A
HREF="#TBL-LIBC-INOTI-INTS"
>Table 14-33</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-INOTI-INTS"
></A
><P
><B
>Table 14-33. libc - Inotify Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>inotify_add_watch(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>inotify_init(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>inotify_rm_watch(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN6345"
>14.3.21. Standard Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN6348"
>14.3.21.1. Interfaces for Standard Library</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Standard Library specified in <A
HREF="#TBL-LIBC-STANE-INTS"
>Table 14-34</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STANE-INTS"
></A
><P
><B
>Table 14-34. libc - Standard Library Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Exit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>__assert_fail <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__confstr_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__cxa_atexit <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__cxa_finalize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__errno_location <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__fpending <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__getcwd_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__getlogin_r_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__getpagesize <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isinf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isinff <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__isinfl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isnan <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isnanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__isnanl <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__pread64_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__pread_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__realpath_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__sysconf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>__syslog_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__ttyname_r_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__vsyslog_chk(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>__xpg_basename <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>_exit <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>_longjmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>_setjmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>a64l <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>abort <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>abs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>alphasort <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>alphasort64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>argz_add <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_add_sep <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_append <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_count <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>argz_create <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_create_sep <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_delete <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_extract <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>argz_insert <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_next <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_replace <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>argz_stringify <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>atof <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>atoi <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>atol <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>atoll <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>basename <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>bsearch <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>calloc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>closelog <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>confstr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>cuserid <A
HREF="#REFSTD.LIBC.4"
>[SUSv2]</A
></TD
><TD
>daemon <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>dirfd <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dirname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>div <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>dl_iterate_phdr <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>drand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>drand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>ecvt <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>envz_add <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>envz_entry <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>envz_get <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>envz_merge <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>envz_remove <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>envz_strip <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>erand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>erand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>err <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>error <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>errx <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fcvt <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>fmemopen <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>fmtmsg <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fnmatch <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>fpathconf <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>free <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>freeaddrinfo <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ftrylockfile <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ftw <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>funlockfile <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>gai_strerror <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>gcvt <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>getaddrinfo <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getcwd <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getdate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getdomainname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getenv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getlogin <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getlogin_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getnameinfo <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>getopt <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getopt_long <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getopt_long_only <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>getsubopt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>gettimeofday <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>glob <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>glob64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>globfree <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>globfree64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>grantpt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>hcreate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>hcreate_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>hdestroy <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>hdestroy_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>hsearch <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>hsearch_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>htonl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>htons <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>imaxabs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>imaxdiv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>inet_addr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>inet_aton <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>inet_ntoa <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>inet_ntop <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>inet_pton <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>initstate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>initstate_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>insque <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isatty <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>isblank <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>jrand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>jrand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>l64a <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>labs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lcong48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>lcong48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>ldiv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lfind <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>llabs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>lldiv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>longjmp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lrand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>lrand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>lsearch <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>makecontext <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>malloc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>memmem <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>mkdtemp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mkstemp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>mktemp <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>mrand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mrand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>nftw <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>nrand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>nrand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>ntohl <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ntohs <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>open_memstream <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>open_wmemstream(GLIBC_2.4) <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>openlog <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>perror <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>posix_openpt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ptsname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>putenv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>qsort <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>rand <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>rand_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>random <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>random_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>realloc <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>realpath <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>remque <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>scandir <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>scandir64 <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>seed48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>seed48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sendfile <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>sendfile64(GLIBC_2.3) <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setenv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sethostname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>setlogmask <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setstate <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>setstate_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>srand <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>srand48 <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>srand48_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>srandom <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>srandom_r <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>strtod <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtol <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>strtoul <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>swapcontext <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>syslog <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>system <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>tdelete <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>tfind <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tmpfile <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tmpnam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>tsearch <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ttyname <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>ttyname_r <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>twalk <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>unlockpt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>unsetenv <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>usleep <A
HREF="#REFSTD.LIBC.5"
>[SUSv3]</A
></TD
><TD
>verrx <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vfscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>vscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vsscanf <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>vsyslog <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>warn <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>warnx <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>wordexp <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>wordfree <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Standard Library specified in <A
HREF="#TBL-LIBC-STANE-DEPINTS"
>Table 14-35</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STANE-DEPINTS"
></A
><P
><B
>Table 14-35. libc - Standard Library Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basename <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>getdomainname <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>inet_aton <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>tmpnam <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Standard Library specified in <A
HREF="#TBL-LIBC-STANE-DATA"
>Table 14-36</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-STANE-DATA"
></A
><P
><B
>Table 14-36. libc - Standard Library Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__environ <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_environ <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>_sys_errlist <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>environ <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>getdate_err <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>optarg <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>opterr <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>optind <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>optopt <A
HREF="#REFSTD.LIBC.6"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7310"
>14.3.22. GNU Extensions for libc</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN7313"
>14.3.22.1. Interfaces for GNU Extensions for libc</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for GNU Extensions for libc specified in <A
HREF="#TBL-LIBC-GNU-E-INTS"
>Table 14-37</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBC-GNU-E-INTS"
></A
><P
><B
>Table 14-37. libc - GNU Extensions for libc Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>gnu_get_libc_release <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>gnu_get_libc_version <A
HREF="#REFSTD.LIBC.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBC-DDEFS"
>14.4. Data Definitions for libc</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libc.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7338"
>14.4.1. argz.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef int error_t;
extern error_t argz_add(char **argz, size_t * argz_len, const char *str);
extern error_t argz_add_sep(char **argz, size_t * argz_len,
			    const char *str, int sep);
extern error_t argz_append(char **argz, size_t * argz_len, const char *buf,
			   size_t buf_len);
extern size_t argz_count(const char *argz, size_t * argz_len);
extern error_t argz_create(char *const argv[], char **argz,
			   size_t * argz_len);
extern error_t argz_create_sep(const char *str, int sep, char **argz,
			       size_t * argz_len);
extern void argz_delete(char **argz, size_t * argz_len, char *entry);
extern void argz_extract(const char *argz, size_t argz_len, char **argv);
extern error_t argz_insert(char **argz_insert, size_t * argz_len,
			   char *before, const char *entry);
extern char argz_next(const char *argz, size_t argz_len,
		      const char *entry);
extern error_t argz_replace(char **argz, size_t * argz_len,
			    const char *str, const char *with,
			    unsigned int *replace_count);
extern void argz_stringify(char *argz, size_t argz_len, int sep);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7342"
>14.4.2. arpa/inet.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern uint32_t htonl(uint32_t);
extern uint16_t htons(uint16_t);
extern in_addr_t inet_addr(const char *__cp);
extern int inet_aton(const char *__cp, struct in_addr *__inp);
extern char *inet_ntoa(struct in_addr __in);
extern const char *inet_ntop(int __af, const void *__cp, char *__buf,
			     socklen_t __len);
extern int inet_pton(int __af, const char *__cp, void *__buf);
extern uint32_t ntohl(uint32_t);
extern uint16_t ntohs(uint16_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7346"
>14.4.3. assert.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#ifdef NDEBUG
#define assert(expr) ((void)0)
#else
#define assert(expr)	((void) ((expr) ? 0 : (__assert_fail (#expr, __FILE__, __LINE__, __PRETTY_FUNCTION__), 0)))
#endif

extern void __assert_fail(const char *__assertion, const char *__file,
			  unsigned int __line, const char *__function);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7350"
>14.4.4. cpio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define C_IXOTH	000001
#define C_IWOTH	000002
#define C_IROTH	000004
#define C_IXGRP	000010
#define C_IWGRP	000020
#define C_IRGRP	000040
#define C_IXUSR	000100
#define C_IWUSR	000200
#define C_IRUSR	000400
#define C_ISVTX	001000
#define C_ISGID	002000
#define C_ISUID	004000
#define C_ISFIFO	010000
#define C_ISREG	0100000
#define C_ISCTG	0110000
#define C_ISLNK	0120000
#define C_ISSOCK	0140000
#define C_ISCHR	020000
#define C_ISDIR	040000
#define C_ISBLK	060000
#define MAGIC	"070707"</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7354"
>14.4.5. ctype.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern const unsigned short **__ctype_b_loc(void);
extern const int32_t **__ctype_tolower_loc(void);
extern const int32_t **__ctype_toupper_loc(void);
extern int _tolower(int);
extern int _toupper(int);
extern int isalnum(int);
extern int isalnum_l(int c, locale_t locale);
extern int isalpha(int);
extern int isalpha_l(int c, locale_t locale);
extern int isascii(int __c);
extern int isblank(int);
extern int isblank_l(int c, locale_t locale);
extern int iscntrl(int);
extern int iscntrl_l(int c, locale_t locale);
extern int isdigit(int);
extern int isdigit_l(int c, locale_t locale);
extern int isgraph(int);
extern int isgraph_l(int c, locale_t locale);
extern int islower(int);
extern int islower_l(int c, locale_t locale);
extern int isprint(int);
extern int isprint_l(int c, locale_t locale);
extern int ispunct(int);
extern int ispunct_l(int c, locale_t locale);
extern int isspace(int);
extern int isspace_l(int c, locale_t locale);
extern int isupper(int);
extern int isupper_l(int c, locale_t locale);
extern int isxdigit(int);
extern int isxdigit_l(int c, locale_t locale);
extern int toascii(int __c);
extern int tolower(int __c);
extern int tolower_l(int c, locale_t locale);
extern int toupper(int __c);
extern int toupper_l(int c, locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7358"
>14.4.6. dirent.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MAXNAMLEN	NAME_MAX

typedef struct __dirstream DIR;

struct dirent {
    long int d_ino;
    off_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
struct dirent64 {
    uint64_t d_ino;
    int64_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
extern int alphasort(const struct dirent **__e1,
		     const struct dirent **__e2);
extern int alphasort64(const struct dirent64 **__e1,
		       const struct dirent64 **__e2);
extern int closedir(DIR * __dirp);
extern int dirfd(DIR * __dirp);
extern DIR *fdopendir(int __fd);
extern DIR *opendir(const char *__name);
extern struct dirent *readdir(DIR * __dirp);
extern struct dirent64 *readdir64(DIR * __dirp);
extern int readdir64_r(DIR * __dirp, struct dirent64 *__entry,
		       struct dirent64 **__result);
extern int readdir_r(DIR * __dirp, struct dirent *__entry,
		     struct dirent **__result);
extern void rewinddir(DIR * __dirp);
extern int scandir(const char *__dir, struct dirent ***__namelist,
		   int (*__selector) (const struct dirent *),
		   int (*__cmp) (const struct dirent * *,
				 const struct dirent * *));
extern int scandir64(const char *__dir, struct dirent64 ***__namelist,
		     int (*__selector) (const struct dirent64 *),
		     int (*__cmp) (const struct dirent64 * *,
				   const struct dirent64 * *));
extern void seekdir(DIR * __dirp, long int __pos);
extern long int telldir(DIR * __dirp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7362"
>14.4.7. elf.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ELFMAG1	'E'
#define ELFMAG3	'F'
#define ELFMAG2	'L'
#define ELF64_R_INFO(sym, type)	((((Elf64_Xword) (sym)) &#60;&#60; 32) + (type))
#define ELF32_ST_INFO(bind,type)	(((bind) &#60;&#60; 4) + ((type) &#38; 0xf))
#define ELF32_R_INFO(sym, type)	(((sym) &#60;&#60; 8) + ((type) &#38; 0xff))
#define ELF32_M_INFO(sym, size)	(((sym) &#60;&#60; 8) + (unsigned char) (size))
#define ELF32_ST_BIND(val)	(((unsigned char) (val)) &#62;&#62; 4)
#define ELF64_R_TYPE(i)	((i) &#38; 0xffffffff)
#define ELF64_R_SYM(i)	((i) &#62;&#62; 32)
#define ELF32_M_SYM(info)	((info) &#62;&#62; 8)
#define ELF32_ST_VISIBILITY(o)	((o) &#38; 0x03)
#define ELF32_M_SIZE(info)	((unsigned char) (info))
#define ELF32_ST_TYPE(val)	((val) &#38; 0xf)
#define ELF32_R_TYPE(val)	((val) &#38; 0xff)
#define ELF32_R_SYM(val)	((val) &#62;&#62; 8)
#define PF_X	(1 &#60;&#60; 0)
#define SHF_WRITE	(1 &#60;&#60; 0)
#define PF_W	(1 &#60;&#60; 1)
#define SHF_ALLOC	(1 &#60;&#60; 1)
#define SHF_TLS	(1 &#60;&#60; 10)
#define PF_R	(1 &#60;&#60; 2)
#define SHF_EXECINSTR	(1 &#60;&#60; 2)
#define SHF_MERGE	(1 &#60;&#60; 4)
#define SHF_STRINGS	(1 &#60;&#60; 5)
#define SHF_INFO_LINK	(1 &#60;&#60; 6)
#define SHF_LINK_ORDER	(1 &#60;&#60; 7)
#define SHF_OS_NONCONFORMING	(1 &#60;&#60; 8)
#define SHF_GROUP	(1 &#60;&#60; 9)
#define EI_NIDENT	(16)
#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))
#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
#define DT_PPC64_GLINK	(DT_LOPROC + 0)
#define DT_PPC_GOT	(DT_LOPROC + 0)
#define DT_PPC64_OPD	(DT_LOPROC + 1)
#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))
#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))
#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)
#define PT_IA_64_UNWIND	(PT_LOPROC + 1)
#define SHT_IA_64_EXT	(SHT_LOPROC + 0)
#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1)
#define DT_NULL	0
#define EI_MAG0	0
#define ELFCLASSNONE	0
#define ELFDATANONE	0
#define ELFOSABI_NONE	0
#define ELFOSABI_SYSV	0
#define ELF_NOTE_OS_LINUX	0
#define EM_NONE	0
#define ET_NONE	0
#define EV_NONE	0
#define PT_NULL	0
#define R_386_NONE	0
#define R_390_NONE	0
#define R_PPC_NONE	0
#define R_X86_64_NONE	0
#define SHN_UNDEF	0
#define SHT_NULL	0
#define STB_LOCAL	0
#define STN_UNDEF	0
#define STT_NOTYPE	0
#define STV_DEFAULT	0
#define SYMINFO_NONE	0
#define R_IA64_NONE	0x00
#define DF_1_NOW	0x00000001
#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
#define DF_P1_LAZYLOAD	0x00000001
#define DTF_1_PARINIT	0x00000001
#define EF_S390_HIGH_GPRS	0x00000001
#define DF_1_GLOBAL	0x00000002
#define DF_P1_GROUPPERM	0x00000002
#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions start with this object */
#define DTF_1_CONFEXP	0x00000002
#define DF_1_GROUP	0x00000004
#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
#define DF_1_NODELETE	0x00000008
#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
#define EF_IA_64_MASKOS	0x0000000f
#define DF_1_LOADFLTR	0x00000010
#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
#define EF_IA_64_ABI64	0x00000010
#define DF_1_INITFIRST	0x00000020
#define DF_1_NOOPEN	0x00000040
#define DF_1_ORIGIN	0x00000080
#define DF_1_DIRECT	0x00000100
#define DF_1_TRANS	0x00000200
#define DF_1_INTERPOSE	0x00000400
#define DF_1_NODEFLIB	0x00000800
#define DF_1_NODUMP	0x00001000
#define DF_1_CONFALT	0x00002000
#define DF_1_ENDFILTEE	0x00004000
#define DF_1_DISPRELDNE	0x00008000
#define SYMINFO_FLG_DIRECT	0x0001
#define DF_1_DISPRELPND	0x00010000
#define SYMINFO_FLG_PASSTHRU	0x0002
#define SYMINFO_FLG_COPY	0x0004
#define SYMINFO_FLG_LAZYLOAD	0x0008
#define EF_CPU32	0x00810000
#define PF_MASKOS	0x0ff00000
#define SHF_MASKOS	0x0ff00000
#define GRP_COMDAT	0x1
#define SHF_IA_64_SHORT	0x10000000
#define SHF_IA_64_NORECOV	0x20000000
#define R_IA64_IMM14	0x21
#define R_IA64_IMM22	0x22
#define R_IA64_IMM64	0x23
#define R_IA64_DIR32MSB	0x24
#define R_IA64_DIR32LSB	0x25
#define R_IA64_DIR64MSB	0x26
#define R_IA64_DIR64LSB	0x27
#define R_IA64_GPREL22	0x2a
#define R_IA64_GPREL64I	0x2b
#define R_IA64_GPREL32MSB	0x2c
#define R_IA64_GPREL32LSB	0x2d
#define R_IA64_GPREL64MSB	0x2e
#define R_IA64_GPREL64LSB	0x2f
#define R_IA64_LTOFF22	0x32
#define R_IA64_LTOFF64I	0x33
#define R_IA64_PLTOFF22	0x3a
#define R_IA64_PLTOFF64I	0x3b
#define R_IA64_PLTOFF64MSB	0x3e
#define R_IA64_PLTOFF64LSB	0x3f
#define R_IA64_FPTR64I	0x43
#define R_IA64_FPTR32MSB	0x44
#define R_IA64_FPTR32LSB	0x45
#define R_IA64_FPTR64MSB	0x46
#define R_IA64_FPTR64LSB	0x47
#define R_IA64_PCREL60B	0x48
#define R_IA64_PCREL21B	0x49
#define R_IA64_PCREL21M	0x4a
#define R_IA64_PCREL21F	0x4b
#define R_IA64_PCREL32MSB	0x4c
#define R_IA64_PCREL32LSB	0x4d
#define R_IA64_PCREL64MSB	0x4e
#define R_IA64_PCREL64LSB	0x4f
#define R_IA64_LTOFF_FPTR22	0x52
#define R_IA64_LTOFF_FPTR64I	0x53
#define R_IA64_LTOFF_FPTR32MSB	0x54
#define R_IA64_LTOFF_FPTR32LSB	0x55
#define R_IA64_LTOFF_FPTR64MSB	0x56
#define R_IA64_LTOFF_FPTR64LSB	0x57
#define R_IA64_SEGREL32MSB	0x5c
#define R_IA64_SEGREL32LSB	0x5d
#define R_IA64_SEGREL64MSB	0x5e
#define R_IA64_SEGREL64LSB	0x5f
#define PT_LOOS	0x60000000
#define SHT_LOOS	0x60000000
#define DT_LOOS	0x6000000d
#define R_IA64_SECREL32MSB	0x64
#define PT_GNU_EH_FRAME	0x6474e550
#define PT_GNU_STACK	0x6474e551
#define PT_GNU_RELRO	0x6474e552
#define R_IA64_SECREL32LSB	0x65
#define R_IA64_SECREL64MSB	0x66
#define R_IA64_SECREL64LSB	0x67
#define R_IA64_REL32MSB	0x6c
#define R_IA64_REL32LSB	0x6d
#define R_IA64_REL64MSB	0x6e
#define R_IA64_REL64LSB	0x6f
#define DT_HIOS	0x6ffff000
#define DT_VALRNGLO	0x6ffffd00
#define DT_GNU_PRELINKED	0x6ffffdf5
#define DT_GNU_CONFLICTSZ	0x6ffffdf6
#define DT_GNU_LIBLISTSZ	0x6ffffdf7
#define DT_CHECKSUM	0x6ffffdf8
#define DT_PLTPADSZ	0x6ffffdf9
#define DT_MOVEENT	0x6ffffdfa
#define DT_MOVESZ	0x6ffffdfb
#define DT_FEATURE_1	0x6ffffdfc
#define DT_POSFLAG_1	0x6ffffdfd
#define DT_SYMINSZ	0x6ffffdfe
#define DT_SYMINENT	0x6ffffdff
#define DT_VALRNGHI	0x6ffffdff
#define DT_ADDRRNGLO	0x6ffffe00
#define DT_GNU_HASH	0x6ffffef5
#define DT_TLSDESC_PLT	0x6ffffef6
#define DT_TLSDESC_GOT	0x6ffffef7
#define DT_GNU_CONFLICT	0x6ffffef8
#define DT_GNU_LIBLIST	0x6ffffef9
#define DT_CONFIG	0x6ffffefa
#define DT_DEPAUDIT	0x6ffffefb
#define DT_AUDIT	0x6ffffefc
#define DT_PLTPAD	0x6ffffefd
#define DT_MOVETAB	0x6ffffefe
#define DT_ADDRRNGHI	0x6ffffeff
#define DT_SYMINFO	0x6ffffeff
#define DT_VERSYM	0x6ffffff0
#define SHT_GNU_ATTRIBUTES	0x6ffffff5
#define SHT_GNU_HASH	0x6ffffff6
#define SHT_GNU_LIBLIST	0x6ffffff7
#define SHT_CHECKSUM	0x6ffffff8
#define DT_RELACOUNT	0x6ffffff9
#define DT_RELCOUNT	0x6ffffffa
#define DT_FLAGS_1	0x6ffffffb
#define DT_VERDEF	0x6ffffffc
#define DT_VERDEFNUM	0x6ffffffd
#define SHT_GNU_verdef	0x6ffffffd
#define DT_VERNEED	0x6ffffffe
#define SHT_GNU_verneed	0x6ffffffe
#define DT_VERNEEDNUM	0x6fffffff
#define PT_HIOS	0x6fffffff
#define SHT_GNU_versym	0x6fffffff
#define SHT_HIOS	0x6fffffff
#define DT_LOPROC	0x70000000
#define PT_LOPROC	0x70000000
#define SHT_LOPROC	0x70000000
#define R_IA64_LTV32MSB	0x74
#define R_IA64_LTV32LSB	0x75
#define R_IA64_LTV64MSB	0x76
#define R_IA64_LTV64LSB	0x77
#define R_IA64_PCREL21BI	0x79
#define R_IA64_PCREL22	0x7a
#define R_IA64_PCREL64I	0x7b
#define ELFMAG0	0x7f
#define DT_AUXILIARY	0x7ffffffd
#define DT_FILTER	0x7fffffff
#define DT_HIPROC	0x7fffffff
#define PT_HIPROC	0x7fffffff
#define SHT_HIPROC	0x7fffffff
#define R_IA64_IPLTMSB	0x80
#define PF_IA_64_NORECOV	0x80000000
#define SHT_LOUSER	0x80000000
#define R_IA64_IPLTLSB	0x81
#define R_IA64_COPY	0x84
#define R_IA64_SUB	0x85
#define R_IA64_LTOFF22X	0x86
#define R_IA64_LDXMOV	0x87
#define SHT_HIUSER	0x8fffffff
#define R_IA64_TPREL14	0x91
#define R_IA64_TPREL22	0x92
#define R_IA64_TPREL64I	0x93
#define R_IA64_TPREL64MSB	0x96
#define R_IA64_TPREL64LSB	0x97
#define R_IA64_LTOFF_TPREL22	0x9a
#define R_IA64_DTPMOD64MSB	0xa6
#define R_IA64_DTPMOD64LSB	0xa7
#define R_IA64_LTOFF_DTPMOD22	0xaa
#define R_IA64_DTPREL14	0xb1
#define R_IA64_DTPREL22	0xb2
#define R_IA64_DTPREL64I	0xb3
#define R_IA64_DTPREL32MSB	0xb4
#define R_IA64_DTPREL32LSB	0xb5
#define R_IA64_DTPREL64MSB	0xb6
#define R_IA64_DTPREL64LSB	0xb7
#define R_IA64_LTOFF_DTPREL22	0xba
#define PF_MASKPROC	0xf0000000
#define SHF_MASKPROC	0xf0000000
#define ET_LOOS	0xfe00
#define ET_HIOS	0xfeff
#define ET_LOPROC	0xff00
#define SHN_LOPROC	0xff00
#define SHN_LORESERVE	0xff00
#define SYMINFO_BT_LOWRESERVE	0xff00
#define EF_IA_64_ARCH	0xff000000
#define SHN_HIPROC	0xff1f
#define SHN_LOOS	0xff20
#define SHN_HIOS	0xff3f
#define SHN_ABS	0xfff1
#define SHN_COMMON	0xfff2
#define SYMINFO_BT_PARENT	0xfffe
#define ET_HIPROC	0xffff
#define PN_XNUM	0xffff
#define SHN_HIRESERVE	0xffff
#define SHN_XINDEX	0xffff
#define SYMINFO_BT_SELF	0xffff
#define DT_IA_64_NUM	1
#define DT_NEEDED	1
#define DT_PPC_NUM	1
#define EI_MAG1	1
#define ELFCLASS32	1
#define ELFDATA2LSB	1
#define ELF_NOTE_OS_GNU	1
#define ET_REL	1
#define EV_CURRENT	1
#define NT_GNU_ABI_TAG	1
#define PT_LOAD	1
#define R_386_32	1
#define R_390_8	1
#define R_PPC_ADDR32	1
#define R_X86_64_64	1
#define SHT_PROGBITS	1
#define STB_GLOBAL	1
#define STT_OBJECT	1
#define STV_INTERNAL	1
#define SYMINFO_CURRENT	1
#define DT_STRSZ	10
#define R_386_GOTPC	10
#define R_390_GLOB_DAT	10
#define R_PPC_REL24	10
#define R_X86_64_32	10
#define SHT_SHLIB	10
#define STB_LOOS	10
#define STT_GNU_IFUNC	10
#define STT_LOOS	10
#define R_PPC64_TPREL16_HIGHESTA	100
#define R_PPC64_DTPREL16_DS	101
#define R_PPC64_DTPREL16_LO_DS	102
#define R_PPC64_DTPREL16_HIGHER	103
#define R_PPC64_DTPREL16_HIGHERA	104
#define R_PPC64_DTPREL16_HIGHEST	105
#define R_PPC64_DTPREL16_HIGHESTA	106
#define DT_ADDRNUM	11
#define DT_SYMENT	11
#define R_386_32PLT	11
#define R_390_JMP_SLOT	11
#define R_PPC_REL14	11
#define R_X86_64_32S	11
#define SHT_DYNSYM	11
#define DT_INIT	12
#define DT_VALNUM	12
#define R_390_RELATIVE	12
#define R_PPC_REL14_BRTAKEN	12
#define R_X86_64_16	12
#define STB_HIOS	12
#define STT_HIOS	12
#define DT_FINI	13
#define R_390_GOTOFF32	13
#define R_PPC_REL14_BRNTAKEN	13
#define R_X86_64_PC16	13
#define STB_LOPROC	13
#define STT_LOPROC	13
#define DT_SONAME	14
#define R_386_TLS_TPOFF	14
#define R_390_GOTPC	14
#define R_PPC_GOT16	14
#define R_X86_64_8	14
#define SHT_INIT_ARRAY	14
#define DT_RPATH	15
#define R_386_TLS_IE	15
#define R_390_GOT16	15
#define R_PPC_GOT16_LO	15
#define R_X86_64_PC8	15
#define SHT_FINI_ARRAY	15
#define STB_HIPROC	15
#define STT_HIPROC	15
#define DT_SYMBOLIC	16
#define DT_VERSIONTAGNUM	16
#define R_386_TLS_GOTIE	16
#define R_390_PC16	16
#define R_PPC_GOT16_HI	16
#define R_X86_64_DTPMOD64	16
#define SHT_PREINIT_ARRAY	16
#define DT_REL	17
#define R_386_TLS_LE	17
#define R_390_PC16DBL	17
#define R_PPC_GOT16_HA	17
#define R_X86_64_DTPOFF64	17
#define SHT_GROUP	17
#define DT_RELSZ	18
#define R_386_TLS_GD	18
#define R_390_PLT16DBL	18
#define R_PPC_PLTREL24	18
#define R_X86_64_TPOFF64	18
#define SHT_SYMTAB_SHNDX	18
#define DT_RELENT	19
#define R_386_TLS_LDM	19
#define R_390_PC32DBL	19
#define R_PPC_COPY	19
#define R_X86_64_TLSGD	19
#define DT_PLTRELSZ	2
#define EI_MAG2	2
#define ELFCLASS64	2
#define ELFDATA2MSB	2
#define ELF_NOTE_OS_SOLARIS2	2
#define ET_EXEC	2
#define EV_NUM	2
#define PT_DYNAMIC	2
#define R_386_PC32	2
#define R_390_12	2
#define R_PPC_ADDR24	2
#define R_X86_64_PC32	2
#define SHT_SYMTAB	2
#define STB_WEAK	2
#define STT_FUNC	2
#define STV_HIDDEN	2
#define SYMINFO_NUM	2
#define DT_PLTREL	20
#define EM_PPC	20
#define R_386_16	20
#define R_390_PLT32DBL	20
#define R_PPC_GLOB_DAT	20
#define R_X86_64_TLSLD	20
#define DT_DEBUG	21
#define EM_PPC64	21
#define R_386_PC16	21
#define R_390_GOTPCDBL	21
#define R_PPC_JMP_SLOT	21
#define R_X86_64_DTPOFF32	21
#define DT_TEXTREL	22
#define EM_S390	22
#define R_386_8	22
#define R_390_64	22
#define R_PPC_RELATIVE	22
#define R_X86_64_GOTTPOFF	22
#define DT_JMPREL	23
#define R_386_PC8	23
#define R_390_PC64	23
#define R_PPC_LOCAL24PC	23
#define R_X86_64_TPOFF32	23
#define DT_BIND_NOW	24
#define R_386_TLS_GD_32	24
#define R_390_GOT64	24
#define R_PPC_UADDR32	24
#define R_X86_64_PC64	24
#define R_PPC64_JMP_IREL	247
#define R_PPC64_IRELATIVE	248
#define R_PPC_IRELATIVE	248
#define R_PPC64_REL16	249
#define R_PPC_REL16	249
#define DT_INIT_ARRAY	25
#define R_386_TLS_GD_PUSH	25
#define R_390_PLT64	25
#define R_PPC_UADDR16	25
#define R_X86_64_GOTOFF64	25
#define R_PPC64_REL16_LO	250
#define R_PPC_REL16_LO	250
#define R_PPC64_REL16_HI	251
#define R_PPC_REL16_HI	251
#define R_PPC64_REL16_HA	252
#define R_PPC_REL16_HA	252
#define R_PPC_TOC16	255
#define DT_FINI_ARRAY	26
#define R_386_TLS_GD_CALL	26
#define R_390_GOTENT	26
#define R_PPC_REL32	26
#define R_X86_64_GOTPC32	26
#define DT_INIT_ARRAYSZ	27
#define R_386_TLS_GD_POP	27
#define R_390_GOTOFF16	27
#define R_PPC_PLT32	27
#define R_X86_64_GOT64	27
#define DT_FINI_ARRAYSZ	28
#define R_386_TLS_LDM_32	28
#define R_390_GOTOFF64	28
#define R_PPC_PLTREL32	28
#define R_X86_64_GOTPCREL64	28
#define DT_RUNPATH	29
#define R_386_TLS_LDM_PUSH	29
#define R_390_GOTPLT12	29
#define R_PPC_PLT16_LO	29
#define R_X86_64_GOTPC64	29
#define DT_EXTRANUM	3
#define DT_PLTGOT	3
#define DT_PPC64_NUM	3
#define EI_MAG3	3
#define ELFCLASSNUM	3
#define ELFDATANUM	3
#define ELFOSABI_LINUX	3
#define ELF_NOTE_OS_FREEBSD	3
#define EM_386	3
#define ET_DYN	3
#define PT_INTERP	3
#define R_386_GOT32	3
#define R_390_16	3
#define R_PPC_ADDR16	3
#define R_X86_64_GOT32	3
#define SHT_STRTAB	3
#define STB_NUM	3
#define STT_SECTION	3
#define STV_PROTECTED	3
#define DT_FLAGS	30
#define R_386_TLS_LDM_CALL	30
#define R_390_GOTPLT16	30
#define R_PPC_PLT16_HI	30
#define R_X86_64_GOTPLT64	30
#define R_386_TLS_LDM_POP	31
#define R_390_GOTPLT32	31
#define R_PPC_PLT16_HA	31
#define R_X86_64_PLTOFF64	31
#define DT_ENCODING	32
#define DT_PREINIT_ARRAY	32
#define R_386_TLS_LDO_32	32
#define R_390_GOTPLT64	32
#define R_PPC_SDAREL16	32
#define R_X86_64_SIZE32	32
#define DT_PREINIT_ARRAYSZ	33
#define R_386_TLS_IE_32	33
#define R_390_GOTPLTENT	33
#define R_PPC_SECTOFF	33
#define R_X86_64_SIZE64	33
#define DT_NUM	34
#define R_386_TLS_LE_32	34
#define R_390_PLTOFF16	34
#define R_PPC_SECTOFF_LO	34
#define R_X86_64_GOTPC32_TLSDESC	34
#define R_386_TLS_DTPMOD32	35
#define R_390_PLTOFF32	35
#define R_PPC_SECTOFF_HI	35
#define R_X86_64_TLSDESC_CALL	35
#define R_386_TLS_DTPOFF32	36
#define R_390_PLTOFF64	36
#define R_PPC_SECTOFF_HA	36
#define R_X86_64_TLSDESC	36
#define R_386_TLS_TPOFF32	37
#define R_390_TLS_LOAD	37
#define R_PPC64_ADDR30	37
#define R_X86_64_IRELATIVE	37
#define R_390_TLS_GDCALL	38
#define R_PPC64_ADDR64	38
#define R_X86_64_NUM	38
#define R_386_TLS_GOTDESC	39
#define R_390_TLS_LDCALL	39
#define R_PPC64_ADDR16_HIGHER	39
#define DT_HASH	4
#define EI_CLASS	4
#define ET_CORE	4
#define PT_NOTE	4
#define R_386_PLT32	4
#define R_390_32	4
#define R_PPC_ADDR16_LO	4
#define R_X86_64_PLT32	4
#define SELFMAG	4
#define SHT_RELA	4
#define STT_FILE	4
#define EM_ARM	40
#define R_386_TLS_DESC_CALL	40
#define R_390_TLS_GD32	40
#define R_PPC64_ADDR16_HIGHERA	40
#define R_386_TLS_DESC	41
#define R_390_TLS_GD64	41
#define R_PPC64_ADDR16_HIGHEST	41
#define R_386_IRELATIVE	42
#define R_390_TLS_GOTIE12	42
#define R_PPC64_ADDR16_HIGHESTA	42
#define R_386_NUM	43
#define R_390_TLS_GOTIE32	43
#define R_PPC64_UADDR64	43
#define R_390_TLS_GOTIE64	44
#define R_PPC64_REL64	44
#define R_390_TLS_LDM32	45
#define R_PPC64_PLT64	45
#define R_390_TLS_LDM64	46
#define R_PPC64_PLTREL64	46
#define R_390_TLS_IE32	47
#define R_PPC64_TOC16	47
#define R_390_TLS_IE64	48
#define R_PPC64_TOC16_LO	48
#define R_390_TLS_IEENT	49
#define R_PPC64_TOC16_HI	49
#define DT_STRTAB	5
#define EI_DATA	5
#define ET_NUM	5
#define PT_SHLIB	5
#define R_386_COPY	5
#define R_390_PC32	5
#define R_PPC_ADDR16_HI	5
#define R_X86_64_COPY	5
#define SHT_HASH	5
#define STT_COMMON	5
#define EM_IA_64	50
#define R_390_TLS_LE32	50
#define R_PPC64_TOC16_HA	50
#define R_390_TLS_LE64	51
#define R_PPC64_TOC	51
#define R_390_TLS_LDO32	52
#define R_PPC64_PLTGOT16	52
#define R_390_TLS_LDO64	53
#define R_PPC64_PLTGOT16_LO	53
#define R_390_TLS_DTPMOD	54
#define R_PPC64_PLTGOT16_HI	54
#define R_390_TLS_DTPOFF	55
#define R_PPC64_PLTGOT16_HA	55
#define R_390_TLS_TPOFF	56
#define R_PPC64_ADDR16_DS	56
#define R_390_20	57
#define R_PPC64_ADDR16_LO_DS	57
#define R_390_GOT20	58
#define R_PPC64_GOT16_DS	58
#define R_390_GOTPLT20	59
#define R_PPC64_GOT16_LO_DS	59
#define DT_SYMTAB	6
#define EI_VERSION	6
#define PT_PHDR	6
#define R_386_GLOB_DAT	6
#define R_390_GOT12	6
#define R_PPC_ADDR16_HA	6
#define R_X86_64_GLOB_DAT	6
#define SHT_DYNAMIC	6
#define STT_TLS	6
#define R_390_TLS_GOTIE20	60
#define R_PPC64_PLT16_LO_DS	60
#define R_390_NUM	61
#define R_PPC64_SECTOFF_DS	61
#define EM_X86_64	62
#define R_PPC64_SECTOFF_LO_DS	62
#define R_PPC64_TOC16_DS	63
#define R_PPC64_TOC16_LO_DS	64
#define R_PPC64_PLTGOT16_DS	65
#define R_PPC64_PLTGOT16_LO_DS	66
#define R_PPC64_TLS	67
#define R_PPC_TLS	67
#define R_PPC64_DTPMOD64	68
#define R_PPC_DTPMOD32	68
#define R_PPC64_TPREL16	69
#define R_PPC_TPREL16	69
#define DT_RELA	7
#define EI_OSABI	7
#define PT_TLS	7
#define R_386_JMP_SLOT	7
#define R_390_GOT32	7
#define R_PPC_ADDR14	7
#define R_X86_64_JUMP_SLOT	7
#define SHT_NOTE	7
#define STT_NUM	7
#define R_PPC64_TPREL16_LO	70
#define R_PPC_TPREL16_LO	70
#define R_PPC64_TPREL16_HI	71
#define R_PPC_TPREL16_HI	71
#define R_PPC64_TPREL16_HA	72
#define R_PPC_TPREL16_HA	72
#define R_PPC64_TPREL64	73
#define R_PPC_TPREL32	73
#define R_PPC64_DTPREL16	74
#define R_PPC_DTPREL16	74
#define R_PPC64_DTPREL16_LO	75
#define R_PPC_DTPREL16_LO	75
#define R_PPC64_DTPREL16_HI	76
#define R_PPC_DTPREL16_HI	76
#define R_PPC64_DTPREL16_HA	77
#define R_PPC_DTPREL16_HA	77
#define R_PPC64_DTPREL64	78
#define R_PPC_DTPREL32	78
#define R_PPC64_GOT_TLSGD16	79
#define R_PPC_GOT_TLSGD16	79
#define DT_RELASZ	8
#define EI_ABIVERSION	8
#define PT_NUM	8
#define R_386_RELATIVE	8
#define R_390_PLT32	8
#define R_PPC_ADDR14_BRTAKEN	8
#define R_X86_64_RELATIVE	8
#define SHT_NOBITS	8
#define R_PPC64_GOT_TLSGD16_LO	80
#define R_PPC_GOT_TLSGD16_LO	80
#define R_PPC64_GOT_TLSGD16_HI	81
#define R_PPC_GOT_TLSGD16_HI	81
#define R_PPC64_GOT_TLSGD16_HA	82
#define R_PPC_GOT_TLSGD16_HA	82
#define R_PPC64_GOT_TLSLD16	83
#define R_PPC_GOT_TLSLD16	83
#define R_PPC64_GOT_TLSLD16_LO	84
#define R_PPC_GOT_TLSLD16_LO	84
#define R_PPC64_GOT_TLSLD16_HI	85
#define R_PPC_GOT_TLSLD16_HI	85
#define R_PPC64_GOT_TLSLD16_HA	86
#define R_PPC_GOT_TLSLD16_HA	86
#define R_PPC64_GOT_TPREL16_DS	87
#define R_PPC_GOT_TPREL16	87
#define R_PPC64_GOT_TPREL16_LO_DS	88
#define R_PPC_GOT_TPREL16_LO	88
#define R_PPC64_GOT_TPREL16_HI	89
#define R_PPC_GOT_TPREL16_HI	89
#define DT_RELAENT	9
#define EI_PAD	9
#define R_386_GOTOFF	9
#define R_390_COPY	9
#define R_PPC_ADDR14_BRNTAKEN	9
#define R_X86_64_GOTPCREL	9
#define SHT_REL	9
#define R_PPC64_GOT_TPREL16_HA	90
#define R_PPC_GOT_TPREL16_HA	90
#define R_PPC64_GOT_DTPREL16_DS	91
#define R_PPC_GOT_DTPREL16	91
#define R_PPC64_GOT_DTPREL16_LO_DS	92
#define R_PPC_GOT_DTPREL16_LO	92
#define R_PPC64_GOT_DTPREL16_HI	93
#define R_PPC_GOT_DTPREL16_HI	93
#define R_PPC64_GOT_DTPREL16_HA	94
#define R_PPC_GOT_DTPREL16_HA	94
#define R_PPC64_TPREL16_DS	95
#define R_PPC64_TPREL16_LO_DS	96
#define R_PPC64_TPREL16_HIGHER	97
#define R_PPC64_TPREL16_HIGHERA	98
#define R_PPC64_TPREL16_HIGHEST	99
#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
#define ELF64_ST_BIND(val)	ELF32_ST_BIND (val)
#define ELF64_ST_INFO(bind,type)	ELF32_ST_INFO ((bind), (type))
#define ELF64_ST_TYPE(val)	ELF32_ST_TYPE (val)
#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY(o)
#define ELF_NOTE_GNU	"GNU"
#define ELF_NOTE_ABI	NT_GNU_ABI_TAG
#define R_PPC64_ADDR14	R_PPC_ADDR14
#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
#define R_PPC64_ADDR16	R_PPC_ADDR16
#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA
#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI
#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO
#define R_PPC64_ADDR24	R_PPC_ADDR24
#define R_PPC64_ADDR32	R_PPC_ADDR32
#define R_PPC64_COPY	R_PPC_COPY
#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
#define R_PPC64_GOT16	R_PPC_GOT16
#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
#define R_PPC64_NONE	R_PPC_NONE
#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
#define R_PPC64_PLT32	R_PPC_PLT32
#define R_PPC64_PLTREL32	R_PPC_PLTREL32
#define R_PPC64_REL14	R_PPC_REL14
#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
#define R_PPC64_REL24	R_PPC_REL24
#define R_PPC64_REL32	R_PPC_REL32
#define R_PPC64_RELATIVE	R_PPC_RELATIVE
#define R_PPC64_SECTOFF	R_PPC_SECTOFF
#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
#define R_PPC64_UADDR16	R_PPC_UADDR16
#define R_PPC64_UADDR32	R_PPC_UADDR32
#define ELFMAG	"\177ELF"

typedef uint32_t Elf32_Addr;
typedef uint64_t Elf64_Addr;
typedef uint32_t Elf32_Word;
typedef uint32_t Elf64_Word;
typedef int32_t Elf32_Sword;
typedef int32_t Elf64_Sword;
typedef uint64_t Elf32_Xword;
typedef uint64_t Elf64_Xword;
typedef int64_t Elf32_Sxword;
typedef int64_t Elf64_Sxword;
typedef uint32_t Elf32_Off;
typedef uint64_t Elf64_Off;
typedef struct {
    Elf32_Word p_type;		/* Segment type */
    Elf32_Off p_offset;		/* Segment file offset */
    Elf32_Addr p_vaddr;		/* Segment virtual address */
    Elf32_Addr p_paddr;		/* Segment physical address */
    Elf32_Word p_filesz;	/* Segment size in file */
    Elf32_Word p_memsz;		/* Segment size in memory */
    Elf32_Word p_flags;		/* Segment flags */
    Elf32_Word p_align;		/* Segment alignment */
} Elf32_Phdr;
typedef struct {
    Elf64_Word p_type;		/* Segment type */
    Elf64_Word p_flags;		/* Segment flags */
    Elf64_Off p_offset;		/* Segment file offset */
    Elf64_Addr p_vaddr;		/* Segment virtual address */
    Elf64_Addr p_paddr;		/* Segment physical address */
    Elf64_Xword p_filesz;	/* Segment size in file */
    Elf64_Xword p_memsz;	/* Segment size in memory */
    Elf64_Xword p_align;	/* Segment alignment */
} Elf64_Phdr;
typedef uint16_t Elf32_Half;
typedef uint16_t Elf64_Half;
typedef uint16_t Elf32_Section;
typedef uint16_t Elf64_Section;
typedef struct {
    Elf32_Word n_namesz;
    Elf32_Word n_descsz;
    Elf32_Word n_type;
} Elf32_Nhdr;
typedef struct {
    Elf64_Word n_namesz;
    Elf64_Word n_descsz;
    Elf64_Word n_type;
} Elf64_Nhdr;
typedef struct {
    Elf64_Word st_name;
    unsigned char st_info;
    unsigned char st_other;
    Elf64_Section st_shndx;
    Elf64_Addr st_value;
    Elf64_Xword st_size;
} Elf64_Sym;
typedef struct {
    Elf32_Word st_name;
    Elf32_Addr st_value;
    Elf32_Word st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf32_Section st_shndx;
} Elf32_Sym;
typedef struct {
    Elf64_Addr r_offset;
    Elf64_Xword r_info;
} Elf64_Rel;
typedef struct {
    Elf32_Addr r_offset;
    Elf32_Word r_info;
} Elf32_Rel;
typedef struct {
    Elf64_Addr r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
} Elf64_Rela;
typedef struct {
    Elf32_Addr r_offset;
    Elf32_Word r_info;
    Elf32_Sword r_addend;
} Elf32_Rela;
typedef struct {
    Elf32_Half vd_version;
    Elf32_Half vd_flags;
    Elf32_Half vd_ndx;
    Elf32_Half vd_cnt;
    Elf32_Word vd_hash;
    Elf32_Word vd_aux;
    Elf32_Word vd_next;
} Elf32_Verdef;
typedef struct {
    Elf64_Half vd_version;
    Elf64_Half vd_flags;
    Elf64_Half vd_ndx;
    Elf64_Half vd_cnt;
    Elf64_Word vd_hash;
    Elf64_Word vd_aux;
    Elf64_Word vd_next;
} Elf64_Verdef;
typedef struct {
    Elf64_Word vda_name;
    Elf64_Word vda_next;
} Elf64_Verdaux;
typedef struct {
    Elf32_Word vda_name;
    Elf32_Word vda_next;
} Elf32_Verdaux;
typedef struct {
    Elf32_Half vn_version;
    Elf32_Half vn_cnt;
    Elf32_Word vn_file;
    Elf32_Word vn_aux;
    Elf32_Word vn_next;
} Elf32_Verneed;
typedef struct {
    Elf64_Half vn_version;
    Elf64_Half vn_cnt;
    Elf64_Word vn_file;
    Elf64_Word vn_aux;
    Elf64_Word vn_next;
} Elf64_Verneed;
typedef struct {
    Elf32_Word vna_hash;
    Elf32_Half vna_flags;
    Elf32_Half vna_other;
    Elf32_Word vna_name;
    Elf32_Word vna_next;
} Elf32_Vernaux;
typedef struct {
    Elf64_Word vna_hash;
    Elf64_Half vna_flags;
    Elf64_Half vna_other;
    Elf64_Word vna_name;
    Elf64_Word vna_next;
} Elf64_Vernaux;
typedef struct {
    unsigned char e_ident[EI_NIDENT];
    Elf64_Half e_type;
    Elf64_Half e_machine;
    Elf64_Word e_version;
    Elf64_Addr e_entry;
    Elf64_Off e_phoff;
    Elf64_Off e_shoff;
    Elf64_Word e_flags;
    Elf64_Half e_ehsize;
    Elf64_Half e_phentsize;
    Elf64_Half e_phnum;
    Elf64_Half e_shentsize;
    Elf64_Half e_shnum;
    Elf64_Half e_shstrndx;
} Elf64_Ehdr;
typedef struct {
    unsigned char e_ident[EI_NIDENT];
    Elf32_Half e_type;
    Elf32_Half e_machine;
    Elf32_Word e_version;
    Elf32_Addr e_entry;
    Elf32_Off e_phoff;
    Elf32_Off e_shoff;
    Elf32_Word e_flags;
    Elf32_Half e_ehsize;
    Elf32_Half e_phentsize;
    Elf32_Half e_phnum;
    Elf32_Half e_shentsize;
    Elf32_Half e_shnum;
    Elf32_Half e_shstrndx;
} Elf32_Ehdr;
typedef struct {
    Elf32_Word sh_name;
    Elf32_Word sh_type;
    Elf32_Word sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off sh_offset;
    Elf32_Word sh_size;
    Elf32_Word sh_link;
    Elf32_Word sh_info;
    Elf32_Word sh_addralign;
    Elf32_Word sh_entsize;
} Elf32_Shdr;
typedef struct {
    Elf64_Word sh_name;
    Elf64_Word sh_type;
    Elf64_Xword sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off sh_offset;
    Elf64_Xword sh_size;
    Elf64_Word sh_link;
    Elf64_Word sh_info;
    Elf64_Xword sh_addralign;
    Elf64_Xword sh_entsize;
} Elf64_Shdr;
typedef struct {
    Elf32_Sword d_tag;
    union {
	Elf32_Word d_val;
	Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
typedef struct {
    Elf64_Sxword d_tag;
    union {
	Elf64_Xword d_val;
	Elf64_Addr d_ptr;
    } d_un;
} Elf64_Dyn;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7366"
>14.4.8. endian.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __LITTLE_ENDIAN	1234
#define __BIG_ENDIAN	4321
#define BIG_ENDIAN	__BIG_ENDIAN
#define BYTE_ORDER	__BYTE_ORDER
#define LITTLE_ENDIAN	__LITTLE_ENDIAN</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7370"
>14.4.9. envz.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern error_t envz_add(char **envz, size_t * envz_len, const char *name,
			const char *value);
extern char envz_entry(const char *envz, size_t envz_len,
		       const char *name);
extern char envz_get(const char *envz, size_t envz_len, const char *name);
extern error_t envz_merge(char **envz, size_t * envz_len,
			  const char *envz2, size_t envz2_len,
			  int override);
extern void envz_remove(char **envz, size_t * envz_len, const char *name);
extern void envz_strip(char **envz, size_t * envz_len);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7374"
>14.4.10. err.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void err(int eval, const char *fmt, ...);
extern void errx(int eval, const char *fmt, ...);
extern void verrx(int eval, const char *fmt, va_list args);
extern void warn(const char *fmt, ...);
extern void warnx(const char *fmt, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7378"
>14.4.11. errno.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define errno	(*__errno_location())

#define EPERM	1		/* Operation not permitted */
#define ECHILD	10		/* No child processes */
#define ENETDOWN	100	/* Network is down */
#define ENETUNREACH	101	/* Network is unreachable */
#define ENETRESET	102	/* Network dropped connection because of reset */
#define ECONNABORTED	103	/* Software caused connection abort */
#define ECONNRESET	104	/* Connection reset by peer */
#define ENOBUFS	105		/* No buffer space available */
#define EISCONN	106		/* Transport endpoint is already connected */
#define ENOTCONN	107	/* Transport endpoint is not connected */
#define ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
#define ETOOMANYREFS	109	/* Too many references: cannot splice */
#define EAGAIN	11		/* Try again */
#define ETIMEDOUT	110	/* Connection timed out */
#define ECONNREFUSED	111	/* Connection refused */
#define EHOSTDOWN	112	/* Host is down */
#define EHOSTUNREACH	113	/* No route to host */
#define EALREADY	114	/* Operation already in progress */
#define EINPROGRESS	115	/* Operation now in progress */
#define ESTALE	116		/* Stale NFS file handle */
#define EUCLEAN	117		/* Structure needs cleaning */
#define ENOTNAM	118		/* Not a XENIX named type file */
#define ENAVAIL	119		/* No XENIX semaphores available */
#define ENOMEM	12		/* Out of memory */
#define EISNAM	120		/* Is a named type file */
#define EREMOTEIO	121	/* Remote I/O error */
#define EDQUOT	122		/* Quota exceeded */
#define ENOMEDIUM	123	/* No medium found */
#define EMEDIUMTYPE	124	/* Wrong medium type */
#define ECANCELED	125	/* Operation Canceled */
#define EACCES	13		/* Permission denied */
#define EOWNERDEAD	130	/* Owner died */
#define ENOTRECOVERABLE	131	/* State not recoverable */
#define ERFKILL	132		/* Operation not possible due to RF-kill */
#define EFAULT	14		/* Bad address */
#define ENOTBLK	15		/* Block device required */
#define EBUSY	16		/* Device or resource busy */
#define EEXIST	17		/* File exists */
#define EXDEV	18		/* Cross-device link */
#define ENODEV	19		/* No such device */
#define ENOENT	2		/* No such file or directory */
#define ENOTDIR	20		/* Not a directory */
#define EISDIR	21		/* Is a directory */
#define EINVAL	22		/* Invalid argument */
#define ENFILE	23		/* File table overflow */
#define EMFILE	24		/* Too many open files */
#define ENOTTY	25		/* Not a typewriter */
#define ETXTBSY	26		/* Text file busy */
#define EFBIG	27		/* File too large */
#define ENOSPC	28		/* No space left on device */
#define ESPIPE	29		/* Illegal seek */
#define ESRCH	3		/* No such process */
#define EROFS	30		/* Read-only file system */
#define EMLINK	31		/* Too many links */
#define EPIPE	32		/* Broken pipe */
#define EDOM	33		/* Math argument out of domain of func */
#define ERANGE	34		/* Math result not representable */
#define EDEADLK	35		/* Resource deadlock would occur */
#define ENAMETOOLONG	36	/* File name too long */
#define ENOLCK	37		/* No record locks available */
#define ENOSYS	38		/* Function not implemented */
#define ENOTEMPTY	39	/* Directory not empty */
#define EINTR	4		/* Interrupted system call */
#define ELOOP	40		/* Too many symbolic links encountered */
#define ENOMSG	42		/* No message of desired type */
#define EIDRM	43		/* Identifier removed */
#define ECHRNG	44		/* Channel number out of range */
#define EL2NSYNC	45	/* Level 2 not synchronized */
#define EL3HLT	46		/* Level 3 halted */
#define EL3RST	47		/* Level 3 reset */
#define ELNRNG	48		/* Link number out of range */
#define EUNATCH	49		/* Protocol driver not attached */
#define EIO	5		/* I/O error */
#define ENOANO	55		/* No anode */
#define EBADRQC	56		/* Invalid request code */
#define EBADSLT	57		/* Invalid slot */
#define EBFONT	59		/* Bad font file format */
#define ENXIO	6		/* No such device or address */
#define ENOSTR	60		/* Device not a stream */
#define ENODATA	61		/* No data available */
#define ETIME	62		/* Timer expired */
#define ENOSR	63		/* Out of streams resources */
#define ENONET	64		/* Machine is not on the network */
#define ENOPKG	65		/* Package not installed */
#define EREMOTE	66		/* Object is remote */
#define ENOLINK	67		/* Link has been severed */
#define EADV	68		/* Advertise error */
#define ESRMNT	69		/* Srmount error */
#define E2BIG	7		/* Argument list too long */
#define ECOMM	70		/* Communication error on send */
#define EPROTO	71		/* Protocol error */
#define EMULTIHOP	72	/* Multihop attempted */
#define EDOTDOT	73		/* RFS specific error */
#define EBADMSG	74		/* Not a data message */
#define EOVERFLOW	75	/* Value too large for defined data type */
#define ENOTUNIQ	76	/* Name not unique on network */
#define EBADFD	77		/* File descriptor in bad state */
#define EREMCHG	78		/* Remote address changed */
#define ELIBACC	79		/* Can not access a needed shared library */
#define ENOEXEC	8		/* Exec format error */
#define ELIBBAD	80		/* Accessing a corrupted shared library */
#define ELIBSCN	81		/* .lib section in a.out corrupted */
#define ELIBMAX	82		/* Attempting to link in too many shared libraries */
#define ELIBEXEC	83	/* Cannot exec a shared library directly */
#define EILSEQ	84		/* Illegal byte sequence */
#define ERESTART	85	/* Interrupted system call should be restarted */
#define ESTRPIPE	86	/* Streams pipe error */
#define EUSERS	87		/* Too many users */
#define ENOTSOCK	88	/* Socket operation on non-socket */
#define EDESTADDRREQ	89	/* Destination address required */
#define EBADF	9		/* Bad file number */
#define EMSGSIZE	90	/* Message too long */
#define EPROTOTYPE	91	/* Protocol wrong type for socket */
#define ENOPROTOOPT	92	/* Protocol not available */
#define EPROTONOSUPPORT	93	/* Protocol not supported */
#define ESOCKTNOSUPPORT	94	/* Socket type not supported */
#define EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
#define EPFNOSUPPORT	96	/* Protocol family not supported */
#define EAFNOSUPPORT	97	/* Address family not supported by protocol */
#define EADDRINUSE	98	/* Address already in use */
#define EADDRNOTAVAIL	99	/* Cannot assign requested address */
#define EWOULDBLOCK	EAGAIN	/* Operation would block */
#define ENOTSUP	EOPNOTSUPP

extern int *__errno_location(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7382"
>14.4.12. error.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void error(int status, int errnum, const char *format, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7386"
>14.4.13. execinfo.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int backtrace(void **__array, int __size);
extern char **backtrace_symbols(void *const *__array, int __size);
extern void backtrace_symbols_fd(void *const *__array, int __size,
				 int __fd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7390"
>14.4.14. fcntl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define AT_FDCWD	-100	/* Use the current working directory to determine the target of relative file paths. */
#define POSIX_FADV_NORMAL	0
#define O_RDONLY	00
#define O_ACCMODE	0003
#define O_WRONLY	01
#define O_CREAT	0100
#define O_TRUNC	01000
#define O_DSYNC	010000
#define O_RDWR	02
#define O_EXCL	0200
#define O_APPEND	02000
#define O_ASYNC	020000
#define O_CLOEXEC	02000000	/* The FD_CLOEXEC flag associated with the new descriptor shall be set to close the file descriptor upon execution of an exec family function. */
#define O_NOCTTY	0400
#define O_NDELAY	04000
#define O_NONBLOCK	04000
#define O_SYNC	04010000
#define AT_SYMLINK_NOFOLLOW	0x100	/* Do not follow symbolic links. */
#define AT_EMPTY_PATH	0x1000	/* Allow empty relative pathname. */
#define AT_EACCESS	0x200	/* Check access using effective user and group ID. */
#define AT_REMOVEDIR	0x200	/* Remove directory instead of file. */
#define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic link. */
#define AT_NO_AUTOMOUNT	0x800	/* Suppress terminal automount traversal. */
#define FD_CLOEXEC	1
#define POSIX_FADV_RANDOM	1
#define F_DUPFD_CLOEXEC	1030	/* Duplicate file descriptor with the close-on-exec flag FD_CLOEXEC set. */
#define POSIX_FADV_SEQUENTIAL	2
#define POSIX_FADV_WILLNEED	3
#define O_RSYNC	O_SYNC

struct flock {
    short l_type;
    short l_whence;
    off_t l_start;
    off_t l_len;
    pid_t l_pid;
};
struct flock64 {
    short l_type;
    short l_whence;
    loff_t l_start;
    loff_t l_len;
    pid_t l_pid;
};

#define AT_FDCWD	-100
#define AT_SYMLINK_NOFOLLOW	0x100
#define AT_EACCESS	0x200
#define AT_REMOVEDIR	0x200
#define AT_SYMLINK_FOLLOW	0x400

#define F_DUPFD	0
#define F_RDLCK	0
#ifndef SEEK_SET
#define SEEK_SET	0
#endif
#define F_GETFD	1
#define F_WRLCK	1
#ifndef SEEK_CUR
#define SEEK_CUR	1
#endif
#define F_SETSIG	10
#define F_GETSIG	11
#define F_SETFD	2
#define F_UNLCK	2
#ifndef SEEK_END
#define SEEK_END	2
#endif
#define F_GETFL	3
#define F_SETFL	4
#define F_GETLK	5
#define F_SETLK	6
#define F_SETLKW	7
#define F_SETOWN	8
#define F_GETOWN	9

extern int creat(const char *__file, mode_t __mode);
extern int creat64(const char *__file, mode_t __mode);
extern int fcntl(int __fd, int __cmd, ...);
extern int open(const char *__file, int __oflag, ...);
extern int open64(const char *__file, int __oflag, ...);
extern int openat(int __fd, const char *__file, int __oflag, ...);
extern int openat64(int __fd, const char *__file, int __oflag, ...);
extern int posix_fadvise(int __fd, off_t __offset, off_t __len,
			 int __advise);
extern int posix_fadvise64(int __fd, off64_t __offset, off64_t __len,
			   int __advise);
extern int posix_fallocate(int __fd, off_t __offset, off_t __len);
extern int posix_fallocate64(int __fd, off64_t __offset, off64_t __len);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7394"
>14.4.15. fmtmsg.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MM_HARD	1		/* Source of the condition is hardware. */
#define MM_NRECOV	128	/* Non-recoverable error. */
#define MM_UTIL	16		/* Condition detected by utility. */
#define MM_SOFT	2		/* Source of the condition is software. */
#define MM_PRINT	256	/* Display message in standard error. */
#define MM_OPSYS	32	/* Condition detected by operating system. */
#define MM_FIRM	4		/* Source of the condition is firmware. */
#define MM_CONSOLE	512	/* Display message on system console. */
#define MM_RECOVER	64	/* Recoverable error. */
#define MM_APPL	8		/* Condition detected by application. */

#define MM_NOSEV	0	/* No severity level provided for the message. */
#define MM_HALT	1		/* Error causing application to halt. */
#define MM_ERROR	2	/* Application has encountered a non-fatal fault. */
#define MM_WARNING	3	/* Application has detected unusual non-error condition. */
#define MM_INFO	4		/* Informative message. */

#define MM_NULLACT	((char *) 0)
#define MM_NULLLBL	((char *) 0)
#define MM_NULLTAG	((char *) 0)
#define MM_NULLTXT	((char *) 0)
#define MM_NULLMC	((long int) 0)
#define MM_NULLSEV	0

#define MM_NOTOK	-1	/* The function failed completely. */
#define MM_OK	0		/* The function succeeded. */
#define MM_NOMSG	1	/* The function was unable to generate a message on standard error, but otherwise succeeded. */
#define MM_NOCON	4	/* The function was unable to generate a console message, but otherwise succeeded. */

extern int fmtmsg(long int __classification, const char *__label,
		  int __severity, const char *__text, const char *__action,
		  const char *__tag);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7398"
>14.4.16. fnmatch.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FNM_CASEFOLD	(1&#60;&#60;4)
#define FNM_FILE_NAME	FNM_PATHNAME

#define FNM_PATHNAME	(1&#60;&#60;0)
#define FNM_NOESCAPE	(1&#60;&#60;1)
#define FNM_PERIOD	(1&#60;&#60;2)
#define FNM_NOMATCH	1

extern int fnmatch(const char *__pattern, const char *__name, int __flags);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7402"
>14.4.17. ftw.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FTW_D	FTW_D
#define FTW_DNR	FTW_DNR
#define FTW_DP	FTW_DP
#define FTW_F	FTW_F
#define FTW_NS	FTW_NS
#define FTW_SL	FTW_SL
#define FTW_SLN	FTW_SLN

enum {
    FTW_F,
    FTW_D,
    FTW_DNR,
    FTW_NS,
    FTW_SL,
    FTW_DP,
    FTW_SLN
};

enum {
    FTW_PHYS = 1,
    FTW_MOUNT = 2,
    FTW_CHDIR = 4,
    FTW_DEPTH = 8
};

struct FTW {
    int base;
    int level;
};

typedef int (*__ftw_func_t) (const char *__filename,
			     const struct stat * __status, int __flag);
typedef int (*__ftw64_func_t) (const char *__filename,
			       const struct stat64 * __status, int __flag);
typedef int (*__nftw_func_t) (const char *__filename,
			      const struct stat * __status, int __flag,
			      struct FTW * __info);
typedef int (*__nftw64_func_t) (const char *__filename,
				const struct stat64 * __status, int __flag,
				struct FTW * __info);
extern int ftw(const char *__dir, __ftw_func_t __func, int __descriptors);
extern int ftw64(const char *__dir, __ftw64_func_t __func,
		 int __descriptors);
extern int nftw(const char *__dir, __nftw_func_t __func, int __descriptors,
		int __flag);
extern int nftw64(const char *__dir, __nftw64_func_t __func,
		  int __descriptors, int __flag);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7406"
>14.4.18. getopt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define no_argument	0
#define required_argument	1
#define optional_argument	2

struct option {
    const char *name;
    int has_arg;
    int *flag;
    int val;
};
extern int getopt_long(int ___argc, char *const ___argv[],
		       const char *__shortopts,
		       const struct option *__longopts, int *__longind);
extern int getopt_long_only(int ___argc, char *const ___argv[],
			    const char *__shortopts,
			    const struct option *__longopts,
			    int *__longind);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7410"
>14.4.19. glob.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define GLOB_ERR	(1&#60;&#60;0)
#define GLOB_MARK	(1&#60;&#60;1)
#define GLOB_BRACE	(1&#60;&#60;10)
#define GLOB_NOMAGIC	(1&#60;&#60;11)
#define GLOB_TILDE	(1&#60;&#60;12)
#define GLOB_ONLYDIR	(1&#60;&#60;13)
#define GLOB_TILDE_CHECK	(1&#60;&#60;14)
#define GLOB_NOSORT	(1&#60;&#60;2)
#define GLOB_DOOFFS	(1&#60;&#60;3)
#define GLOB_NOCHECK	(1&#60;&#60;4)
#define GLOB_APPEND	(1&#60;&#60;5)
#define GLOB_NOESCAPE	(1&#60;&#60;6)
#define GLOB_PERIOD	(1&#60;&#60;7)
#define GLOB_MAGCHAR	(1&#60;&#60;8)
#define GLOB_ALTDIRFUNC	(1&#60;&#60;9)

#define GLOB_NOSPACE	1
#define GLOB_ABORTED	2
#define GLOB_NOMATCH	3
#define GLOB_NOSYS	4

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob_t;

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent64 *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob64_t;
extern int glob(const char *__pattern, int __flags,
		int (*__errfunc) (const char *, int), glob_t * __pglob);
extern int glob64(const char *__pattern, int __flags,
		  int (*__errfunc) (const char *, int),
		  glob64_t * __pglob);
extern void globfree(glob_t * __pglob);
extern void globfree64(glob64_t * __pglob);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7414"
>14.4.20. gnu/libc-version.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern const char *gnu_get_libc_release(void);
extern const char *gnu_get_libc_version(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7418"
>14.4.21. grp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct group {
    char *gr_name;
    char *gr_passwd;
    gid_t gr_gid;
    char **gr_mem;
};

extern void endgrent(void);
extern struct group *getgrent(void);
extern int getgrent_r(struct group *__resultbuf, char *__buffer,
		      size_t __buflen, struct group **__result);
extern struct group *getgrgid(gid_t __gid);
extern int getgrgid_r(gid_t __gid, struct group *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct group **__result);
extern struct group *getgrnam(const char *__name);
extern int getgrnam_r(const char *__name, struct group *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct group **__result);
extern int getgrouplist(const char *__user, gid_t __group,
			gid_t * __groups, int *__ngroups);
extern int initgroups(const char *__user, gid_t __group);
extern void setgrent(void);
extern int setgroups(size_t __n, const gid_t * __groups);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7422"
>14.4.22. iconv.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef void *iconv_t;
extern size_t iconv(iconv_t __cd, char **__inbuf, size_t * __inbytesleft,
		    char **__outbuf, size_t * __outbytesleft);
extern int iconv_close(iconv_t __cd);
extern iconv_t iconv_open(const char *__tocode, const char *__fromcode);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7426"
>14.4.23. ifaddrs.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ifa_broadaddr	ifa_ifu.ifu_broadaddr
#define ifa_dstaddr	ifa_ifu.ifu_dstaddr

struct ifaddrs {
    struct ifaddrs *ifa_next;
    char *ifa_name;
    unsigned int ifa_flags;
    struct sockaddr *ifa_addr;
    struct sockaddr *ifa_netmask;
    union {
	struct sockaddr *ifu_broadaddr;
	struct sockaddr *ifu_dstaddr;
    } ifa_ifu;
    void *ifa_data;
};
extern void freeifaddrs(struct ifaddrs *);
extern int getifaddrs(struct ifaddrs **);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7430"
>14.4.24. inttypes.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#if !defined __cplusplus || defined __STDC_FORMAT_MACROS
#define PRId16	"d"
#define PRId32	"d"
#define PRId8	"d"
#define PRIdFAST8	"d"
#define PRIdLEAST16	"d"
#define PRIdLEAST32	"d"
#define PRIdLEAST8	"d"
#define SCNd32	"d"
#define SCNdLEAST32	"d"
#define SCNd16	"hd"
#define SCNdLEAST16	"hd"
#define SCNd8	"hhd"
#define SCNdFAST8	"hhd"
#define SCNdLEAST8	"hhd"
#define SCNi8	"hhi"
#define SCNiFAST8	"hhi"
#define SCNiLEAST8	"hhi"
#define SCNo8	"hho"
#define SCNoFAST8	"hho"
#define SCNoLEAST8	"hho"
#define SCNu8	"hhu"
#define SCNuFAST8	"hhu"
#define SCNuLEAST8	"hhu"
#define SCNx8	"hhx"
#define SCNxFAST8	"hhx"
#define SCNxLEAST8	"hhx"
#define SCNi16	"hi"
#define SCNiLEAST16	"hi"
#define SCNo16	"ho"
#define SCNoLEAST16	"ho"
#define SCNu16	"hu"
#define SCNuLEAST16	"hu"
#define SCNx16	"hx"
#define SCNxLEAST16	"hx"
#define PRIi16	"i"
#define PRIi32	"i"
#define PRIi8	"i"
#define PRIiFAST8	"i"
#define PRIiLEAST16	"i"
#define PRIiLEAST32	"i"
#define PRIiLEAST8	"i"
#define SCNi32	"i"
#define SCNiLEAST32	"i"
#define PRIo16	"o"
#define PRIo32	"o"
#define PRIo8	"o"
#define PRIoFAST8	"o"
#define PRIoLEAST16	"o"
#define PRIoLEAST32	"o"
#define PRIoLEAST8	"o"
#define SCNo32	"o"
#define SCNoLEAST32	"o"
#define PRIu16	"u"
#define PRIu32	"u"
#define PRIu8	"u"
#define PRIuFAST8	"u"
#define PRIuLEAST16	"u"
#define PRIuLEAST32	"u"
#define PRIuLEAST8	"u"
#define SCNu32	"u"
#define SCNuLEAST32	"u"
#define PRIX16	"X"
#define PRIX32	"X"
#define PRIX8	"X"
#define PRIXFAST8	"X"
#define PRIXLEAST16	"X"
#define PRIXLEAST32	"X"
#define PRIXLEAST8	"X"
#define PRIx16	"x"
#define PRIx32	"x"
#define PRIx8	"x"
#define PRIxFAST8	"x"
#define PRIxLEAST16	"x"
#define PRIxLEAST32	"x"
#define PRIxLEAST8	"x"
#define SCNx32	"x"
#define SCNxLEAST32	"x"
#define PRId64	__PRI64_PREFIX"d"
#define PRIdFAST64	__PRI64_PREFIX"d"
#define PRIdLEAST64	__PRI64_PREFIX"d"
#define PRIdMAX	__PRI64_PREFIX"d"
#define SCNd64	__PRI64_PREFIX"d"
#define SCNdFAST64	__PRI64_PREFIX"d"
#define SCNdLEAST64	__PRI64_PREFIX"d"
#define SCNdMAX	__PRI64_PREFIX"d"
#define PRIi64	__PRI64_PREFIX"i"
#define PRIiFAST64	__PRI64_PREFIX"i"
#define PRIiLEAST64	__PRI64_PREFIX"i"
#define PRIiMAX	__PRI64_PREFIX"i"
#define SCNi64	__PRI64_PREFIX"i"
#define SCNiFAST64	__PRI64_PREFIX"i"
#define SCNiLEAST64	__PRI64_PREFIX"i"
#define SCNiMAX	__PRI64_PREFIX"i"
#define PRIo64	__PRI64_PREFIX"o"
#define PRIoFAST64	__PRI64_PREFIX"o"
#define PRIoLEAST64	__PRI64_PREFIX"o"
#define PRIoMAX	__PRI64_PREFIX"o"
#define SCNo64	__PRI64_PREFIX"o"
#define SCNoFAST64	__PRI64_PREFIX"o"
#define SCNoLEAST64	__PRI64_PREFIX"o"
#define SCNoMAX	__PRI64_PREFIX"o"
#define PRIu64	__PRI64_PREFIX"u"
#define PRIuFAST64	__PRI64_PREFIX"u"
#define PRIuLEAST64	__PRI64_PREFIX"u"
#define PRIuMAX	__PRI64_PREFIX"u"
#define SCNu64	__PRI64_PREFIX"u"
#define SCNuFAST64	__PRI64_PREFIX"u"
#define SCNuLEAST64	__PRI64_PREFIX"u"
#define SCNuMAX	__PRI64_PREFIX"u"
#define PRIX64	__PRI64_PREFIX"X"
#define PRIXFAST64	__PRI64_PREFIX"X"
#define PRIXLEAST64	__PRI64_PREFIX"X"
#define PRIXMAX	__PRI64_PREFIX"X"
#define PRIx64	__PRI64_PREFIX"x"
#define PRIxFAST64	__PRI64_PREFIX"x"
#define PRIxLEAST64	__PRI64_PREFIX"x"
#define PRIxMAX	__PRI64_PREFIX"x"
#define SCNx64	__PRI64_PREFIX"x"
#define SCNxFAST64	__PRI64_PREFIX"x"
#define SCNxLEAST64	__PRI64_PREFIX"x"
#define SCNxMAX	__PRI64_PREFIX"x"
#define PRIdFAST16	__PRIPTR_PREFIX"d"
#define PRIdFAST32	__PRIPTR_PREFIX"d"
#define PRIdPTR	__PRIPTR_PREFIX"d"
#define SCNdFAST16	__PRIPTR_PREFIX"d"
#define SCNdFAST32	__PRIPTR_PREFIX"d"
#define SCNdPTR	__PRIPTR_PREFIX"d"
#define PRIiFAST16	__PRIPTR_PREFIX"i"
#define PRIiFAST32	__PRIPTR_PREFIX"i"
#define PRIiPTR	__PRIPTR_PREFIX"i"
#define SCNiFAST16	__PRIPTR_PREFIX"i"
#define SCNiFAST32	__PRIPTR_PREFIX"i"
#define SCNiPTR	__PRIPTR_PREFIX"i"
#define PRIoFAST16	__PRIPTR_PREFIX"o"
#define PRIoFAST32	__PRIPTR_PREFIX"o"
#define PRIoPTR	__PRIPTR_PREFIX"o"
#define SCNoFAST16	__PRIPTR_PREFIX"o"
#define SCNoFAST32	__PRIPTR_PREFIX"o"
#define SCNoPTR	__PRIPTR_PREFIX"o"
#define PRIuFAST16	__PRIPTR_PREFIX"u"
#define PRIuFAST32	__PRIPTR_PREFIX"u"
#define PRIuPTR	__PRIPTR_PREFIX"u"
#define SCNuFAST16	__PRIPTR_PREFIX"u"
#define SCNuFAST32	__PRIPTR_PREFIX"u"
#define SCNuPTR	__PRIPTR_PREFIX"u"
#define PRIXFAST16	__PRIPTR_PREFIX"X"
#define PRIXFAST32	__PRIPTR_PREFIX"X"
#define PRIXPTR	__PRIPTR_PREFIX"X"
#define PRIxFAST16	__PRIPTR_PREFIX"x"
#define PRIxFAST32	__PRIPTR_PREFIX"x"
#define PRIxPTR	__PRIPTR_PREFIX"x"
#define SCNxFAST16	__PRIPTR_PREFIX"x"
#define SCNxFAST32	__PRIPTR_PREFIX"x"
#define SCNxPTR	__PRIPTR_PREFIX"x"
#endif

#define __PDP_ENDIAN	3412
#define PDP_ENDIAN	__PDP_ENDIAN

extern intmax_t imaxabs(intmax_t __n);
extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom);
extern intmax_t strtoimax(const char *__nptr, char **__endptr, int __base);
extern uintmax_t strtoumax(const char *__nptr, char **__endptr,
			   int __base);
extern intmax_t wcstoimax(const wchar_t * __nptr, wchar_t * *__endptr,
			  int __base);
extern uintmax_t wcstoumax(const wchar_t * __nptr, wchar_t * *__endptr,
			   int __base);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7434"
>14.4.25. langinfo.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ABDAY_1	0x20000		/* Sun. */
#define ABDAY_2	0x20001
#define ABDAY_3	0x20002
#define ABDAY_4	0x20003
#define ABDAY_5	0x20004
#define ABDAY_6	0x20005
#define ABDAY_7	0x20006

#define DAY_1	0x20007
#define DAY_2	0x20008
#define DAY_3	0x20009
#define DAY_4	0x2000A
#define DAY_5	0x2000B
#define DAY_6	0x2000C
#define DAY_7	0x2000D

#define ABMON_1	0x2000E
#define ABMON_2	0x2000F
#define ABMON_3	0x20010
#define ABMON_4	0x20011
#define ABMON_5	0x20012
#define ABMON_6	0x20013
#define ABMON_7	0x20014
#define ABMON_8	0x20015
#define ABMON_9	0x20016
#define ABMON_10	0x20017
#define ABMON_11	0x20018
#define ABMON_12	0x20019

#define MON_1	0x2001A
#define MON_2	0x2001B
#define MON_3	0x2001C
#define MON_4	0x2001D
#define MON_5	0x2001E
#define MON_6	0x2001F
#define MON_7	0x20020
#define MON_8	0x20021
#define MON_9	0x20022
#define MON_10	0x20023
#define MON_11	0x20024
#define MON_12	0x20025

#define AM_STR	0x20026
#define PM_STR	0x20027

#define D_T_FMT	0x20028
#define D_FMT	0x20029
#define T_FMT	0x2002A
#define T_FMT_AMPM	0x2002B

#define ERA	0x2002C
#define ERA_D_FMT	0x2002E
#define ALT_DIGITS	0x2002F
#define ERA_D_T_FMT	0x20030
#define ERA_T_FMT	0x20031

#define CODESET	14

#define CRNCYSTR	0x4000F

#define RADIXCHAR	0x10000
#define THOUSEP	0x10001
#define YESEXPR	0x50000
#define NOEXPR	0x50001
#define YESSTR	0x50002
#define NOSTR	0x50003

extern char *nl_langinfo(nl_item __item);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7438"
>14.4.26. libgen.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define basename __xpg_basename

extern char *__xpg_basename(char *__path);
extern char *dirname(char *__path);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7442"
>14.4.27. libintl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern char *bind_textdomain_codeset(const char *__domainname,
				     const char *__codeset);
extern char *bindtextdomain(const char *__domainname,
			    const char *__dirname);
extern char *dcgettext(const char *__domainname, const char *__msgid,
		       int __category);
extern char *dcngettext(const char *__domainname, const char *__msgid1,
			const char *__msgid2, unsigned long int __n,
			int __category);
extern char *dgettext(const char *__domainname, const char *__msgid);
extern char *dngettext(const char *__domainname, const char *__msgid1,
		       const char *__msgid2, unsigned long int __n);
extern char *gettext(const char *__msgid);
extern char *ngettext(const char *__msgid1, const char *__msgid2,
		      unsigned long int __n);
extern char *textdomain(const char *__domainname);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7446"
>14.4.28. limits.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LLONG_MIN	(-LLONG_MAX-1LL)
#define _POSIX_AIO_MAX	1
#define _POSIX_QLIMIT	1
#define _POSIX2_BC_STRING_MAX	1000
#define IOV_MAX	1024
#define _POSIX2_CHARCLASS_NAME_MAX	14
#define _POSIX_NAME_MAX	14
#define _POSIX_UIO_MAXIOV	16
#define ULLONG_MAX	18446744073709551615ULL
#define _POSIX2_COLL_WEIGHTS_MAX	2
#define _POSIX_AIO_LISTIO_MAX	2
#define _POSIX_OPEN_MAX	20
#define _POSIX_CLOCKRES_MIN	20000000
#define CHARCLASS_NAME_MAX	2048
#define LINE_MAX	2048
#define _POSIX2_BC_DIM_MAX	2048
#define _POSIX2_LINE_MAX	2048
#define _POSIX_CHILD_MAX	25
#define COLL_WEIGHTS_MAX	255
#define NAME_MAX	255
#define _POSIX2_RE_DUP_MAX	255
#define _POSIX_HOST_NAME_MAX	255
#define _POSIX_MAX_CANON	255
#define _POSIX_MAX_INPUT	255
#define _POSIX_RE_DUP_MAX	255
#define _POSIX_SYMLINK_MAX	255
#define _POSIX_PATH_MAX	256
#define _POSIX_SEM_NSEMS_MAX	256
#define NGROUPS_MAX	32
#define WORD_BIT	32
#define _POSIX2_EXPR_NEST_MAX	32
#define _POSIX_DELAYTIMER_MAX	32
#define _POSIX_MQ_PRIO_MAX	32
#define _POSIX_SIGQUEUE_MAX	32
#define _POSIX_TIMER_MAX	32
#define _POSIX_SEM_VALUE_MAX	32767
#define _POSIX_SSIZE_MAX	32767
#define PATH_MAX	4096
#define _POSIX_ARG_MAX	4096
#define _POSIX_PIPE_BUF	512
#define _POSIX_TZNAME_MAX	6
#define _POSIX_LINK_MAX	8
#define _POSIX_MQ_OPEN_MAX	8
#define _POSIX_NGROUPS_MAX	8
#define _POSIX_RTSIG_MAX	8
#define _POSIX_STREAM_MAX	8
#define _POSIX_SYMLOOP_MAX	8
#define _POSIX_LOGIN_NAME_MAX	9
#define _POSIX_TTY_NAME_MAX	9
#define LLONG_MAX	9223372036854775807LL
#define _POSIX2_BC_BASE_MAX	99
#define _POSIX2_BC_SCALE_MAX	99
#define NL_MSGMAX	INT_MAX
#define NL_SETMAX	INT_MAX
#define NL_TEXTMAX	INT_MAX
#define SSIZE_MAX	LONG_MAX	/* Maximum value of an object of type ssize_t */
#define BC_BASE_MAX	_POSIX2_BC_BASE_MAX
#define BC_DIM_MAX	_POSIX2_BC_DIM_MAX
#define BC_SCALE_MAX	_POSIX2_BC_SCALE_MAX
#define BC_STRING_MAX	_POSIX2_BC_STRING_MAX
#define EXPR_NEST_MAX	_POSIX2_EXPR_NEST_MAX
#define NL_LANGMAX	_POSIX2_LINE_MAX
#define NL_ARGMAX	_POSIX_ARG_MAX
#define _POSIX_FD_SETSIZE	_POSIX_OPEN_MAX
#define _POSIX_HIWAT	_POSIX_PIPE_BUF

#define MB_LEN_MAX	16

#define SCHAR_MIN	(-128)
#define SCHAR_MAX	127
#define UCHAR_MAX	255
#define CHAR_BIT	8

#define SHRT_MIN	(-32768)
#define SHRT_MAX	32767
#define USHRT_MAX	65535

#define INT_MIN	(-INT_MAX-1)
#define INT_MAX	2147483647
#define UINT_MAX	4294967295U

#define LONG_MIN	(-LONG_MAX-1L)

#define PTHREAD_KEYS_MAX	1024
#define PTHREAD_THREADS_MAX	16384
#define PTHREAD_DESTRUCTOR_ITERATIONS	4</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7450"
>14.4.29. link.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int
dl_iterate_phdr(int (*callback) (struct dl_phdr_info *, size_t, void *),
		void *data);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7454"
>14.4.30. locale.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};

#define LC_GLOBAL_LOCALE	((locale_t) -1L)
#define LC_CTYPE	0
#define LC_NUMERIC	1
#define LC_TELEPHONE	10
#define LC_MEASUREMENT	11
#define LC_IDENTIFICATION	12
#define LC_TIME	2
#define LC_COLLATE	3
#define LC_MONETARY	4
#define LC_MESSAGES	5
#define LC_ALL	6
#define LC_PAPER	7
#define LC_NAME	8
#define LC_ADDRESS	9

struct __locale_struct {
    struct locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;

typedef struct __locale_struct *locale_t;

#define LC_ADDRESS_MASK	(1 &#60;&#60; LC_ADDRESS)
#define LC_COLLATE_MASK	(1 &#60;&#60; LC_COLLATE)
#define LC_IDENTIFICATION_MASK	(1 &#60;&#60; LC_IDENTIFICATION)
#define LC_MEASUREMENT_MASK	(1 &#60;&#60; LC_MEASUREMENT)
#define LC_MESSAGES_MASK	(1 &#60;&#60; LC_MESSAGES)
#define LC_MONETARY_MASK	(1 &#60;&#60; LC_MONETARY)
#define LC_NAME_MASK	(1 &#60;&#60; LC_NAME)
#define LC_NUMERIC_MASK	(1 &#60;&#60; LC_NUMERIC)
#define LC_PAPER_MASK	(1 &#60;&#60; LC_PAPER)
#define LC_TELEPHONE_MASK	(1 &#60;&#60; LC_TELEPHONE)
#define LC_TIME_MASK	(1 &#60;&#60; LC_TIME)
#define LC_CTYPE_MASK	(1&#60;&#60;LC_CTYPE)
#define LC_ALL_MASK	\
        (LC_CTYPE_MASK| LC_NUMERIC_MASK| LC_TIME_MASK| LC_COLLATE_MASK| LC_MONETARY_MASK|\
         LC_MESSAGES_MASK| LC_PAPER_MASK| LC_NAME_MASK| LC_ADDRESS_MASK| LC_TELEPHONE_MASK|\
         LC_MEASUREMENT_MASK| LC_IDENTIFICATION_MASK)

extern locale_t duplocale(locale_t __dataset);
extern void freelocale(locale_t __dataset);
extern struct lconv *localeconv(void);
extern locale_t newlocale(int __category_mask, const char *__locale,
			  locale_t __base);
extern char *setlocale(int __category, const char *__locale);
extern locale_t uselocale(locale_t __dataset);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7458"
>14.4.31. lsb/time.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct timeval {
    time_t tv_sec;
    suseconds_t tv_usec;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7462"
>14.4.32. lsb/types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;/*
 * This header is architecture dependent
 * Please refer to the specific architecture specification for details
 */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7466"
>14.4.33. lsb/wchar.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef unsigned int wint_t;
typedef struct {
    int count;
    wint_t value;
} __mbstate_t;

typedef __mbstate_t mbstate_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7470"
>14.4.34. monetary.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t strfmon(char *__s, size_t __maxsize, const char *__format,
		       ...);
extern ssize_t strfmon_l(char *s, size_t maxsize, locale_t locale,
			 const char *format, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7474"
>14.4.35. net/if.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IF_NAMESIZE	16

#define IFF_UP	0x01		/* Interface is up. */
#define IFF_BROADCAST	0x02	/* Broadcast address valid. */
#define IFF_DEBUG	0x04	/* Turn on debugging. */
#define IFF_LOOPBACK	0x08	/* Is a loopback net. */
#define IFF_POINTOPOINT	0x10	/* Interface is point-to-point link. */
#define IFF_PROMISC	0x100	/* Receive all packets. */
#define IFF_MULTICAST	0x1000	/* Supports multicast. */
#define IFF_NOTRAILERS	0x20	/* Avoid use of trailers. */
#define IFF_RUNNING	0x40	/* Resources allocated. */
#define IFF_NOARP	0x80	/* No address resolution protocol. */

struct if_nameindex {
    unsigned int if_index;	/* 1, 2, ... */
    char *if_name;		/* null terminated name: */
};

struct ifaddr {
    struct sockaddr ifa_addr;	/* Address of interface. */
    union {
	struct sockaddr ifu_broadaddr;
	struct sockaddr ifu_dstaddr;
    } ifa_ifu;
    void *ifa_ifp;
    void *ifa_next;
};

#define ifr_name	ifr_ifrn.ifrn_name	/* interface name */
#define ifr_addr	ifr_ifru.ifru_addr	/* address */
#define ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
#define ifr_data	ifr_ifru.ifru_data	/* for use by interface */
#define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk */
#define ifr_flags	ifr_ifru.ifru_flags	/* flags */
#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* interface name */
#define ifr_bandwidth	ifr_ifru.ifru_ivalue	/* link bandwidth */
#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index */
#define ifr_metric	ifr_ifru.ifru_ivalue	/* metric */
#define ifr_qlen	ifr_ifru.ifru_ivalue	/* queue length */
#define ifr_mtu	ifr_ifru.ifru_mtu	/* mtu */
#define ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
#define ifr_slave	ifr_ifru.ifru_slave	/* slave device */
#define IFNAMSIZ	IF_NAMESIZE

struct ifreq {
    union {
	char ifrn_name[IFNAMSIZ];
    } ifr_ifrn;
    union {
	struct sockaddr ifru_addr;
	struct sockaddr ifru_dstaddr;
	struct sockaddr ifru_broadaddr;
	struct sockaddr ifru_netmask;
	struct sockaddr ifru_hwaddr;
	short ifru_flags;
	int ifru_ivalue;
	int ifru_mtu;
	char ifru_slave[IFNAMSIZ];
	char ifru_newname[IFNAMSIZ];
	caddr_t ifru_data;
	struct ifmap ifru_map;
    } ifr_ifru;
};

#define ifc_buf	ifc_ifcu.ifcu_buf	/* Buffer address. */
#define ifc_req	ifc_ifcu.ifcu_req	/* Array of structures. */

struct ifconf {
    int ifc_len;
    union {
	caddr_t ifcu_buf;
	struct ifreq *ifcu_req;
    } ifc_ifcu;
};
extern void if_freenameindex(struct if_nameindex *__ptr);
extern char *if_indextoname(unsigned int __ifindex, char *__ifname);
extern struct if_nameindex *if_nameindex(void);
extern unsigned int if_nametoindex(const char *__ifname);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7478"
>14.4.36. netdb.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define h_errno	(*__h_errno_location ())
#define NETDB_INTERNAL	-1	/* See errno. */
#define NETDB_SUCCESS	0	/* No problem. */
#define HOST_NOT_FOUND	1	/* Authoritative Answer Host not found. */
#define IPPORT_RESERVED	1024
#define NI_MAXHOST	1025
#define TRY_AGAIN	2	/* Non-Authoritative Host not found, or SERVERFAIL. */
#define NO_RECOVERY	3	/* Non recoverable errors, FORMERR, REFUSED, NOTIMP. */
#define NI_MAXSERV	32
#define NO_DATA	4		/* Valid name, no data record of requested type. */
#define h_addr	h_addr_list[0]
#define NO_ADDRESS	NO_DATA	/* No address, look for MX record. */

struct servent {
    char *s_name;
    char **s_aliases;
    int s_port;
    char *s_proto;
};
struct hostent {
    char *h_name;
    char **h_aliases;
    int h_addrtype;
    int h_length;
    char **h_addr_list;
};
struct protoent {
    char *p_name;
    char **p_aliases;
    int p_proto;
};
struct netent {
    char *n_name;
    char **n_aliases;
    int n_addrtype;
    unsigned int n_net;
};

#define AI_PASSIVE	0x0001	/* Socket address is intended for `bind' */
#define AI_CANONNAME	0x0002	/* Request for canonical name */
#define AI_NUMERICHOST	0x0004	/* Don't use name resolution */
#define AI_V4MAPPED	0x0008	/* IPv4 mapped addresses are acceptable. */
#define AI_ALL	0x0010		/* Return IPv4 mapped and IPv6 addresses. */
#define AI_ADDRCONFIG	0x0020	/* Use configuration of this host to choose returned address type.. */
#define AI_NUMERICSERV	0x0400	/* Don't use name resolution */

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
};

#define NI_NUMERICHOST	1
#define NI_DGRAM	16
#define NI_NUMERICSERV	2
#define NI_NOFQDN	4
#define NI_NAMEREQD	8

#define EAI_BADFLAGS	-1	/* Invalid value for `ai_flags' field. */
#define EAI_MEMORY	-10	/* Memory allocation failure. */
#define EAI_SYSTEM	-11	/* System error returned in `errno'. */
#define EAI_NONAME	-2	/* NAME or SERVICE is unknown. */
#define EAI_AGAIN	-3	/* Temporary failure in name resolution. */
#define EAI_FAIL	-4	/* Non-recoverable failure in name res. */
#define EAI_NODATA	-5	/* No address associated with NAME. */
#define EAI_FAMILY	-6	/* `ai_family' not supported. */
#define EAI_SOCKTYPE	-7	/* `ai_family' not supported. */
#define EAI_SERVICE	-8	/* SERVICE not supported for `ai_socktype'. */
#define EAI_ADDRFAMILY	-9	/* Address family for NAME not supported. */

extern int *__h_errno_location(void);
extern void endprotoent(void);
extern void endservent(void);
extern void freeaddrinfo(struct addrinfo *__ai);
extern const char *gai_strerror(int __ecode);
extern int getaddrinfo(const char *__name, const char *__service,
		       const struct addrinfo *__req,
		       struct addrinfo **__pai);
extern struct hostent *gethostbyaddr(const void *__addr, socklen_t __len,
				     int __type);
extern int gethostbyaddr_r(const void *__addr, socklen_t __len, int __type,
			   struct hostent *__result_buf, char *__buf,
			   size_t __buflen, struct hostent **__result,
			   int *__h_errnop);
extern struct hostent *gethostbyname(const char *__name);
extern struct hostent *gethostbyname2(const char *__name, int __af);
extern int gethostbyname2_r(const char *__name, int __af,
			    struct hostent *__result_buf, char *__buf,
			    size_t __buflen, struct hostent **__result,
			    int *__h_errnop);
extern int gethostbyname_r(const char *__name,
			   struct hostent *__result_buf, char *__buf,
			   size_t __buflen, struct hostent **__result,
			   int *__h_errnop);
extern struct protoent *getprotobyname(const char *__name);
extern int getprotobyname_r(const char *__name,
			    struct protoent *__result_buf, char *__buf,
			    size_t __buflen, struct protoent **__result);
extern struct protoent *getprotobynumber(int __proto);
extern int getprotobynumber_r(int __proto, struct protoent *__result_buf,
			      char *__buf, size_t __buflen,
			      struct protoent **__result);
extern struct protoent *getprotoent(void);
extern int getprotoent_r(struct protoent *__result_buf, char *__buf,
			 size_t __buflen, struct protoent **__result);
extern struct servent *getservbyname(const char *__name,
				     const char *__proto);
extern int getservbyname_r(const char *__name, const char *__proto,
			   struct servent *__result_buf, char *__buf,
			   size_t __buflen, struct servent **__result);
extern struct servent *getservbyport(int __port, const char *__proto);
extern int getservbyport_r(int __port, const char *__proto,
			   struct servent *__result_buf, char *__buf,
			   size_t __buflen, struct servent **__result);
extern struct servent *getservent(void);
extern int getservent_r(struct servent *__result_buf, char *__buf,
			size_t __buflen, struct servent **__result);
extern void setprotoent(int __stay_open);
extern void setservent(int __stay_open);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7482"
>14.4.37. netinet/icmp6.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ICMP6_FILTER_WILLBLOCK(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) &#38; (1 &#60;&#60; ((type) &#38; 31))) != 0)
#define ICMP6_FILTER_WILLPASS(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) &#38; (1 &#60;&#60; ((type) &#38; 31))) == 0)
#define ICMP6_FILTER_SETPASS(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) &#38;= ~(1 &#60;&#60; ((type) &#38; 31))))
#define ICMP6_FILTER_SETBLOCK(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) |= (1 &#60;&#60; ((type) &#38; 31))))
#define ICMP6_DST_UNREACH_NOROUTE	0
#define ICMP6_PARAMPROB_HEADER	0
#define ICMP6_TIME_EXCEED_TRANSIT	0
#define ICMP6_RR_FLAGS_PREVDONE	0x08
#define ICMP6_RR_FLAGS_SPECSITE	0x10
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO	0x10
#define ICMP6_RR_FLAGS_FORCEAPPLY	0x20
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK	0x20
#define ND_OPT_PI_FLAG_RADDR	0x20
#define ND_RA_FLAG_HOME_AGENT	0x20
#define ICMP6_RR_FLAGS_REQRESULT	0x40
#define ND_OPT_PI_FLAG_AUTO	0x40
#define ND_RA_FLAG_OTHER	0x40
#define ICMP6_INFOMSG_MASK	0x80
#define ICMP6_RR_FLAGS_TEST	0x80
#define ND_OPT_PI_FLAG_ONLINK	0x80
#define ND_RA_FLAG_MANAGED	0x80
#define ICMP6_DST_UNREACH	1
#define ICMP6_DST_UNREACH_ADMIN	1
#define ICMP6_FILTER	1
#define ICMP6_FILTER_BLOCK	1
#define ICMP6_PARAMPROB_NEXTHEADER	1
#define ICMP6_TIME_EXCEED_REASSEMBLY	1
#define ND_OPT_SOURCE_LINKADDR	1
#define RPM_PCO_ADD	1
#define ICMP6_ECHO_REQUEST	128
#define ICMP6_ECHO_REPLY	129
#define MLD_LISTENER_QUERY	130
#define MLD_LISTENER_REPORT	131
#define MLD_LISTENER_REDUCTION	132
#define ND_ROUTER_SOLICIT	133
#define ND_ROUTER_ADVERT	134
#define ND_NEIGHBOR_SOLICIT	135
#define ND_NEIGHBOR_ADVERT	136
#define ND_REDIRECT	137
#define ICMP6_ROUTER_RENUMBERING	138
#define ICMP6_DST_UNREACH_BEYONDSCOPE	2
#define ICMP6_FILTER_PASS	2
#define ICMP6_PACKET_TOO_BIG	2
#define ICMP6_PARAMPROB_OPTION	2
#define ND_OPT_TARGET_LINKADDR	2
#define RPM_PCO_CHANGE	2
#define ICMP6_DST_UNREACH_ADDR	3
#define ICMP6_FILTER_BLOCKOTHERS	3
#define ICMP6_TIME_EXCEEDED	3
#define ND_OPT_PREFIX_INFORMATION	3
#define RPM_PCO_SETGLOBAL	3
#define ICMP6_DST_UNREACH_NOPORT	4
#define ICMP6_FILTER_PASSONLY	4
#define ICMP6_PARAM_PROB	4
#define ND_OPT_REDIRECTED_HEADER	4
#define ND_OPT_MTU	5
#define ND_OPT_RTR_ADV_INTERVAL	7
#define ND_OPT_HOME_AGENT_INFO	8
#define icmp6_id	icmp6_data16[0]
#define icmp6_maxdelay	icmp6_data16[0]
#define icmp6_seq	icmp6_data16[1]
#define icmp6_mtu	icmp6_data32[0]
#define icmp6_pptr	icmp6_data32[0]
#define icmp6_data16	icmp6_dataun.icmp6_un_data16
#define icmp6_data32	icmp6_dataun.icmp6_un_data32
#define icmp6_data8	icmp6_dataun.icmp6_un_data8
#define ICMP6_FILTER_SETPASSALL(filterp)	memset (filterp, 0, sizeof (struct icmp6_filter));
#define ICMP6_FILTER_SETBLOCKALL(filterp)	memset (filterp, 0xFF, sizeof (struct icmp6_filter));
#define mld_cksum	mld_icmp6_hdr.icmp6_cksum
#define mld_code	mld_icmp6_hdr.icmp6_code
#define mld_maxdelay	mld_icmp6_hdr.icmp6_data16[0]
#define mld_reserved	mld_icmp6_hdr.icmp6_data16[1]
#define mld_type	mld_icmp6_hdr.icmp6_type
#define nd_na_cksum	nd_na_hdr.icmp6_cksum
#define nd_na_code	nd_na_hdr.icmp6_code
#define nd_na_flags_reserved	nd_na_hdr.icmp6_data32[0]
#define nd_na_type	nd_na_hdr.icmp6_type
#define nd_ns_cksum	nd_ns_hdr.icmp6_cksum
#define nd_ns_code	nd_ns_hdr.icmp6_code
#define nd_ns_reserved	nd_ns_hdr.icmp6_data32[0]
#define nd_ns_type	nd_ns_hdr.icmp6_type
#define nd_ra_cksum	nd_ra_hdr.icmp6_cksum
#define nd_ra_code	nd_ra_hdr.icmp6_code
#define nd_ra_router_lifetime	nd_ra_hdr.icmp6_data16[1]
#define nd_ra_curhoplimit	nd_ra_hdr.icmp6_data8[0]
#define nd_ra_flags_reserved	nd_ra_hdr.icmp6_data8[1]
#define nd_ra_type	nd_ra_hdr.icmp6_type
#define nd_rd_cksum	nd_rd_hdr.icmp6_cksum
#define nd_rd_code	nd_rd_hdr.icmp6_code
#define nd_rd_reserved	nd_rd_hdr.icmp6_data32[0]
#define nd_rd_type	nd_rd_hdr.icmp6_type
#define nd_rs_cksum	nd_rs_hdr.icmp6_cksum
#define nd_rs_code	nd_rs_hdr.icmp6_code
#define nd_rs_reserved	nd_rs_hdr.icmp6_data32[0]
#define nd_rs_type	nd_rs_hdr.icmp6_type
#define rr_cksum	rr_hdr.icmp6_cksum
#define rr_code	rr_hdr.icmp6_code
#define rr_seqnum	rr_hdr.icmp6_data32[0]
#define rr_type	rr_hdr.icmp6_type

struct icmp6_filter {
    uint32_t icmp6_filt[8];
};
struct icmp6_hdr {
    uint8_t icmp6_type;
    uint8_t icmp6_code;
    uint16_t icmp6_cksum;
    union {
	uint32_t icmp6_un_data32[1];
	uint16_t icmp6_un_data16[2];
	uint8_t icmp6_un_data8[4];
    } icmp6_dataun;
};
struct nd_router_solicit {
    struct icmp6_hdr nd_rs_hdr;
};
struct nd_router_advert {
    struct icmp6_hdr nd_ra_hdr;
    uint32_t nd_ra_reachable;
    uint32_t nd_ra_retransmit;
};
struct nd_neighbor_solicit {
    struct icmp6_hdr nd_ns_hdr;
    struct in6_addr nd_ns_target;
};
struct nd_neighbor_advert {
    struct icmp6_hdr nd_na_hdr;
    struct in6_addr nd_na_target;
};
struct nd_redirect {
    struct icmp6_hdr nd_rd_hdr;
    struct in6_addr nd_rd_target;
    struct in6_addr nd_rd_dst;
};
struct nd_opt_hdr {
    uint8_t nd_opt_type;
    uint8_t nd_opt_len;
};
struct nd_opt_prefix_info {
    uint8_t nd_opt_pi_type;
    uint8_t nd_opt_pi_len;
    uint8_t nd_opt_pi_prefix_len;
    uint8_t nd_opt_pi_flags_reserved;
    uint32_t nd_opt_pi_valid_time;
    uint32_t nd_opt_pi_preferred_time;
    uint32_t nd_opt_pi_reserved2;
    struct in6_addr nd_opt_pi_prefix;
};
struct nd_opt_rd_hdr {
    uint8_t nd_opt_rh_type;
    uint8_t nd_opt_rh_len;
    uint16_t nd_opt_rh_reserved1;
    uint32_t nd_opt_rh_reserved2;
};
struct nd_opt_mtu {
    uint8_t nd_opt_mtu_type;
    uint8_t nd_opt_mtu_len;
    uint16_t nd_opt_mtu_reserved;
    uint32_t nd_opt_mtu_mtu;
};
struct mld_hdr {
    struct icmp6_hdr mld_icmp6_hdr;
    struct in6_addr mld_addr;
};
struct icmp6_router_renum {
    struct icmp6_hdr rr_hdr;
    uint8_t rr_segnum;
    uint8_t rr_flags;
    uint16_t rr_maxdelay;
    uint32_t rr_reserved;
};
struct rr_pco_match {
    uint8_t rpm_code;
    uint8_t rpm_len;
    uint8_t rpm_ordinal;
    uint8_t rpm_matchlen;
    uint8_t rpm_minlen;
    uint8_t rpm_maxlen;
    uint16_t rpm_reserved;
    struct in6_addr rpm_prefix;
};
struct rr_pco_use {
    uint8_t rpu_uselen;
    uint8_t rpu_keeplen;
    uint8_t rpu_ramask;
    uint8_t rpu_raflags;
    uint32_t rpu_vltime;
    uint32_t rpu_pltime;
    uint32_t rpu_flags;
    struct in6_addr rpu_prefix;
};
struct rr_result {
    uint16_t rrr_flags;
    uint8_t rrr_ordinal;
    uint8_t rrr_matchedlen;
    uint32_t rrr_ifid;
    struct in6_addr rrr_prefix;
};
struct nd_opt_adv_interval {
    uint8_t nd_opt_adv_interval_type;
    uint8_t nd_opt_adv_interval_len;
    uint16_t nd_opt_adv_interval_reserved;
    uint32_t nd_opt_adv_interval_ival;
};
struct nd_opt_home_agent_info {
    uint8_t nd_opt_home_agent_info_type;
    uint8_t nd_opt_home_agent_info_len;
    uint16_t nd_opt_home_agent_info_reserved;
    int16_t nd_opt_home_agent_info_preference;
    uint16_t nd_opt_home_agent_info_lifetime;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7486"
>14.4.38. netinet/igmp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IGMP_MEMBERSHIP_QUERY	0x11
#define IGMP_V1_MEMBERSHIP_REPORT	0x12
#define IGMP_DVMRP	0x13
#define IGMP_PIM	0x14
#define IGMP_TRACE	0x15
#define IGMP_V2_MEMBERSHIP_REPORT	0x16
#define IGMP_V2_LEAVE_GROUP	0x17
#define IGMP_MTRACE_RESP	0x1e
#define IGMP_MTRACE	0x1f
#define IGMP_DELAYING_MEMBER	1
#define IGMP_v1_ROUTER	1
#define IGMP_MAX_HOST_REPORT_DELAY	10
#define IGMP_TIMER_SCALE	10
#define IGMP_IDLE_MEMBER	2
#define IGMP_v2_ROUTER	2
#define IGMP_LAZY_MEMBER	3
#define IGMP_SLEEPING_MEMBER	4
#define IGMP_AWAKENING_MEMBER	5
#define IGMP_MINLEN	8
#define IGMP_HOST_MEMBERSHIP_QUERY	IGMP_MEMBERSHIP_QUERY
#define IGMP_HOST_MEMBERSHIP_REPORT	IGMP_V1_MEMBERSHIP_REPORT
#define IGMP_HOST_LEAVE_MESSAGE	IGMP_V2_LEAVE_GROUP
#define IGMP_HOST_NEW_MEMBERSHIP_REPORT	IGMP_V2_MEMBERSHIP_REPORT

struct igmp {
    u_int8_t igmp_type;
    u_int8_t igmp_code;
    u_int16_t igmp_cksum;
    struct in_addr igmp_group;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7490"
>14.4.39. netinet/in.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPPROTO_IP	0
#define IPPROTO_ICMP	1
#define IPPROTO_UDP	17
#define IPPROTO_IGMP	2
#define IPPROTO_RAW	255
#define IPPROTO_IPV6	41
#define IPPROTO_ICMPV6	58
#define IPPROTO_TCP	6

typedef uint16_t in_port_t;

struct in_addr {
    uint32_t s_addr;
};
typedef uint32_t in_addr_t;

#define INADDR_NONE	((in_addr_t) 0xffffffff)
#define INADDR_BROADCAST	(0xffffffff)
#define INADDR_ANY	0
#define INADDR_LOOPBACK	0x7f000001	/* 127.0.0.1 */

#define s6_addr16	in6_u.u6_addr16
#define s6_addr32	in6_u.u6_addr32
#define s6_addr	in6_u.u6_addr8

struct in6_addr {
    union {
	uint8_t u6_addr8[16];
	uint16_t u6_addr16[8];
	uint32_t u6_addr32[4];
    } in6_u;
};

#define IN6ADDR_ANY_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
#define IN6ADDR_LOOPBACK_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

#define IN_MULTICAST(a)	((((in_addr_t)(a))&#38;0xf0000000)==0xe0000000)
#define INET_ADDRSTRLEN	16

struct sockaddr_in {
    sa_family_t sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    unsigned char sin_zero[8];
};

#define IN6_IS_ADDR_LINKLOCAL(a)	((((const uint32_t *) (a))[0] &#38; htonl (0xffc00000)) == htonl (0xfe800000))
#define IN6_IS_ADDR_SITELOCAL(a)	((((const uint32_t *) (a))[0] &#38; htonl (0xffc00000)) == htonl (0xfec00000))
#define IN6_ARE_ADDR_EQUAL(a,b)	((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0]) &#38;&#38; (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1]) &#38;&#38; (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2]) &#38;&#38; (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))
#define IN6_IS_ADDR_V4COMPAT(a)	((((const uint32_t *) (a))[0] == 0) &#38;&#38; (((const uint32_t *) (a))[1] == 0) &#38;&#38; (((const uint32_t *) (a))[2] == 0) &#38;&#38; (ntohl (((const uint32_t *) (a))[3]) &#62; 1))
#define IN6_IS_ADDR_V4MAPPED(a)	((((const uint32_t *) (a))[0] == 0) &#38;&#38; (((const uint32_t *) (a))[1] == 0) &#38;&#38; (((const uint32_t *) (a))[2] == htonl (0xffff)))
#define IN6_IS_ADDR_UNSPECIFIED(a)	(((const uint32_t *) (a))[0] == 0 &#38;&#38; ((const uint32_t *) (a))[1] == 0 &#38;&#38; ((const uint32_t *) (a))[2] == 0 &#38;&#38; ((const uint32_t *) (a))[3] == 0)
#define IN6_IS_ADDR_LOOPBACK(a)	(((const uint32_t *) (a))[0] == 0 &#38;&#38; ((const uint32_t *) (a))[1] == 0 &#38;&#38; ((const uint32_t *) (a))[2] == 0 &#38;&#38; ((const uint32_t *) (a))[3] == htonl (1))
#define IN6_IS_ADDR_MULTICAST(a)	(((const uint8_t *) (a))[0] == 0xff)
#define IN6_IS_ADDR_MC_NODELOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x1))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x2))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x5))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x8))
#define IN6_IS_ADDR_MC_GLOBAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0xe))
#define INET6_ADDRSTRLEN	46

struct sockaddr_in6 {
    unsigned short sin6_family;	/* AF_INET6 */
    uint16_t sin6_port;		/* Transport layer port # */
    uint32_t sin6_flowinfo;	/* IPv6 flow information */
    struct in6_addr sin6_addr;	/* IPv6 address */
    uint32_t sin6_scope_id;	/* scope id (new in RFC2553) */
};

#define SOL_IP	0
#define IP_TOS	1		/* IP type of service and precedence */
#define IPV6_UNICAST_HOPS	16
#define IPV6_MULTICAST_IF	17
#define IPV6_MULTICAST_HOPS	18
#define IPV6_MULTICAST_LOOP	19
#define IP_TTL	2		/* IP time to live */
#define IPV6_JOIN_GROUP	20
#define IPV6_LEAVE_GROUP	21
#define IPV6_V6ONLY	26
#define IP_MULTICAST_IF	32	/* set/get IP multicast i/f */
#define IP_MULTICAST_TTL	33	/* set/get IP multicast ttl */
#define IP_MULTICAST_LOOP	34	/* set/get IP multicast loopback */
#define IP_ADD_MEMBERSHIP	35	/* add an IP group membership */
#define IP_DROP_MEMBERSHIP	36	/* drop an IP group membership */
#define IP_OPTIONS	4	/* IP per-packet options */
#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP

struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;	/* IPv6 multicast address of group */
    int ipv6mr_interface;	/* local IPv6 address of interface */
};
struct ip_mreq {
    struct in_addr imr_multiaddr;	/* IP multicast address of group */
    struct in_addr imr_interface;	/* local IP address of interface */
};
extern int bindresvport(int, struct sockaddr_in *);
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7494"
>14.4.40. netinet/in_systm.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef u_int16_t n_short;
typedef u_int32_t n_long;
typedef u_int32_t n_time;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7498"
>14.4.41. netinet/ip.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPOPT_CLASS(o)	((o) &#38; IPOPT_CLASS_MASK)
#define IPOPT_COPIED(o)	((o) &#38; IPOPT_COPY)
#define IPOPT_NUMBER(o)	((o) &#38; IPOPT_NUMBER_MASK)
#define IPOPT_EOL	0
#define IPOPT_OPTVAL	0
#define IPOPT_TS_TSONLY	0
#define IPOPT_CONTROL	0x00
#define IPOPT_SECUR_UNCLASS	0x0000
#define IPOPT_NUMBER_MASK	0x1f
#define IP_OFFMASK	0x1fff
#define IPOPT_RESERVED1	0x20
#define IP_MF	0x2000
#define IPOPT_DEBMEAS	0x40
#define IP_DF	0x4000
#define IPOPT_CLASS_MASK	0x60
#define IPOPT_RESERVED2	0x60
#define IPOPT_SECUR_TOPSECRET	0x6bc5
#define IPOPT_SECUR_EFTO	0x789a
#define IPOPT_COPY	0x80
#define IP_RF	0x8000
#define IPOPT_SECUR_RESTR	0xaf13
#define IPOPT_SECUR_MMMM	0xbc4d
#define IPOPT_SECUR_SECRET	0xd788
#define IPOPT_SECUR_CONFID	0xf135
#define IPOPT_NOP	1
#define IPOPT_OLEN	1
#define IPOPT_TS_TSANDADDR	1
#define IPTTLDEC	1
#define IPOPT_SECURITY	130
#define IPOPT_LSRR	131
#define IPOPT_SATID	136
#define IPOPT_SSRR	137
#define IPOPT_RA	148
#define IPOPT_OFFSET	2
#define MAXTTL	255
#define IPOPT_TS_PRESPEC	3
#define IPOPT_MINOFF	4
#define IPVERSION	4
#define MAX_IPOPTLEN	40
#define IP_MSS	576
#define IPFRAGTTL	60
#define IPDEFTTL	64
#define IP_MAXPACKET	65535
#define IPOPT_TS	68
#define IPOPT_RR	7
#define IPOPT_MEASUREMENT	IPOPT_DEBMEAS
#define IPOPT_END	IPOPT_EOL
#define IPOPT_NOOP	IPOPT_NOP
#define IPOPT_SID	IPOPT_SATID
#define IPOPT_SEC	IPOPT_SECURITY
#define IPOPT_TIMESTAMP	IPOPT_TS

#define IPTOS_TOS(tos)	((tos) &#38; IPTOS_TOS_MASK)
#define IPTOS_LOWCOST	0x02
#define IPTOS_RELIABILITY	0x04
#define IPTOS_THROUGHPUT	0x08
#define IPTOS_LOWDELAY	0x10
#define IPTOS_TOS_MASK	0x1e
#define IPTOS_MINCOST	IPTOS_LOWCOST

#define IPTOS_PREC(tos)	((tos) &#38; IPTOS_PREC_MASK)
#define IPTOS_PREC_MASK	0xe0</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7502"
>14.4.42. netinet/ip6.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IP6OPT_TYPE(o)	((o) &#38; 0xc0)
#define IP6OPT_PAD1	0
#define IP6OPT_TYPE_SKIP	0x00
#define IP6OPT_TUNNEL_LIMIT	0x04
#define IP6OPT_ROUTER_ALERT	0x05
#define IP6OPT_TYPE_MUTABLE	0x20
#define IP6OPT_TYPE_DISCARD	0x40
#define IP6OPT_TYPE_FORCEICMP	0x80
#define IP6OPT_TYPE_ICMP	0xc0
#define IP6OPT_JUMBO	0xc2
#define IP6OPT_NSAP_ADDR	0xc3
#define IP6OPT_PADN	1
#define IP6OPT_JUMBO_LEN	6
#define ip6_flow	ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_hlim	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_nxt	ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_plen	ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_vfc	ip6_ctlun.ip6_un2_vfc

struct ip6_hdrctl {
    uint32_t ip6_un1_flow;
    uint16_t ip6_un1_plen;
    uint8_t ip6_un1_nxt;
    uint8_t ip6_un1_hlim;
};
struct ip6_hdr {
    struct in6_addr ip6_src;
    struct in6_addr ip6_dst;
};
struct ip6_ext {
    uint8_t ip6e_nxt;
    uint8_t ip6e_len;
};
struct ip6_hbh {
    uint8_t ip6h_nxt;
    uint8_t ip6h_len;
};
struct ip6_dest {
    uint8_t ip6d_nxt;
    uint8_t ip6d_len;
};
struct ip6_rthdr {
    uint8_t ip6r_nxt;
    uint8_t ip6r_len;
    uint8_t ip6r_type;
    uint8_t ip6r_segleft;
};
struct ip6_frag {
    uint8_t ip6f_nxt;
    uint8_t ip6f_reserved;
    uint16_t ip6f_offlg;
    uint32_t ip6f_ident;
};
struct ip6_opt {
    uint8_t ip6o_type;
    uint8_t ip6o_len;
};
struct ip6_opt_jumbo {
    uint8_t ip6oj_type;
    uint8_t ip6oj_len;
    uint8_t ip6oj_jumbo_len[4];
};
struct ip6_opt_nsap {
    uint8_t ip6on_type;
    uint8_t ip6on_len;
    uint8_t ip6on_src_nsap_len;
    uint8_t ip6on_dst_nsap_len;
};
struct ip6_opt_tunnel {
    uint8_t ip6ot_type;
    uint8_t ip6ot_len;
    uint8_t ip6ot_encap_limit;
};
struct ip6_opt_router {
    uint8_t ip6or_type;
    uint8_t ip6or_len;
    uint8_t ip6or_value[2];
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7506"
>14.4.43. netinet/ip_icmp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ICMP_INFOTYPE(type)	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || (type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || (type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || (type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || (type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
#define ICMP_ADVLEN(p)	(8 + ((p)-&#62;icmp_ip.ip_hl &#60;&#60; 2) + 8)
#define ICMP_TSLEN	(8 + 3 * sizeof (n_time))
#define ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)
#define ICMP_ECHOREPLY	0
#define ICMP_EXC_TTL	0
#define ICMP_NET_UNREACH	0
#define ICMP_REDIRECT_NET	0
#define ICMP_REDIR_NET	0
#define ICMP_TIMXCEED_INTRANS	0
#define ICMP_UNREACH_NET	0
#define ICMP_EXC_FRAGTIME	1
#define ICMP_HOST_UNREACH	1
#define ICMP_PARAMPROB_OPTABSENT	1
#define ICMP_REDIRECT_HOST	1
#define ICMP_REDIR_HOST	1
#define ICMP_TIMXCEED_REASS	1
#define ICMP_UNREACH_HOST	1
#define ICMP_HOST_ANO	10
#define ICMP_ROUTERSOLICIT	10
#define ICMP_UNREACH_HOST_PROHIB	10
#define ICMP_NET_UNR_TOS	11
#define ICMP_TIME_EXCEEDED	11
#define ICMP_TIMXCEED	11
#define ICMP_UNREACH_TOSNET	11
#define ICMP_HOST_UNR_TOS	12
#define ICMP_MASKLEN	12
#define ICMP_PARAMETERPROB	12
#define ICMP_PARAMPROB	12
#define ICMP_UNREACH_TOSHOST	12
#define ICMP_PKT_FILTERED	13
#define ICMP_TIMESTAMP	13
#define ICMP_TSTAMP	13
#define ICMP_UNREACH_FILTER_PROHIB	13
#define ICMP_PREC_VIOLATION	14
#define ICMP_TIMESTAMPREPLY	14
#define ICMP_TSTAMPREPLY	14
#define ICMP_UNREACH_HOST_PRECEDENCE	14
#define ICMP_INFO_REQUEST	15
#define ICMP_IREQ	15
#define ICMP_PREC_CUTOFF	15
#define ICMP_UNREACH_PRECEDENCE_CUTOFF	15
#define NR_ICMP_UNREACH	15
#define ICMP_INFO_REPLY	16
#define ICMP_IREQREPLY	16
#define ICMP_ADDRESS	17
#define ICMP_MASKREQ	17
#define ICMP_ADDRESSREPLY	18
#define ICMP_MASKREPLY	18
#define ICMP_MAXTYPE	18
#define NR_ICMP_TYPES	18
#define ICMP_PROT_UNREACH	2
#define ICMP_REDIRECT_TOSNET	2
#define ICMP_REDIR_NETTOS	2
#define ICMP_UNREACH_PROTOCOL	2
#define ICMP_DEST_UNREACH	3
#define ICMP_PORT_UNREACH	3
#define ICMP_REDIRECT_TOSHOST	3
#define ICMP_REDIR_HOSTTOS	3
#define ICMP_UNREACH	3
#define ICMP_UNREACH_PORT	3
#define ICMP_FRAG_NEEDED	4
#define ICMP_SOURCEQUENCH	4
#define ICMP_SOURCE_QUENCH	4
#define ICMP_UNREACH_NEEDFRAG	4
#define ICMP_REDIRECT	5
#define ICMP_SR_FAILED	5
#define ICMP_UNREACH_SRCFAIL	5
#define ICMP_NET_UNKNOWN	6
#define ICMP_UNREACH_NET_UNKNOWN	6
#define ICMP_HOST_UNKNOWN	7
#define ICMP_UNREACH_HOST_UNKNOWN	7
#define ICMP_ECHO	8
#define ICMP_HOST_ISOLATED	8
#define ICMP_MINLEN	8
#define ICMP_UNREACH_ISOLATED	8
#define ICMP_NET_ANO	9
#define ICMP_ROUTERADVERT	9
#define ICMP_UNREACH_NET_PROHIB	9
#define icmp_data	icmp_dun.id_data
#define icmp_ip	icmp_dun.id_ip.idi_ip
#define icmp_mask	icmp_dun.id_mask
#define icmp_radv	icmp_dun.id_radv
#define icmp_otime	icmp_dun.id_ts.its_otime
#define icmp_rtime	icmp_dun.id_ts.its_rtime
#define icmp_ttime	icmp_dun.id_ts.its_ttime
#define icmp_gwaddr	icmp_hun.ih_gwaddr
#define icmp_id	icmp_hun.ih_idseq.icd_id
#define icmp_seq	icmp_hun.ih_idseq.icd_seq
#define icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
#define icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
#define icmp_pptr	icmp_hun.ih_pptr
#define icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
#define icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
#define icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
#define icmp_void	icmp_hun.ih_void

struct icmphdr {
    u_int8_t type;
    u_int8_t code;
    u_int16_t checksum;
    union {
	struct {
	    u_int16_t id;
	    u_int16_t sequence;
	} echo;
	u_int32_t gateway;
	struct {
	    u_int16_t __unused;
	    u_int16_t mtu;
	} frag;
    } un;
};
struct icmp_ra_addr {
    u_int32_t ira_addr;
    u_int32_t ira_preference;
};
struct ih_idseq {
    u_int16_t icd_id;
    u_int16_t icd_seq;
};
struct ih_pmtu {
    u_int16_t ipm_void;
    u_int16_t ipm_nextmtu;
};
struct ih_rtradv {
    u_int8_t irt_num_addrs;
    u_int8_t irt_wpa;
    u_int16_t irt_lifetime;
};
struct icmp {
    u_int8_t icmp_type;
    u_int8_t icmp_code;
    u_int16_t icmp_cksum;
    union {
	u_int16_t ih_pptr;
	struct in_addr ih_gwaddr;
	struct ih_idseq ih_idseq;
	u_int32_t ih_void;
	struct ih_pmtu ih_pmtu;
	struct ih_rtradv ih_rtradv;
    } icmp_hun;
    union {
	struct {
	    u_int32_t its_otime;
	    u_int32_t its_rtime;
	    u_int32_t its_ttime;
	} id_ts;
	struct {
	    struct ip idi_ip;
	} id_ip;
	struct icmp_ra_addr id_radv;
	u_int32_t id_mask;
	u_int8_t id_data[1];
    } icmp_dun;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7510"
>14.4.44. netinet/tcp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2)
#define TCPOPT_TSTAMP_HDR	(TCPOPT_NOP&#60;&#60;24|TCPOPT_NOP&#60;&#60;16|TCPOPT_TIMESTAMP&#60;&#60;8|TCPOLEN_TIMESTAMP)
#define TCPOPT_EOL	0
#define TCPI_OPT_TIMESTAMPS	1
#define TCPOPT_NOP	1
#define TCP_NODELAY	1
#define TCPOLEN_TIMESTAMP	10
#define TCP_WINDOW_CLAMP	10
#define TCP_INFO	11
#define TCP_QUICKACK	12
#define TCP_CONGESTION	13
#define TCP_MAX_WINSHIFT	14
#define TCPI_OPT_SACK	2
#define TCPOLEN_SACK_PERMITTED	2
#define TCPOPT_MAXSEG	2
#define TCP_MAXSEG	2
#define TCPOLEN_WINDOW	3
#define TCPOPT_WINDOW	3
#define TCP_CORK	3
#define TCPI_OPT_WSCALE	4
#define TCPOLEN_MAXSEG	4
#define TCPOPT_SACK_PERMITTED	4
#define TCP_KEEPIDLE	4
#define TCPOPT_SACK	5
#define TCP_KEEPINTVL	5
#define TCP_MSS	512
#define SOL_TCP	6
#define TCP_KEEPCNT	6
#define TCP_MAXWIN	65535
#define TCP_SYNCNT	7
#define TCPI_OPT_ECN	8
#define TCPOPT_TIMESTAMP	8
#define TCP_LINGER2	8
#define TCP_DEFER_ACCEPT	9

enum tcp_ca_state {
    TCP_CA_Open,
    TCP_CA_Disorder,
    TCP_CA_CWR,
    TCP_CA_Recovery,
    TCP_CA_Loss
};
struct tcp_info {
    uint8_t tcpi_state;
    uint8_t tcpi_ca_state;
    uint8_t tcpi_retransmits;
    uint8_t tcpi_probes;
    uint8_t tcpi_backoff;
    uint8_t tcpi_options;
    uint8_t tcpi_snd_wscale:4;
    uint8_t tcpi_rcv_wscale:4;
    uint32_t tcpi_rto;
    uint32_t tcpi_ato;
    uint32_t tcpi_snd_mss;
    uint32_t tcpi_rcv_mss;
    uint32_t tcpi_unacked;
    uint32_t tcpi_sacked;
    uint32_t tcpi_lost;
    uint32_t tcpi_retrans;
    uint32_t tcpi_fackets;
    uint32_t tcpi_last_data_sent;
    uint32_t tcpi_last_ack_sent;
    uint32_t tcpi_last_data_recv;
    uint32_t tcpi_last_ack_recv;
    uint32_t tcpi_pmtu;
    uint32_t tcpi_rcv_ssthresh;
    uint32_t tcpi_rtt;
    uint32_t tcpi_rttvar;
    uint32_t tcpi_snd_ssthresh;
    uint32_t tcpi_snd_cwnd;
    uint32_t tcpi_advmss;
    uint32_t tcpi_reordering;
};
enum {
    TCP_ESTABLISHED = 1,
    TCP_SYN_SENT = 2,
    TCP_SYN_RECV = 3,
    TCP_FIN_WAIT1 = 4,
    TCP_FIN_WAIT2 = 5,
    TCP_TIME_WAIT = 6,
    TCP_CLOSE = 7,
    TCP_CLOSE_WAIT = 8,
    TCP_LAST_ACK = 9,
    TCP_LISTEN = 10,
    TCP_CLOSING = 11
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7514"
>14.4.45. netinet/udp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SOL_UDP	17

struct udphdr {
    u_int16_t source;
    u_int16_t dest;
    u_int16_t len;
    u_int16_t check;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7518"
>14.4.46. nl_types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NL_CAT_LOCALE	1
#define NL_SETD	1

typedef void *nl_catd;

typedef int nl_item;
extern int catclose(nl_catd __catalog);
extern char *catgets(nl_catd __catalog, int __set, int __number,
		     const char *__string);
extern nl_catd catopen(const char *__cat_name, int __flag);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7522"
>14.4.47. poll.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int poll(struct pollfd *__fds, nfds_t __nfds, int __timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7526"
>14.4.48. pwd.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct passwd {
    char *pw_name;
    char *pw_passwd;
    uid_t pw_uid;
    gid_t pw_gid;
    char *pw_gecos;
    char *pw_dir;
    char *pw_shell;
};
extern void endpwent(void);
extern struct passwd *getpwent(void);
extern int getpwent_r(struct passwd *__resultbuf, char *__buffer,
		      size_t __buflen, struct passwd **__result);
extern struct passwd *getpwnam(const char *__name);
extern int getpwnam_r(const char *__name, struct passwd *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct passwd **__result);
extern struct passwd *getpwuid(uid_t __uid);
extern int getpwuid_r(uid_t __uid, struct passwd *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct passwd **__result);
extern void setpwent(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7530"
>14.4.49. regex.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RE_DUP_MAX	(0x7fff)

typedef unsigned long int reg_syntax_t;

typedef struct re_pattern_buffer {
    unsigned char *buffer;
    unsigned long int allocated;
    unsigned long int used;
    reg_syntax_t syntax;
    char *fastmap;
    char *translate;
    size_t re_nsub;
    unsigned int can_be_null:1;
    unsigned int regs_allocated:2;
    unsigned int fastmap_accurate:1;
    unsigned int no_sub:1;
    unsigned int not_bol:1;
    unsigned int not_eol:1;
    unsigned int newline_anchor:1;
} regex_t;
typedef int regoff_t;
typedef struct {
    regoff_t rm_so;
    regoff_t rm_eo;
} regmatch_t;

#define REG_ICASE	(REG_EXTENDED&#60;&#60;1)
#define REG_NEWLINE	(REG_ICASE&#60;&#60;1)
#define REG_NOSUB	(REG_NEWLINE&#60;&#60;1)
#define REG_EXTENDED	1

#define REG_NOTEOL	(1&#60;&#60;1)
#define REG_NOTBOL	1

typedef enum {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} reg_errcode_t;
extern int regcomp(regex_t * __preg, const char *__pattern, int __cflags);
extern size_t regerror(int __errcode, const regex_t * __preg,
		       char *__errbuf, size_t __errbuf_size);
extern int regexec(const regex_t * __preg, const char *__string,
		   size_t __nmatch, regmatch_t __pmatch[], int __eflags);
extern void regfree(regex_t * __preg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7534"
>14.4.50. rpc/auth.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define auth_destroy(auth)	((*((auth)-&#62;ah_ops-&#62;ah_destroy))(auth))

enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,		/* bogus credentials (seal broken) */
    AUTH_REJECTEDCRED = 2,	/* client should begin new session */
    AUTH_BADVERF = 3,		/* bogus verifier (seal broken) */
    AUTH_REJECTEDVERF = 4,	/* verifier expired or was replayed */
    AUTH_TOOWEAK = 5,		/* Rpc calls return an enum clnt_stat. */
    AUTH_INVALIDRESP = 6,	/* bogus response verifier */
    AUTH_FAILED = 7		/* some unknown reason */
};

union des_block {
    struct {
	u_int32_t high;
	u_int32_t low;
    } key;
    char c[8];
};

struct opaque_auth {
    enum_t oa_flavor;		/* flavor of auth */
    caddr_t oa_base;		/* address of more auth stuff */
    u_int oa_length;		/* not to exceed MAX_AUTH_BYTES */
};

typedef struct AUTH {
    struct opaque_auth ah_cred;
    struct opaque_auth ah_verf;
    union des_block ah_key;
    struct auth_ops *ah_ops;
    caddr_t ah_private;
} AUTH;

struct auth_ops {
    void (*ah_nextverf) (struct AUTH *);
    int (*ah_marshal) (struct AUTH *, XDR *);	/* nextverf &#38; serialize */
    int (*ah_validate) (struct AUTH *, struct opaque_auth *);	/* validate verifier */
    int (*ah_refresh) (struct AUTH *);	/* refresh credentials */
    void (*ah_destroy) (struct AUTH *);	/* Rpc calls return an enum clnt_stat. */
};
extern struct AUTH *authnone_create(void);
extern int key_decryptsession(char *, union des_block *);
extern bool_t xdr_opaque_auth(XDR *, struct opaque_auth *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7538"
>14.4.51. rpc/clnt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define clnt_control(cl,rq,in)	((*(cl)-&#62;cl_ops-&#62;cl_control)(cl,rq,in))
#define clnt_abort(rh)	((*(rh)-&#62;cl_ops-&#62;cl_abort)(rh))
#define clnt_destroy(rh)	((*(rh)-&#62;cl_ops-&#62;cl_destroy)(rh))
#define clnt_freeres(rh,xres,resp)	((*(rh)-&#62;cl_ops-&#62;cl_freeres)(rh,xres,resp))
#define clnt_geterr(rh,errp)	((*(rh)-&#62;cl_ops-&#62;cl_geterr)(rh, errp))
#define NULLPROC	((u_long)0)	/* By convention, procedure 0 takes null arguments and returns */
#define CLSET_TIMEOUT	1	/* set timeout (timeval) */
#define CLGET_XID	10	/* Get xid */
#define CLSET_XID	11	/* Set xid */
#define CLGET_VERS	12	/* Get version number */
#define CLSET_VERS	13	/* Set version number */
#define CLGET_PROG	14	/* Get program number */
#define CLSET_PROG	15	/* Set program number */
#define CLGET_TIMEOUT	2	/* get timeout (timeval) */
#define CLGET_SERVER_ADDR	3	/* get server's address (sockaddr) */
#define CLSET_RETRY_TIMEOUT	4	/* set retry timeout (timeval) */
#define CLGET_RETRY_TIMEOUT	5	/* get retry timeout (timeval) */
#define CLGET_FD	6	/* get connections file descriptor */
#define CLGET_SVC_ADDR	7	/* get server's address (netbuf) */
#define CLSET_FD_CLOSE	8	/* close fd while clnt_destroy */
#define CLSET_FD_NCLOSE	9	/* Do not close fd while clnt_destroy */
#define clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)-&#62;cl_ops-&#62;cl_call)(rh, proc, xargs, argsp, xres, resp, secs))

enum clnt_stat {
    RPC_SUCCESS = 0,		/* call succeeded */
    RPC_CANTENCODEARGS = 1,	/* can't encode arguments */
    RPC_CANTDECODERES = 2,	/* can't decode results */
    RPC_CANTSEND = 3,		/* failure in sending call */
    RPC_CANTRECV = 4,		/* failure in receiving result */
    RPC_TIMEDOUT = 5,		/* call timed out */
    RPC_VERSMISMATCH = 6,	/* rpc versions not compatible */
    RPC_AUTHERROR = 7,		/* authentication error */
    RPC_PROGUNAVAIL = 8,	/* program not available */
    RPC_PROGVERSMISMATCH = 9,	/* program version mismatched */
    RPC_PROCUNAVAIL = 10,	/* procedure unavailable */
    RPC_CANTDECODEARGS = 11,	/* decode arguments error */
    RPC_SYSTEMERROR = 12,	/* generic "other problem" */
    RPC_NOBROADCAST = 21,	/* Broadcasting not supported */
    RPC_UNKNOWNHOST = 13,	/* unknown host name */
    RPC_UNKNOWNPROTO = 17,	/* unknown protocol */
    RPC_UNKNOWNADDR = 19,	/* Remote address unknown */
    RPC_RPCBFAILURE = 14,	/* portmapper failed in its call */
    RPC_PROGNOTREGISTERED = 15,	/* remote program is not registered */
    RPC_N2AXLATEFAILURE = 22,	/* Name to addr translation failed */
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
};
struct rpc_err {
    enum clnt_stat re_status;
    union {
	int RE_errno;
	enum auth_stat RE_why;
	struct {
	    u_long low;
	    u_long high;
	} RE_vers;
	struct {
	    long int s1;
	    long int s2;
	} RE_lb;
    } ru;
};

typedef struct CLIENT {
    struct AUTH *cl_auth;
    struct clnt_ops *cl_ops;
    caddr_t cl_private;
} CLIENT;

struct clnt_ops {
    enum clnt_stat (*cl_call) (struct CLIENT *, u_long, xdrproc_t, caddr_t,
			       xdrproc_t, caddr_t, struct timeval);
    void (*cl_abort) (void);
    void (*cl_geterr) (struct CLIENT *, struct rpc_err *);
     bool_t(*cl_freeres) (struct CLIENT *, xdrproc_t, caddr_t);
    void (*cl_destroy) (struct CLIENT *);
     bool_t(*cl_control) (struct CLIENT *, int, char *);
};
extern int callrpc(const char *__host, const u_long __prognum,
		   const u_long __versnum, const u_long __procnum,
		   const xdrproc_t __inproc, const char *__in,
		   const xdrproc_t __outproc, char *__out);
extern struct CLIENT *clnt_create(const char *__host, const u_long __prog,
				  const u_long __vers, const char *__prot);
extern void clnt_pcreateerror(const char *__msg);
extern void clnt_perrno(enum clnt_stat __num);
extern void clnt_perror(struct CLIENT *__clnt, const char *__msg);
extern char *clnt_spcreateerror(const char *__msg);
extern char *clnt_sperrno(enum clnt_stat __num);
extern char *clnt_sperror(struct CLIENT *__clnt, const char *__msg);
extern struct CLIENT *clntraw_create(u_long __prog, u_long __vers);
extern struct CLIENT *clnttcp_create(struct sockaddr_in *__raddr,
				     u_long __prog, u_long __version,
				     int *__sockp, u_int __sendsz,
				     u_int __recvsz);
extern struct CLIENT *clntudp_bufcreate(struct sockaddr_in *__raddr,
					u_long __program, u_long __version,
					struct timeval __wait_resend,
					int *__sockp, u_int __sendsz,
					u_int __recvsz);
extern struct CLIENT *clntudp_create(struct sockaddr_in *__raddr,
				     u_long __program, u_long __version,
				     struct timeval __wait_resend,
				     int *__sockp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7542"
>14.4.52. rpc/pmap_clnt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern u_short pmap_getport(struct sockaddr_in *__address,
			    const u_long __program, const u_long __version,
			    u_int __protocol);
extern bool_t pmap_set(const u_long __program, const u_long __vers,
		       int __protocol, u_short __port);
extern bool_t pmap_unset(u_long __program, u_long __vers);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7546"
>14.4.53. rpc/rpc_msg.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum msg_type {
    CALL = 0,
    REPLY = 1
};
enum reply_stat {
    MSG_ACCEPTED = 0,
    MSG_DENIED = 1
};
enum accept_stat {
    SUCCESS = 0,
    PROG_UNAVAIL = 1,
    PROG_MISMATCH = 2,
    PROC_UNAVAIL = 3,
    GARBAGE_ARGS = 4,
    SYSTEM_ERR = 5
};
enum reject_stat {
    RPC_MISMATCH = 0,
    AUTH_ERROR = 1
};

#define ar_results	ru.AR_results
#define ar_vers	ru.AR_versions

struct accepted_reply {
    struct opaque_auth ar_verf;
    enum accept_stat ar_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} AR_versions;
	struct {
	    caddr_t where;
	    xdrproc_t proc;
	} AR_results;
    } ru;
};

#define rj_vers	ru.RJ_versions
#define rj_why	ru.RJ_why

struct rejected_reply {
    enum reject_stat rj_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} RJ_versions;
	enum auth_stat RJ_why;	/* why authentication did not work */
    } ru;
};

#define rp_acpt	ru.RP_ar
#define rp_rjct	ru.RP_dr

struct reply_body {
    enum reply_stat rp_stat;
    union {
	struct accepted_reply RP_ar;
	struct rejected_reply RP_dr;
    } ru;
};

struct call_body {
    unsigned long int cb_rpcvers;	/* must be equal to two */
    unsigned long int cb_prog;
    unsigned long int cb_vers;
    unsigned long int cb_proc;
    struct opaque_auth cb_cred;
    struct opaque_auth cb_verf;	/* protocol specific - provided by client */
};

#define rm_call	ru.RM_cmb
#define rm_reply	ru.RM_rmb
#define acpted_rply	ru.RM_rmb.ru.RP_ar
#define rjcted_rply	ru.RM_rmb.ru.RP_dr

struct rpc_msg {
    unsigned long int rm_xid;
    enum msg_type rm_direction;
    union {
	struct call_body RM_cmb;
	struct reply_body RM_rmb;
    } ru;
};
extern bool_t xdr_accepted_reply(XDR *, struct accepted_reply *);
extern bool_t xdr_callhdr(XDR * __xdrs, struct rpc_msg *__cmsg);
extern bool_t xdr_callmsg(XDR * __xdrs, struct rpc_msg *__cmsg);
extern bool_t xdr_rejected_reply(XDR *, struct rejected_reply *);
extern bool_t xdr_replymsg(XDR * __xdrs, struct rpc_msg *__rmsg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7550"
>14.4.54. rpc/svc.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define svc_getcaller(x)	(&#38;(x)-&#62;xp_raddr)
#define svc_destroy(xprt)	(*(xprt)-&#62;xp_ops-&#62;xp_destroy)(xprt)
#define svc_recv(xprt,msg)	(*(xprt)-&#62;xp_ops-&#62;xp_recv)((xprt), (msg))
#define svc_reply(xprt,msg)	(*(xprt)-&#62;xp_ops-&#62;xp_reply) ((xprt), (msg))
#define svc_stat(xprt)	(*(xprt)-&#62;xp_ops-&#62;xp_stat)(xprt)
#define RPC_ANYSOCK	-1
#define svc_freeargs(xprt,xargs, argsp)	\
	(*(xprt)-&#62;xp_ops-&#62;xp_freeargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt,xargs, argsp)	\
	(*(xprt)-&#62;xp_ops-&#62;xp_getargs)((xprt), (xargs), (argsp))

enum xprt_stat {
    XPRT_DIED,
    XPRT_MOREREQS,
    XPRT_IDLE
};

typedef struct SVCXPRT {
    int xp_sock;
    u_short xp_port;
    struct xp_ops *xp_ops;
    int xp_addrlen;
    struct sockaddr_in xp_raddr;
    struct opaque_auth xp_verf;
    caddr_t xp_p1;
    caddr_t xp_p2;
    char xp_pad[256];
} SVCXPRT;

struct svc_req {
    rpcprog_t rq_prog;
    rpcvers_t rq_vers;
    rpcproc_t rq_proc;
    struct opaque_auth rq_cred;
    caddr_t rq_clntcred;
    SVCXPRT *rq_xprt;
};

typedef void (*__dispatch_fn_t) (struct svc_req *, SVCXPRT *);

struct xp_ops {
    bool_t(*xp_recv) (SVCXPRT * __xprt, struct rpc_msg * __msg);
    enum xprt_stat (*xp_stat) (SVCXPRT * __xprt);
     bool_t(*xp_getargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			  caddr_t args_ptr);
     bool_t(*xp_reply) (SVCXPRT * __xprt, struct rpc_msg * __msg);
     bool_t(*xp_freeargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			   caddr_t args_ptr);
    void (*xp_destroy) (SVCXPRT * __xprt);
};
extern void svc_getreqset(fd_set * __readfds);
extern bool_t svc_register(SVCXPRT * __xprt, rpcprog_t __prog,
			   rpcvers_t __vers, __dispatch_fn_t __dispatch,
			   rpcprot_t __protocol);
extern void svc_run(void);
extern bool_t svc_sendreply(SVCXPRT * xprt, xdrproc_t __xdr_results,
			    caddr_t __xdr_location);
extern void svcerr_auth(SVCXPRT * __xprt, enum auth_stat __why);
extern void svcerr_decode(SVCXPRT * __xprt);
extern void svcerr_noproc(SVCXPRT * __xprt);
extern void svcerr_noprog(SVCXPRT * __xprt);
extern void svcerr_progvers(SVCXPRT * __xprt, rpcvers_t __low_vers,
			    rpcvers_t __high_vers);
extern void svcerr_systemerr(SVCXPRT * __xprt);
extern void svcerr_weakauth(SVCXPRT * __xprt);
extern SVCXPRT *svcfd_create(int, unsigned int, unsigned int);
extern SVCXPRT *svcraw_create(void);
extern SVCXPRT *svctcp_create(int __sock, u_int __sendsize,
			      u_int __recvsize);
extern SVCXPRT *svcudp_create(int __sock);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7554"
>14.4.55. rpc/types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef int bool_t;
typedef int enum_t;
typedef unsigned long int rpcprog_t;
typedef unsigned long int rpcvers_t;
typedef unsigned long int rpcproc_t;
typedef unsigned long int rpcprot_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7558"
>14.4.56. rpc/xdr.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define XDR_DESTROY(xdrs)	 \
   do { if ((xdrs)-&#62;x_ops-&#62;x_destroy) (*(xdrs)-&#62;x_ops-&#62;x_destroy)(xdrs); \
      } while (0)
#define xdr_destroy(xdrs)	 \
   do { if ((xdrs)-&#62;x_ops-&#62;x_destroy) (*(xdrs)-&#62;x_ops-&#62;x_destroy)(xdrs); \
      } while (0)
#define XDR_GETBYTES(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_getbytes)(xdrs, addr, len)
#define XDR_GETINT32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_getint32)(xdrs, int32p)
#define xdr_getint32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_getint32)(xdrs, int32p)
#define XDR_GETLONG(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_getlong)(xdrs, longp)
#define XDR_GETPOS(xdrs)	(*(xdrs)-&#62;x_ops-&#62;x_getpostn)(xdrs)
#define xdr_getpos(xdrs)	(*(xdrs)-&#62;x_ops-&#62;x_getpostn)(xdrs)
#define XDR_INLINE(xdrs,len)	(*(xdrs)-&#62;x_ops-&#62;x_inline)(xdrs, len)
#define xdr_inline(xdrs,len)	(*(xdrs)-&#62;x_ops-&#62;x_inline)(xdrs, len)
#define XDR_PUTBYTES(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_putbytes)(xdrs, addr, len)
#define XDR_PUTINT32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_putint32)(xdrs, int32p)
#define xdr_putint32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_putint32)(xdrs, int32p)
#define XDR_PUTLONG(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_putlong)(xdrs, longp)
#define XDR_SETPOS(xdrs,pos)	(*(xdrs)-&#62;x_ops-&#62;x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs,pos)	(*(xdrs)-&#62;x_ops-&#62;x_setpostn)(xdrs, pos)

enum xdr_op {
    XDR_ENCODE,
    XDR_DECODE,
    XDR_FREE
};
typedef struct XDR {
    enum xdr_op x_op;
    struct xdr_ops *x_ops;
    caddr_t x_public;
    caddr_t x_private;
    caddr_t x_base;
    int x_handy;
} XDR;

struct xdr_ops {
    bool_t(*x_getlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_putlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_getbytes) (XDR * __xdrs, caddr_t __addr, u_int __len);
    bool_t(*x_putbytes) (XDR * __xdrs, char *__addr, u_int __len);
    u_int(*x_getpostn) (XDR * __xdrs);
    bool_t(*x_setpostn) (XDR * __xdrs, u_int __pos);
    int32_t *(*x_inline) (XDR * __xdrs, int __len);
    void (*x_destroy) (XDR * __xdrs);
     bool_t(*x_getint32) (XDR * __xdrs, int32_t * __ip);
     bool_t(*x_putint32) (XDR * __xdrs, int32_t * __ip);
};

typedef bool_t(*xdrproc_t) (XDR *, void *, ...);

struct xdr_discrim {
    int value;
    xdrproc_t proc;
};
extern bool_t xdr_array(XDR * _xdrs, caddr_t * __addrp, u_int * __sizep,
			u_int __maxsize, u_int __elsize,
			xdrproc_t __elproc);
extern bool_t xdr_bool(XDR * __xdrs, bool_t * __bp);
extern bool_t xdr_bytes(XDR * __xdrs, char **__cpp, u_int * __sizep,
			u_int __maxsize);
extern bool_t xdr_char(XDR * __xdrs, char *__cp);
extern bool_t xdr_double(XDR * __xdrs, double *__dp);
extern bool_t xdr_enum(XDR * __xdrs, enum_t * __ep);
extern bool_t xdr_float(XDR * __xdrs, float *__fp);
extern void xdr_free(xdrproc_t __proc, char *__objp);
extern bool_t xdr_int(XDR * __xdrs, int *__ip);
extern bool_t xdr_long(XDR * __xdrs, long int *__lp);
extern bool_t xdr_opaque(XDR * __xdrs, caddr_t __cp, u_int __cnt);
extern bool_t xdr_pointer(XDR * __xdrs, char **__objpp, u_int __obj_size,
			  xdrproc_t __xdr_obj);
extern bool_t xdr_reference(XDR * __xdrs, caddr_t * __xpp, u_int __size,
			    xdrproc_t __proc);
extern bool_t xdr_short(XDR * __xdrs, short *__sp);
extern bool_t xdr_string(XDR * __xdrs, char **__cpp, u_int __maxsize);
extern bool_t xdr_u_char(XDR * __xdrs, u_char * __cp);
extern bool_t xdr_u_int(XDR * __xdrs, u_int * __up);
extern bool_t xdr_u_long(XDR * __xdrs, u_long * __ulp);
extern bool_t xdr_u_short(XDR * __xdrs, u_short * __usp);
extern bool_t xdr_union(XDR * __xdrs, enum_t * __dscmp, char *__unp,
			const struct xdr_discrim *__choices,
			xdrproc_t dfault);
extern bool_t xdr_vector(XDR * __xdrs, char *__basep, u_int __nelem,
			 u_int __elemsize, xdrproc_t __xdr_elem);
extern bool_t xdr_void(void);
extern bool_t xdr_wrapstring(XDR * __xdrs, char **__cpp);
extern void xdrmem_create(XDR * __xdrs, caddr_t __addr, u_int __size,
			  enum xdr_op __xop);
extern void xdrrec_create(XDR * __xdrs, u_int __sendsize, u_int __recvsize,
			  caddr_t __tcp_handle, int (*__readit) (char *,
								 char *,
								 int),
			  int (*__writeit) (char *, char *, int));
extern bool_t xdrrec_endofrecord(XDR * __xdrs, bool_t __sendnow);
extern bool_t xdrrec_eof(XDR * __xdrs);
extern bool_t xdrrec_skiprecord(XDR * __xdrs);
extern void xdrstdio_create(XDR * __xdrs, FILE * __file,
			    enum xdr_op __xop);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7562"
>14.4.57. sched.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __CPU_ALLOC_SIZE(count)	((((count) + __NCPUBITS - 1) / __NCPUBITS) * 8)
#define __CPUELT(cpu)	((cpu) / __NCPUBITS)
#define __CPUMASK(cpu)	((__cpu_mask) 1 &#60;&#60; ((cpu) % __NCPUBITS))
#define __NCPUBITS	(8 * sizeof (__cpu_mask))
#define SCHED_OTHER	0
#define SCHED_FIFO	1
#define __CPU_SETSIZE	1024
#define SCHED_RR	2
#define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) 	\
  (__extension__\
   ({ cpu_set_t *__dest = (destset); \
     cpu_set_t *__arr1 = (srcset1); \
     cpu_set_t *__arr2 = (srcset2); \
     size_t __imax = (setsize) / sizeof (__cpu_mask); \
     size_t __i; \
     for (__i = 0; __i &#60; __imax; ++__i)\
       __dest-&#62;__bits[__i] = __arr1-&#62;__bits[__i] op __arr2-&#62;__bits[__i]; \
 __dest; }))
#define __CPU_SET_S(cpu, setsize, cpusetp)	\
  (__extension__\
   ({ size_t __cpu = (cpu); \
     __cpu &#60; 8 * (setsize) \
     ? ((cpusetp)-&#62;__bits[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))
#define __CPU_ISSET_S(cpu, setsize, cpusetp)	\
  (__extension__\
   ({ size_t __cpu = (cpu); \
     __cpu &#60; 8 * (setsize)\
     ? (((cpusetp)-&#62;__bits[__CPUELT (__cpu)] &#38; __CPUMASK (__cpu))) != 0 \
 : 0; }))
#define __CPU_CLR_S(cpu, setsize, cpusetp)	\
  (__extension__\
   ({ size_t __cpu = (cpu); \
     __cpu &#60; 8 * (setsize)\
     ? ((cpusetp)-&#62;__bits[__CPUELT (__cpu)] &#38;= ~__CPUMASK (__cpu)) : 0; }))
#define __CPU_ZERO_S(setsize, cpusetp)	\
  do {\
    size_t __i; \
    size_t __imax = (setsize) / sizeof (__cpu_mask); \
    cpu_set_t *__arr = (cpusetp); \
    for (__i = 0; __i &#60; __imax; ++__i)\
       __arr-&#62;__bits[__i] = 0; \
  } while (0)
#define CPU_ALLOC_SIZE(count)	__CPU_ALLOC_SIZE (count)
#define CPU_CLR(cpu, cpusetp)	__CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_ISSET(cpu, cpusetp)	__CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_AND_S(setsize, destset, srcset1, srcset2)	__CPU_OP_S (setsize, destset, srcset1, srcset2, &#38;)
#define CPU_XOR_S(setsize, destset, srcset1, srcset2)	__CPU_OP_S (setsize, destset, srcset1, srcset2, ^)
#define CPU_OR_S(setsize, destset, srcset1, srcset2)	__CPU_OP_S (setsize, destset, srcset1, srcset2, |)
#define CPU_AND(destset, srcset1, srcset2)	__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &#38;)
#define CPU_XOR(destset, srcset1, srcset2)	__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)
#define CPU_OR(destset, srcset1, srcset2)	__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)
#define CPU_SETSIZE	__CPU_SETSIZE
#define CPU_SET(cpu, cpusetp)	__CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_ZERO(cpusetp)	__CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)

struct sched_param {
    int sched_priority;
};
typedef unsigned long int __cpu_mask;
typedef struct {
    __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
} cpu_set_t;
extern int sched_get_priority_max(int __algorithm);
extern int sched_get_priority_min(int __algorithm);
extern int sched_getaffinity(pid_t __pid, size_t __cpusetsize,
			     cpu_set_t * __cpuset);
extern int sched_getparam(pid_t __pid, struct sched_param *__param);
extern int sched_getscheduler(pid_t __pid);
extern int sched_rr_get_interval(pid_t __pid, struct timespec *__t);
extern int sched_setaffinity(pid_t __pid, size_t __cpusetsize,
			     const cpu_set_t * __cpuset);
extern int sched_setparam(pid_t __pid, const struct sched_param *__param);
extern int sched_setscheduler(pid_t __pid, int __policy,
			      const struct sched_param *__param);
extern int sched_yield(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7566"
>14.4.58. search.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct entry {
    char *key;
    void *data;
} ENTRY;
typedef enum {
    FIND,
    ENTER
} ACTION;
struct _ENTRY;
typedef enum {
    preorder,
    postorder,
    endorder,
    leaf
} VISIT;
struct hsearch_data {
    struct _ENTRY *table;
    unsigned int size;
    unsigned int filled;
};

typedef void (*__action_fn_t) (const void *__nodep, VISIT __value,
			       int __level);
extern int hcreate(size_t __nel);
extern int hcreate_r(size_t __nel, struct hsearch_data *__htab);
extern void hdestroy(void);
extern void hdestroy_r(struct hsearch_data *__htab);
extern ENTRY *hsearch(ENTRY __item, ACTION __action);
extern int hsearch_r(ENTRY __item, ACTION __action, ENTRY * *__retval,
		     struct hsearch_data *__htab);
extern void insque(void *__elem, void *__prev);
extern void *lfind(const void *__key, const void *__base, size_t * __nmemb,
		   size_t __size, __compar_fn_t __compar);
extern void *lsearch(const void *__key, void *__base, size_t * __nmemb,
		     size_t __size, __compar_fn_t __compar);
extern void remque(void *__elem);
extern void *tdelete(const void *__key, void **__rootp,
		     __compar_fn_t __compar);
extern void *tfind(const void *__key, void *const *__rootp,
		   __compar_fn_t __compar);
extern void *tsearch(const void *__key, void **__rootp,
		     __compar_fn_t __compar);
extern void twalk(const void *__root, __action_fn_t __action);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7570"
>14.4.59. setjmp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define setjmp(env)	_setjmp(env)
#define sigsetjmp(a,b)	__sigsetjmp(a,b)

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    sigset_t __saved_mask;
};

typedef struct __jmp_buf_tag jmp_buf[1];
typedef jmp_buf sigjmp_buf;
extern int __sigsetjmp(jmp_buf __env, int __savemask);
extern void _longjmp(jmp_buf __env, int __val);
extern int _setjmp(jmp_buf __env);
extern void longjmp(jmp_buf __env, int __val);
extern void siglongjmp(sigjmp_buf __env, int __val);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7574"
>14.4.60. signal.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define sigpause __xpg_sigpause

#define _SIGSET_NWORDS	(1024/(8*sizeof(unsigned long)))
#define SIGRTMAX	(__libc_current_sigrtmax ())
#define SIGRTMIN	(__libc_current_sigrtmin ())
#define NSIG	65
#define SIG_BLOCK	0	/* Block signals. */
#define SIG_UNBLOCK	1	/* Unblock signals. */
#define SIG_SETMASK	2	/* Set the set of blocked signals. */

typedef int sig_atomic_t;

typedef void (*sighandler_t) (int);

#define SIG_HOLD	((sighandler_t) 2)	/* Request that signal be held. */
#define SIG_DFL	((sighandler_t)0)	/* Request for default signal handling. */
#define SIG_IGN	((sighandler_t)1)	/* Request that signal be ignored. */
#define SIG_ERR	((sighandler_t)-1)	/* Return value from signal() in case of error. */

#define SIGHUP	1		/* Hangup. */
#define SIGINT	2		/* Terminal interrupt signal. */
#define SIGQUIT	3		/* Terminal quit signal. */
#define SIGILL	4		/* Illegal instruction. */
#define SIGTRAP	5		/* Trace/breakpoint trap. */
#define SIGABRT	6		/* Process abort signal. */
#define SIGIOT	6		/* IOT trap */
#define SIGBUS	7		/* Access to an undefined portion of a memory object. */
#define SIGFPE	8		/* Erroneous arithmetic operation. */
#define SIGKILL	9		/* Kill (cannot be caught or ignored). */
#define SIGUSR1	10		/* User-defined signal 1. */
#define SIGSEGV	11		/* Invalid memory reference. */
#define SIGUSR2	12		/* User-defined signal 2. */
#define SIGPIPE	13		/* Write  on a pipe with no one to read it. */
#define SIGALRM	14		/* Alarm clock. */
#define SIGTERM	15		/* Termination signal. */
#define SIGSTKFLT	16	/* Stack fault. */
#define SIGCHLD	17		/* Child process terminated, stopped, or continued. */
#define SIGCLD	SIGCHLD		/* Same as SIGCHLD */
#define SIGCONT	18		/* Continue executing, if stopped. */
#define SIGSTOP	19		/* Stop executing (cannot be caught or ignored). */
#define SIGTSTP	20		/* Terminal stop signal. */
#define SIGTTIN	21		/* Background process attempting read. */
#define SIGTTOU	22		/* Background process attempting write. */
#define SIGURG	23		/* High bandwidth data is available at a socket. */
#define SIGXCPU	24		/* CPU time limit exceeded. */
#define SIGXFSZ	25		/* File size limit exceeded. */
#define SIGVTALRM	26	/* Virtual timer expired. */
#define SIGPROF	27		/* Profiling timer expired. */
#define SIGWINCH	28	/* Window size change. */
#define SIGIO	29		/* I/O now possible. */
#define SIGPOLL	SIGIO		/* Pollable event. */
#define SIGPWR	30		/* Power failure restart */
#define SIGSYS	31		/* Bad system call. */
#define SIGUNUSED	31

#define SV_ONSTACK	(1&#60;&#60;0)	/* Take the signal on the signal stack. */
#define SV_INTERRUPT	(1&#60;&#60;1)	/* Do not restart system calls. */
#define SV_RESETHAND	(1&#60;&#60;2)	/* Reset handler to SIG_DFL on receipt. */

typedef union sigval {
    int sival_int;
    void *sival_ptr;
} sigval_t;

#define SIGEV_SIGNAL	0	/* Notify via signal. */
#define SIGEV_NONE	1	/* Other notification: meaningless. */
#define SIGEV_THREAD	2	/* Deliver via thread creation. */
#define SIGEV_MAX_SIZE	64

typedef struct sigevent {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;
    union {
	int _pad[SIGEV_PAD_SIZE];
	struct {
	    void (*_function) (sigval_t);
	    void *_attribute;
	} _sigev_thread;
    } _sigev_un;
} sigevent_t;

#define SI_MAX_SIZE	128
#define si_pid	_sifields._kill._pid
#define si_uid	_sifields._kill._uid
#define si_value	_sifields._rt._sigval
#define si_int	_sifields._rt._sigval.sival_int
#define si_ptr	_sifields._rt._sigval.sival_ptr
#define si_status	_sifields._sigchld._status
#define si_stime	_sifields._sigchld._stime
#define si_utime	_sifields._sigchld._utime
#define si_addr	_sifields._sigfault._addr
#define si_band	_sifields._sigpoll._band
#define si_fd	_sifields._sigpoll._fd
#define si_timer1	_sifields._timer._timer1
#define si_timer2	_sifields._timer._timer2
#define sigev_notify_attributes	_sigev_un._sigev_thread._attribute
#define sigev_notify_function	_sigev_un._sigev_thread._function

typedef struct siginfo {
    int si_signo;		/* Signal number. */
    int si_errno;
    int si_code;		/* Signal code. */
    union {
	int _pad[SI_PAD_SIZE];
	struct {
	    pid_t _pid;
	    uid_t _uid;
	} _kill;
	struct {
	    unsigned int _timer1;
	    unsigned int _timer2;
	} _timer;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    sigval_t _sigval;
	} _rt;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    int _status;
	    clock_t _utime;
	    clock_t _stime;
	} _sigchld;
	struct {
	    void *_addr;
	} _sigfault;
	struct {
	    int _band;
	    int _fd;
	} _sigpoll;
    } _sifields;
} siginfo_t;

#define SI_QUEUE	-1	/* Sent by sigqueue. */
#define SI_TIMER	-2	/* Sent by timer expiration. */
#define SI_MESGQ	-3	/* Sent by real time mesq state change. */
#define SI_ASYNCIO	-4	/* Sent by AIO completion. */
#define SI_SIGIO	-5	/* Sent by queued SIGIO. */
#define SI_TKILL	-6	/* Sent by tkill. */
#define SI_ASYNCNL	-60	/* Sent by asynch name lookup completion. */
#define SI_USER	0		/* Sent by kill, sigsend, raise. */
#define SI_KERNEL	0x80	/* Sent by kernel. */

#define ILL_ILLOPC	1	/* Illegal opcode. */
#define ILL_ILLOPN	2	/* Illegal operand. */
#define ILL_ILLADR	3	/* Illegal addressing mode. */
#define ILL_ILLTRP	4	/* Illegal trap. */
#define ILL_PRVOPC	5	/* Privileged opcode. */
#define ILL_PRVREG	6	/* Privileged register. */
#define ILL_COPROC	7	/* Coprocessor error. */
#define ILL_BADSTK	8	/* Internal stack error. */

#define FPE_INTDIV	1	/* Integer divide by zero. */
#define FPE_INTOVF	2	/* Integer overflow. */
#define FPE_FLTDIV	3	/*  Floating-point divide by zero. */
#define FPE_FLTOVF	4	/* Floating-point overflow. */
#define FPE_FLTUND	5	/*  Floating-point underflow. */
#define FPE_FLTRES	6	/*  Floating-point inexact result. */
#define FPE_FLTINV	7	/* Invalid floating-point operation. */
#define FPE_FLTSUB	8	/* Subscript out of range. */

#define SEGV_MAPERR	1	/* Address not mapped to object. */
#define SEGV_ACCERR	2	/*  Invalid permissions for mapped object. */

#define BUS_ADRALN	1	/*  Invalid address alignment. */
#define BUS_ADRERR	2	/*  Nonexistent physical address. */
#define BUS_OBJERR	3	/*  Object-specific hardware error. */

#define TRAP_BRKPT	1	/*  Process breakpoint. */
#define TRAP_TRACE	2	/*  Process trace trap. */

#define CLD_EXITED	1	/* Child has exited. */
#define CLD_KILLED	2	/* Child has terminated abnormally and did not create a core fi */
#define CLD_DUMPED	3	/* Child has terminated abnormally and created a core file. */
#define CLD_TRAPPED	4	/*  Traced child has trapped. */
#define CLD_STOPPED	5	/* Child has stopped. */
#define CLD_CONTINUED	6	/* Stopped child has continued. */

#define POLL_IN	1		/*  Data input available. */
#define POLL_OUT	2	/*  Output buffers available. */
#define POLL_MSG	3	/*  Input message available. */
#define POLL_ERR	4	/*  I/O error. */
#define POLL_PRI	5	/* High priority input available. */
#define POLL_HUP	6	/*  Device disconnected. */

typedef struct {
    unsigned long int sig[_SIGSET_NWORDS];
} sigset_t;

#define SA_INTERRUPT	0x20000000
#define sa_handler	__sigaction_handler._sa_handler
#define sa_sigaction	__sigaction_handler._sa_sigaction
#define SA_ONSTACK	0x08000000	/* Use signal stack by using `sa_restorer`. */
#define SA_RESETHAND	0x80000000	/* Reset to SIG_DFL on entry to handler. */
#define SA_NOCLDSTOP	0x00000001	/* Don't send SIGCHLD when children stop. */
#define SA_SIGINFO	0x00000004	/* Invoke signal-catching function with three arguments instead of one. */
#define SA_NODEFER	0x40000000	/* Don't automatically block the signal when its handler is being executed. */
#define SA_RESTART	0x10000000	/* Restart syscall on signal return. */
#define SA_NOCLDWAIT	0x00000002	/* Don't create zombie on child death. */
#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND

typedef struct sigaltstack {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
} stack_t;

#define SS_ONSTACK	1
#define SS_DISABLE	2

extern int __libc_current_sigrtmax(void);
extern int __libc_current_sigrtmin(void);
extern sighandler_t __sysv_signal(int __sig, sighandler_t __handler);
extern int __xpg_sigpause(int);
extern char *const _sys_siglist[];
extern sighandler_t bsd_signal(int __sig, sighandler_t __handler);
extern int kill(pid_t __pid, int __sig);
extern int killpg(pid_t __pgrp, int __sig);
extern void psiginfo(const siginfo_t * pinfo, const char *message);
extern void psignal(int __sig, const char *__s);
extern int pthread_kill(pthread_t, int);
extern int pthread_sigmask(int, const sigset_t *, sigset_t *);
extern int raise(int __sig);
extern int sigaction(int __sig, const struct sigaction *__act,
		     struct sigaction *__oact);
extern int sigaddset(sigset_t * __set, int __signo);
extern int sigaltstack(const struct sigaltstack *__ss,
		       struct sigaltstack *__oss);
extern int sigandset(sigset_t * __set, const sigset_t * __left,
		     const sigset_t * __right);
extern int sigdelset(sigset_t * __set, int __signo);
extern int sigemptyset(sigset_t * __set);
extern int sigfillset(sigset_t * __set);
extern int sighold(int __sig);
extern int sigignore(int __sig);
extern int siginterrupt(int __sig, int __interrupt);
extern int sigisemptyset(const sigset_t * __set);
extern int sigismember(const sigset_t * __set, int __signo);
extern sighandler_t signal(int __sig, sighandler_t __handler);
extern int sigorset(sigset_t * __set, const sigset_t * __left,
		    const sigset_t * __right);
extern int sigpending(sigset_t * __set);
extern int sigprocmask(int __how, const sigset_t * __set,
		       sigset_t * __oset);
extern int sigqueue(pid_t __pid, int __sig, const union sigval __val);
extern int sigrelse(int __sig);
extern int sigreturn(struct sigcontext *__scp);
extern sighandler_t sigset(int __sig, sighandler_t __disp);
extern int sigsuspend(const sigset_t * __set);
extern int sigtimedwait(const sigset_t * __set, siginfo_t * __info,
			const struct timespec *__timeout);
extern int sigwait(const sigset_t * __set, int *__sig);
extern int sigwaitinfo(const sigset_t * __set, siginfo_t * __info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7578"
>14.4.61. spawn.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define POSIX_SPAWN_RESETIDS	0x01
#define POSIX_SPAWN_SETPGROUP	0x02
#define POSIX_SPAWN_SETSIGDEF	0x04
#define POSIX_SPAWN_SETSIGMASK	0x08
#define POSIX_SPAWN_SETSCHEDPARAM	0x10
#define POSIX_SPAWN_SETSCHEDULER	0x20

typedef struct {
    int __allocated;
    int __used;
    struct __spawn_action *__actions;
    int __pad[16];
} posix_spawn_file_actions_t;
typedef struct {
    short __flags;
    pid_t __pgrp;
    sigset_t __sd;
    sigset_t __ss;
    struct sched_param __sp;
    int __policy;
    int __pad[16];
} posix_spawnattr_t;
extern int posix_spawn(pid_t * __pid, const char *__path,
		       const posix_spawn_file_actions_t * __file_actions,
		       const posix_spawnattr_t * __attrp,
		       char *const argv[], char *const envp[]);
extern int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *
					     __file_actions, int __fd);
extern int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *
					    __file_actions, int __fd,
					    int __newfd);
extern int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *
					    __file_actions, int __fd,
					    const char *__path,
					    int __oflag, mode_t __mode);
extern int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *
					    __file_actions);
extern int posix_spawn_file_actions_init(posix_spawn_file_actions_t *
					 __file_actions);
extern int posix_spawnattr_destroy(posix_spawnattr_t * __attr);
extern int posix_spawnattr_getflags(const posix_spawnattr_t * __attr,
				    short int *__flags);
extern int posix_spawnattr_getpgroup(const posix_spawnattr_t * __attr,
				     pid_t * __pgroup);
extern int posix_spawnattr_getschedparam(const posix_spawnattr_t * __attr,
					 struct sched_param *__schedparam);
extern int posix_spawnattr_getschedpolicy(const posix_spawnattr_t * __attr,
					  int *__schedpolicy);
extern int posix_spawnattr_getsigdefault(const posix_spawnattr_t * __attr,
					 sigset_t * __sigdefault);
extern int posix_spawnattr_getsigmask(const posix_spawnattr_t * __attr,
				      sigset_t * __sigmask);
extern int posix_spawnattr_init(posix_spawnattr_t * __attr);
extern int posix_spawnattr_setflags(posix_spawnattr_t * _attr,
				    short int __flags);
extern int posix_spawnattr_setpgroup(posix_spawnattr_t * __attr,
				     pid_t __pgroup);
extern int posix_spawnattr_setschedparam(posix_spawnattr_t * __attr,
					 const struct sched_param
					 *__schedparam);
extern int posix_spawnattr_setschedpolicy(posix_spawnattr_t * __attr,
					  int __schedpolicy);
extern int posix_spawnattr_setsigdefault(posix_spawnattr_t * __attr,
					 const sigset_t * __sigdefault);
extern int posix_spawnattr_setsigmask(posix_spawnattr_t * __attr,
				      const sigset_t * __sigmask);
extern int posix_spawnp(pid_t * __pid, const char *__file,
			const posix_spawn_file_actions_t * __file_actions,
			const posix_spawnattr_t * __attrp,
			char *const argv[], char *const envp[]);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7582"
>14.4.62. stddef.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#if !defined(__GNUC__)
#define __builtin_offsetof (TYPE, MEMBER)	((size_t)&#38;((TYPE*)0)-&#62;MEMBER)
#endif
#ifndef NULL
#  ifdef __cplusplus
#    define NULL        (0L)
#  else
#    define NULL        ((void*) 0)
#  endif
#endif
#define offsetof(TYPE,MEMBER)	__builtin_offsetof (TYPE, MEMBER)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7586"
>14.4.63. stdint.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define INT16_C(c)	c
#define INT32_C(c)	c
#define INT8_C(c)	c
#define UINT16_C(c)	c
#define UINT8_C(c)	c
#define UINT32_C(c)	c ## U

#define INT8_MIN	(-128)
#define INT_FAST8_MIN	(-128)
#define INT_LEAST8_MIN	(-128)
#define INT32_MIN	(-2147483647-1)
#define INT_LEAST32_MIN	(-2147483647-1)
#define SIG_ATOMIC_MIN	(-2147483647-1)
#define INT16_MIN	(-32767-1)
#define INT_LEAST16_MIN	(-32767-1)
#define INT64_MIN	(-__INT64_C(9223372036854775807)-1)
#define INTMAX_MIN	(-__INT64_C(9223372036854775807)-1)
#define INT_FAST64_MIN	(-__INT64_C(9223372036854775807)-1)
#define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
#define WINT_MIN	(0u)
#define INT8_MAX	(127)
#define INT_FAST8_MAX	(127)
#define INT_LEAST8_MAX	(127)
#define INT32_MAX	(2147483647)
#define INT_LEAST32_MAX	(2147483647)
#define SIG_ATOMIC_MAX	(2147483647)
#define UINT8_MAX	(255)
#define UINT_FAST8_MAX	(255)
#define UINT_LEAST8_MAX	(255)
#define INT16_MAX	(32767)
#define INT_LEAST16_MAX	(32767)
#define UINT32_MAX	(4294967295U)
#define UINT_LEAST32_MAX	(4294967295U)
#define WINT_MAX	(4294967295u)
#define UINT16_MAX	(65535)
#define UINT_LEAST16_MAX	(65535)
#define INT64_MAX	(__INT64_C(9223372036854775807))
#define INTMAX_MAX	(__INT64_C(9223372036854775807))
#define INT_FAST64_MAX	(__INT64_C(9223372036854775807))
#define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))
#define UINT64_MAX	(__UINT64_C(18446744073709551615))
#define UINTMAX_MAX	(__UINT64_C(18446744073709551615))
#define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))
#define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7590"
>14.4.64. stdio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EOF	(-1)
#define P_tmpdir	"/tmp"
#ifndef SEEK_SET
#define SEEK_SET	0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR	1
#endif
#define FOPEN_MAX	16
#ifndef SEEK_END
#define SEEK_END	2
#endif
#define L_tmpnam	20
#define TMP_MAX	238328
#define FILENAME_MAX	4096
#define BUFSIZ	8192
#define L_ctermid	9
#define L_cuserid	9

typedef struct {
    off_t __pos;
    mbstate_t __state;
} fpos_t;
typedef struct {
    off64_t __pos;
    mbstate_t __state;
} fpos64_t;

typedef struct _IO_FILE FILE;

#define _IOFBF	0
#define _IOLBF	1
#define _IONBF	2

extern char *__fgets_chk(char *, size_t, int, FILE *);
extern char *__fgets_unlocked_chk(char *, size_t, int, FILE *);
extern size_t __fpending(FILE *);
extern int __fprintf_chk(FILE *, int, const char *, ...);
extern int __printf_chk(int, const char *, ...);
extern int __snprintf_chk(char *, size_t, int, size_t, const char *, ...);
extern int __sprintf_chk(char *, int, size_t, const char *, ...);
extern int __vfprintf_chk(FILE *, int, const char *, va_list);
extern int __vprintf_chk(int, const char *, va_list);
extern int __vsnprintf_chk(char *, size_t, int, size_t, const char *,
			   va_list);
extern int __vsprintf_chk(char *, int, size_t, const char *, va_list);
extern char *const _sys_errlist[];
extern int asprintf(char **__ptr, const char *__fmt, ...);
extern void clearerr(FILE * __stream);
extern void clearerr_unlocked(FILE * __stream);
extern int dprintf(int __fd, const char *__fmt, ...);
extern int fclose(FILE * __stream);
extern FILE *fdopen(int __fd, const char *__modes);
extern int feof(FILE * __stream);
extern int feof_unlocked(FILE * __stream);
extern int ferror(FILE * __stream);
extern int ferror_unlocked(FILE * __stream);
extern int fflush(FILE * __stream);
extern int fflush_unlocked(FILE * __stream);
extern int fgetc(FILE * __stream);
extern int fgetc_unlocked(FILE * __stream);
extern int fgetpos(FILE * __stream, fpos_t * __pos);
extern int fgetpos64(FILE * __stream, fpos64_t * __pos);
extern char *fgets(char *__s, int __n, FILE * __stream);
extern char *fgets_unlocked(char *__s, int __n, FILE * __stream);
extern int fileno(FILE * __stream);
extern int fileno_unlocked(FILE * __stream);
extern void flockfile(FILE * __stream);
extern FILE *fmemopen(void *__s, size_t __len, const char *__modes);
extern FILE *fopen(const char *__filename, const char *__modes);
extern FILE *fopen64(const char *__filename, const char *__modes);
extern int fprintf(FILE * __stream, const char *__format, ...);
extern int fputc(int __c, FILE * __stream);
extern int fputc_unlocked(int __c, FILE * __stream);
extern int fputs(const char *__s, FILE * __stream);
extern int fputs_unlocked(const char *__s, FILE * __stream);
extern size_t fread(void *__ptr, size_t __size, size_t __n,
		    FILE * __stream);
extern size_t fread_unlocked(void *__ptr, size_t __size, size_t __n,
			     FILE * __stream);
extern FILE *freopen(const char *__filename, const char *__modes,
		     FILE * __stream);
extern FILE *freopen64(const char *__filename, const char *__modes,
		       FILE * __stream);
extern int fscanf(FILE * __stream, const char *__format, ...);
extern int fseek(FILE * __stream, long int __off, int __whence);
extern int fseeko(FILE * __stream, off_t __off, int __whence);
extern int fseeko64(FILE * __stream, loff_t __off, int __whence);
extern int fsetpos(FILE * __stream, const fpos_t * __pos);
extern int fsetpos64(FILE * __stream, const fpos64_t * __pos);
extern long int ftell(FILE * __stream);
extern off_t ftello(FILE * __stream);
extern loff_t ftello64(FILE * __stream);
extern int ftrylockfile(FILE * __stream);
extern void funlockfile(FILE * __stream);
extern size_t fwrite(const void *__ptr, size_t __size, size_t __n,
		     FILE * __s);
extern size_t fwrite_unlocked(const void *__ptr, size_t __size, size_t __n,
			      FILE * __stream);
extern int getc(FILE * __stream);
extern int getc_unlocked(FILE * __stream);
extern int getchar(void);
extern int getchar_unlocked(void);
extern ssize_t getdelim(char **__lineptr, size_t * __n, int __delimiter,
			FILE * __stream);
extern ssize_t getline(char **__lineptr, size_t * __n, FILE * __stream);
extern int getw(FILE * __stream);
extern FILE *open_memstream(char **__bufloc, size_t * __sizeloc);
extern int pclose(FILE * __stream);
extern void perror(const char *__s);
extern FILE *popen(const char *__command, const char *__modes);
extern int printf(const char *__format, ...);
extern int putc(int __c, FILE * __stream);
extern int putc_unlocked(int __c, FILE * __stream);
extern int putchar(int __c);
extern int putchar_unlocked(int __c);
extern int puts(const char *__s);
extern int putw(int __w, FILE * __stream);
extern int remove(const char *__filename);
extern int rename(const char *__old, const char *__new);
extern int renameat(int __oldfd, const char *__old, int __newfd,
		    const char *__new);
extern void rewind(FILE * __stream);
extern int scanf(const char *__format, ...);
extern void setbuf(FILE * __stream, char *__buf);
extern void setbuffer(FILE * __stream, char *__buf, size_t __size);
extern int setvbuf(FILE * __stream, char *__buf, int __modes, size_t __n);
extern int snprintf(char *__s, size_t __maxlen, const char *__format, ...);
extern int sprintf(char *__s, const char *__format, ...);
extern int sscanf(const char *__s, const char *__format, ...);
extern FILE *stderr;
extern FILE *stdin;
extern FILE *stdout;
extern char *tempnam(const char *__dir, const char *__pfx);
extern FILE *tmpfile(void);
extern FILE *tmpfile64(void);
extern char *tmpnam(char *__s);
extern int ungetc(int __c, FILE * __stream);
extern int vasprintf(char **__ptr, const char *__f, va_list __arg);
extern int vdprintf(int __fd, const char *__fmt, va_list __arg);
extern int vfprintf(FILE * __s, const char *__format, va_list __arg);
extern int vfscanf(FILE * __s, const char *__format, va_list __arg);
extern int vprintf(const char *__format, va_list __arg);
extern int vscanf(const char *__format, va_list __arg);
extern int vsnprintf(char *__s, size_t __maxlen, const char *__format,
		     va_list __arg);
extern int vsprintf(char *__s, const char *__format, va_list __arg);
extern int vsscanf(const char *__s, const char *__format, va_list __arg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7594"
>14.4.65. stdlib.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MB_CUR_MAX	(__ctype_get_mb_cur_max())
#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
#define RAND_MAX	2147483647

struct drand48_data {
    unsigned short __x[3];
    unsigned short __old_x[3];
    unsigned short __c;
    unsigned short __init;
    unsigned long long int __a;
};
typedef int (*__compar_fn_t) (const void *, const void *);
struct random_data {
    int32_t *fptr;		/* Front pointer. */
    int32_t *rptr;		/* Rear pointer. */
    int32_t *state;		/* Array of state values. */
    int rand_type;		/* Type of random number generator. */
    int rand_deg;		/* Degree of random number generator. */
    int rand_sep;		/* Distance between front and rear. */
    int32_t *end_ptr;		/* Pointer behind state table. */
};

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;
extern void _Exit(int __status);
extern size_t __ctype_get_mb_cur_max(void);
extern size_t __mbstowcs_chk(wchar_t *, const char *, size_t, size_t);
extern char *__realpath_chk(const char *, char *, size_t);
extern double __strtod_internal(const char *, char **, int);
extern float __strtof_internal(const char *, char **, int);
extern long int __strtol_internal(const char *, char **, int, int);
extern long double __strtold_internal(const char *, char **, int);
extern long long int __strtoll_internal(const char *, char **, int, int);
extern unsigned long int __strtoul_internal(const char *, char **, int,
					    int);
extern unsigned long long int __strtoull_internal(const char *, char **,
						  int, int);
extern size_t __wcstombs_chk(char *, const wchar_t *, size_t, size_t);
extern int __wctomb_chk(char *, wchar_t, size_t);
extern long int a64l(const char *__s);
extern void abort(void);
extern int abs(int __x);
extern int atexit(void (*__func) (void));
extern double atof(const char *__nptr);
extern int atoi(const char *__nptr);
extern long int atol(const char *__nptr);
extern long long int atoll(const char *__nptr);
extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
		     size_t __size, __compar_fn_t __compar);
extern void *calloc(size_t __nmemb, size_t __size);
extern div_t div(int __numer, int __denom);
extern double drand48(void);
extern int drand48_r(struct drand48_data *__buffer, double *__result);
extern char *ecvt(double __value, int __ndigit, int *__decpt, int *__sign);
extern char **environ;
extern double erand48(unsigned short __xsubi[3]);
extern int erand48_r(unsigned short __xsubi[3],
		     struct drand48_data *__buffer, double *__result);
extern void exit(int __status);
extern char *fcvt(double __value, int __ndigit, int *__decpt, int *__sign);
extern void free(void *__ptr);
extern char *gcvt(double __value, int __ndigit, char *__buf);
extern char *getenv(const char *__name);
extern int getloadavg(double __loadavg[], int __nelem);
extern int getsubopt(char **__optionp, char *const *__tokens,
		     char **__valuep);
extern int grantpt(int __fd);
extern char *initstate(unsigned int __seed, char *__statebuf,
		       size_t __statelen);
extern int initstate_r(unsigned int __seed, char *__statebuf,
		       size_t __statelen, struct random_data *__buf);
extern long int jrand48(unsigned short __xsubi[3]);
extern int jrand48_r(unsigned short __xsubi[3],
		     struct drand48_data *__buffer, long int *__result);
extern char *l64a(long int __n);
extern long int labs(long int __x);
extern void lcong48(unsigned short __param[7]);
extern int lcong48_r(unsigned short __param[7],
		     struct drand48_data *__buffer);
extern ldiv_t ldiv(long int __numer, long int __denom);
extern long long int llabs(long long int __x);
extern lldiv_t lldiv(long long int __numer, long long int __denom);
extern long int lrand48(void);
extern int lrand48_r(struct drand48_data *__buffer, long int *__result);
extern void *malloc(size_t __size);
extern int mblen(const char *__s, size_t __n);
extern size_t mbstowcs(wchar_t * __pwcs, const char *__s, size_t __n);
extern int mbtowc(wchar_t * __pwc, const char *__s, size_t __n);
extern char *mkdtemp(char *__template);
extern int mkstemp(char *__template);
extern int mkstemp64(char *__template);
extern char *mktemp(char *__template);
extern long int mrand48(void);
extern int mrand48_r(struct drand48_data *__buffer, long int *__result);
extern long int nrand48(unsigned short __xsubi[3]);
extern int nrand48_r(unsigned short __xsubi[3],
		     struct drand48_data *__buffer, long int *__result);
extern int posix_memalign(void **__memptr, size_t __alignment,
			  size_t __size);
extern int posix_openpt(int __oflag);
extern char *ptsname(int __fd);
extern int putenv(char *__string);
extern void qsort(void *__base, size_t __nmemb, size_t __size,
		  const __compar_fn_t __compar);
extern int rand(void);
extern int rand_r(unsigned int *__seed);
extern long int random(void);
extern int random_r(struct random_data *__buf, int32_t * __result);
extern void *realloc(void *__ptr, size_t __size);
extern char *realpath(const char *__name, char *__resolved);
extern unsigned short *seed48(unsigned short __seed16v[3]);
extern int seed48_r(unsigned short __seed16v[3],
		    struct drand48_data *__buffer);
extern int setenv(const char *__name, const char *__value, int __replace);
extern char *setstate(char *__statebuf);
extern int setstate_r(char *__statebuf, struct random_data *__buf);
extern void srand(unsigned int __seed);
extern void srand48(long int __seedval);
extern int srand48_r(long int __seedval, struct drand48_data *__buffer);
extern void srandom(unsigned int __seed);
extern int srandom_r(unsigned int __seed, struct random_data *__buf);
extern double strtod(const char *__nptr, char **__endptr);
extern float strtof(const char *__nptr, char **__endptr);
extern long int strtol(const char *__nptr, char **__endptr, int __base);
extern long double strtold(const char *__nptr, char **__endptr);
extern long long int strtoll(const char *__nptr, char **__endptr,
			     int __base);
extern long long int strtoq(const char *__nptr, char **__endptr,
			    int __base);
extern unsigned long int strtoul(const char *__nptr, char **__endptr,
				 int __base);
extern unsigned long long int strtoull(const char *__nptr, char **__endptr,
				       int __base);
extern unsigned long long int strtouq(const char *__nptr, char **__endptr,
				      int __base);
extern int system(const char *__command);
extern int unlockpt(int __fd);
extern int unsetenv(const char *__name);
extern size_t wcstombs(char *__s, const wchar_t * __pwcs, size_t __n);
extern int wctomb(char *__s, wchar_t __wchar);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7598"
>14.4.66. string.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define strerror_r __xpg_strerror_r

#define bzero(s,n)	memset(s,0,n)

extern void *__memcpy_chk(void *, const void *, size_t, size_t);
extern void *__memmove_chk(void *, const void *, size_t, size_t);
extern void *__mempcpy(void *__dest, const void *__src, size_t __n);
extern void *__mempcpy_chk(void *, const void *, size_t, size_t);
extern void *__memset_chk(void *, int, size_t, size_t);
extern char *__stpcpy(char *__dest, const char *__src);
extern char *__stpcpy_chk(char *, const char *, size_t);
extern char *__stpncpy_chk(char *, const char *, size_t, size_t);
extern char *__strcat_chk(char *, const char *, size_t);
extern char *__strcpy_chk(char *, const char *, size_t);
extern char *__strncat_chk(char *, const char *, size_t, size_t);
extern char *__strncpy_chk(char *, const char *, size_t, size_t);
extern char *__strtok_r(char *__s, const char *__delim, char **__save_ptr);
extern int __xpg_strerror_r(int, char *, size_t);
extern void *memccpy(void *__dest, const void *__src, int __c, size_t __n);
extern void *memchr(const void *__s, int __c, size_t __n);
extern int memcmp(const void *__s1, const void *__s2, size_t __n);
extern void *memcpy(void *__dest, const void *__src, size_t __n);
extern void *memmem(const void *__haystack, size_t __haystacklen,
		    const void *__needle, size_t __needlelen);
extern void *memmove(void *__dest, const void *__src, size_t __n);
extern void *memrchr(const void *__s, int __c, size_t __n);
extern void *memset(void *__s, int __c, size_t __n);
extern char *stpcpy(char *__dest, const char *__src);
extern char *stpncpy(char *__dest, const char *__src, size_t __n);
extern char *strcasestr(const char *__haystack, const char *__needle);
extern char *strcat(char *__dest, const char *__src);
extern char *strchr(const char *__s, int __c);
extern int strcmp(const char *__s1, const char *__s2);
extern int strcoll(const char *__s1, const char *__s2);
extern int strcoll_l(const char *s1, const char *s2, locale_t locale);
extern char *strcpy(char *__dest, const char *__src);
extern size_t strcspn(const char *__s, const char *__reject);
extern char *strdup(const char *__s);
extern char *strerror(int __errnum);
extern char *strerror_l(int errnum, locale_t locale);
extern size_t strlen(const char *__s);
extern char *strncat(char *__dest, const char *__src, size_t __n);
extern int strncmp(const char *__s1, const char *__s2, size_t __n);
extern char *strncpy(char *__dest, const char *__src, size_t __n);
extern char *strndup(const char *__string, size_t __n);
extern size_t strnlen(const char *__string, size_t __maxlen);
extern char *strpbrk(const char *__s, const char *__accept);
extern char *strrchr(const char *__s, int __c);
extern char *strsep(char **__stringp, const char *__delim);
extern char *strsignal(int __sig);
extern size_t strspn(const char *__s, const char *__accept);
extern char *strstr(const char *__haystack, const char *__needle);
extern char *strtok(char *__s, const char *__delim);
extern char *strtok_r(char *__s, const char *__delim, char **__save_ptr);
extern size_t strxfrm(char *__dest, const char *__src, size_t __n);
extern size_t strxfrm_l(char *s1, const char *s2, size_t n,
			locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7602"
>14.4.67. strings.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int bcmp(const void *__s1, const void *__s2, size_t __n);
extern void bcopy(const void *__src, void *__dest, size_t __n);
extern void bzero(void *__s, size_t __n);
extern int ffs(int __i);
extern char *index(const char *__s, int __c);
extern char *rindex(const char *__s, int __c);
extern int strcasecmp(const char *__s1, const char *__s2);
extern int strcasecmp_l(const char *s1, const char *s2, locale_t locale);
extern int strncasecmp(const char *__s1, const char *__s2, size_t __n);
extern int strncasecmp_l(const char *s1, const char *s2, size_t n,
			 locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7606"
>14.4.68. sys/epoll.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EPOLL_CTL_ADD	1	/* Add a file decriptor to the interface. */
#define EPOLL_CTL_DEL	2	/* Remove a file decriptor from the interface. */
#define EPOLL_CTL_MOD	3	/* Change file decriptor epoll_event structure. */
#define EPOLLIN	1
#define EPOLLPRI	2
#define EPOLLOUT	4
#define EPOLLERR	8
#define EPOLLHUP	16
#define EPOLLRDHUP	0x2000
#define EPOLLONESHOT	(1 &#60;&#60; 30)
#define EPOLLET	(1 &#60;&#60; 31)

typedef union epoll_data {
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;

struct epoll_event {
    uint32_t events;
    epoll_data_t data;
};
extern int epoll_create(int __size);
extern int epoll_ctl(int __epfd, int __op, int __fd,
		     struct epoll_event *__event);
extern int epoll_wait(int __epfd, struct epoll_event *__events,
		      int __maxevents, int __timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7610"
>14.4.69. sys/file.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LOCK_SH	1
#define LOCK_EX	2
#define LOCK_NB	4
#define LOCK_UN	8

extern int flock(int __fd, int __operation);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7614"
>14.4.70. sys/inotify.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IN_ACCESS	0x00000001
#define IN_MODIFY	0x00000002
#define IN_ATTRIB	0x00000004
#define IN_CLOSE_WRITE	0x00000008
#define IN_CLOSE_NOWRITE	0x00000010
#define IN_OPEN	0x00000020
#define IN_MOVED_FROM	0x00000040
#define IN_MOVED_TO	0x00000080
#define IN_CREATE	0x00000100
#define IN_DELETE	0x00000200
#define IN_DELETE_SELF	0x00000400
#define IN_MOVE_SELF	0x00000800
#define IN_UNMOUNT	0x00002000
#define IN_Q_OVERFLOW	0x00004000
#define IN_IGNORED	0x00008000
#define IN_ISDIR	0x40000000
#define IN_ONESHOT	0x80000000
#define IN_CLOSE	(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
#define IN_MOVE	(IN_MOVED_FROM | IN_MOVED_TO)
#define IN_ALL_EVENTS	 \
   (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
  IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_CREATE | \
 IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF)

struct inotify_event {
    int wd;
    uint32_t mask;
    uint32_t cookie;
    uint32_t len;
    char name[];
};
extern int inotify_add_watch(int __fd, const char *__name,
			     uint32_t __mask);
extern int inotify_init(void);
extern int inotify_rm_watch(int __fd, int __wd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7618"
>14.4.71. sys/ioctl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _IOC(dir,type,nr,size)	(((dir) &#60;&#60; _IOC_DIRSHIFT) | ((type) &#60;&#60; _IOC_TYPESHIFT) | ((nr) &#60;&#60; _IOC_NRSHIFT) | ((size) &#60;&#60; _IOC_SIZESHIFT))
#define _IOC_DIR(nr)	(((nr) &#62;&#62; _IOC_DIRSHIFT) &#38; _IOC_DIRMASK)
#define _IOC_NR(nr)	(((nr) &#62;&#62; _IOC_NRSHIFT) &#38; _IOC_NRMASK)
#define _IOC_SIZE(nr)	(((nr) &#62;&#62; _IOC_SIZESHIFT) &#38; _IOC_SIZEMASK)
#define _IOC_TYPE(nr)	(((nr) &#62;&#62; _IOC_TYPESHIFT) &#38; _IOC_TYPEMASK)
#define _IOC_DIRMASK	((1 &#60;&#60; _IOC_DIRBITS)-1)
#define _IOC_NRMASK	((1 &#60;&#60; _IOC_NRBITS)-1)
#define _IOC_SIZEMASK	((1 &#60;&#60; _IOC_SIZEBITS)-1)
#define _IOC_TYPEMASK	((1 &#60;&#60; _IOC_TYPEBITS)-1)
#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) &#60;&#60; _IOC_DIRSHIFT)
#define _IOC_TYPECHECK(t)	(sizeof(t))
#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
#define IOC_OUT	(_IOC_READ &#60;&#60; _IOC_DIRSHIFT)
#define IOCSIZE_MASK	(_IOC_SIZEMASK &#60;&#60; _IOC_SIZESHIFT)
#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
#define IOC_IN	(_IOC_WRITE &#60;&#60; _IOC_DIRSHIFT)
#define _IOC_NRSHIFT	0
#define _IOC_NONE	0U
#define _IOC_SIZEBITS	14
#define _IOC_WRITE	1U
#define _IOC_DIRBITS	2
#define _IOC_READ	2U
#define _IOC_NRBITS	8
#define _IOC_TYPEBITS	8
#define _IO(type,nr)	_IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))

struct winsize {
    unsigned short ws_row;	/* Rows, in characters. */
    unsigned short ws_col;	/* Columns, in characters. */
    unsigned short ws_xpixel;	/* Horizontal pixels. */
    unsigned short ws_ypixel;	/* Vertical pixels. */
};
extern int ioctl(int __fd, unsigned long int __request, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7622"
>14.4.72. sys/ipc.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPC_PRIVATE	((key_t)0)
#define IPC_RMID	0
#define IPC_CREAT	00001000
#define IPC_EXCL	00002000
#define IPC_NOWAIT	00004000
#define IPC_SET	1
#define IPC_STAT	2

extern key_t ftok(const char *__pathname, int __proj_id);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7626"
>14.4.73. sys/mman.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MAP_FAILED	((void*)-1)
#define POSIX_MADV_NORMAL	0
#define PROT_NONE	0x0
#define MAP_SHARED	0x01
#define MAP_PRIVATE	0x02
#define PROT_READ	0x1
#define MAP_FIXED	0x10
#define PROT_WRITE	0x2
#define MAP_ANONYMOUS	0x20
#define PROT_EXEC	0x4
#define MREMAP_MAYMOVE	1
#define MS_ASYNC	1
#define POSIX_MADV_RANDOM	1
#define MREMAP_FIXED	2
#define MS_INVALIDATE	2
#define POSIX_MADV_SEQUENTIAL	2
#define POSIX_MADV_WILLNEED	3
#define MS_SYNC	4
#define POSIX_MADV_DONTNEED	4
#define MAP_ANON	MAP_ANONYMOUS

extern int mlock(const void *__addr, size_t __len);
extern int mlockall(int __flags);
extern void *mmap(void *__addr, size_t __len, int __prot, int __flags,
		  int __fd, off_t __offset);
extern void *mmap64(void *__addr, size_t __len, int __prot, int __flags,
		    int __fd, off64_t __offset);
extern int mprotect(void *__addr, size_t __len, int __prot);
extern void *mremap(void *__addr, size_t __old_len, size_t __new_len,
		    int __flags, ...);
extern int msync(void *__addr, size_t __len, int __flags);
extern int munlock(const void *__addr, size_t __len);
extern int munlockall(void);
extern int munmap(void *__addr, size_t __len);
extern int posix_madvise(void *__addr, size_t __len, int __advice);
extern int shm_open(const char *__name, int __oflag, mode_t __mode);
extern int shm_unlink(const char *__name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7630"
>14.4.74. sys/msg.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MSG_NOERROR	010000

extern int msgctl(int __msqid, int __cmd, struct msqid_ds *__buf);
extern int msgget(key_t __key, int __msgflg);
extern ssize_t msgrcv(int __msqid, void *__msgp, size_t __msgsz,
		      long int __msgtyp, int __msgflg);
extern int msgsnd(int __msqid, const void *__msgp, size_t __msgsz,
		  int __msgflg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7634"
>14.4.75. sys/param.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NOFILE	256
#define MAXPATHLEN	4096</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7638"
>14.4.76. sys/poll.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define POLLIN	0x0001		/* There is data to read */
#define POLLPRI	0x0002		/* There is urgent data to read */
#define POLLOUT	0x0004		/* Writing now will not block */
#define POLLERR	0x0008		/* Error condition */
#define POLLHUP	0x0010		/* Hung up */
#define POLLNVAL	0x0020	/* Invalid request: fd not open */
#define POLLRDNORM	0x0040	/* Normal data may be read */
#define POLLRDBAND	0x0080	/* Priority data may be read */
#define POLLWRNORM	0x0100	/* Writing now will not block */
#define POLLWRBAND	0x0200	/* Priority data may be written */

struct pollfd {
    int fd;			/* File descriptor to poll. */
    short events;		/* Types of events poller cares about. */
    short revents;		/* Types of events that actually occurred. */
};
typedef unsigned long int nfds_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7642"
>14.4.77. sys/ptrace.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum __ptrace_setoptions {
    PTRACE_O_TRACESYSGOOD = 0x00000001,
    PTRACE_O_TRACEFORK = 0x00000002,
    PTRACE_O_TRACEVFORK = 0x00000004,
    PTRACE_O_TRACECLONE = 0x00000008,
    PTRACE_O_TRACEEXEC = 0x00000010,
    PTRACE_O_TRACEVFORKDONE = 0x00000020,
    PTRACE_O_TRACEEXIT = 0x00000040,
    PTRACE_O_MASK = 0x0000007f
};
enum __ptrace_eventcodes {
    PTRACE_EVENT_FORK = 1,
    PTRACE_EVENT_VFORK = 2,
    PTRACE_EVENT_CLONE = 3,
    PTRACE_EVENT_EXEC = 4,
    PTRACE_EVENT_VFORK_DONE = 5,
    PTRACE_EVENT_EXIT = 6
};
extern long int ptrace(enum __ptrace_request, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7646"
>14.4.78. sys/resource.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RUSAGE_CHILDREN	(-1)
#define RLIM_INFINITY	(~0UL)
#define RLIM_SAVED_CUR	-1
#define RLIM_SAVED_MAX	-1
#define RLIMIT_CPU	0
#define RUSAGE_SELF	0
#define RLIMIT_FSIZE	1
#define RLIMIT_LOCKS	10
#define RLIMIT_SIGPENDING	11
#define RLIMIT_MSGQUEUE	12
#define RLIMIT_NICE	13
#define RLIMIT_RTPRIO	14
#define RLIMIT_RTTIME	15
#define RLIM_NLIMITS	16
#define RLIMIT_DATA	2
#define RLIMIT_STACK	3
#define RLIMIT_CORE	4
#define RLIMIT_RSS	5
#define RLIMIT_NPROC	6
#define RLIMIT_NOFILE	7
#define RLIMIT_MEMLOCK	8
#define RLIMIT_AS	9

typedef unsigned long int rlim_t;
typedef unsigned long long int rlim64_t;
typedef int __rlimit_resource_t;

struct rlimit {
    rlim_t rlim_cur;		/* The current (soft) limit. */
    rlim_t rlim_max;		/* The hard limit. */
};
struct rlimit64 {
    rlim64_t rlim_cur;		/* The current (soft) limit. */
    rlim64_t rlim_max;		/* The hard limit. */
};

struct rusage {
    struct timeval ru_utime;	/* Total amount of user time used. */
    struct timeval ru_stime;	/* Total amount of system time used. */
    long int ru_maxrss;		/* Maximum resident set size (in kilobytes). */
    long int ru_ixrss;		/* Amount of sharing of text segment memory        with other p */
    long int ru_idrss;		/* Amount of data segment memory used (kilobyte-seconds). */
    long int ru_isrss;		/* Amount of stack memory used (kilobyte-seconds). */
    long int ru_minflt;		/* Number of soft page faults (i.e. those serviced by reclaimin */
    long int ru_majflt;		/* Number of hard page faults (i.e. those that required I/O). */
    long int ru_nswap;		/* Number of times a process was swapped out of physical memory */
    long int ru_inblock;	/* Number of input operations via the file system.  Note: This */
    long int ru_oublock;	/* Number of output operations via the file system. */
    long int ru_msgsnd;		/* Number of IPC messages sent. */
    long int ru_msgrcv;		/* Number of IPC messages received. */
    long int ru_nsignals;	/* Number of signals delivered. */
    long int ru_nvcsw;		/* Number of voluntary context switches, i.e. because the proce */
    long int ru_nivcsw;		/* Number of involuntary context switches, i.e. a higher priori */
};

enum __priority_which {
    PRIO_PROCESS = 0,		/* WHO is a process ID. */
    PRIO_PGRP = 1,		/* WHO is a process group ID. */
    PRIO_USER = 2		/* WHO is a user ID. */
};

#define PRIO_PGRP	PRIO_PGRP
#define PRIO_PROCESS	PRIO_PROCESS
#define PRIO_USER	PRIO_USER

typedef enum __priority_which __priority_which_t;
extern int getpriority(__priority_which_t __which, id_t __who);
extern int getrlimit(__rlimit_resource_t __resource,
		     struct rlimit *__rlimits);
extern int getrlimit64(__rlimit_resource_t __resource,
		       struct rlimit64 *__rlimits);
extern int getrusage(int __who, struct rusage *__usage);
extern int setpriority(__priority_which_t __which, id_t __who, int __prio);
extern int setrlimit(__rlimit_resource_t __resource,
		     const struct rlimit *__rlimits);
extern int setrlimit64(__rlimit_resource_t __resource,
		       const struct rlimit64 *__rlimits);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7650"
>14.4.79. sys/select.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FD_ISSET(d,set)	(((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]&#38;(1L&#60;&#60;((d)%(8*sizeof(long)))))!=0)
#define FD_CLR(d,set)	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]&#38;=~(1L&#60;&#60;((d)%(8*sizeof(long)))))
#define FD_SET(d,set)	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]|=(1L&#60;&#60;((d)%(8*sizeof(long)))))
#define NFDBITS	(8 * sizeof (long))
#define FD_SETSIZE	1024
#define FD_ZERO(fdsetp)	bzero(fdsetp, sizeof(*(fdsetp)))

typedef struct {
    unsigned long int fds_bits[FD_SETSIZE / NFDBITS];
} fd_set;
extern int pselect(int __nfds, fd_set * __readfds, fd_set * __writefds,
		   fd_set * __exceptfds, const struct timespec *__timeout,
		   const sigset_t * __sigmask);
extern int select(int __nfds, fd_set * __readfds, fd_set * __writefds,
		  fd_set * __exceptfds, struct timeval *__timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7654"
>14.4.80. sys/sem.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SEM_UNDO	0x1000
#define GETPID	11
#define GETVAL	12
#define GETALL	13
#define GETNCNT	14
#define GETZCNT	15
#define SETVAL	16
#define SETALL	17

struct sembuf {
    short sem_num;
    short sem_op;
    short sem_flg;
};
extern int semctl(int __semid, int __semnum, int __cmd, ...);
extern int semget(key_t __key, int __nsems, int __semflg);
extern int semop(int __semid, struct sembuf *__sops, size_t __nsops);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7658"
>14.4.81. sys/sendfile.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t sendfile(int __out_fd, int __in_fd, off_t * __offset,
			size_t __count);
extern ssize_t sendfile64(int __out_fd, int __in_fd, off64_t * __offset,
			  size_t __count);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7662"
>14.4.82. sys/shm.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SHM_RDONLY	010000
#define SHM_W	0200
#define SHM_RND	020000
#define SHM_R	0400
#define SHM_REMAP	040000
#define SHM_LOCK	11
#define SHM_UNLOCK	12

extern int __getpagesize(void);
extern void *shmat(int __shmid, const void *__shmaddr, int __shmflg);
extern int shmctl(int __shmid, int __cmd, struct shmid_ds *__buf);
extern int shmdt(const void *__shmaddr);
extern int shmget(key_t __key, size_t __size, int __shmflg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7666"
>14.4.83. sys/socket.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CMSG_FIRSTHDR(msg)	((size_t) (msg)-&#62;msg_controllen &#62;= sizeof(struct cmsghdr) ? (struct cmsghdr *)(msg)-&#62;msg_control : (struct cmsghdr *) NULL)
#define CMSG_LEN(len)	(CMSG_ALIGN(sizeof(struct cmsghdr))+(len))
#define SCM_RIGHTS	0x01
#define SOL_SOCKET	1
#define SOMAXCONN	128
#define SOL_RAW	255
#define CMSG_ALIGN(len)	\
	(((len)+sizeof(size_t)-1)&#38;(size_t)~(sizeof(size_t)-1))
#define CMSG_DATA(cmsg)	\
	((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr)))
#define CMSG_SPACE(len)	\
	(CMSG_ALIGN(sizeof(struct cmsghdr))+CMSG_ALIGN(len))
#define CMSG_NXTHDR(mhdr,cmsg)	\
        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \
         (((u_char *)(cmsg) + CMSG_ALIGN((cmsg)-&#62;cmsg_len) \
                            + CMSG_ALIGN(sizeof(struct cmsghdr)) &#62; \
           (u_char *)((mhdr)-&#62;msg_control) + (mhdr)-&#62;msg_controllen) ? \
          (struct cmsghdr *)NULL : \
          (struct cmsghdr *)((u_char *)(cmsg) + CMSG_ALIGN((cmsg)-&#62;cmsg_len))))

struct linger {
    int l_onoff;
    int l_linger;
};
struct cmsghdr {
    size_t cmsg_len;
    int cmsg_level;
    int cmsg_type;
};
struct iovec {
    void *iov_base;
    size_t iov_len;
};

typedef unsigned short sa_family_t;
typedef unsigned int socklen_t;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};
struct sockaddr_storage {
    sa_family_t ss_family;
    __ss_aligntype __ss_align;
    char __ss_padding[(128 - (2 * sizeof(__ss_aligntype)))];
};

struct msghdr {
    void *msg_name;
    int msg_namelen;
    struct iovec *msg_iov;
    size_t msg_iovlen;
    void *msg_control;
    size_t msg_controllen;
    unsigned int msg_flags;
};

#define AF_UNSPEC	0
#define AF_UNIX	1
#define AF_INET6	10
#define AF_INET	2

#define PF_INET	AF_INET
#define PF_INET6	AF_INET6
#define PF_UNIX	AF_UNIX
#define PF_UNSPEC	AF_UNSPEC

#define SOCK_STREAM	1
#define SOCK_PACKET	10
#define SOCK_DGRAM	2
#define SOCK_RAW	3
#define SOCK_RDM	4
#define SOCK_SEQPACKET	5

#define SO_DEBUG	1
#define SO_OOBINLINE	10
#define SO_NO_CHECK	11
#define SO_PRIORITY	12
#define SO_LINGER	13
#define SO_BSDCOMPAT	14
#define SO_REUSEADDR	2
#define SO_TYPE	3
#define SO_ACCEPTCONN	30
#define SO_ERROR	4
#define SO_DONTROUTE	5
#define SO_BROADCAST	6
#define SO_SNDBUF	7
#define SO_RCVBUF	8
#define SO_KEEPALIVE	9

#define SIOCGIFNAME	0x8910
#define SIOCGIFCONF	0x8912
#define SIOCGIFFLAGS	0x8913
#define SIOCGIFADDR	0x8915
#define SIOCGIFDSTADDR	0x8917
#define SIOCGIFBRDADDR	0x8919
#define SIOCGIFNETMASK	0x891b
#define SIOCGIFMTU	0x8921
#define SIOCGIFHWADDR	0x8927

#define SHUT_RD	0
#define SHUT_WR	1
#define SHUT_RDWR	2

#define MSG_WAITALL	0x100
#define MSG_TRUNC	0x20
#define MSG_NOSIGNAL	0x4000
#define MSG_EOR	0x80
#define MSG_OOB	1
#define MSG_PEEK	2
#define MSG_DONTROUTE	4
#define MSG_CTRUNC	8

extern ssize_t __recv_chk(int, void *, size_t, size_t, int);
extern ssize_t __recvfrom_chk(int, void *, size_t, size_t, int,
			      struct sockaddr *, socklen_t *);
extern int accept(int __fd, struct sockaddr *__addr,
		  socklen_t * __addr_len);
extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len);
extern int connect(int __fd, const struct sockaddr *__addr,
		   socklen_t __len);
extern int getnameinfo(const struct sockaddr *__sa, socklen_t __salen,
		       char *__host, socklen_t __hostlen, char *__serv,
		       socklen_t __servlen, unsigned int __flags);
extern int getpeername(int __fd, struct sockaddr *__addr,
		       socklen_t * __len);
extern int getsockname(int __fd, struct sockaddr *__addr,
		       socklen_t * __len);
extern int getsockopt(int __fd, int __level, int __optname, void *__optval,
		      socklen_t * __optlen);
extern int listen(int __fd, int __n);
extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags);
extern ssize_t recvfrom(int __fd, void *__buf, size_t __n, int __flags,
			struct sockaddr *__addr, socklen_t * __addr_len);
extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags);
extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags);
extern ssize_t sendmsg(int __fd, const struct msghdr *__message,
		       int __flags);
extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags,
		      const struct sockaddr *__addr, socklen_t __addr_len);
extern int setsockopt(int __fd, int __level, int __optname,
		      const void *__optval, socklen_t __optlen);
extern int shutdown(int __fd, int __how);
extern int sockatmark(int __fd);
extern int socket(int __domain, int __type, int __protocol);
extern int socketpair(int __domain, int __type, int __protocol,
		      int __fds[2]);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7670"
>14.4.84. sys/stat.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define S_ISBLK(m)	(((m)&#38;S_IFMT)==S_IFBLK)
#define S_ISCHR(m)	(((m)&#38;S_IFMT)==S_IFCHR)
#define S_ISDIR(m)	(((m)&#38;S_IFMT)==S_IFDIR)
#define S_ISFIFO(m)	(((m)&#38;S_IFMT)==S_IFIFO)
#define S_ISLNK(m)	(((m)&#38;S_IFMT)==S_IFLNK)
#define S_ISREG(m)	(((m)&#38;S_IFMT)==S_IFREG)
#define S_ISSOCK(m)	(((m)&#38;S_IFMT)==S_IFSOCK)
#define UTIME_NOW	((1l &#60;&#60; 30) - 1l)
#define UTIME_OMIT	((1l &#60;&#60; 30) - 2l)
#define S_TYPEISMQ(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_TYPEISSEM(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_TYPEISSHM(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_IRWXU	(S_IREAD|S_IWRITE|S_IEXEC)
#define S_IROTH	(S_IRGRP&#62;&#62;3)
#define S_IRGRP	(S_IRUSR&#62;&#62;3)
#define S_IRWXO	(S_IRWXG&#62;&#62;3)
#define S_IRWXG	(S_IRWXU&#62;&#62;3)
#define S_IWOTH	(S_IWGRP&#62;&#62;3)
#define S_IWGRP	(S_IWUSR&#62;&#62;3)
#define S_IXOTH	(S_IXGRP&#62;&#62;3)
#define S_IXGRP	(S_IXUSR&#62;&#62;3)
#define S_ISVTX	01000
#define S_IXUSR	0x0040
#define S_IWUSR	0x0080
#define S_IRUSR	0x0100
#define S_ISGID	0x0400
#define S_ISUID	0x0800
#define S_IFIFO	0x1000
#define S_IFCHR	0x2000
#define S_IFDIR	0x4000
#define S_IFBLK	0x6000
#define S_IFREG	0x8000
#define S_IFLNK	0xa000
#define S_IFSOCK	0xc000
#define S_IFMT	0xf000
#define st_atime	st_atim.tv_sec
#define st_ctime	st_ctim.tv_sec
#define st_mtime	st_mtim.tv_sec
#define S_IREAD	S_IRUSR
#define S_IWRITE	S_IWUSR
#define S_IEXEC	S_IXUSR

extern int __fxstat(int __ver, int __fildes, struct stat *__stat_buf);
extern int __fxstat64(int __ver, int __fildes, struct stat64 *__stat_buf);
extern int __fxstatat(int __ver, int __fildes, const char *__filename,
		      struct stat *__stat_buf, int __flag);
extern int __fxstatat64(int __ver, int __fildes, const char *__filename,
			struct stat64 *__stat_buf, int __flag);
extern int __lxstat(int __ver, const char *__filename,
		    struct stat *__stat_buf);
extern int __lxstat64(int __ver, const char *__filename,
		      struct stat64 *__stat_buf);
extern int __xmknod(int __ver, const char *__path, mode_t __mode,
		    dev_t * __dev);
extern int __xmknodat(int __ver, int __fd, const char *__path,
		      mode_t __mode, dev_t * __dev);
extern int __xstat(int __ver, const char *__filename,
		   struct stat *__stat_buf);
extern int __xstat64(int __ver, const char *__filename,
		     struct stat64 *__stat_buf);
extern int chmod(const char *__file, mode_t __mode);
extern int fchmod(int __fd, mode_t __mode);
extern int fchmodat(int __fd, const char *__file, mode_t mode, int __flag);
extern int fstat(int __fd, struct stat *__buf);
extern int fstat64(int __fd, struct stat64 *__buf);
extern int fstatat(int __fd, const char *__file, struct stat *__buf,
		   int __flag);
extern int fstatat64(int __fd, const char *__file, struct stat64 *__buf,
		     int __flag);
extern int futimens(int fd, const struct timespec times[2]);
extern int lstat(const char *__file, struct stat *__buf);
extern int lstat64(const char *__file, struct stat64 *__buf);
extern int mkdir(const char *__path, mode_t __mode);
extern int mkdirat(int __fd, const char *__path, mode_t __mode);
extern int mkfifo(const char *__path, mode_t __mode);
extern int mkfifoat(int __fd, const char *__path, mode_t __mode);
extern int mknod(const char *__path, mode_t __mode, dev_t __dev);
extern int mknodat(int __fd, const char *__path, mode_t __mode,
		   dev_t __dev);
extern int stat(const char *__file, struct stat *__buf);
extern int stat64(const char *__file, struct stat64 *__buf);
extern mode_t umask(mode_t __mask);
extern int utimensat(int fd, const char *path,
		     const struct timespec times[2], int flags);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7674"
>14.4.85. sys/statfs.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NFS_SUPER_MAGIC	0x6969

extern int fstatfs(int __fildes, struct statfs *__buf);
extern int fstatfs64(int __fildes, struct statfs64 *__buf);
extern int statfs(const char *__file, struct statfs *__buf);
extern int statfs64(const char *__file, struct statfs64 *__buf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7678"
>14.4.86. sys/statvfs.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int fstatvfs(int __fildes, struct statvfs *__buf);
extern int fstatvfs64(int __fildes, struct statvfs64 *__buf);
extern int statvfs(const char *__file, struct statvfs *__buf);
extern int statvfs64(const char *__file, struct statvfs64 *__buf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7682"
>14.4.87. sys/sysinfo.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct sysinfo {
    long int uptime;		/* Seconds since boot */
    unsigned long int loads[3];	/* 1, 5, and 15 minute load averages */
    unsigned long int totalram;	/* Total usable main memory size */
    unsigned long int freeram;	/* Available memory size */
    unsigned long int sharedram;	/* Amount of shared memory */
    unsigned long int bufferram;	/* Memory used by buffers */
    unsigned long int totalswap;	/* Total swap space size */
    unsigned long int freeswap;	/* Swap space still available */
    unsigned short procs;	/* Number of current processes */
    unsigned short pad;		/* Padding for m68k */
    unsigned long int totalhigh;	/* Total high memory size */
    unsigned long int freehigh;	/* Available high memory size */
    unsigned int mem_unit;	/* Memory unit size in bytes */
    char _f[20 - 2 * sizeof(long) - sizeof(int)];	/* Padding for libc5 */
};
extern int sysinfo(struct sysinfo *info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7686"
>14.4.88. sys/time.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ITIMER_REAL	0
#define ITIMER_VIRTUAL	1
#define ITIMER_PROF	2

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef int __itimer_which_t;

struct itimerval {
    struct timeval it_interval;
    struct timeval it_value;
};
extern int adjtime(const struct timeval *__delta,
		   struct timeval *__olddelta);
extern int futimes(int fd, const struct timeval tv[2]);
extern int getitimer(__itimer_which_t __which, struct itimerval *__value);
extern int gettimeofday(struct timeval *__tv, struct timezone *__tz);
extern int lutimes(const char *filename, const struct timeval tv[2]);
extern int setitimer(__itimer_which_t __which,
		     const struct itimerval *__new,
		     struct itimerval *__old);
extern int utimes(const char *__file, const struct timeval *__tvp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7690"
>14.4.89. sys/timeb.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct timeb {
    time_t time;		/* Seconds since epoch, as from time. */
    unsigned short millitm;	/* Additional milliseconds. */
    short timezone;		/* Minutes west of GMT. */
    short dstflag;		/* Nonzero if Daylight Savings Time used. */
};
extern int ftime(struct timeb *__timebuf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7694"
>14.4.90. sys/times.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct tms {
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
};
extern clock_t times(struct tms *__buffer);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7698"
>14.4.91. sys/types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	1
#endif

typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long int u_int64_t;
typedef unsigned int uid_t;
typedef int pid_t;
typedef long int off_t;
typedef long long int off64_t;
typedef int key_t;
typedef long int suseconds_t;
typedef unsigned int u_int;
typedef struct {
    int __val[2];
} fsid_t;
typedef unsigned int useconds_t;
typedef long int blksize_t;
typedef long int fd_mask;
typedef void *timer_t;
typedef int clockid_t;

typedef unsigned int id_t;

typedef unsigned long long int ino64_t;
typedef long long int loff_t;
typedef long int blkcnt_t;
typedef unsigned long int fsblkcnt_t;
typedef unsigned long int fsfilcnt_t;
typedef long long int blkcnt64_t;
typedef unsigned long long int fsblkcnt64_t;
typedef unsigned long long int fsfilcnt64_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned long int u_long;

typedef unsigned long int ino_t;
typedef unsigned int gid_t;
typedef unsigned long long int dev_t;
typedef unsigned int mode_t;
typedef unsigned long int nlink_t;
typedef char *caddr_t;

typedef long int clock_t;
typedef long int time_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7702"
>14.4.92. sys/uio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t readv(int __fd, const struct iovec *__iovec, int __count);
extern ssize_t writev(int __fd, const struct iovec *__iovec, int __count);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7706"
>14.4.93. sys/un.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct sockaddr_un {
    sa_family_t sun_family;	/* AF_UNIX */
    char sun_path[108];
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7710"
>14.4.94. sys/utsname.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SYS_NMLN	65

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};
extern int uname(struct utsname *__name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7714"
>14.4.95. sys/wait.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define WIFSIGNALED(status)	(!WIFSTOPPED(status) &#38;&#38; !WIFEXITED(status))
#define WIFSTOPPED(status)	(((status) &#38; 0xff) == 0x7f)
#define WEXITSTATUS(status)	(((status) &#38; 0xff00) &#62;&#62; 8)
#define WTERMSIG(status)	((status) &#38; 0x7f)
#define WCOREDUMP(status)	((status) &#38; 0x80)
#define WIFEXITED(status)	(WTERMSIG(status) == 0)
#define WNOHANG	0x00000001
#define WUNTRACED	0x00000002
#define WCOREFLAG	0x80
#define WSTOPSIG(status)	WEXITSTATUS(status)

typedef enum {
    P_ALL,
    P_PID,
    P_PGID
} idtype_t;
extern pid_t wait(int *__stat_loc);
extern pid_t wait4(pid_t __pid, int *__stat_loc, int __options,
		   struct rusage *__usage);
extern int waitid(idtype_t __idtype, id_t __id, siginfo_t * __infop,
		  int __options);
extern pid_t waitpid(pid_t __pid, int *__stat_loc, int __options);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7718"
>14.4.96. sysexits.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EX_OK	0		/* successful termination  */
#define EX_USAGE	64	/* command line usage error  */
#define EX__BASE	64	/* base value for error messages  */
#define EX_DATAERR	65	/* data format error  */
#define EX_NOINPUT	66	/* cannot open input  */
#define EX_NOUSER	67	/* addressee unknown  */
#define EX_NOHOST	68	/* host name unknown  */
#define EX_UNAVAILABLE	69	/* service unavailable  */
#define EX_SOFTWARE	70	/* internal software error  */
#define EX_OSERR	71	/* system error (e.g., cannot fork)  */
#define EX_OSFILE	72	/* critical OS file missing  */
#define EX_CANTCREAT	73	/* cannot create (user) output file  */
#define EX_IOERR	74	/* input/output error  */
#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry  */
#define EX_PROTOCOL	76	/* remote error in protocol  */
#define EX_NOPERM	77	/* permission denied  */
#define EX_CONFIG	78	/* configuration error  */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7722"
>14.4.97. syslog.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LOG_MAKEPRI(fac, pri)	(((fac) &#60;&#60; 3) | (pri))
#define LOG_PRI(p)	((p) &#38; LOG_PRIMASK)	/* extract priority */
#define LOG_EMERG	0	/* system is unusable */
#define LOG_PRIMASK	0x07	/* mask to extract priority part */
#define LOG_ALERT	1	/* action must be taken immediately */
#define LOG_CRIT	2	/* critical conditions */
#define LOG_ERR	3		/* error conditions */
#define LOG_WARNING	4	/* warning conditions */
#define LOG_NOTICE	5	/* normal but significant condition */
#define LOG_INFO	6	/* informational */
#define LOG_DEBUG	7	/* debug-level messages */

#define LOG_FAC(p)	(((p) &#38; LOG_FACMASK) &#62;&#62; 3)	/* facility of pri */
#define LOG_KERN	(0&#60;&#60;3)	/* kernel messages */
#define LOG_AUTHPRIV	(10&#60;&#60;3)	/* security/authorization messages (private) */
#define LOG_FTP	(11&#60;&#60;3)		/* ftp daemon */
#define LOG_USER	(1&#60;&#60;3)	/* random user-level messages */
#define LOG_MAIL	(2&#60;&#60;3)	/* mail system */
#define LOG_DAEMON	(3&#60;&#60;3)	/* system daemons */
#define LOG_AUTH	(4&#60;&#60;3)	/* security/authorization messages */
#define LOG_SYSLOG	(5&#60;&#60;3)	/* messages generated internally by syslogd */
#define LOG_LPR	(6&#60;&#60;3)		/* line printer subsystem */
#define LOG_NEWS	(7&#60;&#60;3)	/* network news subsystem */
#define LOG_UUCP	(8&#60;&#60;3)	/* UUCP subsystem */
#define LOG_CRON	(9&#60;&#60;3)	/* clock daemon */
#define LOG_FACMASK	0x03f8	/* mask to extract facility part */

#define LOG_LOCAL0	(16&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL1	(17&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL2	(18&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL3	(19&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL4	(20&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL5	(21&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL6	(22&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL7	(23&#60;&#60;3)	/* reserved for local use */

#define LOG_UPTO(pri)	((1 &#60;&#60; ((pri)+1)) - 1)	/* all priorities through pri */
#define LOG_MASK(pri)	(1 &#60;&#60; (pri))	/* mask for one priority */

#define LOG_PID	0x01		/* log the pid with each message */
#define LOG_CONS	0x02	/* log on the console if errors in sending */
#define LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
#define LOG_NDELAY	0x08	/* don't delay open */
#define LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
#define LOG_PERROR	0x20	/* log to stderr as well */

extern void __syslog_chk(int, int, const char *, ...);
extern void __vsyslog_chk(int, int, const char *, va_list);
extern void closelog(void);
extern void openlog(const char *__ident, int __option, int __facility);
extern int setlogmask(int __mask);
extern void syslog(int __pri, const char *__fmt, ...);
extern void vsyslog(int __pri, const char *__fmt, va_list __ap);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7726"
>14.4.98. tar.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define REGTYPE	'0'
#define LNKTYPE	'1'
#define SYMTYPE	'2'
#define CHRTYPE	'3'
#define BLKTYPE	'4'
#define DIRTYPE	'5'
#define FIFOTYPE	'6'
#define CONTTYPE	'7'
#define AREGTYPE	'\0'
#define TVERSION	"00"
#define TOEXEC	00001
#define TOWRITE	00002
#define TOREAD	00004
#define TGEXEC	00010
#define TGWRITE	00020
#define TGREAD	00040
#define TUEXEC	00100
#define TUWRITE	00200
#define TUREAD	00400
#define TSVTX	01000
#define TSGID	02000
#define TSUID	04000
#define TVERSLEN	2
#define TMAGLEN	6
#define TMAGIC	"ustar"</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7730"
>14.4.99. termios.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define TCIFLUSH	0
#define TCOOFF	0
#define TCSANOW	0
#define BS0	0000000
#define CR0	0000000
#define FF0	0000000
#define NL0	0000000
#define TAB0	0000000
#define VT0	0000000
#define OPOST	0000001
#define OCRNL	0000010
#define ONOCR	0000020
#define ONLRET	0000040
#define OFILL	0000100
#define OFDEL	0000200
#define NL1	0000400
#define TCOFLUSH	1
#define TCOON	1
#define TCSADRAIN	1
#define TCIOFF	2
#define TCIOFLUSH	2
#define TCSAFLUSH	2
#define TCION	3

typedef unsigned int speed_t;
typedef unsigned char cc_t;
typedef unsigned int tcflag_t;

#define NCCS	32

struct termios {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;		/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
};

#define VINTR	0
#define VQUIT	1
#define VLNEXT	15
#define VERASE	2
#define VKILL	3
#define VEOF	4

#define IGNBRK	0000001
#define BRKINT	0000002
#define IGNPAR	0000004
#define PARMRK	0000010
#define INPCK	0000020
#define ISTRIP	0000040
#define INLCR	0000100
#define IGNCR	0000200
#define ICRNL	0000400
#define IXANY	0004000
#define IMAXBEL	0020000

#define CS5	0000000

#define ECHO	0000010

#define B0	0000000
#define B50	0000001
#define B75	0000002
#define B110	0000003
#define B134	0000004
#define B150	0000005
#define B200	0000006
#define B300	0000007
#define B600	0000010
#define B1200	0000011
#define B1800	0000012
#define B2400	0000013
#define B4800	0000014
#define B9600	0000015
#define B19200	0000016
#define B38400	0000017

extern speed_t cfgetispeed(const struct termios *__termios_p);
extern speed_t cfgetospeed(const struct termios *__termios_p);
extern void cfmakeraw(struct termios *__termios_p);
extern int cfsetispeed(struct termios *__termios_p, speed_t __speed);
extern int cfsetospeed(struct termios *__termios_p, speed_t __speed);
extern int cfsetspeed(struct termios *__termios_p, speed_t __speed);
extern int tcdrain(int __fd);
extern int tcflow(int __fd, int __action);
extern int tcflush(int __fd, int __queue_selector);
extern int tcgetattr(int __fd, struct termios *__termios_p);
extern pid_t tcgetsid(int __fd);
extern int tcsendbreak(int __fd, int __duration);
extern int tcsetattr(int __fd, int __optional_actions,
		     const struct termios *__termios_p);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7734"
>14.4.100. time.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CLK_TCK	((clock_t)sysconf(2))
#define timerclear(tvp)	((tvp)-&#62;tv_sec = (tvp)-&#62;tv_usec = 0)
#define timerisset(tvp)	((tvp)-&#62;tv_sec || (tvp)-&#62;tv_usec)
#define CLOCK_REALTIME	0
#define CLOCK_MONOTONIC	1
#define TIMER_ABSTIME	1
#define CLOCKS_PER_SEC	1000000l
#define CLOCK_PROCESS_CPUTIME_ID	2
#define CLOCK_THREAD_CPUTIME_ID	3
#define timeradd(a,b,result)	\
  do { \
    (result)-&#62;tv_sec = (a)-&#62;tv_sec + (b)-&#62;tv_sec; \
    (result)-&#62;tv_usec = (a)-&#62;tv_usec + (b)-&#62;tv_usec; \
    if ((result)-&#62;tv_usec &#62;= 1000000) \
      { \
        ++(result)-&#62;tv_sec; \
        (result)-&#62;tv_usec -= 1000000; \
      } \
  } while (0)
#define timersub(a,b,result)	\
  do { \
    (result)-&#62;tv_sec = (a)-&#62;tv_sec - (b)-&#62;tv_sec; \
    (result)-&#62;tv_usec = (a)-&#62;tv_usec - (b)-&#62;tv_usec; \
    if ((result)-&#62;tv_usec &#60; 0) { \
      --(result)-&#62;tv_sec; \
      (result)-&#62;tv_usec += 1000000; \
    } \
  } while (0)
#define timercmp(a,b,CMP)	\
 (((a)-&#62;tv_sec == (b)-&#62;tv_sec) ? \
  ((a)-&#62;tv_usec CMP (b)-&#62;tv_usec) : \
  ((a)-&#62;tv_sec CMP (b)-&#62;tv_sec))

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    char *tm_zone;
};

struct timespec {
    time_t tv_sec;
    long int tv_nsec;
};

struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
extern int __daylight;
extern long int __timezone;
extern char *__tzname[];
extern char *asctime(const struct tm *__tp);
extern char *asctime_r(const struct tm *__tp, char *__buf);
extern clock_t clock(void);
extern int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id);
extern int clock_getres(clockid_t __clock_id, struct timespec *__res);
extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp);
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
			   const struct timespec *__req,
			   struct timespec *__rem);
extern int clock_settime(clockid_t __clock_id,
			 const struct timespec *__tp);
extern char *ctime(const time_t * __timer);
extern char *ctime_r(const time_t * __timer, char *__buf);
extern int daylight;
extern double difftime(time_t __time1, time_t __time0);
extern struct tm *getdate(const char *__string);
extern int getdate_err;
extern struct tm *gmtime(const time_t * __timer);
extern struct tm *gmtime_r(const time_t * __timer, struct tm *__tp);
extern struct tm *localtime(const time_t * __timer);
extern struct tm *localtime_r(const time_t * __timer, struct tm *__tp);
extern time_t mktime(struct tm *__tp);
extern int nanosleep(const struct timespec *__requested_time,
		     struct timespec *__remaining);
extern int stime(const time_t * __when);
extern size_t strftime(char *__s, size_t __maxsize, const char *__format,
		       const struct tm *__tp);
extern size_t strftime_l(char *s, size_t maxsize, const char *format,
			 const struct tm *timeptr, locale_t locale);
extern char *strptime(const char *__s, const char *__fmt, struct tm *__tp);
extern time_t time(time_t * __timer);
extern int timer_create(clockid_t __clock_id, struct sigevent *__evp,
			timer_t * __timerid);
extern int timer_delete(timer_t __timerid);
extern int timer_getoverrun(timer_t __timerid);
extern int timer_gettime(timer_t __timerid, struct itimerspec *__value);
extern int timer_settime(timer_t __timerid, int __flags,
			 const struct itimerspec *__value,
			 struct itimerspec *__ovalue);
extern long int timezone;
extern char *tzname[];
extern void tzset(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7738"
>14.4.101. ucontext.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int getcontext(ucontext_t * __ucp);
extern void makecontext(ucontext_t * __ucp, void (*__func) (void),
			int __argc, ...);
extern int setcontext(const struct ucontext *__ucp);
extern int swapcontext(ucontext_t * __oucp, const struct ucontext *__ucp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7742"
>14.4.102. ulimit.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UL_GETFSIZE	1
#define UL_SETFSIZE	2

extern long int ulimit(int __cmd, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7746"
>14.4.103. unistd.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#ifndef SEEK_SET
#define SEEK_SET	0
#endif
#define STDIN_FILENO	0
#ifndef SEEK_CUR
#define SEEK_CUR	1
#endif
#define STDOUT_FILENO	1
#ifndef SEEK_END
#define SEEK_END	2
#endif
#define STDERR_FILENO	2

#define F_OK	0
#define X_OK	1
#define W_OK	2
#define R_OK	4

#define _POSIX_VDISABLE	'\0'
#define _POSIX_ASYNC_IO	0
#define _POSIX_CHOWN_RESTRICTED	1
#define _POSIX_JOB_CONTROL	1
#define _POSIX_NO_TRUNC	1
#define _POSIX_SHELL	1
#define _POSIX2_CHAR_TERM	200809L
#define _POSIX2_C_BIND	200809L
#define _POSIX2_LOCALEDEF	200809L
#define _POSIX2_VERSION	200809L
#define _POSIX_ADVISORY_INFO	200809L
#define _POSIX_BARRIERS	200809L
#define _POSIX_CLOCK_SELECTION	200809L
#define _POSIX_FSYNC	200809L
#define _POSIX_IPV6	200809L
#define _POSIX_MAPPED_FILES	200809L
#define _POSIX_MEMLOCK	200809L
#define _POSIX_MEMLOCK_RANGE	200809L
#define _POSIX_MEMORY_PROTECTION	200809L
#define _POSIX_MESSAGE_PASSING	200809L
#define _POSIX_PRIORITIZED_IO	200809L
#define _POSIX_PRIORITY_SCHEDULING	200809L
#define _POSIX_RAW_SOCKETS	200809L
#define _POSIX_READER_WRITER_LOCKS	200809L
#define _POSIX_REALTIME_SIGNALS	200809L
#define _POSIX_SEMAPHORES	200809L
#define _POSIX_SHARED_MEMORY_OBJECTS	200809L
#define _POSIX_SPAWN	200809L
#define _POSIX_SPIN_LOCKS	200809L
#define _POSIX_SYNCHRONIZED_IO	200809L
#define _POSIX_THREADS	200809L
#define _POSIX_THREAD_ATTR_STACKADDR	200809L
#define _POSIX_THREAD_ATTR_STACKSIZE	200809L
#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
#define _POSIX_THREAD_PRIO_INHERIT	200809L
#define _POSIX_THREAD_PRIO_PROTECT	200809L
#define _POSIX_THREAD_PROCESS_SHARED	200809L
#define _POSIX_THREAD_ROBUST_PRIO_INHERIT	200809L
#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
#define _POSIX_TIMEOUTS	200809L
#define _POSIX_TIMERS	200809L
#define _POSIX_VERSION	200809L

#define _PC_LINK_MAX	0
#define _PC_MAX_CANON	1
#define _PC_ASYNC_IO	10
#define _PC_PRIO_IO	11
#define _PC_FILESIZEBITS	13
#define _PC_REC_INCR_XFER_SIZE	14
#define _PC_REC_MIN_XFER_SIZE	16
#define _PC_REC_XFER_ALIGN	17
#define _PC_ALLOC_SIZE_MIN	18
#define _PC_MAX_INPUT	2
#define _PC_2_SYMLINKS	20
#define _PC_NAME_MAX	3
#define _PC_PATH_MAX	4
#define _PC_PIPE_BUF	5
#define _PC_CHOWN_RESTRICTED	6
#define _PC_NO_TRUNC	7
#define _PC_VDISABLE	8
#define _PC_SYNC_IO	9

#define _SC_ARG_MAX	0
#define _SC_CHILD_MAX	1
#define _SC_PRIORITY_SCHEDULING	10
#define _SC_XOPEN_XPG4	100
#define _SC_CHAR_BIT	101
#define _SC_CHAR_MAX	102
#define _SC_CHAR_MIN	103
#define _SC_INT_MAX	104
#define _SC_INT_MIN	105
#define _SC_LONG_BIT	106
#define _SC_WORD_BIT	107
#define _SC_MB_LEN_MAX	108
#define _SC_NZERO	109
#define _SC_TIMERS	11
#define _SC_SSIZE_MAX	110
#define _SC_SCHAR_MAX	111
#define _SC_SCHAR_MIN	112
#define _SC_SHRT_MAX	113
#define _SC_SHRT_MIN	114
#define _SC_UCHAR_MAX	115
#define _SC_UINT_MAX	116
#define _SC_ULONG_MAX	117
#define _SC_USHRT_MAX	118
#define _SC_NL_ARGMAX	119
#define _SC_ASYNCHRONOUS_IO	12
#define _SC_NL_LANGMAX	120
#define _SC_NL_MSGMAX	121
#define _SC_NL_NMAX	122
#define _SC_NL_SETMAX	123
#define _SC_NL_TEXTMAX	124
#define _SC_XBS5_ILP32_OFF32	125
#define _SC_XBS5_ILP32_OFFBIG	126
#define _SC_XBS5_LP64_OFF64	127
#define _SC_XBS5_LPBIG_OFFBIG	128
#define _SC_XOPEN_LEGACY	129
#define _SC_PRIORITIZED_IO	13
#define _SC_XOPEN_REALTIME	130
#define _SC_XOPEN_REALTIME_THREADS	131
#define _SC_ADVISORY_INFO	132
#define _SC_BARRIERS	133
#define _SC_BASE	134
#define _SC_C_LANG_SUPPORT	135
#define _SC_C_LANG_SUPPORT_R	136
#define _SC_CLOCK_SELECTION	137
#define _SC_CPUTIME	138
#define _SC_THREAD_CPUTIME	139
#define _SC_SYNCHRONIZED_IO	14
#define _SC_DEVICE_IO	140
#define _SC_DEVICE_SPECIFIC	141
#define _SC_DEVICE_SPECIFIC_R	142
#define _SC_FD_MGMT	143
#define _SC_FIFO	144
#define _SC_PIPE	145
#define _SC_FILE_ATTRIBUTES	146
#define _SC_FILE_LOCKING	147
#define _SC_FILE_SYSTEM	148
#define _SC_MONOTONIC_CLOCK	149
#define _SC_FSYNC	15
#define _SC_MULTI_PROCESS	150
#define _SC_SINGLE_PROCESS	151
#define _SC_NETWORKING	152
#define _SC_READER_WRITER_LOCKS	153
#define _SC_SPIN_LOCKS	154
#define _SC_REGEXP	155
#define _SC_REGEX_VERSION	156
#define _SC_SHELL	157
#define _SC_SIGNALS	158
#define _SC_SPAWN	159
#define _SC_MAPPED_FILES	16
#define _SC_SPORADIC_SERVER	160
#define _SC_THREAD_SPORADIC_SERVER	161
#define _SC_SYSTEM_DATABASE	162
#define _SC_SYSTEM_DATABASE_R	163
#define _SC_TIMEOUTS	164
#define _SC_TYPED_MEMORY_OBJECTS	165
#define _SC_USER_GROUPS	166
#define _SC_USER_GROUPS_R	167
#define _SC_2_PBS	168
#define _SC_2_PBS_ACCOUNTING	169
#define _SC_MEMLOCK	17
#define _SC_2_PBS_LOCATE	170
#define _SC_2_PBS_MESSAGE	171
#define _SC_2_PBS_TRACK	172
#define _SC_SYMLOOP_MAX	173
#define _SC_STREAMS	174
#define _SC_2_PBS_CHECKPOINT	175
#define _SC_V6_ILP32_OFF32	176
#define _SC_V6_ILP32_OFFBIG	177
#define _SC_V6_LP64_OFF64	178
#define _SC_V6_LPBIG_OFFBIG	179
#define _SC_MEMLOCK_RANGE	18
#define _SC_HOST_NAME_MAX	180
#define _SC_TRACE	181
#define _SC_TRACE_EVENT_FILTER	182
#define _SC_TRACE_INHERIT	183
#define _SC_TRACE_LOG	184
#define _SC_LEVEL1_ICACHE_SIZE	185
#define _SC_LEVEL1_ICACHE_ASSOC	186
#define _SC_LEVEL1_ICACHE_LINESIZE	187
#define _SC_LEVEL1_DCACHE_SIZE	188
#define _SC_LEVEL1_DCACHE_ASSOC	189
#define _SC_MEMORY_PROTECTION	19
#define _SC_LEVEL1_DCACHE_LINESIZE	190
#define _SC_LEVEL2_CACHE_SIZE	191
#define _SC_LEVEL2_CACHE_ASSOC	192
#define _SC_LEVEL2_CACHE_LINESIZE	193
#define _SC_LEVEL3_CACHE_SIZE	194
#define _SC_LEVEL3_CACHE_ASSOC	195
#define _SC_LEVEL3_CACHE_LINESIZE	196
#define _SC_LEVEL4_CACHE_SIZE	197
#define _SC_LEVEL4_CACHE_ASSOC	198
#define _SC_LEVEL4_CACHE_LINESIZE	199
#define _SC_CLK_TCK	2
#define _SC_MESSAGE_PASSING	20
#define _SC_SEMAPHORES	21
#define _SC_SHARED_MEMORY_OBJECTS	22
#define _SC_AIO_LISTIO_MAX	23
#define _SC_IPV6	235
#define _SC_RAW_SOCKETS	236
#define _SC_V7_ILP32_OFF32	237
#define _SC_V7_ILP32_OFFBIG	238
#define _SC_V7_LP64_OFF64	239
#define _SC_AIO_MAX	24
#define _SC_V7_LPBIG_OFFBIG	240
#define _SC_SS_REPL_MAX	241
#define _SC_TRACE_EVENT_NAME_MAX	242
#define _SC_TRACE_NAME_MAX	243
#define _SC_TRACE_SYS_MAX	244
#define _SC_TRACE_USER_EVENT_MAX	245
#define _SC_XOPEN_STREAMS	246
#define _SC_THREAD_ROBUST_PRIO_INHERIT	247
#define _SC_THREAD_ROBUST_PRIO_PROTECT	248
#define _SC_AIO_PRIO_DELTA_MAX	25
#define _SC_DELAYTIMER_MAX	26
#define _SC_MQ_OPEN_MAX	27
#define _SC_MQ_PRIO_MAX	28
#define _SC_VERSION	29
#define _SC_NGROUPS_MAX	3
#define _SC_PAGESIZE	30
#define _SC_PAGE_SIZE	30
#define _SC_RTSIG_MAX	31
#define _SC_SEM_NSEMS_MAX	32
#define _SC_SEM_VALUE_MAX	33
#define _SC_SIGQUEUE_MAX	34
#define _SC_TIMER_MAX	35
#define _SC_BC_BASE_MAX	36
#define _SC_BC_DIM_MAX	37
#define _SC_BC_SCALE_MAX	38
#define _SC_BC_STRING_MAX	39
#define _SC_OPEN_MAX	4
#define _SC_COLL_WEIGHTS_MAX	40
#define _SC_EQUIV_CLASS_MAX	41
#define _SC_EXPR_NEST_MAX	42
#define _SC_LINE_MAX	43
#define _SC_RE_DUP_MAX	44
#define _SC_CHARCLASS_NAME_MAX	45
#define _SC_2_VERSION	46
#define _SC_2_C_BIND	47
#define _SC_2_C_DEV	48
#define _SC_2_FORT_DEV	49
#define _SC_STREAM_MAX	5
#define _SC_2_FORT_RUN	50
#define _SC_2_SW_DEV	51
#define _SC_2_LOCALEDEF	52
#define _SC_PII	53
#define _SC_PII_XTI	54
#define _SC_PII_SOCKET	55
#define _SC_PII_INTERNET	56
#define _SC_PII_OSI	57
#define _SC_POLL	58
#define _SC_SELECT	59
#define _SC_TZNAME_MAX	6
#define _SC_IOV_MAX	60
#define _SC_UIO_MAXIOV	60
#define _SC_PII_INTERNET_STREAM	61
#define _SC_PII_INTERNET_DGRAM	62
#define _SC_PII_OSI_COTS	63
#define _SC_PII_OSI_CLTS	64
#define _SC_PII_OSI_M	65
#define _SC_T_IOV_MAX	66
#define _SC_THREADS	67
#define _SC_THREAD_SAFE_FUNCTIONS	68
#define _SC_GETGR_R_SIZE_MAX	69
#define _SC_JOB_CONTROL	7
#define _SC_GETPW_R_SIZE_MAX	70
#define _SC_LOGIN_NAME_MAX	71
#define _SC_TTY_NAME_MAX	72
#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
#define _SC_THREAD_KEYS_MAX	74
#define _SC_THREAD_STACK_MIN	75
#define _SC_THREAD_THREADS_MAX	76
#define _SC_THREAD_ATTR_STACKADDR	77
#define _SC_THREAD_ATTR_STACKSIZE	78
#define _SC_THREAD_PRIORITY_SCHEDULING	79
#define _SC_SAVED_IDS	8
#define _SC_THREAD_PRIO_INHERIT	80
#define _SC_THREAD_PRIO_PROTECT	81
#define _SC_THREAD_PROCESS_SHARED	82
#define _SC_NPROCESSORS_CONF	83
#define _SC_NPROCESSORS_ONLN	84
#define _SC_PHYS_PAGES	85
#define _SC_AVPHYS_PAGES	86
#define _SC_ATEXIT_MAX	87
#define _SC_PASS_MAX	88
#define _SC_XOPEN_VERSION	89
#define _SC_REALTIME_SIGNALS	9
#define _SC_XOPEN_XCU_VERSION	90
#define _SC_XOPEN_UNIX	91
#define _SC_XOPEN_CRYPT	92
#define _SC_XOPEN_ENH_I18N	93
#define _SC_XOPEN_SHM	94
#define _SC_2_CHAR_TERM	95
#define _SC_2_C_VERSION	96
#define _SC_2_UPE	97
#define _SC_XOPEN_XPG2	98
#define _SC_XOPEN_XPG3	99

#define _CS_PATH	0
#define _POSIX_REGEXP	1
#define _CS_XBS5_ILP32_OFF32_CFLAGS	1100
#define _CS_XBS5_ILP32_OFF32_LDFLAGS	1101
#define _CS_XBS5_ILP32_OFF32_LIBS	1102
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS	1103
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS	1104
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS	1105
#define _CS_XBS5_ILP32_OFFBIG_LIBS	1106
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS	1107
#define _CS_XBS5_LP64_OFF64_CFLAGS	1108
#define _CS_XBS5_LP64_OFF64_LDFLAGS	1109
#define _CS_XBS5_LP64_OFF64_LIBS	1110
#define _CS_XBS5_LP64_OFF64_LINTFLAGS	1111
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS	1112
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS	1113
#define _CS_XBS5_LPBIG_OFFBIG_LIBS	1114
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS	1115
#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS	1116
#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS	1117
#define _CS_POSIX_V6_ILP32_OFF32_LIBS	1118
#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS	1119
#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS	1120
#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS	1121
#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS	1122
#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS	1123
#define _CS_POSIX_V6_LP64_OFF64_CFLAGS	1124
#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS	1125
#define _CS_POSIX_V6_LP64_OFF64_LIBS	1126
#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS	1127
#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS	1128
#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS	1129
#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS	1130
#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS	1131
#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS	1132
#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS	1133
#define _CS_POSIX_V7_ILP32_OFF32_LIBS	1134
#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS	1135
#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS	1136
#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS	1137
#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS	1138
#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS	1139
#define _CS_POSIX_V7_LP64_OFF64_CFLAGS	1140
#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS	1141
#define _CS_POSIX_V7_LP64_OFF64_LIBS	1142
#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS	1143
#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS	1144
#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS	1145
#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS	1146
#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS	1147
#define _CS_V6_ENV	1148
#define _CS_V7_ENV	1149

#define _XOPEN_XPG4	1
#define _XOPEN_VERSION	700

#define F_ULOCK	0
#define F_LOCK	1
#define F_TLOCK	2
#define F_TEST	3

extern size_t __confstr_chk(int, char *, size_t, size_t);
extern char **__environ;
extern char *__getcwd_chk(char *, size_t, size_t);
extern int __getgroups_chk(int, gid_t *, size_t);
extern int __gethostname_chk(char *, size_t, size_t);
extern int __getlogin_r_chk(char *, size_t, size_t);
extern pid_t __getpgid(pid_t __pid);
extern ssize_t __pread64_chk(int, void *, size_t, off64_t, size_t);
extern ssize_t __pread_chk(int, void *, size_t, off_t, size_t);
extern ssize_t __read_chk(int, void *, size_t, size_t);
extern ssize_t __readlink_chk(const char *, char *, size_t, size_t);
extern int __ttyname_r_chk(int, char *, size_t, size_t);
extern char **_environ;
extern void _exit(int __status);
extern int access(const char *__name, int __type);
extern int acct(const char *__name);
extern unsigned int alarm(unsigned int __seconds);
extern int brk(void *__addr);
extern int chdir(const char *__path);
extern int chown(const char *__file, uid_t __owner, gid_t __group);
extern int chroot(const char *__path);
extern int close(int __fd);
extern size_t confstr(int __name, char *__buf, size_t __len);
extern char *crypt(const char *__key, const char *__salt);
extern char *ctermid(char *__s);
extern char *cuserid(char *__s);
extern int daemon(int __nochdir, int __noclose);
extern int dup(int __fd);
extern int dup2(int __fd, int __fd2);
extern void encrypt(char *__block, int __edflag);
extern int execl(const char *__path, const char *__arg, ...);
extern int execle(const char *__path, const char *__arg, ...);
extern int execlp(const char *__file, const char *__arg, ...);
extern int execv(const char *__path, char *const __argv[]);
extern int execve(const char *__path, char *const __argv[],
		  char *const __envp[]);
extern int execvp(const char *__file, char *const __argv[]);
extern int faccessat(int __fd, const char *__file, int __type, int __flag);
extern int fchdir(int __fd);
extern int fchown(int __fd, uid_t __owner, gid_t __group);
extern int fchownat(int __fd, const char *__file, uid_t __owner,
		    gid_t __group, int __flag);
extern int fdatasync(int __fildes);
extern int fexecve(int __fd, char *const __argv[], char *const __envp[]);
extern pid_t fork(void);
extern long int fpathconf(int __fd, int __name);
extern int fsync(int __fd);
extern int ftruncate(int __fd, off_t __length);
extern int ftruncate64(int __fd, off64_t __length);
extern char *getcwd(char *__buf, size_t __size);
extern int getdomainname(char *__name, size_t __len);
extern int getdtablesize(void);
extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern int getgroups(int __size, gid_t __list[]);
extern long int gethostid(void);
extern int gethostname(char *__name, size_t __len);
extern char *getlogin(void);
extern int getlogin_r(char *__name, size_t __name_len);
extern int getopt(int ___argc, char *const ___argv[],
		  const char *__shortopts);
extern int getpagesize(void);
extern pid_t getpgid(pid_t __pid);
extern pid_t getpgrp(void);
extern pid_t getpid(void);
extern pid_t getppid(void);
extern pid_t getsid(pid_t __pid);
extern uid_t getuid(void);
extern char *getwd(char *__buf);
extern int isatty(int __fd);
extern int lchown(const char *__file, uid_t __owner, gid_t __group);
extern int link(const char *__from, const char *__to);
extern int linkat(int __fromfd, const char *__from, int __tofd,
		  const char *__to, int __flags);
extern int lockf(int __fd, int __cmd, off_t __len);
extern int lockf64(int __fd, int __cmd, off64_t __len);
extern off_t lseek(int __fd, off_t __offset, int __whence);
extern loff_t lseek64(int __fd, loff_t __offset, int __whence);
extern int nice(int __inc);
extern char *optarg;
extern int opterr;
extern int optind;
extern int optopt;
extern long int pathconf(const char *__path, int __name);
extern int pause(void);
extern int pipe(int __pipedes[2]);
extern ssize_t pread(int __fd, void *__buf, size_t __nbytes,
		     off_t __offset);
extern ssize_t pread64(int __fd, void *__buf, size_t __nbytes,
		       off64_t __offset);
extern ssize_t pwrite(int __fd, const void *__buf, size_t __n,
		      off_t __offset);
extern ssize_t pwrite64(int __fd, const void *__buf, size_t __n,
			off64_t __offset);
extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
extern ssize_t readlink(const char *__path, char *__buf, size_t __len);
extern ssize_t readlinkat(int __fd, const char *__path, char *__buf,
			  size_t __len);
extern int rmdir(const char *__path);
extern void *sbrk(intptr_t __delta);
extern int setegid(gid_t __gid);
extern int seteuid(uid_t __uid);
extern int setgid(gid_t __gid);
extern int sethostname(const char *__name, size_t __len);
extern void setkey(const char *__key);
extern int setpgid(pid_t __pid, pid_t __pgid);
extern int setpgrp(void);
extern int setregid(gid_t __rgid, gid_t __egid);
extern int setreuid(uid_t __ruid, uid_t __euid);
extern pid_t setsid(void);
extern int setuid(uid_t __uid);
extern unsigned int sleep(unsigned int __seconds);
extern void swab(const void *__from, void *__to, ssize_t __n);
extern int symlink(const char *__from, const char *__to);
extern int symlinkat(const char *__from, int __tofd, const char *__to);
extern void sync(void);
extern long int sysconf(int __name);
extern pid_t tcgetpgrp(int __fd);
extern int tcsetpgrp(int __fd, pid_t __pgrp_id);
extern int truncate(const char *__file, off_t __length);
extern int truncate64(const char *__file, off64_t __length);
extern char *ttyname(int __fd);
extern int ttyname_r(int __fd, char *__buf, size_t __buflen);
extern unsigned int ualarm(useconds_t __value, useconds_t __interval);
extern int unlink(const char *__name);
extern int unlinkat(int __fd, const char *__name, int __flag);
extern int usleep(useconds_t __useconds);
extern pid_t vfork(void);
extern ssize_t write(int __fd, const void *__buf, size_t __n);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7750"
>14.4.104. utime.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct utimbuf {
    time_t actime;
    time_t modtime;
};
extern int utime(const char *__file, const struct utimbuf *__file_times);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7754"
>14.4.105. utmp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UT_HOSTSIZE	256
#define UT_LINESIZE	32
#define UT_NAMESIZE	32
#define ut_addr	ut_addr_v6[0]
#define ut_time	ut_tv.tv_sec
#define ut_name	ut_user		/* Backwards compatability */

struct exit_status {
    short e_termination;	/* Process termination status. */
    short e_exit;		/* Process exit status. */
};

#define EMPTY	0		/* No valid user accounting information. */
#define RUN_LVL	1		/* The system's runlevel. */
#define BOOT_TIME	2	/* Time of system boot. */
#define NEW_TIME	3	/* Time after system clock changed. */
#define OLD_TIME	4	/* Time when system clock changed. */
#define INIT_PROCESS	5	/* Process spawned by the init process. */
#define LOGIN_PROCESS	6	/* Session leader of a logged in user. */
#define USER_PROCESS	7	/* Normal process. */
#define DEAD_PROCESS	8	/* Terminated process. */
#define ACCOUNTING	9

extern void endutent(void);
extern struct utmp *getutent(void);
extern int getutent_r(struct utmp *__buffer, struct utmp **__result);
extern void login(const struct utmp *__entry);
extern int login_tty(int __fd);
extern int logout(const char *__ut_line);
extern void logwtmp(const char *__ut_line, const char *__ut_name,
		    const char *__ut_host);
extern void setutent(void);
extern int utmpname(const char *__file);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7758"
>14.4.106. utmpx.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void endutxent(void);
extern struct utmpx *getutxent(void);
extern struct utmpx *getutxid(const struct utmpx *__id);
extern struct utmpx *getutxline(const struct utmpx *__line);
extern struct utmpx *pututxline(const struct utmpx *__utmpx);
extern void setutxent(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7762"
>14.4.107. wchar.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define WEOF	(0xffffffffu)
#define WCHAR_MAX	0x7FFFFFFF
#define WCHAR_MIN	0x80000000

typedef unsigned long int wctype_t;
typedef const int32_t *wctrans_t;

extern wchar_t *__fgetws_chk(wchar_t *, size_t, int, FILE *);
extern wchar_t *__fgetws_unlocked_chk(wchar_t *, size_t, int, FILE *);
extern int __fwprintf_chk(FILE *, int, const wchar_t *, ...);
extern size_t __mbsnrtowcs_chk(wchar_t *, const char **, size_t, size_t,
			       mbstate_t *, size_t);
extern size_t __mbsrtowcs_chk(wchar_t *, const char **, size_t,
			      mbstate_t *, size_t);
extern int __swprintf_chk(wchar_t *, size_t, int, size_t, const wchar_t *,
			  ...);
extern int __vfwprintf_chk(FILE *, int, const wchar_t *, va_list);
extern int __vswprintf_chk(wchar_t *, size_t, int, size_t, const wchar_t *,
			   va_list);
extern int __vwprintf_chk(int, const wchar_t *, va_list);
extern wchar_t *__wcpcpy_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcpncpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern size_t __wcrtomb_chk(char *, wchar_t, mbstate_t *, size_t);
extern wchar_t *__wcscat_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcscpy_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcsncat_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wcsncpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern size_t __wcsnrtombs_chk(char *, const wchar_t * *, size_t, size_t,
			       mbstate_t *, size_t);
extern size_t __wcsrtombs_chk(char *, const wchar_t * *, size_t,
			      mbstate_t *, size_t);
extern double __wcstod_internal(const wchar_t *, wchar_t * *, int);
extern float __wcstof_internal(const wchar_t *, wchar_t * *, int);
extern long int __wcstol_internal(const wchar_t *, wchar_t * *, int, int);
extern long double __wcstold_internal(const wchar_t *, wchar_t * *, int);
extern unsigned long int __wcstoul_internal(const wchar_t *, wchar_t * *,
					    int, int);
extern wchar_t *__wmemcpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmemmove_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmempcpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmemset_chk(wchar_t *, wchar_t, size_t, size_t);
extern int __wprintf_chk(int, const wchar_t *, ...);
extern wint_t btowc(int __c);
extern wint_t fgetwc(FILE * __stream);
extern wint_t fgetwc_unlocked(FILE * __stream);
extern wchar_t *fgetws(wchar_t * __ws, int __n, FILE * __stream);
extern wchar_t *fgetws_unlocked(wchar_t * __ws, int __n, FILE * __stream);
extern wint_t fputwc(wchar_t __wc, FILE * __stream);
extern wint_t fputwc_unlocked(wchar_t __wc, FILE * __stream);
extern int fputws(const wchar_t * __ws, FILE * __stream);
extern int fputws_unlocked(const wchar_t * __ws, FILE * __stream);
extern int fwide(FILE * __fp, int __mode);
extern int fwprintf(FILE * __stream, const wchar_t * __format, ...);
extern int fwscanf(FILE * __stream, const wchar_t * __format, ...);
extern wint_t getwc(FILE * __stream);
extern wint_t getwc_unlocked(FILE * __stream);
extern wint_t getwchar(void);
extern wint_t getwchar_unlocked(void);
extern size_t mbrlen(const char *__s, size_t __n, mbstate_t * __ps);
extern size_t mbrtowc(wchar_t * __pwc, const char *__s, size_t __n,
		      mbstate_t * __p);
extern int mbsinit(const mbstate_t * __ps);
extern size_t mbsnrtowcs(wchar_t * __dst, const char **__src, size_t __nmc,
			 size_t __len, mbstate_t * __ps);
extern size_t mbsrtowcs(wchar_t * __dst, const char **__src, size_t __len,
			mbstate_t * __ps);
extern FILE *open_wmemstream(wchar_t * *__bufloc, size_t * __sizeloc);
extern wint_t putwc(wchar_t __wc, FILE * __stream);
extern wint_t putwc_unlocked(wchar_t __wc, FILE * __stream);
extern wint_t putwchar(wchar_t __wc);
extern wint_t putwchar_unlocked(wchar_t __wc);
extern int swprintf(wchar_t * __s, size_t __n, const wchar_t * __format,
		    ...);
extern int swscanf(const wchar_t * __s, const wchar_t * __format, ...);
extern wint_t ungetwc(wint_t __wc, FILE * __stream);
extern int vfwprintf(FILE * __s, const wchar_t * __format, va_list __arg);
extern int vfwscanf(FILE * __s, const wchar_t * __format, va_list __arg);
extern int vswprintf(wchar_t * __s, size_t __n, const wchar_t * __format,
		     va_list __arg);
extern int vswscanf(const wchar_t * __s, const wchar_t * __format,
		    va_list __arg);
extern int vwprintf(const wchar_t * __format, va_list __arg);
extern int vwscanf(const wchar_t * __format, va_list __arg);
extern wchar_t *wcpcpy(wchar_t * __dest, const wchar_t * __src);
extern wchar_t *wcpncpy(wchar_t * __dest, const wchar_t * __src,
			size_t __n);
extern size_t wcrtomb(char *__s, wchar_t __wc, mbstate_t * __ps);
extern int wcscasecmp(const wchar_t * __s1, const wchar_t * __s2);
extern int wcscasecmp_l(const wchar_t * ws1, const wchar_t * ws2,
			locale_t locale);
extern wchar_t *wcscat(wchar_t * __dest, const wchar_t * __src);
extern wchar_t *wcschr(const wchar_t * __wcs, wchar_t __wc);
extern int wcscmp(const wchar_t * __s1, const wchar_t * __s2);
extern int wcscoll(const wchar_t * __s1, const wchar_t * __s2);
extern int wcscoll_l(const wchar_t * ws1, const wchar_t * ws2,
		     locale_t locale);
extern wchar_t *wcscpy(wchar_t * __dest, const wchar_t * __src);
extern size_t wcscspn(const wchar_t * __wcs, const wchar_t * __reject);
extern wchar_t *wcsdup(const wchar_t * __s);
extern size_t wcsftime(wchar_t * __s, size_t __maxsize,
		       const wchar_t * __format, const struct tm *__tp);
extern size_t wcslen(const wchar_t * __s);
extern int wcsncasecmp(const wchar_t * __s1, const wchar_t * __s2,
		       size_t __n);
extern int wcsncasecmp_l(const wchar_t * ws1, const wchar_t * ws2,
			 size_t n, locale_t locale);
extern wchar_t *wcsncat(wchar_t * __dest, const wchar_t * __src,
			size_t __n);
extern int wcsncmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wcsncpy(wchar_t * __dest, const wchar_t * __src,
			size_t __n);
extern size_t wcsnlen(const wchar_t * __s, size_t __maxlen);
extern size_t wcsnrtombs(char *__dst, const wchar_t * *__src, size_t __nwc,
			 size_t __len, mbstate_t * __ps);
extern wchar_t *wcspbrk(const wchar_t * __wcs, const wchar_t * __accept);
extern wchar_t *wcsrchr(const wchar_t * __wcs, wchar_t __wc);
extern size_t wcsrtombs(char *__dst, const wchar_t * *__src, size_t __len,
			mbstate_t * __ps);
extern size_t wcsspn(const wchar_t * __wcs, const wchar_t * __accept);
extern wchar_t *wcsstr(const wchar_t * __haystack,
		       const wchar_t * __needle);
extern double wcstod(const wchar_t * __nptr, wchar_t * *__endptr);
extern float wcstof(const wchar_t * __nptr, wchar_t * *__endptr);
extern wchar_t *wcstok(wchar_t * __s, const wchar_t * __delim,
		       wchar_t * *__ptr);
extern long int wcstol(const wchar_t * __nptr, wchar_t * *__endptr,
		       int __base);
extern long double wcstold(const wchar_t * __nptr, wchar_t * *__endptr);
extern long long int wcstoll(const wchar_t * __nptr, wchar_t * *__endptr,
			     int __base);
extern long long int wcstoq(const wchar_t * __nptr, wchar_t * *__endptr,
			    int __base);
extern unsigned long int wcstoul(const wchar_t * __nptr,
				 wchar_t * *__endptr, int __base);
extern unsigned long long int wcstoull(const wchar_t * __nptr,
				       wchar_t * *__endptr, int __base);
extern unsigned long long int wcstouq(const wchar_t * __nptr,
				      wchar_t * *__endptr, int __base);
extern wchar_t *wcswcs(const wchar_t * __haystack,
		       const wchar_t * __needle);
extern int wcswidth(const wchar_t * __s, size_t __n);
extern size_t wcsxfrm(wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern size_t wcsxfrm_l(const wchar_t * ws1, const wchar_t * ws2, size_t n,
			locale_t locale);
extern int wctob(wint_t __c);
extern int wcwidth(wchar_t __c);
extern wchar_t *wmemchr(const wchar_t * __s, wchar_t __c, size_t __n);
extern int wmemcmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wmemcpy(wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wmemmove(wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wmemset(wchar_t * __s, wchar_t __c, size_t __n);
extern int wprintf(const wchar_t * __format, ...);
extern int wscanf(const wchar_t * __format, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7766"
>14.4.108. wctype.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int iswalnum(wint_t __wc);
extern int iswalnum_l(wint_t wc, locale_t locale);
extern int iswalpha(wint_t __wc);
extern int iswalpha_l(wint_t wc, locale_t locale);
extern int iswblank(wint_t __wc);
extern int iswblank_l(wint_t wc, locale_t locale);
extern int iswcntrl(wint_t __wc);
extern int iswcntrl_l(wint_t wc, locale_t locale);
extern int iswctype(wint_t __wc, wctype_t __desc);
extern int iswctype_l(wint_t wc, locale_t locale);
extern int iswdigit(wint_t __wc);
extern int iswdigit_l(wint_t wc, locale_t locale);
extern int iswgraph(wint_t __wc);
extern int iswgraph_l(wint_t wc, locale_t locale);
extern int iswlower(wint_t __wc);
extern int iswlower_l(wint_t wc, locale_t locale);
extern int iswprint(wint_t __wc);
extern int iswprint_l(wint_t wc, locale_t locale);
extern int iswpunct(wint_t __wc);
extern int iswpunct_l(wint_t wc, locale_t locale);
extern int iswspace(wint_t __wc);
extern int iswspace_l(wint_t wc, locale_t locale);
extern int iswupper(wint_t __wc);
extern int iswupper_l(wint_t wc, locale_t locale);
extern int iswxdigit(wint_t __wc);
extern int iswxdigit_l(wint_t wc, locale_t locale);
extern wint_t towctrans(wint_t __wc, wctrans_t __desc);
extern wint_t towctrans_l(wint_t wc, wctrans_t desc, locale_t locale);
extern wint_t towlower(wint_t __wc);
extern wint_t towlower_l(wint_t wc, locale_t locale);
extern wint_t towupper(wint_t __wc);
extern wint_t towupper_l(wint_t wc, locale_t locale);
extern wctrans_t wctrans(const char *__property);
extern size_t wctrans_l(const char *charclass, locale_t locale);
extern wctype_t wctype(const char *__property);
extern size_t wctype_l(const char *property, locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN7770"
>14.4.109. wordexp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum {
    WRDE_DOOFFS = 1,
    WRDE_APPEND = 2,
    WRDE_NOCMD = 4,
    WRDE_REUSE = 8,
    WRDE_SHOWERR = 16,
    WRDE_UNDEF = 32
};

typedef struct {
    size_t we_wordc;
    char **we_wordv;
    size_t we_offs;
} wordexp_t;

enum {
    WRDE_NOSYS = -1,
    WRDE_NOSPACE = 1,
    WRDE_BADCHAR = 2,
    WRDE_BADVAL = 3,
    WRDE_CMDSUB = 4,
    WRDE_SYNTAX = 5
};
extern int wordexp(const char *__words, wordexp_t * __pwordexp,
		   int __flags);
extern void wordfree(wordexp_t * __wordexp);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBCMAN"
>14.5. Interface Definitions for libc</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB--IO-FEOF-3"
>_IO_feof</A
>&nbsp;--&nbsp;alias for feof</DT
><DT
><A
HREF="#BASELIB--IO-GETC-3"
>_IO_getc</A
>&nbsp;--&nbsp;alias for getc</DT
><DT
><A
HREF="#BASELIB--IO-PUTC-3"
>_IO_putc</A
>&nbsp;--&nbsp;alias for putc</DT
><DT
><A
HREF="#BASELIB--IO-PUTS-3"
>_IO_puts</A
>&nbsp;--&nbsp;alias for puts</DT
><DT
><A
HREF="#BASELIB---ASSERT-FAIL-1"
>__assert_fail</A
>&nbsp;--&nbsp;abort the program after false assertion</DT
><DT
><A
HREF="#BASELIB---CHK-FAIL-1"
>__chk_fail</A
>&nbsp;--&nbsp;terminate a function in case of buffer overflow</DT
><DT
><A
HREF="#BASELIB---CONFSTR-CHK-1"
>__confstr_chk</A
>&nbsp;--&nbsp;get configuration dependent string variables, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---CTYPE-B-LOC"
>__ctype_b_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b array for ctype functions</DT
><DT
><A
HREF="#BASELIB---CTYPE-GET-MB-CUR-MAX-1"
>__ctype_get_mb_cur_max</A
>&nbsp;--&nbsp;maximum length of a multibyte character in the current locale</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOLOWER-LOC"
>__ctype_tolower_loc</A
>&nbsp;--&nbsp;accessor function for __ctype_b_tolower array for ctype tolower() function</DT
><DT
><A
HREF="#LIBUTIL---CTYPE-TOUPPER-LOC"
>__ctype_toupper_loc</A
>&nbsp;--&nbsp;accessor function for <TT
CLASS="FUNCTION"
>__ctype_b_toupper()</TT
>
array for ctype <TT
CLASS="FUNCTION"
>toupper()</TT
> function</DT
><DT
><A
HREF="#BASELIB---CXA-ATEXIT"
>__cxa_atexit</A
>&nbsp;--&nbsp;register a function to be called by exit or when a shared library is unloaded</DT
><DT
><A
HREF="#BASELIB---CXA-FINALIZE"
>__cxa_finalize</A
>&nbsp;--&nbsp;call destructors of global (or local static) C++
objects and exit functions registered with atexit</DT
><DT
><A
HREF="#BASELIB---DAYLIGHT"
>__daylight</A
>&nbsp;--&nbsp;external daylight savings time flag</DT
><DT
><A
HREF="#BASELIB---ENVIRON"
>__environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB---ERRNO-LOCATION"
>__errno_location</A
>&nbsp;--&nbsp;address of errno variable</DT
><DT
><A
HREF="#BASELIB---FGETS-CHK-1"
>__fgets_chk</A
>&nbsp;--&nbsp;string input, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---FGETS-UNLOCKED-CHK-1"
>__fgets_unlocked_chk</A
>&nbsp;--&nbsp;non-locking string input, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---FGETWS-CHK-1"
>__fgetws_chk</A
>&nbsp;--&nbsp;read a wide-character string from a FILE stream, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---FGETWS-UNLOCKED-CHK-1"
>__fgetws_unlocked_chk</A
>&nbsp;--&nbsp;read a wide-character string from a FILE stream in a non-locking manner, with stack checking</DT
><DT
><A
HREF="#BASELIB---FPENDING"
>__fpending</A
>&nbsp;--&nbsp;returns in bytes the amount of output pending on a stream</DT
><DT
><A
HREF="#BASELIB---FPRINTF-CHK-1"
>__fprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---FWPRINTF-CHK-1"
>__fwprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---FXSTATAT-1"
>__fxstatat</A
>&nbsp;--&nbsp;get file status relative to directory file descriptor</DT
><DT
><A
HREF="#BASELIB---FXSTATAT64-1"
>__fxstatat64, fstatat64</A
>&nbsp;--&nbsp;get file status relative to a directory file descriptor (Large File Support)</DT
><DT
><A
HREF="#BASELIB---GETCWD-CHK-1"
>__getcwd_chk</A
>&nbsp;--&nbsp;get current working directory, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---GETGROUPS-CHK-1"
>__getgroups_chk</A
>&nbsp;--&nbsp;get list of supplementary group IDs, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---GETHOSTNAME-CHK-1"
>__gethostname_chk</A
>&nbsp;--&nbsp;get host name, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---GETLOGIN-R-CHK-1"
>__getlogin_r_chk</A
>&nbsp;--&nbsp;get user name, with buffer overflow checking (reentrant)</DT
><DT
><A
HREF="#BASELIB---GETPAGESIZE"
>__getpagesize</A
>&nbsp;--&nbsp;alias for getpagesize - get current page size </DT
><DT
><A
HREF="#BASELIB---GETPGID-1"
>__getpgid</A
>&nbsp;--&nbsp;get the process group id</DT
><DT
><A
HREF="#BASELIB---H-ERRNO-LOCATION"
>__h_errno_location</A
>&nbsp;--&nbsp;address of h_errno variable</DT
><DT
><A
HREF="#BASELIB---ISINF"
>__isinf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFF"
>__isinff</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISINFL"
>__isinfl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNAN"
>__isnan</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANF"
>__isnanf</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---ISNANL"
>__isnanl</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMAX-1"
>__libc_current_sigrtmax</A
>&nbsp;--&nbsp;return number of available real-time signal with lowest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-CURRENT-SIGRTMIN-1"
>__libc_current_sigrtmin</A
>&nbsp;--&nbsp;return number of available real-time signal with highest priority</DT
><DT
><A
HREF="#BASELIB---LIBC-START-MAIN-"
>__libc_start_main</A
>&nbsp;--&nbsp;initialization routine</DT
><DT
><A
HREF="#BASELIB---MBSNRTOWCS-CHK-1"
>__mbsnrtowcs_chk</A
>&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MBSRTOWCS-CHK-1"
>__mbsrtowcs_chk</A
>&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MBSTOWCS-CHK-1"
>__mbstowcs_chk</A
>&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMCPY-CHK-1"
>__memcpy_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMMOVE-CHK-1"
>__memmove_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMPCPY"
>__mempcpy</A
>&nbsp;--&nbsp;copy given number of bytes of source to destination</DT
><DT
><A
HREF="#BASELIB---MEMPCPY-CHK-1"
>__mempcpy_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---MEMSET-CHK-1"
>__memset_chk</A
>&nbsp;--&nbsp;fill memory with a constant byte, using buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---PREAD64-CHK-1"
>__pread64_chk</A
>&nbsp;--&nbsp;read from a file descriptor at a given offset, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---PREAD-CHK-1"
>__pread_chk</A
>&nbsp;--&nbsp;read from a file descriptor at a given offset, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---PRINTF-CHK-1"
>__printf_chk</A
>&nbsp;--&nbsp;format and print data, with stack checking</DT
><DT
><A
HREF="#BASELIB---RAWMEMCHR"
>__rawmemchr</A
>&nbsp;--&nbsp;scan memory</DT
><DT
><A
HREF="#BASELIB---READ-CHK-1"
>__read_chk</A
>&nbsp;--&nbsp;read from a file descriptor, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---READLINK-CHK-1"
>__readlink_chk</A
>&nbsp;--&nbsp;display value of a symbolic link, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---REALPATH-CHK-1"
>__realpath_chk</A
>&nbsp;--&nbsp;return the canonicalized absolute pathname, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---RECV-CHK-1"
>__recv_chk</A
>&nbsp;--&nbsp;receive a message from a socket, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---RECVFROM-CHK-1"
>__recvfrom_chk</A
>&nbsp;--&nbsp;receive a message from a socket, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---REGISTER-ATFORK"
>__register_atfork</A
>&nbsp;--&nbsp;alias for register_atfork</DT
><DT
><A
HREF="#BASELIB---SIGSETJMP-1"
>__sigsetjmp</A
>&nbsp;--&nbsp;save stack context for non-local goto</DT
><DT
><A
HREF="#BASELIB---SNPRINTF-CHK-1"
>__snprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---SPRINTF-CHK-1"
>__sprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---STACK-CHK-FAIL-1"
>__stack_chk_fail</A
>&nbsp;--&nbsp;terminate a function in case of stack overflow</DT
><DT
><A
HREF="#LIBUTIL---STPCPY-2"
>__stpcpy</A
>&nbsp;--&nbsp;alias for stpcpy</DT
><DT
><A
HREF="#BASELIB---STPCPY-CHK-1"
>__stpcpy_chk</A
>&nbsp;--&nbsp;copy a string returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STPNCPY-CHK-1"
>__stpncpy_chk</A
>&nbsp;--&nbsp;copy a fixed-size string, returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRCAT-CHK-1"
>__strcat_chk</A
>&nbsp;--&nbsp;concatenate two strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRCPY-CHK-1"
>__strcpy_chk</A
>&nbsp;--&nbsp;copy a string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRDUP-1"
>__strdup</A
>&nbsp;--&nbsp;alias for strdup</DT
><DT
><A
HREF="#BASELIB---STRNCAT-CHK-1"
>__strncat_chk</A
>&nbsp;--&nbsp;concatenate two strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRNCPY-CHK-1"
>__strncpy_chk</A
>&nbsp;--&nbsp;copy a string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---STRTOD-INTERNAL-1"
>__strtod_internal</A
>&nbsp;--&nbsp;underlying function for strtod</DT
><DT
><A
HREF="#BASELIB---STRTOF-INTERNAL"
>__strtof_internal</A
>&nbsp;--&nbsp;underlying function for strtof</DT
><DT
><A
HREF="#BASELIB---STRTOK-R-1"
>__strtok_r</A
>&nbsp;--&nbsp;alias for strtok_r</DT
><DT
><A
HREF="#BASELIB---STRTOL-INTERNAL-1"
>__strtol_internal</A
>&nbsp;--&nbsp;alias for strtol</DT
><DT
><A
HREF="#BASELIB---STRTOLD-INTERNAL-1"
>__strtold_internal</A
>&nbsp;--&nbsp;underlying function for strtold</DT
><DT
><A
HREF="#BASELIB---STRTOLL-INTERNAL-1"
>__strtoll_internal</A
>&nbsp;--&nbsp;underlying function for strtoll</DT
><DT
><A
HREF="#BASELIB---STRTOUL-INTERNAL"
>__strtoul_internal</A
>&nbsp;--&nbsp;underlying function for strtoul</DT
><DT
><A
HREF="#BASELIB---STRTOULL-INTERNAL-1"
>__strtoull_internal</A
>&nbsp;--&nbsp;underlying function for strtoull</DT
><DT
><A
HREF="#BASELIB---SWPRINTF-CHK-1"
>__swprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---SYSCONF"
>__sysconf</A
>&nbsp;--&nbsp;get configuration information at runtime</DT
><DT
><A
HREF="#BASELIB---SYSLOG-CHK-1"
>__syslog_chk</A
>&nbsp;--&nbsp;send messages to the system logger, with stack checking</DT
><DT
><A
HREF="#BASELIB---SYSV-SIGNAL-1"
>__sysv_signal</A
>&nbsp;--&nbsp;signal handling</DT
><DT
><A
HREF="#BASELIB---TIMEZONE"
>__timezone</A
>&nbsp;--&nbsp;external variable containing timezone</DT
><DT
><A
HREF="#BASELIB---TTYNAME-R-CHK-1"
>__ttyname_r_chk</A
>&nbsp;--&nbsp;return name of a terminal, with buffer overflow checking (reentrant)</DT
><DT
><A
HREF="#BASELIB---TZNAME"
>__tzname</A
>&nbsp;--&nbsp;external variable containing the timezone names</DT
><DT
><A
HREF="#BASELIB---VFPRINTF-CHK-1"
>__vfprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VFWPRINTF-CHK-1"
>__vfwprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VPRINTF-CHK-1"
>__vprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSNPRINTF-CHK-1"
>__vsnprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSPRINTF-CHK-1"
>__vsprintf_chk</A
>&nbsp;--&nbsp;convert formatted output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSWPRINTF-CHK-1"
>__vswprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---VSYSLOG-CHK-1"
>__vsyslog_chk</A
>&nbsp;--&nbsp;send messages to the system logger, with stack checking</DT
><DT
><A
HREF="#BASELIB---VWPRINTF-CHK-1"
>__vwprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---WCPCPY-CHK-1"
>__wcpcpy_chk</A
>&nbsp;--&nbsp;copy a wide-character string, returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCPNCPY-CHK-1"
>__wcpncpy_chk</A
>&nbsp;--&nbsp;copy a fixed-size string of wide characters, returning a pointer to its end, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCRTOMB-CHK-1"
>__wcrtomb_chk</A
>&nbsp;--&nbsp;convert a wide character to a multibyte sequence, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSCAT-CHK-1"
>__wcscat_chk</A
>&nbsp;--&nbsp;concatenate two wide-character strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSCPY-CHK-1"
>__wcscpy_chk</A
>&nbsp;--&nbsp;copy a wide-character string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSNCAT-CHK-1"
>__wcsncat_chk</A
>&nbsp;--&nbsp;concatenate two wide-character strings, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSNCPY-CHK-1"
>__wcsncpy_chk</A
>&nbsp;--&nbsp;copy a fixed-size string of wide characters, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSNRTOMBS-CHK-1"
>__wcsnrtombs_chk</A
>&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSRTOMBS-CHK-1"
>__wcsrtombs_chk</A
>&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSTOD-INTERNAL-1"
>__wcstod_internal</A
>&nbsp;--&nbsp;underlying function for wcstod</DT
><DT
><A
HREF="#BASELIB---WCSTOF-INTERNAL-1"
>__wcstof_internal</A
>&nbsp;--&nbsp;underlying function for wcstof</DT
><DT
><A
HREF="#BASELIB---WCSTOL-INTERNAL-1"
>__wcstol_internal</A
>&nbsp;--&nbsp;underlying function for wcstol</DT
><DT
><A
HREF="#BASELIB---WCSTOLD-INTERNAL-1"
>__wcstold_internal</A
>&nbsp;--&nbsp;underlying function for wcstold</DT
><DT
><A
HREF="#BASELIB---WCSTOMBS-CHK-1"
>__wcstombs_chk</A
>&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WCSTOUL-INTERNAL-1"
>__wcstoul_internal</A
>&nbsp;--&nbsp;underlying function for wcstoul</DT
><DT
><A
HREF="#BASELIB---WCTOMB-CHK-1"
>__wctomb_chk</A
>&nbsp;--&nbsp;convert a wide character to a multibyte sequence, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMCPY-CHK-1"
>__wmemcpy_chk</A
>&nbsp;--&nbsp;copy an array of wide-characters, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMMOVE-CHK-1"
>__wmemmove_chk</A
>&nbsp;--&nbsp;copy an array of wide-characters, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMPCPY-CHK-1"
>__wmempcpy_chk</A
>&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WMEMSET-CHK-1"
>__wmemset_chk</A
>&nbsp;--&nbsp;fill an array of wide-characters with a constant wide character, with buffer overflow checking</DT
><DT
><A
HREF="#BASELIB---WPRINTF-CHK-1"
>__wprintf_chk</A
>&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DT
><DT
><A
HREF="#BASELIB---XMKNOD-1"
>__xmknod</A
>&nbsp;--&nbsp;make a special file</DT
><DT
><A
HREF="#BASELIB---XMKNODAT-1"
>__xmknodat</A
>&nbsp;--&nbsp;make a special file relative to a directory file descriptor</DT
><DT
><A
HREF="#BASELIB---XPG-BASENAME"
>__xpg_basename</A
>&nbsp;--&nbsp;return the last component of a file name</DT
><DT
><A
HREF="#BASELIB---XPG-SIGPAUSE"
>__xpg_sigpause</A
>&nbsp;--&nbsp;remove a signal from the signal mask and suspend the thread</DT
><DT
><A
HREF="#BASELIB---XPG-STRERROR-R"
>__xpg_strerror_r</A
>&nbsp;--&nbsp;return string describing error number</DT
><DT
><A
HREF="#BASELIB---XSTAT"
>__xstat</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB---XSTAT64"
>__xstat64</A
>&nbsp;--&nbsp;get File Status</DT
><DT
><A
HREF="#BASELIB--ENVIRON"
>_environ</A
>&nbsp;--&nbsp;alias for environ - user environment </DT
><DT
><A
HREF="#BASELIB--NL-MSG-CAT-CNTR"
>_nl_msg_cat_cntr</A
>&nbsp;--&nbsp;new catalog load counter</DT
><DT
><A
HREF="#BASELIB--SYS-ERRLIST"
>_sys_errlist</A
>&nbsp;--&nbsp;array containing the "C" locale strings used by strerror()</DT
><DT
><A
HREF="#BASELIB--SYS-SIGLIST"
>_sys_siglist</A
>&nbsp;--&nbsp;array containing the names of the signal names</DT
><DT
><A
HREF="#BASELIB-ACCT-3"
>acct</A
>&nbsp;--&nbsp;switch process accounting on or off</DT
><DT
><A
HREF="#BASELIB-ADJTIME-2"
>adjtime</A
>&nbsp;--&nbsp;correct the time to allow synchronization of the system clock</DT
><DT
><A
HREF="#BASELIB-ALPHASORT64-1"
>alphasort64</A
>&nbsp;--&nbsp;Comparison function for directory scanning (Large File Support)</DT
><DT
><A
HREF="#BASELIB-ARGZ-ADD"
>argz_add,
argz_add_sep,
argz_append,
argz_count,
argz_create,
argz_create_sep,
argz_delete,
argz_extract,
argz_insert,
argz_next,
argz_replace,
argz_stringify</A
>&nbsp;--&nbsp;Operate on argz vectors</DT
><DT
><A
HREF="#BASELIB-ASPRINTF"
>asprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-BACKTRACE-1"
>backtrace, backtrace_symbols, backtrace_symbols_fd</A
>&nbsp;--&nbsp;runtime stack back tracing</DT
><DT
><A
HREF="#BASELIB-BASENAME-3"
>basename</A
>&nbsp;--&nbsp;return the last component of a file name</DT
><DT
><A
HREF="#BASELIB-BIND-TEXTDOMAIN-CODESET"
>bind_textdomain_codeset</A
>&nbsp;--&nbsp;specify encoding for message retrieval</DT
><DT
><A
HREF="#BASELIB-BINDRESVPORT-3"
>bindresvport</A
>&nbsp;--&nbsp;bind socket to privileged IP port</DT
><DT
><A
HREF="#BASELIB-BINDTEXTDOMAIN"
>bindtextdomain</A
>&nbsp;--&nbsp;specify the location of a message catalog</DT
><DT
><A
HREF="#BASELIB-CFMAKERAW-3"
>cfmakeraw</A
>&nbsp;--&nbsp;get and set terminal attributes</DT
><DT
><A
HREF="#BASELIB-CFSETSPEED-3"
>cfsetspeed</A
>&nbsp;--&nbsp;set terminal input and output data rate</DT
><DT
><A
HREF="#BASELIB-CLEARERR-UNLOCKED-1"
>clearerr_unlocked</A
>&nbsp;--&nbsp;non-thread-safe clearerr</DT
><DT
><A
HREF="#BASELIB-DAEMON-3"
>daemon</A
>&nbsp;--&nbsp;run in the background</DT
><DT
><A
HREF="#BASELIB-DCGETTEXT"
>dcgettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog</DT
><DT
><A
HREF="#BASELIB-DCNGETTEXT"
>dcngettext</A
>&nbsp;--&nbsp;perform domain and category specific lookup in message catalog
with plural</DT
><DT
><A
HREF="#BASELIB-DGETTEXT"
>dgettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current LC_MESSAGES locale</DT
><DT
><A
HREF="#BASELIB-DL-ITERATE-PHDR-1"
>dl_iterate_phdr</A
>&nbsp;--&nbsp;iterate over a program's loaded shared objects</DT
><DT
><A
HREF="#BASELIB-DNGETTEXT"
>dngettext</A
>&nbsp;--&nbsp;perform lookup in message catalog for the current locale</DT
><DT
><A
HREF="#BASELIB-DRAND48-R-1"
>drand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-ENDUTENT-3"
>endutent</A
>&nbsp;--&nbsp;access utmp file entries</DT
><DT
><A
HREF="#BASELIB-ENVZ-ADD"
>envz_add,
envz_entry,
envz_get,
envz_merge,
envz_remove,
envz_strip</A
>&nbsp;--&nbsp;Operate on environment vectors</DT
><DT
><A
HREF="#BASELIB-EPOLL-CREATE-1"
>epoll_create</A
>&nbsp;--&nbsp;open an epoll file descriptor</DT
><DT
><A
HREF="#BASELIB-EPOLL-CTL-1"
>epoll_ctl</A
>&nbsp;--&nbsp;control an epoll file descriptor</DT
><DT
><A
HREF="#BASELIB-EPOLL-WAIT-1"
>epoll_wait</A
>&nbsp;--&nbsp;wait for I/O events on an epoll file descriptor</DT
><DT
><A
HREF="#BASELIB-ERAND48-R-1"
>erand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-ERR-3"
>err</A
>&nbsp;--&nbsp;display formatted error messages</DT
><DT
><A
HREF="#BASELIB-ERROR-N"
>error</A
>&nbsp;--&nbsp;print error message</DT
><DT
><A
HREF="#BASELIB-ERRX-3"
>errx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-FCNTL-3"
>fcntl</A
>&nbsp;--&nbsp;file control</DT
><DT
><A
HREF="#BASELIB-FEOF-UNLOCKED-1"
>feof_unlocked</A
>&nbsp;--&nbsp;non-thread-safe feof</DT
><DT
><A
HREF="#BASELIB-FERROR-UNLOCKED-1"
>ferror_unlocked</A
>&nbsp;--&nbsp;non-thread-safe ferror</DT
><DT
><A
HREF="#BASELIB-FFLUSH-UNLOCKED-1"
>fflush_unlocked</A
>&nbsp;--&nbsp;non thread safe fflush</DT
><DT
><A
HREF="#BASELIB-FGETC-UNLOCKED-1"
>fgetc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fgetc</DT
><DT
><A
HREF="#BASELIB-FGETS-UNLOCKED-1"
>fgets_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fgets</DT
><DT
><A
HREF="#BASELIB-FGETWC-UNLOCKED-1"
>fgetwc_unlocked</A
>&nbsp;--&nbsp;non thread safe fgetwc</DT
><DT
><A
HREF="#BASELIB-FGETWS-UNLOCKED-1"
>fgetws_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fgetws</DT
><DT
><A
HREF="#BASELIB-FILENO-UNLOCKED-1"
>fileno_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fileno</DT
><DT
><A
HREF="#BASELIB-FLOCK-2"
>flock</A
>&nbsp;--&nbsp;apply or remove an advisory lock on an open file</DT
><DT
><A
HREF="#BASELIB-FNMATCH-3"
>fnmatch</A
>&nbsp;--&nbsp;match a filename or a pathname</DT
><DT
><A
HREF="#BASELIB-FPUTC-UNLOCKED-1"
>fputc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputc</DT
><DT
><A
HREF="#BASELIB-FPUTS-UNLOCKED-1"
>fputs_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputs</DT
><DT
><A
HREF="#BASELIB-FPUTWC-UNLOCKED-1"
>fputwc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputwc</DT
><DT
><A
HREF="#BASELIB-FPUTWS-UNLOCKED-1"
>fputws_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fputws</DT
><DT
><A
HREF="#BASELIB-FREAD-UNLOCKED-1"
>fread_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fread</DT
><DT
><A
HREF="#BASELIB-FSCANF"
>fscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-FSTATFS-2"
>fstatfs</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-FSTATFS64"
>fstatfs64</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-FUTIMES"
>futimes</A
>&nbsp;--&nbsp;set file access and modification times</DT
><DT
><A
HREF="#BASELIB-FWRITE-UNLOCKED-1"
>fwrite_unlocked</A
>&nbsp;--&nbsp;non-thread-safe fwrite</DT
><DT
><A
HREF="#BASELIB-FWSCANF"
>fwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-GETCWD"
>getcwd</A
>&nbsp;--&nbsp;get the pathname of the current working directory</DT
><DT
><A
HREF="#BASELIB-GETDOMAINNAME"
>getdomainname</A
>&nbsp;--&nbsp;get NIS domain name (DEPRECATED).</DT
><DT
><A
HREF="#BASELIB-GETDTABLESIZE"
>getdtablesize</A
>&nbsp;--&nbsp;get file descriptor table size (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETGRENT-R-1"
>getgrent_r</A
>&nbsp;--&nbsp;reentrantly get entry in group file</DT
><DT
><A
HREF="#BASELIB-GETGROUPLIST-3"
>getgrouplist</A
>&nbsp;--&nbsp;get groups a user belongs to</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYADDR-R-3"
>gethostbyaddr_r</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYNAME2-3"
>gethostbyname2</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYNAME2-R-3"
>gethostbyname2_r</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETHOSTBYNAME-R-3"
>gethostbyname_r</A
>&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETIFADDRS"
>getifaddrs</A
>&nbsp;--&nbsp;get interface addresses</DT
><DT
><A
HREF="#BASELIB-GETLOADAVG-3"
>getloadavg</A
>&nbsp;--&nbsp;get system load averages</DT
><DT
><A
HREF="#LIBUTIL-GETOPT-3"
>getopt</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-3"
>getopt_long</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETOPT-LONG-ONLY-3"
>getopt_long_only</A
>&nbsp;--&nbsp;parse command line options</DT
><DT
><A
HREF="#BASELIB-GETPAGESIZE"
>getpagesize</A
>&nbsp;--&nbsp;get memory page size (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GETPROTOBYNAME-R"
>getprotobyname_r</A
>&nbsp;--&nbsp;retrieve information from the network protocol database by protocol name, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETPROTOBYNUMBER-R"
>getprotobynumber_r</A
>&nbsp;--&nbsp;retrieve information from the network protocol database by protocol number, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETPROTOENT-R"
>getprotoent_r</A
>&nbsp;--&nbsp;read the next entry of the protocol database, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETPWENT-R-1"
>getpwent_r</A
>&nbsp;--&nbsp;reentrantly get entry in passwd file</DT
><DT
><A
HREF="#BASELIB-GETRLIMIT-1"
>getrlimit, setrlimit</A
>&nbsp;--&nbsp;get resource consumption limits</DT
><DT
><A
HREF="#BASELIB-GETSERVBYNAME-R"
>getservbyname_r</A
>&nbsp;--&nbsp;retrieve information from the network services database by service name, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETSERVBYPORT-R"
>getservbyport_r</A
>&nbsp;--&nbsp;retrieve information from the network services database by service port, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETSERVENT-R"
>getservent_r</A
>&nbsp;--&nbsp;read the next entry of the network services database, reentrantly</DT
><DT
><A
HREF="#BASELIB-GETSOCKOPT-1"
>getsockopt</A
>&nbsp;--&nbsp;get socket options</DT
><DT
><A
HREF="#BASELIB-GETTEXT"
>gettext</A
>&nbsp;--&nbsp;search message catalogs for a string</DT
><DT
><A
HREF="#BASELIB-GETUTENT-3"
>getutent</A
>&nbsp;--&nbsp;access user accounting database entries	</DT
><DT
><A
HREF="#BASELIB-GETUTENT-R-3"
>getutent_r</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-GETWC-UNLOCKED-1"
>getwc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe getwc</DT
><DT
><A
HREF="#BASELIB-GETWCHAR-UNLOCKED-1"
>getwchar_unlocked</A
>&nbsp;--&nbsp;non-thread-safe getwchar</DT
><DT
><A
HREF="#BASELIB-GLOB64"
>glob64</A
>&nbsp;--&nbsp;find pathnames matching a pattern  (Large File Support)</DT
><DT
><A
HREF="#BASELIB-GLOBFREE64"
>globfree64</A
>&nbsp;--&nbsp;free memory from glob64() (Large File Support)</DT
><DT
><A
HREF="#BASELIB-GNU-GET-LIBC-VERSION-1"
>gnu_get_libc_version, gnu_get_libc_release</A
>&nbsp;--&nbsp;get glibc-specific version and release</DT
><DT
><A
HREF="#BASELIB-HCREATE-R"
>hcreate_r</A
>&nbsp;--&nbsp;allocate space for a hash search table, reentrantly</DT
><DT
><A
HREF="#BASELIB-HDESTROY-R"
>hdestroy_r</A
>&nbsp;--&nbsp;dispose of a hash search table, reentrantly</DT
><DT
><A
HREF="#BASELIB-HSEARCH-R"
>hsearch_r</A
>&nbsp;--&nbsp;search a hash table, reentrantly</DT
><DT
><A
HREF="#BASELIB-INET-ATON-3"
>inet_aton</A
>&nbsp;--&nbsp;Internet address manipulation routine</DT
><DT
><A
HREF="#BASELIB-INITGROUPS-3"
>initgroups</A
>&nbsp;--&nbsp;initialize the supplementary group access list</DT
><DT
><A
HREF="#BASELIB-INITSTATE-R-1"
>initstate_r</A
>&nbsp;--&nbsp;reentrantly initialize a state array for random number generator functions</DT
><DT
><A
HREF="#BASELIB-INOTIFY-ADD-WATCH"
>inotify_add_watch</A
>&nbsp;--&nbsp;add a watch to a watch list</DT
><DT
><A
HREF="#BASELIB-INOTIFY-INIT"
>inotify_init</A
>&nbsp;--&nbsp;instantiate inotify</DT
><DT
><A
HREF="#BASELIB-INOTIFY-RM-WATCH"
>inotify_rm_watch</A
>&nbsp;--&nbsp;remove a watch from an inotify watch list</DT
><DT
><A
HREF="#BASELIB-IOCTL-2"
>ioctl</A
>&nbsp;--&nbsp;control device</DT
><DT
><A
HREF="#BASELIB-SOCKIO-2"
>sockio</A
>&nbsp;--&nbsp;socket ioctl commands</DT
><DT
><A
HREF="#BASELIB-TTYIO-2"
>ttyio</A
>&nbsp;--&nbsp;tty ioctl commands</DT
><DT
><A
HREF="#BASELIB-JRAND48-R-1"
>jrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-KILL-3"
>kill</A
>&nbsp;--&nbsp;send a signal</DT
><DT
><A
HREF="#BASELIB-LCONG48-R-1"
>lcong48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-LINK-1"
>link</A
>&nbsp;--&nbsp;create a link to a file</DT
><DT
><A
HREF="#BASELIB-LRAND48-R-1"
>lrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-MEMMEM-3"
>memmem</A
>&nbsp;--&nbsp;locate bytes</DT
><DT
><A
HREF="#BASELIB-MEMRCHR"
>memrchr</A
>&nbsp;--&nbsp;scan memory for a character</DT
><DT
><A
HREF="#BASELIB-MKSTEMP64"
>mkstemp64</A
>&nbsp;--&nbsp;create a unique temporary file (Large File Support)</DT
><DT
><A
HREF="#BASELIB-MRAND48-R-1"
>mrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-MREMAP"
>mremap</A
>&nbsp;--&nbsp;remap a virtual memory address</DT
><DT
><A
HREF="#BASELIB-NGETTEXT"
>ngettext</A
>&nbsp;--&nbsp;search message catalogs for plural string</DT
><DT
><A
HREF="#BASELIB-NRAND48-R-1"
>nrand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-OPENAT64"
>openat64</A
>&nbsp;--&nbsp;open a file relative to a directory file descriptor (Large File Support)</DT
><DT
><A
HREF="#BASELIB-PMAP-GETPORT-3"
>pmap_getport</A
>&nbsp;--&nbsp;find the port number assigned to a service registered with a
portmapper.</DT
><DT
><A
HREF="#BASELIB-PMAP-SET-3"
>pmap_set</A
>&nbsp;--&nbsp;establishes mapping to machine's RPC Bind service.</DT
><DT
><A
HREF="#BASELIB-PMAP-UNSET-3"
>pmap_unset</A
>&nbsp;--&nbsp;
destroys RPC Binding&#13;</DT
><DT
><A
HREF="#BASELIB-POSIX-FADVISE64"
>posix_fadvise64</A
>&nbsp;--&nbsp;File advisory information (Large File Support)</DT
><DT
><A
HREF="#BASELIB-POSIX-FALLOCATE64"
>posix_fallocate64</A
>&nbsp;--&nbsp;file space control (Large File Support)</DT
><DT
><A
HREF="#BASELIB-PREAD64"
>pread64</A
>&nbsp;--&nbsp;read from a file (Large File Support)</DT
><DT
><A
HREF="#BASELIB-PTRACE-1"
>ptrace</A
>&nbsp;--&nbsp;process trace</DT
><DT
><A
HREF="#BASELIB-PUTWC-UNLOCKED-1"
>putwc_unlocked</A
>&nbsp;--&nbsp;non-thread-safe putwc</DT
><DT
><A
HREF="#BASELIB-PUTWCHAR-UNLOCKED-1"
>putwchar_unlocked</A
>&nbsp;--&nbsp;non-thread-safe putwchar</DT
><DT
><A
HREF="#BASELIB-PWRITE64"
>pwrite64</A
>&nbsp;--&nbsp;write on a file (Large File Support)</DT
><DT
><A
HREF="#BASELIB-RANDOM-R-1"
>random_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-READDIR64-R"
>readdir64_r</A
>&nbsp;--&nbsp;read a directory (Large File Support)</DT
><DT
><A
HREF="#BASELIB-REGEXEC-2"
>regexec</A
>&nbsp;--&nbsp;regular expression matching</DT
><DT
><A
HREF="#BASELIB-SCANDIR64-1"
>scandir64</A
>&nbsp;--&nbsp;scan a directory (Large File Support)</DT
><DT
><A
HREF="#BASELIB-SCANF"
>scanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SCHED-GETAFFINITY"
>sched_getaffinity</A
>&nbsp;--&nbsp;retrieve the affinity mask of a process</DT
><DT
><A
HREF="#BASELIB-SCHED-SETAFFINITY"
>sched_setaffinity</A
>&nbsp;--&nbsp;set the CPU affinity mask for a process</DT
><DT
><A
HREF="#BASELIB-SCHED-SETSCHEDULER"
>sched_setscheduler</A
>&nbsp;--&nbsp;set scheduling policy and parameters</DT
><DT
><A
HREF="#BASELIB-SEED48-R-1"
>seed48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-SENDFILE"
>sendfile</A
>&nbsp;--&nbsp;transfer data between two file descriptors</DT
><DT
><A
HREF="#BASELIB-SENDFILE64"
>sendfile64</A
>&nbsp;--&nbsp;transfer data between two file descriptors (Large File Support)</DT
><DT
><A
HREF="#BASELIB-SETBUFFER-3"
>setbuffer</A
>&nbsp;--&nbsp;stream buffering operation</DT
><DT
><A
HREF="#BASELIB-SETGROUPS-2"
>setgroups</A
>&nbsp;--&nbsp;set list of supplementary group IDs</DT
><DT
><A
HREF="#BASELIB-SETHOSTNAME-2"
>sethostname</A
>&nbsp;--&nbsp;set host name</DT
><DT
><A
HREF="#BASELIB-SETSOCKOPT-2"
>setsockopt</A
>&nbsp;--&nbsp;set socket options</DT
><DT
><A
HREF="#BASELIB-SETSTATE-R-1"
>setstate_r</A
>&nbsp;--&nbsp;reentrantly change the state array used by random number generator functions</DT
><DT
><A
HREF="#BASELIB-SETUTENT-3"
>setutent</A
>&nbsp;--&nbsp;access user accounting database entries</DT
><DT
><A
HREF="#BASELIB-SIGANDSET"
>sigandset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical AND</DT
><DT
><A
HREF="#BASELIB-SIGISEMPTYSET"
>sigisemptyset</A
>&nbsp;--&nbsp;check for empty signal set</DT
><DT
><A
HREF="#BASELIB-SIGORSET"
>sigorset</A
>&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical OR</DT
><DT
><A
HREF="#BASELIB-SIGPAUSE-3"
>sigpause</A
>&nbsp;--&nbsp;remove a signal from the signal mask and suspend the thread (deprecated)</DT
><DT
><A
HREF="#BASELIB-SIGRETURN-2"
>sigreturn</A
>&nbsp;--&nbsp;return from signal handler and cleanup stack frame</DT
><DT
><A
HREF="#BASELIB-SRAND48-R-1"
>srand48_r</A
>&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DT
><DT
><A
HREF="#BASELIB-SRANDOM-R-1"
>srandom_r</A
>&nbsp;--&nbsp;reentrantly set the seed for a new sequence of pseudorandom numbers</DT
><DT
><A
HREF="#BASELIB-SSCANF"
>sscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-STATFS-2"
>statfs</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-STATFS64"
>statfs64</A
>&nbsp;--&nbsp;(deprecated)</DT
><DT
><A
HREF="#BASELIB-STIME-2"
>stime</A
>&nbsp;--&nbsp;set time</DT
><DT
><A
HREF="#BASELIB-STRCASESTR"
>strcasestr</A
>&nbsp;--&nbsp;locate a substring ignoring case</DT
><DT
><A
HREF="#BASELIB-STRERROR-R"
>strerror_r</A
>&nbsp;--&nbsp;return string describing error number</DT
><DT
><A
HREF="#BASELIB-STRPTIME-3"
>strptime</A
>&nbsp;--&nbsp;parse a time string</DT
><DT
><A
HREF="#BASELIB-STRSEP-3"
>strsep</A
>&nbsp;--&nbsp;extract token from string</DT
><DT
><A
HREF="#BASELIB-STRTOQ-3"
>strtoq</A
>&nbsp;--&nbsp;convert string value to a long or quad_t integer</DT
><DT
><A
HREF="#BASELIB-STRTOUQ-3"
>strtouq</A
>&nbsp;--&nbsp;convert a string to an unsigned long long</DT
><DT
><A
HREF="#BASELIB-SVC-REGISTER-3"
>svc_register</A
>&nbsp;--&nbsp;register Remote Procedure Call interface</DT
><DT
><A
HREF="#BASELIB-SVC-RUN-3"
>svc_run</A
>&nbsp;--&nbsp;waits for RPC requests to arrive and calls service procedure</DT
><DT
><A
HREF="#BASELIB-SVC-SENDREPLY-3"
>svc_sendreply</A
>&nbsp;--&nbsp;called by RPC service's dispatch routine</DT
><DT
><A
HREF="#BASELIB-SVCTCP-CREATE-3"
>svctcp_create</A
>&nbsp;--&nbsp;create a TCP/IP-based RPC service transport</DT
><DT
><A
HREF="#BASELIB-SVCUDP-CREATE-3"
>svcudp_create</A
>&nbsp;--&nbsp;		create a UDP-based RPC service transport
		</DT
><DT
><A
HREF="#BASELIB-SWSCANF"
>swscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-SYSCONF"
>sysconf</A
>&nbsp;--&nbsp;Get configuration information at runtime</DT
><DT
><A
HREF="#BASELIB-SYSINFO-1"
>sysinfo</A
>&nbsp;--&nbsp;return system information</DT
><DT
><A
HREF="#BASELIB-SYSTEM-3"
>system</A
>&nbsp;--&nbsp;execute a shell command</DT
><DT
><A
HREF="#BASELIB-TEXTDOMAIN"
>textdomain</A
>&nbsp;--&nbsp;set the current default message domain</DT
><DT
><A
HREF="#BASELIB-UNLINK-3"
>unlink</A
>&nbsp;--&nbsp;remove a directory entry</DT
><DT
><A
HREF="#BASELIB-UTMPNAME-3"
>utmpname</A
>&nbsp;--&nbsp;set user accounting database</DT
><DT
><A
HREF="#BASELIB-VASPRINTF"
>vasprintf</A
>&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DT
><DT
><A
HREF="#BASELIB-VERRX-3"
>verrx</A
>&nbsp;--&nbsp;display formatted error message and exit</DT
><DT
><A
HREF="#BASELIB-VFSCANF"
>vfscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VFWSCANF"
>vfwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSCANF"
>vscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSSCANF"
>vsscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSWSCANF"
>vswscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-VSYSLOG-3"
>vsyslog</A
>&nbsp;--&nbsp;log to system log</DT
><DT
><A
HREF="#BASELIB-VWSCANF"
>vwscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-WAIT4-2"
>wait4</A
>&nbsp;--&nbsp;wait for process termination, BSD style</DT
><DT
><A
HREF="#BASELIB-WARN-3"
>warn</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WARNX-3"
>warnx</A
>&nbsp;--&nbsp;formatted error messages</DT
><DT
><A
HREF="#BASELIB-WCSTOQ"
>wcstoq</A
>&nbsp;--&nbsp;convert wide string to long long int representation</DT
><DT
><A
HREF="#BASELIB-WCSTOUQ"
>wcstouq</A
>&nbsp;--&nbsp;convert wide string to unsigned long long int representation</DT
><DT
><A
HREF="#BASELIB-WSCANF"
>wscanf</A
>&nbsp;--&nbsp;convert formatted input</DT
><DT
><A
HREF="#BASELIB-XDR-U-INT-3"
>xdr_u_int</A
>&nbsp;--&nbsp;library routines for external data representation</DT
><DT
><A
HREF="#BASELIB-XDRSTDIO-CREATE-3"
>xdrstdio_create</A
>&nbsp;--&nbsp;library routines for external data representation</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libc and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBC"
>Section 14.3</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB--IO-FEOF-3"
></A
>_IO_feof</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7783"
></A
><H2
>Name</H2
>_IO_feof&nbsp;--&nbsp;alias for feof</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7786"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7789"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_feof</TT
></CODE
>(_IO_FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__fp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7796"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_feof()</TT
> tests the end-of-file indicator for the 
stream pointed to by <TT
CLASS="PARAMETER"
><I
>__fp</I
></TT
>, returning a non-zero 
value if it is set.  </P
><P
><TT
CLASS="FUNCTION"
>_IO_feof()</TT
> is not in the source standard; it is only 
in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--IO-GETC-3"
></A
>_IO_getc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7809"
></A
><H2
>Name</H2
>_IO_getc&nbsp;--&nbsp;alias for getc</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7812"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7815"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_getc</TT
></CODE
>(_IO_FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__fp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7822"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_getc()</TT
> reads the next character from 
<TT
CLASS="PARAMETER"
><I
>__fp</I
></TT
> and returns it as an unsigned char cast 
to an int, or <CODE
CLASS="VARNAME"
>EOF</CODE
> on end-of-file or error.</P
><P
><TT
CLASS="FUNCTION"
>_IO_getc()</TT
> is not in the source standard; it is 
only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--IO-PUTC-3"
></A
>_IO_putc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7836"
></A
><H2
>Name</H2
>_IO_putc&nbsp;--&nbsp;alias for putc</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7839"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7842"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_putc</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__c</I
></TT
></I
></TT
>, _IO_FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__fp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7852"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_putc()</TT
> writes the character 
<TT
CLASS="PARAMETER"
><I
>__c</I
></TT
>, cast to an unsigned char, to 
<TT
CLASS="PARAMETER"
><I
>__fp</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>_IO_putc()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--IO-PUTS-3"
></A
>_IO_puts</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7866"
></A
><H2
>Name</H2
>_IO_puts&nbsp;--&nbsp;alias for puts</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7869"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7872"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>_IO_puts</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__c</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7879"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_IO_puts()</TT
> writes the string <TT
CLASS="PARAMETER"
><I
>__s</I
></TT
> 
and a trailing newline to <CODE
CLASS="VARNAME"
>stdout</CODE
>.</P
><P
><TT
CLASS="FUNCTION"
>_IO_puts()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ASSERT-FAIL-1"
></A
>__assert_fail</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7893"
></A
><H2
>Name</H2
>__assert_fail&nbsp;--&nbsp;abort the program after false assertion</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7896"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7897"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>__assert_fail</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>assertion</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></I
></TT
>, unsigned int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>line</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>function</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7913"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__assert_fail()</TT
> function is used to
implement the <TT
CLASS="FUNCTION"
>assert()</TT
> interface of
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
The <TT
CLASS="FUNCTION"
>__assert_fail()</TT
> function 
shall print the given <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> filename,
<TT
CLASS="PARAMETER"
><I
>line</I
></TT
> line number, 
<TT
CLASS="PARAMETER"
><I
>function</I
></TT
> function name and a message
on the standard error stream in an unspecified format, and abort
program execution via the <TT
CLASS="FUNCTION"
>abort()</TT
> function.
For example:
<A
NAME="AEN7924"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>a.c:10: foobar: Assertion a == b failed.</P
></BLOCKQUOTE
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>function</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>, 
<TT
CLASS="FUNCTION"
>__assert_fail()</TT
> shall omit
information about the function.</P
><P
><TT
CLASS="PARAMETER"
><I
>assertion</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, and
<TT
CLASS="PARAMETER"
><I
>line</I
></TT
> shall be non-<TT
CLASS="LITERAL"
>NULL</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__assert_fail()</TT
> function
is not in the source standard; 
it is only in the binary standard.
The <TT
CLASS="FUNCTION"
>assert()</TT
> interface is not in the binary standard;
it is only in the source standard. The <TT
CLASS="FUNCTION"
>assert()</TT
> may
be implemented as a macro.</P
></DIV
><H1
><A
NAME="BASELIB---CHK-FAIL-1"
></A
>__chk_fail</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7943"
></A
><H2
>Name</H2
>__chk_fail&nbsp;--&nbsp;terminate a function in case of buffer overflow</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7948"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7949"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>__chk_fail</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7954"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__chk_fail()</TT
>
shall abort the function that called it with a message that
a buffer overflow has been detected.
The program that called the function shall then exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__chk_fail()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7960"
></A
><H2
>Application Usage (informative)</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__chk_fail()</TT
>
does not check for a buffer overflow itself.
It merely reports one when invoked.</P
></DIV
><H1
><A
NAME="BASELIB---CONFSTR-CHK-1"
></A
>__confstr_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7968"
></A
><H2
>Name</H2
>__confstr_chk&nbsp;--&nbsp;get configuration dependent string variables, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7973"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN7974"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__confstr_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7987"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__confstr_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>confstr()</TT
>, except that
<TT
CLASS="FUNCTION"
>__confstr_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__confstr_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---CTYPE-B-LOC"
></A
>__ctype_b_loc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8004"
></A
><H2
>Name</H2
>__ctype_b_loc&nbsp;--&nbsp;accessor function for __ctype_b array for ctype functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8007"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8010"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const unsigned short * *
    <TT
CLASS="FUNCTION"
>__ctype_b_loc</TT
>
  </CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8016"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_b_loc()</TT
>
function shall return a pointer into an array of
characters in the current locale that contains characteristics for each
character in the current character set. The array shall contain a total of 
<CODE
CLASS="CONSTANT"
>384</CODE
>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CODE
CLASS="CONSTANT"
>-128</CODE
> and 
<CODE
CLASS="CONSTANT"
>255</CODE
>). If the application is multithreaded, the 
array shall be local to the current thread. </P
><P
>This interface is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8026"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_b_loc()</TT
> function shall return a pointer
to the array of characters to be used for the <TT
CLASS="FUNCTION"
>ctype()</TT
>
family of functions (see <TT
CLASS="FILENAME"
>&#60;ctype.h&#62;</TT
>).</P
></DIV
><H1
><A
NAME="BASELIB---CTYPE-GET-MB-CUR-MAX-1"
></A
>__ctype_get_mb_cur_max</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8036"
></A
><H2
>Name</H2
>__ctype_get_mb_cur_max&nbsp;--&nbsp;maximum length of a multibyte character in the current locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8039"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8042"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>__ctype_get_mb_cur_max</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8047"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__ctype_get_mb_cur_max()</TT
> returns the maximum 
length of a multibyte character in the current locale.</P
><P
><TT
CLASS="FUNCTION"
>__ctype_get_mb_cur_max()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="LIBUTIL---CTYPE-TOLOWER-LOC"
></A
>__ctype_tolower_loc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8059"
></A
><H2
>Name</H2
>__ctype_tolower_loc&nbsp;--&nbsp;accessor function for __ctype_b_tolower array for ctype tolower() function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8062"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8065"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int32_t * *
  <TT
CLASS="FUNCTION"
>__ctype_tolower_loc</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8071"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_tolower_loc()</TT
>
function shall return a pointer into an array of
characters in the current locale that contains lower case equivalents for each
character in the current character set. The array shall contain a total of 
<CODE
CLASS="CONSTANT"
>384</CODE
>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CODE
CLASS="CONSTANT"
>-128</CODE
> and 
<CODE
CLASS="CONSTANT"
>255</CODE
>). If the application is multithreaded, the 
array shall be local to the current thread. </P
><P
>This interface is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8081"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_tolower_loc()</TT
> function shall return a pointer
to the array of characters to be used for the <TT
CLASS="FUNCTION"
>ctype()</TT
>
family of functions (see <TT
CLASS="FILENAME"
>&#60;ctype.h&#62;</TT
>).</P
></DIV
><H1
><A
NAME="LIBUTIL---CTYPE-TOUPPER-LOC"
></A
>__ctype_toupper_loc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8091"
></A
><H2
>Name</H2
>__ctype_toupper_loc&nbsp;--&nbsp;accessor function for <TT
CLASS="FUNCTION"
>__ctype_b_toupper()</TT
>
array for ctype <TT
CLASS="FUNCTION"
>toupper()</TT
> function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8096"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8099"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ctype.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int32_t * *
  <TT
CLASS="FUNCTION"
>__ctype_toupper_loc</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8105"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_toupper_loc()</TT
>
function shall return a pointer into an array of
characters in the current locale that contains upper case equivalents for each
character in the current character set. The array shall contain a total of 
<CODE
CLASS="CONSTANT"
>384</CODE
>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CODE
CLASS="CONSTANT"
>-128</CODE
> and 
<CODE
CLASS="CONSTANT"
>255</CODE
>). If the application is multithreaded, the 
array shall be local to the current thread. </P
><P
>This interface is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8115"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__ctype_toupper_loc()</TT
> function shall return a pointer
to the array of characters to be used for the <TT
CLASS="FUNCTION"
>ctype()</TT
>
family of functions (see <TT
CLASS="FILENAME"
>&#60;ctype.h&#62;</TT
>).</P
></DIV
><H1
><A
NAME="BASELIB---CXA-ATEXIT"
></A
>__cxa_atexit</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8125"
></A
><H2
>Name</H2
>__cxa_atexit&nbsp;--&nbsp;register a function to be called by exit or when a shared library is unloaded</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8128"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8131"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__cxa_atexit</TT
></CODE
>(void (*<TT
CLASS="PARAMETER"
><I
>func</I
></TT
>)
  (void *), void *
  <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>, void *
  <TT
CLASS="PARAMETER"
><I
>dso_handle</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8142"
></A
><H2
>Description</H2
><P
>As described in the <A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
>,
<TT
CLASS="FUNCTION"
>__cxa_atexit()</TT
> registers a destructor function to be called by 
<TT
CLASS="FUNCTION"
>exit()</TT
> or when a shared library is unloaded. 
When a shared library is unloaded, any destructor function associated with that
shared library, identified by <TT
CLASS="PARAMETER"
><I
>dso_handle</I
></TT
>, shall be called
with the single argument <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>, and then that function shall
be removed, or marked as complete, from the list of functions to run at 
<TT
CLASS="FUNCTION"
>exit()</TT
>.
On a call to <TT
CLASS="FUNCTION"
>exit()</TT
>,
any remaining functions registered shall be called 
with the single argument <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>.
Destructor functions shall always be called in the reverse order to their
registration (i.e. the most recently registered function shall be called first),</P
><P
>The <TT
CLASS="FUNCTION"
>__cxa_atexit()</TT
> function is used to implement
<TT
CLASS="FUNCTION"
>atexit()</TT
>, as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
Calling <TT
CLASS="LITERAL"
>atexit(func)</TT
> from the statically linked part of
an application shall be equivalent to
<TT
CLASS="LITERAL"
>__cxa_atexit(func, NULL, NULL)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__cxa_atexit()</TT
> is not in the source standard; 
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><TT
CLASS="FUNCTION"
>atexit()</TT
> is not in the binary standard; 
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB---CXA-FINALIZE"
></A
>__cxa_finalize</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8170"
></A
><H2
>Name</H2
>__cxa_finalize&nbsp;--&nbsp;call destructors of global (or local static) C++
objects and exit functions registered with atexit</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8173"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8174"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>__cxa_finalize</TT
></CODE
>(void *
<TT
CLASS="PARAMETER"
><I
>d</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8180"
></A
><H2
>Description</H2
><P
>As described in the Itanium C++ ABI, the C runtime library shall
maintain a list of termination function entries containing the
following information:</P
><P
></P
><UL
><LI
><P
>A pointer to a termination function.</P
></LI
><LI
><P
>An operand to be passed to the function.</P
></LI
><LI
><P
>A handle identifying the home shared library of the
entry.</P
></LI
></UL
><P
>The list is populated by entries of two kinds:</P
><P
></P
><UL
><LI
><P
>Destructors of global (or local static) C++ objects that require
destruction on exit.</P
></LI
><LI
><P
>Functions registered by the user with atexit().</P
></LI
></UL
><P
>In the former case an entry consists of a pointer to the destructor,
a pointer to the corresponding object and a handle for the home shared
library of the object. In the latter case the pointer to the function
is the pointer passed to atexit(), while the other pointers are NULL.</P
><P
>When __cxa_finalize(d) is called, it shall walk the termination function
list, calling each in turn if d matches the handle of the termination
function entry. If d is NULL, it shall call all the termination
funtions. Multiple calls to __cxa_finalize shall not result in calling
termination function entries multiple times; the implementation may either
remove entries or mark them finished. The termination functions shall
always be called in the reverse order of their registration (i.e. the
most recently registered function shall be called first).</P
><P
>An application shall not call __cxa_finalize() directly. The
implementation shall arrange for__cxa_finalize() to be called during
early shared library unload (e.g. dlclose()) with a handle to the shared
library. When the main program calls exit, the implementation shall cause
any remaining __cxa_atexit-registered functions to be called, either by
calling __cxa_finalize(NULL), or by walking the registration list
itself.</P
><P
>__cxa_finalize() is not in the source standard; it is only in the binary
standard.</P
></DIV
><H1
><A
NAME="BASELIB---DAYLIGHT"
></A
>__daylight</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8204"
></A
><H2
>Name</H2
>__daylight&nbsp;--&nbsp;external daylight savings time flag</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8207"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int <CODE
CLASS="VARNAME"
>__daylight</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8210"
></A
><H2
>Description</H2
><P
>The external variable <CODE
CLASS="VARNAME"
>__daylight</CODE
> 
shall implement the daylight savings time flag <CODE
CLASS="VARNAME"
>daylight</CODE
>
as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<CODE
CLASS="VARNAME"
>__daylight</CODE
> has the same specification as 
<CODE
CLASS="VARNAME"
>daylight</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB---ENVIRON"
></A
>__environ</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8222"
></A
><H2
>Name</H2
>__environ&nbsp;--&nbsp;alias for environ - user environment </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8225"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern char **<CODE
CLASS="VARNAME"
>__environ</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8230"
></A
><H2
>Description</H2
><P
>The external variable <CODE
CLASS="VARNAME"
>__environ</CODE
> 
shall implement the environment variable <CODE
CLASS="VARNAME"
>environ</CODE
>
as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<CODE
CLASS="VARNAME"
>__environ</CODE
> has the same specification as 
<CODE
CLASS="VARNAME"
>environ</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB---ERRNO-LOCATION"
></A
>__errno_location</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8244"
></A
><H2
>Name</H2
>__errno_location&nbsp;--&nbsp;address of errno variable</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8247"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8250"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int *
  <TT
CLASS="FUNCTION"
>__errno_location</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8255"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__errno_location()</TT
> function shall return
the address of the <CODE
CLASS="VARNAME"
>errno</CODE
> variable for the current
thread.</P
><P
><TT
CLASS="FUNCTION"
>__errno_location()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FGETS-CHK-1"
></A
>__fgets_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8268"
></A
><H2
>Name</H2
>__fgets_chk&nbsp;--&nbsp;string input, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8273"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8274"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__fgets_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
>, FILE *
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8287"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__fgets_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>fgets()</TT
>, except that
<TT
CLASS="FUNCTION"
>__fgets_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__fgets_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FGETS-UNLOCKED-CHK-1"
></A
>__fgets_unlocked_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8302"
></A
><H2
>Name</H2
>__fgets_unlocked_chk&nbsp;--&nbsp;non-locking string input, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8307"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8308"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__fgets_unlocked_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
>, FILE *
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8321"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__fgets_unlocked_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>fgets_unlocked()</TT
>, except that
<TT
CLASS="FUNCTION"
>__fgets_unlocked_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__fgets_unlocked_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FGETWS-CHK-1"
></A
>__fgetws_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8336"
></A
><H2
>Name</H2
>__fgetws_chk&nbsp;--&nbsp;read a wide-character string from a FILE stream, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8341"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8342"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__fgetws_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>ws</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
>, FILE *
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8355"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__fgetws_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>fgetws()</TT
>, except that
<TT
CLASS="FUNCTION"
>__fgetws_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__fgetws_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FGETWS-UNLOCKED-CHK-1"
></A
>__fgetws_unlocked_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8370"
></A
><H2
>Name</H2
>__fgetws_unlocked_chk&nbsp;--&nbsp;read a wide-character string from a FILE stream in a non-locking manner, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8375"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8376"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__fgetws_unlocked_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>ws</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, FILE *
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8389"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__fgetws_unlocked_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>fgetws_unlocked()</TT
>, except that
<TT
CLASS="FUNCTION"
>__fgetws_unlocked_chk()</TT
> shall check for stack overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>strsize</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__fgetws_unlocked_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FPENDING"
></A
>__fpending</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8404"
></A
><H2
>Name</H2
>__fpending&nbsp;--&nbsp;returns in bytes the amount of output pending on a stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8407"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8410"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t 
  <TT
CLASS="FUNCTION"
>__fpending</TT
></CODE
>(FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>stream</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8417"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__fpending()</TT
> returns the amount of output in bytes 
pending on a stream.</P
><P
><TT
CLASS="FUNCTION"
>__fpending()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FPRINTF-CHK-1"
></A
>__fprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8429"
></A
><H2
>Name</H2
>__fprintf_chk&nbsp;--&nbsp;convert formatted output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8434"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8435"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__fprintf_chk</TT
></CODE
>(FILE *
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8446"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__fprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>fprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__fprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__fprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FWPRINTF-CHK-1"
></A
>__fwprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8461"
></A
><H2
>Name</H2
>__fwprintf_chk&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8466"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8467"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__fwprintf_chk</TT
></CODE
>(FILE *
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8478"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__fwprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>fwprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__fwprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__fwprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FXSTATAT-1"
></A
>__fxstatat</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8493"
></A
><H2
>Name</H2
>__fxstatat&nbsp;--&nbsp;get file status relative to directory file descriptor</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8498"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8499"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fcntl.h&#62;
#include &#60;sys/stat.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__fxstatat</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>ver</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, struct stat *
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8514"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__fxstatat()</TT
> function shall implement the
<TT
CLASS="FUNCTION"
>fstatat()</TT
> function.
The behavior of <TT
CLASS="FUNCTION"
>__fxstatat()</TT
> 
for values of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> other than
<TT
CLASS="LITERAL"
>_STAT_VER</TT
> is undefined.
See Data Definitions in the architecture specific part of this 
specification for the correct value of <TT
CLASS="LITERAL"
>_STAT_VER</TT
>.</P
><P
><TT
CLASS="LITERAL"
>__fxstatat(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>, 
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>)</TT
>
shall behave as
<TT
CLASS="LITERAL"
>fstatat(<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__fxstatat()</TT
> is not in the source standard;
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>fstatat()</TT
> function is not in the binary standard;
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB---FXSTATAT64-1"
></A
>__fxstatat64, fstatat64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8543"
></A
><H2
>Name</H2
>__fxstatat64, fstatat64&nbsp;--&nbsp;get file status relative to a directory file descriptor (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8550"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8551"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fcntl.h&#62;
#include &#60;sys/stat.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__fxstatat64</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>ver</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, struct stat64 *
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>fstatat64</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, struct stat64 *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8577"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fstatat64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>fstatat()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
It differs from <TT
CLASS="FUNCTION"
>fstatat()</TT
> 
only in that the <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> parameter
refers to a large-file version of the stat structure.</P
><P
>The <TT
CLASS="FUNCTION"
>__fxstatat64()</TT
> function shall implement the
<TT
CLASS="FUNCTION"
>fstatat64()</TT
> function.
The behavior of <TT
CLASS="FUNCTION"
>__fxstatat64()</TT
> 
for values of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> other than
<TT
CLASS="LITERAL"
>_STAT_VER</TT
> is undefined.
See Data Definitions in the architecture specific part of this 
specification for the correct value of <TT
CLASS="LITERAL"
>_STAT_VER</TT
>.</P
><P
><TT
CLASS="LITERAL"
>__fxstatat64(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>, 
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>)</TT
>
shall behave as
<TT
CLASS="LITERAL"
>fstatat64(<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>)</TT
></P
><P
><TT
CLASS="FUNCTION"
>__fxstatat64()</TT
> is not in the source standard;
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>fstatat64()</TT
> function is not in the binary standard;
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB---GETCWD-CHK-1"
></A
>__getcwd_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8611"
></A
><H2
>Name</H2
>__getcwd_chk&nbsp;--&nbsp;get current working directory, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8616"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8617"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__getcwd_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8628"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__getcwd_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>getcwd()</TT
>, except that
<TT
CLASS="FUNCTION"
>__getcwd_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__getcwd_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETGROUPS-CHK-1"
></A
>__getgroups_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8645"
></A
><H2
>Name</H2
>__getgroups_chk&nbsp;--&nbsp;get list of supplementary group IDs, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8650"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8651"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__getgroups_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, gid_t *
<TT
CLASS="PARAMETER"
><I
>list</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>listlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8662"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__getgroups_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>getgroups()</TT
>, except that
<TT
CLASS="FUNCTION"
>__getgroups_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>listlen</I
></TT
> specifies the size in bytes of the object
<TT
CLASS="PARAMETER"
><I
>list</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__getgroups_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETHOSTNAME-CHK-1"
></A
>__gethostname_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8677"
></A
><H2
>Name</H2
>__gethostname_chk&nbsp;--&nbsp;get host name, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8682"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8683"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__gethostname_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8694"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__gethostname_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>gethostname()</TT
>, except that
<TT
CLASS="FUNCTION"
>__gethostname_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__gethostname_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETLOGIN-R-CHK-1"
></A
>__getlogin_r_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8711"
></A
><H2
>Name</H2
>__getlogin_r_chk&nbsp;--&nbsp;get user name, with buffer overflow checking (reentrant)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8716"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8717"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__getlogin_r_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8728"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__getlogin_r_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>getlogin_r()</TT
>, except that
<TT
CLASS="FUNCTION"
>__getlogin_r_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__getlogin_r_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETPAGESIZE"
></A
>__getpagesize</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8745"
></A
><H2
>Name</H2
>__getpagesize&nbsp;--&nbsp;alias for getpagesize - get current page size </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8748"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8751"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__getpagesize</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8756"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__getpagesize()</TT
> is an alias for 
<TT
CLASS="FUNCTION"
>getpagesize()</TT
> - get current page size.</P
><P
><TT
CLASS="FUNCTION"
>__getpagesize()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>getpagesize()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__getpagesize()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---GETPGID-1"
></A
>__getpgid</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8772"
></A
><H2
>Name</H2
>__getpgid&nbsp;--&nbsp;get the process group id</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8775"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8778"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>pid_t 
  <TT
CLASS="FUNCTION"
>__getpgid</TT
></CODE
>(pid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pid</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8785"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__getpgid()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>getpgid()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__getpgid()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---H-ERRNO-LOCATION"
></A
>__h_errno_location</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8798"
></A
><H2
>Name</H2
>__h_errno_location&nbsp;--&nbsp;address of h_errno variable</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8801"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8804"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int *
  <TT
CLASS="FUNCTION"
>__h_errno_location</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8809"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__h_errno_location()</TT
> returns the address of the 
<CODE
CLASS="VARNAME"
>h_errno</CODE
> variable, where <CODE
CLASS="VARNAME"
>h_errno</CODE
> 
is as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__h_errno_location()</TT
> is not in the source standard; 
it is only in the binary standard. Note that <CODE
CLASS="VARNAME"
>h_errno</CODE
> 
itself is only in the source standard; it is not in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISINF"
></A
>__isinf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8825"
></A
><H2
>Name</H2
>__isinf&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8828"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8829"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isinf</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8836"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isinf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isinf()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isinf()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__isinf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISINFF"
></A
>__isinff</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8849"
></A
><H2
>Name</H2
>__isinff&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8852"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8853"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isinff</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8860"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isinff()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isinf()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isinff()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__isinff()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISINFL"
></A
>__isinfl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8873"
></A
><H2
>Name</H2
>__isinfl&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8876"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8877"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isinfl</TT
></CODE
>(long double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8884"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isinfl()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isinf()</TT
> in the <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isinfl()</TT
> is known to be long double.</P
><P
><TT
CLASS="FUNCTION"
>__isinfl()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISNAN"
></A
>__isnan</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8897"
></A
><H2
>Name</H2
>__isnan&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8900"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8901"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isnan</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8908"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isnan()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isnan()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isnan()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__isnan()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISNANF"
></A
>__isnanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8921"
></A
><H2
>Name</H2
>__isnanf&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8924"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8925"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isnanf</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8932"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isnanf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isnan()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isnanf()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__isnanf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---ISNANL"
></A
>__isnanl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8945"
></A
><H2
>Name</H2
>__isnanl&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8948"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8949"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__isnanl</TT
></CODE
>(long double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8956"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__isnanl()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isnan()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__isnanl()</TT
> is known to be long double.</P
><P
><TT
CLASS="FUNCTION"
>__isnanl()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---LIBC-CURRENT-SIGRTMAX-1"
></A
>__libc_current_sigrtmax</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8969"
></A
><H2
>Name</H2
>__libc_current_sigrtmax&nbsp;--&nbsp;return number of available real-time signal with lowest priority</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8972"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8975"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__libc_current_sigrtmax</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN8980"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmax()</TT
> returns the number of 
an available real-time signal with the lowest priority.</P
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmax()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---LIBC-CURRENT-SIGRTMIN-1"
></A
>__libc_current_sigrtmin</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8992"
></A
><H2
>Name</H2
>__libc_current_sigrtmin&nbsp;--&nbsp;return number of available real-time signal with highest priority</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN8995"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN8998"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__libc_current_sigrtmin</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9003"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmin()</TT
> returns the number of 
an available real-time signal with the highest priority.</P
><P
><TT
CLASS="FUNCTION"
>__libc_current_sigrtmin()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---LIBC-START-MAIN-"
></A
>__libc_start_main</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9015"
></A
><H2
>Name</H2
>__libc_start_main&nbsp;--&nbsp;initialization routine</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9018"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9021"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>__libc_start_main</TT
></CODE
>(int (*<TT
CLASS="PARAMETER"
><I
>main</I
></TT
>)
  (int, char **, char **), int 
  <TT
CLASS="PARAMETER"
><I
>argc</I
></TT
>, char ** 
  <TT
CLASS="PARAMETER"
><I
>ubp_av</I
></TT
>, void (*<TT
CLASS="PARAMETER"
><I
>init</I
></TT
>)
  (void), void (*<TT
CLASS="PARAMETER"
><I
>fini</I
></TT
>)
  (void), void (*<TT
CLASS="PARAMETER"
><I
>rtld_fini</I
></TT
>)
  (void), void (*<TT
CLASS="PARAMETER"
><I
>stack_end</I
></TT
>));</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9043"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__libc_start_main()</TT
> function shall
perform any necessary initialization of the execution
environment, call the <TT
CLASS="PARAMETER"
><I
>main</I
></TT
> function
with appropriate arguments, and handle the return from <TT
CLASS="FUNCTION"
>main()</TT
>. If the <TT
CLASS="FUNCTION"
>main()</TT
> function returns,
the return value shall be passed to the <TT
CLASS="FUNCTION"
>exit()</TT
> function.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>While this specification is intended to be implementation independent,
process and library initialization may include:
<P
></P
><UL
><LI
><P
>performing any necessary security checks if the effective user ID is
not the same as the real user ID.</P
></LI
><LI
><P
>initialize the threading subsystem.</P
></LI
><LI
><P
>registering the <TT
CLASS="PARAMETER"
><I
>rtld_fini</I
></TT
> to release resources when this
dynamic shared object exits (or is unloaded).</P
></LI
><LI
><P
>registering the <TT
CLASS="PARAMETER"
><I
>fini</I
></TT
> handler to run at program exit.</P
></LI
><LI
><P
>calling the initializer function <TT
CLASS="FUNCTION"
>(*<TT
CLASS="PARAMETER"
><I
>init</I
></TT
>)()</TT
>.</P
></LI
><LI
><P
>calling <TT
CLASS="FUNCTION"
>main()</TT
> with appropriate arguments.</P
></LI
><LI
><P
>calling <TT
CLASS="FUNCTION"
>exit()</TT
> with the return value from
<TT
CLASS="FUNCTION"
>main()</TT
>.</P
></LI
></UL
>
This list is an example only.</P
></BLOCKQUOTE
></DIV
></P
><P
><TT
CLASS="FUNCTION"
>__libc_start_main()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9079"
></A
><H2
>See Also</H2
><P
>The section on Process Initialization in each of 
the architecture specific parts of the LSB Core Specification.</P
></DIV
><H1
><A
NAME="BASELIB---MBSNRTOWCS-CHK-1"
></A
>__mbsnrtowcs_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9086"
></A
><H2
>Name</H2
>__mbsnrtowcs_chk&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9091"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9092"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__mbsnrtowcs_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char * *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>nmc</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, mbstate_t *
<TT
CLASS="PARAMETER"
><I
>ps</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9109"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__mbsnrtowcs_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>mbsnrtowcs()</TT
>, except that
<TT
CLASS="FUNCTION"
>__mbsnrtowcs_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__mbsnrtowcs_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MBSRTOWCS-CHK-1"
></A
>__mbsrtowcs_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9126"
></A
><H2
>Name</H2
>__mbsrtowcs_chk&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9131"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9132"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__mbsrtowcs_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char * *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, mbstate_t *
<TT
CLASS="PARAMETER"
><I
>ps</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9147"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__mbsrtowcs_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>mbsrtowcs()</TT
>, except that
<TT
CLASS="FUNCTION"
>__mbsrtowcs_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__mbsrtowcs_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MBSTOWCS-CHK-1"
></A
>__mbstowcs_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9164"
></A
><H2
>Name</H2
>__mbstowcs_chk&nbsp;--&nbsp;convert a multibyte string to a wide-character string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9169"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9170"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__mbstowcs_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9183"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__mbstowcs_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>mbstowcs()</TT
>, except that
<TT
CLASS="FUNCTION"
>__mbstowcs_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__mbstowcs_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MEMCPY-CHK-1"
></A
>__memcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9200"
></A
><H2
>Name</H2
>__memcpy_chk&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9205"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9206"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
<TT
CLASS="FUNCTION"
>__memcpy_chk</TT
></CODE
>(void *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const void *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9219"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__memcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>memcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__memcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__memcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MEMMOVE-CHK-1"
></A
>__memmove_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9236"
></A
><H2
>Name</H2
>__memmove_chk&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9241"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9242"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
<TT
CLASS="FUNCTION"
>__memmove_chk</TT
></CODE
>(void *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const void *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9255"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__memmove_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>memmove()</TT
>, except that
<TT
CLASS="FUNCTION"
>__memmove_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__memmove_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MEMPCPY"
></A
>__mempcpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9272"
></A
><H2
>Name</H2
>__mempcpy&nbsp;--&nbsp;copy given number of bytes of source to destination</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9275"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9278"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
  <TT
CLASS="FUNCTION"
>__mempcpy</TT
></CODE
>(void * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const void * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9292"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__mempcpy()</TT
> copies <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> 
bytes of <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>,
returning a pointer to the byte after the last written byte.</P
><P
>If copying takes place between objects that overlap, the behavior is
undefined.</P
><P
>If either <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> 
is a null pointer, the behavior is undefined.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
> and the other parameters
are valid, the return value is <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__mempcpy()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MEMPCPY-CHK-1"
></A
>__mempcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9315"
></A
><H2
>Name</H2
>__mempcpy_chk&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9320"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9321"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
<TT
CLASS="FUNCTION"
>__mempcpy_chk</TT
></CODE
>(void *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const void *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9334"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__mempcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>mempcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__mempcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__mempcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---MEMSET-CHK-1"
></A
>__memset_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9351"
></A
><H2
>Name</H2
>__memset_chk&nbsp;--&nbsp;fill memory with a constant byte, using buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9356"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9357"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
<TT
CLASS="FUNCTION"
>__memset_chk</TT
></CODE
>(void *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>c</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9370"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__memset_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>memset()</TT
>, except that
<TT
CLASS="FUNCTION"
>__memset_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__memset_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---PREAD64-CHK-1"
></A
>__pread64_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9387"
></A
><H2
>Name</H2
>__pread64_chk&nbsp;--&nbsp;read from a file descriptor at a given offset, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9392"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9393"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t
<TT
CLASS="FUNCTION"
>__pread64_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>nbytes</I
></TT
>, off64_t
<TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9408"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__pread64_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>pread64()</TT
>, except that
<TT
CLASS="FUNCTION"
>__pread64_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>nbytes</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__pread64_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---PREAD-CHK-1"
></A
>__pread_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9425"
></A
><H2
>Name</H2
>__pread_chk&nbsp;--&nbsp;read from a file descriptor at a given offset, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9430"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9431"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t
<TT
CLASS="FUNCTION"
>__pread_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>nbytes</I
></TT
>, off_t
<TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9446"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__pread_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>pread()</TT
>, except that
<TT
CLASS="FUNCTION"
>__pread_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>nbytes</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__pread_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---PRINTF-CHK-1"
></A
>__printf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9463"
></A
><H2
>Name</H2
>__printf_chk&nbsp;--&nbsp;format and print data, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9468"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9469"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__printf_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9478"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__printf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>printf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__printf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__printf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---RAWMEMCHR"
></A
>__rawmemchr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9493"
></A
><H2
>Name</H2
>__rawmemchr&nbsp;--&nbsp;scan memory</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9496"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9499"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * 
  <TT
CLASS="FUNCTION"
>__rawmemchr</TT
></CODE
>(const void * 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>c</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9510"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> function shall locate the first occurrence of
<TT
CLASS="PARAMETER"
><I
>c</I
></TT
>
(converted to an unsigned char) in the object pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>. If the byte does
not occur in the object, then the behavior is undefined.</P
><P
><TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> is a weak alias for
<TT
CLASS="FUNCTION"
>rawmemchr()</TT
>. It is similar to 
<TT
CLASS="FUNCTION"
>memchr()</TT
>, but it has no length limit. </P
><P
><TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9524"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>__rawmemchr()</TT
> function shall return a pointer to the located byte.</P
></DIV
><H1
><A
NAME="BASELIB---READ-CHK-1"
></A
>__read_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9534"
></A
><H2
>Name</H2
>__read_chk&nbsp;--&nbsp;read from a file descriptor, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9539"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9540"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t
<TT
CLASS="FUNCTION"
>__read_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>nbytes</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9553"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__read_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>read()</TT
>, except that
<TT
CLASS="FUNCTION"
>__read_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>nbytes</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__read_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---READLINK-CHK-1"
></A
>__readlink_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9570"
></A
><H2
>Name</H2
>__readlink_chk&nbsp;--&nbsp;display value of a symbolic link, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9575"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9576"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t
<TT
CLASS="FUNCTION"
>__readlink_chk</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9589"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__readlink_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>readlink()</TT
>, except that
<TT
CLASS="FUNCTION"
>__readlink_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__readlink_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---REALPATH-CHK-1"
></A
>__realpath_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9606"
></A
><H2
>Name</H2
>__realpath_chk&nbsp;--&nbsp;return the canonicalized absolute pathname, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9611"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9612"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__realpath_chk</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>resolved_path</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>resolved_len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9623"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__realpath_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>realpath()</TT
>, except that
<TT
CLASS="FUNCTION"
>__realpath_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>resolved_len</I
></TT
> specifies the size of the string
<TT
CLASS="PARAMETER"
><I
>resolved_path</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>resolved_len</I
></TT
> is less than
<CODE
CLASS="CONSTANT"
>PATH_MAX</CODE
>, then the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__realpath_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---RECV-CHK-1"
></A
>__recv_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9640"
></A
><H2
>Name</H2
>__recv_chk&nbsp;--&nbsp;receive a message from a socket, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9645"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9646"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t
<TT
CLASS="FUNCTION"
>__recv_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9661"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__recv_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>recv()</TT
>, except that
<TT
CLASS="FUNCTION"
>__recv_chk()</TT
> shall check for buffer overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the buffer, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__recv_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---RECVFROM-CHK-1"
></A
>__recvfrom_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9681"
></A
><H2
>Name</H2
>__recvfrom_chk&nbsp;--&nbsp;receive a message from a socket, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9686"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9687"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t
<TT
CLASS="FUNCTION"
>__recvfrom_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, struct sockaddr *
<TT
CLASS="PARAMETER"
><I
>from</I
></TT
>, socklen_t *
<TT
CLASS="PARAMETER"
><I
>fromlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9706"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__recvfrom_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>recvfrom()</TT
>, except that
<TT
CLASS="FUNCTION"
>__recvfrom_chk()</TT
> shall check for buffer overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the buffer, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__recvfrom_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---REGISTER-ATFORK"
></A
>__register_atfork</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9726"
></A
><H2
>Name</H2
>__register_atfork&nbsp;--&nbsp;alias for register_atfork</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9729"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9732"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__register_atfork</TT
></CODE
>(void (*<TT
CLASS="PARAMETER"
><I
>prepare</I
></TT
>)
  (void), void (*<TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>)
  (void), void (*<TT
CLASS="PARAMETER"
><I
>child</I
></TT
>)
  (void), void *<TT
CLASS="PARAMETER"
><I
>__dso_handle</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9747"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__register_atfork()</TT
> implements
<TT
CLASS="FUNCTION"
>pthread_atfork()</TT
> as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
The additional parameter <TT
CLASS="PARAMETER"
><I
>__dso_handle</I
></TT
> allows a shared
object to pass in it's handle so that functions registered by
<TT
CLASS="FUNCTION"
>__register_atfork()</TT
> can be unregistered by the runtime when
the shared object is unloaded.</P
></DIV
><H1
><A
NAME="BASELIB---SIGSETJMP-1"
></A
>__sigsetjmp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9761"
></A
><H2
>Name</H2
>__sigsetjmp&nbsp;--&nbsp;save stack context for non-local goto</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9764"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9765"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__sigsetjmp</TT
></CODE
>(jmp_buf 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>env</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>savemask</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9775"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__sigsetjmp()</TT
> has the same behavior as 
<TT
CLASS="FUNCTION"
>sigsetjmp()</TT
> as specified by 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__sigsetjmp()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SNPRINTF-CHK-1"
></A
>__snprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9787"
></A
><H2
>Name</H2
>__snprintf_chk&nbsp;--&nbsp;convert formatted output, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9792"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9793"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__snprintf_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>strlen</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9808"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__snprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>snprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__snprintf_chk()</TT
> shall check for buffer overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the buffer, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>strlen</I
></TT
> specifies the size of the buffer
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>strlen</I
></TT
> is less than
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__snprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SPRINTF-CHK-1"
></A
>__sprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9828"
></A
><H2
>Name</H2
>__sprintf_chk&nbsp;--&nbsp;convert formatted output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9833"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9834"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__sprintf_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>strlen</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9847"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__sprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>sprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__sprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>strlen</I
></TT
> specifies the size of the string
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>strlen</I
></TT
> is zero,
the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__sprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STACK-CHK-FAIL-1"
></A
>__stack_chk_fail</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9866"
></A
><H2
>Name</H2
>__stack_chk_fail&nbsp;--&nbsp;terminate a function in case of stack overflow</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9871"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9872"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>__stack_chk_fail</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9877"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__stack_chk_fail()</TT
>
shall abort the function that called it with a message that
a stack overflow has been detected.
The program that called the function shall then exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__stack_chk_fail()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9883"
></A
><H2
>Application Usage (informative)</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__stack_chk_fail()</TT
>
does not check for a stack overflow itself.
It merely reports one when invoked.</P
></DIV
><H1
><A
NAME="LIBUTIL---STPCPY-2"
></A
>__stpcpy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9891"
></A
><H2
>Name</H2
>__stpcpy&nbsp;--&nbsp;alias for stpcpy</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9894"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9897"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>__stpcpy</TT
></CODE
>(char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dest</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>src</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9908"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__stpcpy()</TT
> function has the same specification as
the <TT
CLASS="FUNCTION"
>stpcpy()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__stpcpy()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STPCPY-CHK-1"
></A
>__stpcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9921"
></A
><H2
>Name</H2
>__stpcpy_chk&nbsp;--&nbsp;copy a string returning a pointer to its end, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9926"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9927"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__stpcpy_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9938"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__stpcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>stpcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__stpcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__stpcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STPNCPY-CHK-1"
></A
>__stpncpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9953"
></A
><H2
>Name</H2
>__stpncpy_chk&nbsp;--&nbsp;copy a fixed-size string, returning a pointer to its end, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9958"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9959"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__stpncpy_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN9972"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__stpncpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>stpncpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__stpncpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort, and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__stpncpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRCAT-CHK-1"
></A
>__strcat_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN9989"
></A
><H2
>Name</H2
>__strcat_chk&nbsp;--&nbsp;concatenate two strings, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN9994"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN9995"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__strcat_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10006"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__strcat_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>strcat()</TT
>, except that
<TT
CLASS="FUNCTION"
>__strcat_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__strcat_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRCPY-CHK-1"
></A
>__strcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10021"
></A
><H2
>Name</H2
>__strcpy_chk&nbsp;--&nbsp;copy a string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10026"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10027"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__strcpy_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10038"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__strcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>strcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__strcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__strcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRDUP-1"
></A
>__strdup</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10053"
></A
><H2
>Name</H2
>__strdup&nbsp;--&nbsp;alias for strdup</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10056"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10059"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>__strdup</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10066"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__strdup()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>strdup()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strdup()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRNCAT-CHK-1"
></A
>__strncat_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10079"
></A
><H2
>Name</H2
>__strncat_chk&nbsp;--&nbsp;concatenate two strings, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10084"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10085"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__strncat_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>s1len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10098"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__strncat_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>strncat()</TT
>, except that
<TT
CLASS="FUNCTION"
>__strncat_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>s1len</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__strncat_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRNCPY-CHK-1"
></A
>__strncpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10113"
></A
><H2
>Name</H2
>__strncpy_chk&nbsp;--&nbsp;copy a string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10118"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10119"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__strncpy_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>s1len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10132"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__strncpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>strncpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__strncpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>s1len</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__strncpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOD-INTERNAL-1"
></A
>__strtod_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10147"
></A
><H2
>Name</H2
>__strtod_internal&nbsp;--&nbsp;underlying function for strtod</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10150"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10151"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double 
  <TT
CLASS="FUNCTION"
>__strtod_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10164"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtod_internal()</TT
> is undefined. </P
><P
><TT
CLASS="FUNCTION"
>__strtod_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)()</TT
> 
has the same specification as 
<TT
CLASS="FUNCTION"
>strtod(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>)()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtod_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOF-INTERNAL"
></A
>__strtof_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10184"
></A
><H2
>Name</H2
>__strtof_internal&nbsp;--&nbsp;underlying function for strtof</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10187"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10188"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float 
  <TT
CLASS="FUNCTION"
>__strtof_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10201"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtof_internal()</TT
> is undefined. </P
><P
><TT
CLASS="FUNCTION"
>__strtof_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)()</TT
> 
has the same specification as 
<TT
CLASS="FUNCTION"
>strtof(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>)()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtof_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOK-R-1"
></A
>__strtok_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10221"
></A
><H2
>Name</H2
>__strtok_r&nbsp;--&nbsp;alias for strtok_r</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10224"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10227"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>__strtok_r</TT
></CODE
>(char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>delim</I
></TT
></I
></TT
>, char * * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>save_ptr</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10240"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__strtok_r()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>strtok_r()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtok_r()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOL-INTERNAL-1"
></A
>__strtol_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10253"
></A
><H2
>Name</H2
>__strtol_internal&nbsp;--&nbsp;alias for strtol</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10256"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10259"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long int 
  <TT
CLASS="FUNCTION"
>__strtol_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10275"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtol_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtol_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtol(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtol_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOLD-INTERNAL-1"
></A
>__strtold_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10299"
></A
><H2
>Name</H2
>__strtold_internal&nbsp;--&nbsp;underlying function for strtold</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10302"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10303"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double  
  <TT
CLASS="FUNCTION"
>__strtold_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10316"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtold_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtold_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
has the same specification as 
<TT
CLASS="LITERAL"
>strtold(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtold_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOLL-INTERNAL-1"
></A
>__strtoll_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10336"
></A
><H2
>Name</H2
>__strtoll_internal&nbsp;--&nbsp;underlying function for strtoll</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10339"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10340"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long 
  <TT
CLASS="FUNCTION"
>__strtoll_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10356"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtoll_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtoll_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtoll(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtoll_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOUL-INTERNAL"
></A
>__strtoul_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10378"
></A
><H2
>Name</H2
>__strtoul_internal&nbsp;--&nbsp;underlying function for strtoul</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10381"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10382"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long int 
  <TT
CLASS="FUNCTION"
>__strtoul_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10398"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtoul_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtoul_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtoul(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtoul_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---STRTOULL-INTERNAL-1"
></A
>__strtoull_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10420"
></A
><H2
>Name</H2
>__strtoull_internal&nbsp;--&nbsp;underlying function for strtoull</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10423"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10424"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long 
  <TT
CLASS="FUNCTION"
>__strtoull_internal</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>__group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10440"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>__group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__strtoull_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__strtoull_internal(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> has the same specification as 
<TT
CLASS="LITERAL"
>strtoull(<TT
CLASS="PARAMETER"
><I
>__nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>__endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>__base</I
></TT
>)</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__strtoull_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SWPRINTF-CHK-1"
></A
>__swprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10462"
></A
><H2
>Name</H2
>__swprintf_chk&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10467"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10468"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__swprintf_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>slen</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10483"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__swprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>swprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__swprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> is less than
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__swprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SYSCONF"
></A
>__sysconf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10505"
></A
><H2
>Name</H2
>__sysconf&nbsp;--&nbsp;get configuration information at runtime</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10508"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10511"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long 
  <TT
CLASS="FUNCTION"
>__sysconf</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10519"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> gets configuration information at runtime.</P
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> is weak alias to 
<TT
CLASS="FUNCTION"
>sysconf()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>sysconf()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>__sysconf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SYSLOG-CHK-1"
></A
>__syslog_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10537"
></A
><H2
>Name</H2
>__syslog_chk&nbsp;--&nbsp;send messages to the system logger, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10542"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10543"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;syslog.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>__syslog_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>priority</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10554"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__syslog_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>syslog()</TT
>, except that
<TT
CLASS="FUNCTION"
>__syslog_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__syslog_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SYSV-SIGNAL-1"
></A
>__sysv_signal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10569"
></A
><H2
>Name</H2
>__sysv_signal&nbsp;--&nbsp;signal handling</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10572"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10575"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>__sighandler_t 
  <TT
CLASS="FUNCTION"
>__sysv_signal</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sig</I
></TT
></I
></TT
>, __sighandler_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>handler</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10585"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__sysv_signal()</TT
> has the same behavior as 
<TT
CLASS="FUNCTION"
>signal()</TT
> as specified by 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__sysv_signal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---TIMEZONE"
></A
>__timezone</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10599"
></A
><H2
>Name</H2
>__timezone&nbsp;--&nbsp;external variable containing timezone</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10602"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>long int <CODE
CLASS="VARNAME"
>__timezone</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10605"
></A
><H2
>Description</H2
><P
>The external variable <CODE
CLASS="VARNAME"
>__timezone</CODE
> 
shall implement the timezone variable <CODE
CLASS="VARNAME"
>timezone</CODE
>
as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<CODE
CLASS="VARNAME"
>__timezone</CODE
> has the same specification as 
<CODE
CLASS="VARNAME"
>timezone</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB---TTYNAME-R-CHK-1"
></A
>__ttyname_r_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10617"
></A
><H2
>Name</H2
>__ttyname_r_chk&nbsp;--&nbsp;return name of a terminal, with buffer overflow checking (reentrant)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10622"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10623"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__ttyname_r_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>nreal</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10636"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__ttyname_r_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>ttyname_r()</TT
>, except that
<TT
CLASS="FUNCTION"
>__ttyname_r_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>nreal</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__ttyname_r_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---TZNAME"
></A
>__tzname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10653"
></A
><H2
>Name</H2
>__tzname&nbsp;--&nbsp;external variable containing the timezone names</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10656"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char * <CODE
CLASS="VARNAME"
>__tzname</CODE
>[2];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10659"
></A
><H2
>Description</H2
><P
>The external variable <CODE
CLASS="VARNAME"
>__tzname</CODE
> 
shall implement the timezone name variable <CODE
CLASS="VARNAME"
>tzname</CODE
>
as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> function <TT
CLASS="FUNCTION"
>tzset()</TT
>.
<CODE
CLASS="VARNAME"
>__tzname</CODE
> has the same specification as 
<CODE
CLASS="VARNAME"
>tzname</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB---VFPRINTF-CHK-1"
></A
>__vfprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10672"
></A
><H2
>Name</H2
>__vfprintf_chk&nbsp;--&nbsp;convert formatted output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10677"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10678"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vfprintf_chk</TT
></CODE
>(FILE *
<TT
CLASS="PARAMETER"
><I
>fp</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>ap</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10691"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vfprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vfprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vfprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__vfprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VFWPRINTF-CHK-1"
></A
>__vfwprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10706"
></A
><H2
>Name</H2
>__vfwprintf_chk&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10711"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10712"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vfwprintf_chk</TT
></CODE
>(FILE *
<TT
CLASS="PARAMETER"
><I
>fp</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>ap</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10725"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vfwprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vfwprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vfwprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__vfwprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VPRINTF-CHK-1"
></A
>__vprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10740"
></A
><H2
>Name</H2
>__vprintf_chk&nbsp;--&nbsp;convert formatted output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10745"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10746"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vprintf_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>ap</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10757"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__vprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VSNPRINTF-CHK-1"
></A
>__vsnprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10772"
></A
><H2
>Name</H2
>__vsnprintf_chk&nbsp;--&nbsp;convert formatted output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10777"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10778"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vsnprintf_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>slen</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>args</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10795"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vsnprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vsnprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vsnprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> is less than
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__vsnprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VSPRINTF-CHK-1"
></A
>__vsprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10817"
></A
><H2
>Name</H2
>__vsprintf_chk&nbsp;--&nbsp;convert formatted output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10822"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10823"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vsprintf_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>slen</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>args</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10838"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vsprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vsprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vsprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>. If its value is zero,
the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__vsprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VSWPRINTF-CHK-1"
></A
>__vswprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10856"
></A
><H2
>Name</H2
>__vswprintf_chk&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10861"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10862"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vswprintf_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>slen</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>args</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10879"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vswprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vswprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vswprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>slen</I
></TT
> is less than
<TT
CLASS="PARAMETER"
><I
>maxlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__vswprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VSYSLOG-CHK-1"
></A
>__vsyslog_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10899"
></A
><H2
>Name</H2
>__vsyslog_chk&nbsp;--&nbsp;send messages to the system logger, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10904"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10905"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;syslog.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>__vsyslog_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>priority</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>ap</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10918"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vsyslog_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vsyslog()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vsyslog_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__vsyslog_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---VWPRINTF-CHK-1"
></A
>__vwprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10933"
></A
><H2
>Name</H2
>__vwprintf_chk&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10938"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10939"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__vwprintf_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>, va_list
<TT
CLASS="PARAMETER"
><I
>ap</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10950"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__vwprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>vwprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__vwprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__vwprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCPCPY-CHK-1"
></A
>__wcpcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10965"
></A
><H2
>Name</H2
>__wcpcpy_chk&nbsp;--&nbsp;copy a wide-character string, returning a pointer to its end, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10970"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN10971"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wcpcpy_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN10982"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcpcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcpcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcpcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcpcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCPNCPY-CHK-1"
></A
>__wcpncpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10997"
></A
><H2
>Name</H2
>__wcpncpy_chk&nbsp;--&nbsp;copy a fixed-size string of wide characters, returning a pointer to its end, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11002"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11003"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wcpncpy_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11016"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcpncpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcpncpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcpncpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcpncpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCRTOMB-CHK-1"
></A
>__wcrtomb_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11033"
></A
><H2
>Name</H2
>__wcrtomb_chk&nbsp;--&nbsp;convert a wide character to a multibyte sequence, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11038"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11039"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__wcrtomb_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, wchar_t
<TT
CLASS="PARAMETER"
><I
>wchar</I
></TT
>, mbstate_t *
<TT
CLASS="PARAMETER"
><I
>ps</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11052"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcrtomb_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcrtomb()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcrtomb_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>. If it is less than <CODE
CLASS="CONSTANT"
>MB_CUR_MAX</CODE
>,
then the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcrtomb_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSCAT-CHK-1"
></A
>__wcscat_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11068"
></A
><H2
>Name</H2
>__wcscat_chk&nbsp;--&nbsp;concatenate two wide-character strings, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11073"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11074"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wcscat_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11085"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcscat_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcscat()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcscat_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcscat_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSCPY-CHK-1"
></A
>__wcscpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11100"
></A
><H2
>Name</H2
>__wcscpy_chk&nbsp;--&nbsp;copy a wide-character string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11105"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11106"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wcscpy_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11117"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcscpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcscpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcscpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcscpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSNCAT-CHK-1"
></A
>__wcsncat_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11129"
></A
><H2
>Name</H2
>__wcsncat_chk&nbsp;--&nbsp;concatenate two wide-character strings, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11134"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11135"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wcsncat_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11148"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcsncat_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcsncat()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcsncat_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcsncat_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSNCPY-CHK-1"
></A
>__wcsncpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11163"
></A
><H2
>Name</H2
>__wcsncpy_chk&nbsp;--&nbsp;copy a fixed-size string of wide characters, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11168"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11169"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wcsncpy_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11182"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcsncpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcsncpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcsncpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcsncpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSNRTOMBS-CHK-1"
></A
>__wcsnrtombs_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11199"
></A
><H2
>Name</H2
>__wcsnrtombs_chk&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11204"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11205"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__wcsnrtombs_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t * *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>nwc</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, mbstate_t *
<TT
CLASS="PARAMETER"
><I
>ps</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11222"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcsnrtombs_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcsnrtombs()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcsnrtombs_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcsnrtombs_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSRTOMBS-CHK-1"
></A
>__wcsrtombs_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11239"
></A
><H2
>Name</H2
>__wcsrtombs_chk&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11244"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11245"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__wcsrtombs_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t * *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, mbstate_t *
<TT
CLASS="PARAMETER"
><I
>ps</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11260"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcsrtombs_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcsrtombs()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcsrtombs_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcsrtombs_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOD-INTERNAL-1"
></A
>__wcstod_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11277"
></A
><H2
>Name</H2
>__wcstod_internal&nbsp;--&nbsp;underlying function for wcstod</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11280"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11281"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double 
  <TT
CLASS="FUNCTION"
>__wcstod_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11294"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstod_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstod_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
shall behave as
<TT
CLASS="LITERAL"
>wcstod(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>)</TT
> as specified by
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstod_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOF-INTERNAL-1"
></A
>__wcstof_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11315"
></A
><H2
>Name</H2
>__wcstof_internal&nbsp;--&nbsp;underlying function for wcstof</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11318"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11319"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float 
  <TT
CLASS="FUNCTION"
>__wcstof_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11332"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstof_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstof_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
shall behave as
<TT
CLASS="LITERAL"
>wcstof(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>)</TT
> as specified in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstof_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOL-INTERNAL-1"
></A
>__wcstol_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11353"
></A
><H2
>Name</H2
>__wcstol_internal&nbsp;--&nbsp;underlying function for wcstol</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11356"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11357"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long 
  <TT
CLASS="FUNCTION"
>__wcstol_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11373"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstol_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstol_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>wcstol(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstol_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOLD-INTERNAL-1"
></A
>__wcstold_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11396"
></A
><H2
>Name</H2
>__wcstold_internal&nbsp;--&nbsp;underlying function for wcstold</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11399"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11400"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double 
  <TT
CLASS="FUNCTION"
>__wcstold_internal</TT
></CODE
>(const wchar_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11413"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstold_internal()</TT
> is undefined. </P
><P
><TT
CLASS="LITERAL"
>__wcstold_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="LITERAL"
>0</TT
>)</TT
> 
shall behave as
<TT
CLASS="LITERAL"
>wcstold(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstold_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOMBS-CHK-1"
></A
>__wcstombs_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11434"
></A
><H2
>Name</H2
>__wcstombs_chk&nbsp;--&nbsp;convert a wide-character string to a multibyte string, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11439"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11440"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>__wcstombs_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>src</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11453"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wcstombs_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wcstombs()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wcstombs_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wcstombs_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCSTOUL-INTERNAL-1"
></A
>__wcstoul_internal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11470"
></A
><H2
>Name</H2
>__wcstoul_internal&nbsp;--&nbsp;underlying function for wcstoul</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11473"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11474"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long 
  <TT
CLASS="FUNCTION"
>__wcstoul_internal</TT
></CODE
>(const wchar_t * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t * * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11490"
></A
><H2
>Description</H2
><P
><TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall be <TT
CLASS="LITERAL"
>0</TT
> or the 
behavior of <TT
CLASS="FUNCTION"
>__wcstoul_internal()</TT
> is undefined. </P
><P
><TT
CLASS="FUNCTION"
>__wcstoul_internal(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>, 
<TT
CLASS="LITERAL"
>0</TT
>)()</TT
> shall behave as
<TT
CLASS="FUNCTION"
>wcstoul(<TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>base</I
></TT
>)()</TT
>
as specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__wcstoul_internal()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WCTOMB-CHK-1"
></A
>__wctomb_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11513"
></A
><H2
>Name</H2
>__wctomb_chk&nbsp;--&nbsp;convert a wide character to a multibyte sequence, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11518"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11519"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__wctomb_chk</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, wchar_t
<TT
CLASS="PARAMETER"
><I
>wchar</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11530"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wctomb_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wctomb()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wctomb_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>. If it is less than <CODE
CLASS="CONSTANT"
>MB_CUR_MAX</CODE
>,
then the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wctomb_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WMEMCPY-CHK-1"
></A
>__wmemcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11546"
></A
><H2
>Name</H2
>__wmemcpy_chk&nbsp;--&nbsp;copy an array of wide-characters, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11551"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11552"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wmemcpy_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11565"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wmemcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wmemcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wmemcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wmemcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WMEMMOVE-CHK-1"
></A
>__wmemmove_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11582"
></A
><H2
>Name</H2
>__wmemmove_chk&nbsp;--&nbsp;copy an array of wide-characters, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11587"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11588"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wmemmove_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11601"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wmemmove_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wmemmove()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wmemmove_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wmemmove_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WMEMPCPY-CHK-1"
></A
>__wmempcpy_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11618"
></A
><H2
>Name</H2
>__wmempcpy_chk&nbsp;--&nbsp;copy memory area, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11623"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11624"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wmempcpy_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11637"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wmempcpy_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wmempcpy()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wmempcpy_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>ns1</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wmempcpy_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WMEMSET-CHK-1"
></A
>__wmemset_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11654"
></A
><H2
>Name</H2
>__wmemset_chk&nbsp;--&nbsp;fill an array of wide-characters with a constant wide character, with buffer overflow checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11659"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11660"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>wchar_t *
<TT
CLASS="FUNCTION"
>__wmemset_chk</TT
></CODE
>(wchar_t *
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>, wchar_t
<TT
CLASS="PARAMETER"
><I
>c</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11673"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wmemset_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wmemset()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wmemset_chk()</TT
> shall check for buffer overflow before
computing a result.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
> specifies the size of the object
pointed to by <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> exceeds
<TT
CLASS="PARAMETER"
><I
>destlen</I
></TT
>, the function shall abort
and the program calling it shall exit.</P
><P
>The <TT
CLASS="FUNCTION"
>__wmemset_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---WPRINTF-CHK-1"
></A
>__wprintf_chk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11690"
></A
><H2
>Name</H2
>__wprintf_chk&nbsp;--&nbsp;convert formatted wide-character output, with stack checking</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11695"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11696"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__wprintf_chk</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>, const wchar_t *
<TT
CLASS="PARAMETER"
><I
>format</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11705"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>__wprintf_chk()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>wprintf()</TT
>, except that
<TT
CLASS="FUNCTION"
>__wprintf_chk()</TT
> shall check for stack overflow before
computing a result, depending on the value of the
<TT
CLASS="PARAMETER"
><I
>flag</I
></TT
> parameter.  If an overflow is anticipated,
the function shall abort
and the program calling it shall exit.</P
><P
>In general, the higher the value of <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>,
the more security measures this interface shall take
in the form of checking the stack, parameter values, and so on.</P
><P
>The <TT
CLASS="FUNCTION"
>__wprintf_chk()</TT
> function is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---XMKNOD-1"
></A
>__xmknod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11720"
></A
><H2
>Name</H2
>__xmknod&nbsp;--&nbsp;make a special file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11725"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11728"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/stat.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__xmknod</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, mode_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
></I
></TT
>, dev_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dev</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11745"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__xmknod()</TT
> function shall implement the
<TT
CLASS="FUNCTION"
>mknod()</TT
> interface.
The behavior of <TT
CLASS="FUNCTION"
>__xmknod()</TT
> 
for values of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> other than
<TT
CLASS="LITERAL"
>_MKNOD_VER</TT
> is undefined.
See Data Definitions in the architecture specific part of this 
specification for the correct value of <TT
CLASS="LITERAL"
>_MKNOD_VER</TT
>.</P
><P
><TT
CLASS="LITERAL"
>__xmknod(<TT
CLASS="LITERAL"
>_MKNOD_VER</TT
>, 
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>mknod(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__xmknod()</TT
> function is not in the source standard; 
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>mknod()</TT
> function is not in the binary standard; 
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB---XMKNODAT-1"
></A
>__xmknodat</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11776"
></A
><H2
>Name</H2
>__xmknodat&nbsp;--&nbsp;make a special file relative to a directory file descriptor</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11781"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11782"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/stat.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__xmknodat</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>ver</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, mode_t
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, dev_t *
<TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11797"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__xmknodat()</TT
> function shall implement the
<TT
CLASS="FUNCTION"
>mknodat()</TT
> function.
The behavior of <TT
CLASS="FUNCTION"
>__xmknodat()</TT
> 
for values of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> other than
<TT
CLASS="LITERAL"
>_MKNOD_VER</TT
> is undefined.
See Data Definitions in the architecture specific part of this 
specification for the correct value of <TT
CLASS="LITERAL"
>_MKNOD_VER</TT
>.</P
><P
><TT
CLASS="LITERAL"
>__xmknodat(<TT
CLASS="LITERAL"
>_MKNOD_VER</TT
>, 
<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>)</TT
>
shall behave as
<TT
CLASS="LITERAL"
>mknodat(<TT
CLASS="PARAMETER"
><I
>dirfd</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>dev</I
></TT
>)</TT
>
as specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
>The <TT
CLASS="FUNCTION"
>__xmknodat()</TT
> function is not in the source standard;
it is only in the binary standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>mknodat()</TT
> function is not in the binary standard;
it is only in the source standard.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB---XPG-BASENAME"
></A
>__xpg_basename</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11828"
></A
><H2
>Name</H2
>__xpg_basename&nbsp;--&nbsp;return the last component of a file name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11831"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11832"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libgen.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>__xpg_basename</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11839"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__xpg_basename()</TT
> function shall return a pointer to the final component
of the pathname named by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, as described in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> <TT
CLASS="FUNCTION"
>basename()</TT
>.</P
><P
>This function is not in the source standard, it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11847"
></A
><H2
>Return Value</H2
><P
>See <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB---XPG-SIGPAUSE"
></A
>__xpg_sigpause</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11855"
></A
><H2
>Name</H2
>__xpg_sigpause&nbsp;--&nbsp;remove a signal from the signal mask and suspend the thread</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11858"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11859"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__xpg_sigpause</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>sig</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11866"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__xpg_sigpause()</TT
> function shall implement the
<TT
CLASS="FUNCTION"
>sigpause()</TT
> described in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
>This function is not in the source standard, it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11873"
></A
><H2
>Return Value</H2
><P
>See <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB---XPG-STRERROR-R"
></A
>__xpg_strerror_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11881"
></A
><H2
>Name</H2
>__xpg_strerror_r&nbsp;--&nbsp;return string describing error number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11884"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11885"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__xpg_strerror_r</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11896"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>__xpg_strerror_r()</TT
> function
shall map the error number in <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
> to a locale-dependent error
message string and shall return the string in the buffer pointed to by <TT
CLASS="PARAMETER"
><I
>strerrbuf</I
></TT
>, with length
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, as described in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> <TT
CLASS="FUNCTION"
>strerror_r()</TT
>.</P
><P
>This function is not in the source standard, it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11906"
></A
><H2
>Return Value</H2
><P
>See <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB---XSTAT"
></A
>__xstat</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN11914"
></A
><H2
>Name</H2
>__xstat&nbsp;--&nbsp;get File Status</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11921"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN11924"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/stat.h&#62;
#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__xstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__lxstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fxstat</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fildes</I
></TT
></I
></TT
>, struct stat *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11959"
></A
><H2
>Description</H2
><P
>The functions 
<TT
CLASS="FUNCTION"
>__xstat()</TT
>,
<TT
CLASS="FUNCTION"
>__lxstat()</TT
>, and
<TT
CLASS="FUNCTION"
>__fxstat()</TT
> shall implement
the functions
<TT
CLASS="FUNCTION"
>stat()</TT
>,
<TT
CLASS="FUNCTION"
>lstat()</TT
>, and
<TT
CLASS="FUNCTION"
>fstat()</TT
> respectively.</P
><P
>The behavior of these functions
for values of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> other than
<TT
CLASS="LITERAL"
>_STAT_VER</TT
> is undefined.
See Data Definitions in the architecture specific part of this 
specification for the correct value of <TT
CLASS="LITERAL"
>_STAT_VER</TT
>.</P
><P
><TT
CLASS="LITERAL"
>__xstat(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>, <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall implement
<TT
CLASS="LITERAL"
>stat(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="LITERAL"
>__lxstat(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>, <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall implement
<TT
CLASS="LITERAL"
>lstat(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="LITERAL"
>__fxstat(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>, <TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall implement
<TT
CLASS="LITERAL"
>fstat(<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__xstat()</TT
>, <TT
CLASS="FUNCTION"
>__lxstat()</TT
>, and 
<TT
CLASS="FUNCTION"
>__fxstat()</TT
> are not in the source standard; 
they are only in the binary standard.</P
><P
><TT
CLASS="FUNCTION"
>stat()</TT
>, <TT
CLASS="FUNCTION"
>lstat()</TT
>, and  
<TT
CLASS="FUNCTION"
>fstat()</TT
> are not in the binary standard; 
they are only in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB---XSTAT64"
></A
>__xstat64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12013"
></A
><H2
>Name</H2
>__xstat64&nbsp;--&nbsp;get File Status</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12028"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12031"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _LARGEFILE_SOURCE 1
#include &#60;sys/stat.h&#62;
#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__xstat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat64 *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__lxstat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, struct stat64 *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fxstat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ver</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fildes</I
></TT
></I
></TT
>, struct stat64 *
  <TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12066"
></A
><H2
>Description</H2
><P
>The functions 
<TT
CLASS="FUNCTION"
>__xstat64()</TT
>,
<TT
CLASS="FUNCTION"
>__lxstat64()</TT
>, and
<TT
CLASS="FUNCTION"
>__fxstat64()</TT
> shall implement
the functions
<TT
CLASS="FUNCTION"
>stat64()</TT
>,
<TT
CLASS="FUNCTION"
>lstat64()</TT
>, and
<TT
CLASS="FUNCTION"
>fstat64()</TT
> respectively.</P
><P
>The behavior of these functions
for values of <TT
CLASS="PARAMETER"
><I
>ver</I
></TT
> other than
<TT
CLASS="LITERAL"
>_STAT_VER</TT
> is undefined.
See Data Definitions in the architecture specific part of this 
specification for the correct value of <TT
CLASS="LITERAL"
>_STAT_VER</TT
>.</P
><P
><TT
CLASS="LITERAL"
>__xstat64(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>,
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>stat64(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.LFS"
>Large File Support</A
>.</P
><P
><TT
CLASS="LITERAL"
>__lxstat64(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>,
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>lstat64(<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.LFS"
>Large File Support</A
>.</P
><P
><TT
CLASS="LITERAL"
>__fxstat64(<TT
CLASS="LITERAL"
>_STAT_VER</TT
>,
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> shall behave as
<TT
CLASS="LITERAL"
>fstat64(<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>stat_buf</I
></TT
>)</TT
> as specified by 
<A
HREF="#STD.LFS"
>Large File Support</A
>.</P
><P
><TT
CLASS="FUNCTION"
>__xstat64()</TT
>, <TT
CLASS="FUNCTION"
>__lxstat64()</TT
>, and 
<TT
CLASS="FUNCTION"
>__fxstat64()</TT
> are not in the source standard; 
they are only in the binary standard.</P
><P
><TT
CLASS="FUNCTION"
>stat64()</TT
>, <TT
CLASS="FUNCTION"
>lstat64()</TT
>, and  
<TT
CLASS="FUNCTION"
>fstat64()</TT
> are not in the binary standard; 
they are only in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB--ENVIRON"
></A
>_environ</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12120"
></A
><H2
>Name</H2
>_environ&nbsp;--&nbsp;alias for environ - user environment </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12123"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern char * *<CODE
CLASS="VARNAME"
>_environ</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12128"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>_environ</CODE
> is an alias for 
<CODE
CLASS="VARNAME"
>environ</CODE
> - user environment.</P
></DIV
><H1
><A
NAME="BASELIB--NL-MSG-CAT-CNTR"
></A
>_nl_msg_cat_cntr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12139"
></A
><H2
>Name</H2
>_nl_msg_cat_cntr&nbsp;--&nbsp;new catalog load counter</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12142"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;libintl.h&#62;

extern int <CODE
CLASS="VARNAME"
>_nl_msg_cat_cntr</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12147"
></A
><H2
>Description</H2
><P
>The global variable
<CODE
CLASS="VARNAME"
>_nl_msg_cat_cntr</CODE
> is incremented each time a new
catalog is loaded. 
This variable is only in the binary standard; it is not in the source standard.</P
></DIV
><H1
><A
NAME="BASELIB--SYS-ERRLIST"
></A
>_sys_errlist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12157"
></A
><H2
>Name</H2
>_sys_errlist&nbsp;--&nbsp;array containing the "C" locale strings used by strerror()</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12160"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;stdio.h&#62;

extern const char *const <CODE
CLASS="VARNAME"
>_sys_errlist</CODE
>[];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12165"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>_sys_errlist</CODE
> is an array containing the "C" locale 
strings used by <TT
CLASS="FUNCTION"
>strerror()</TT
>. This normally should not 
be used directly. <TT
CLASS="FUNCTION"
>strerror()</TT
> provides all of the 
needed functionality.</P
></DIV
><H1
><A
NAME="BASELIB--SYS-SIGLIST"
></A
>_sys_siglist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12177"
></A
><H2
>Name</H2
>_sys_siglist&nbsp;--&nbsp;array containing the names of the signal names</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12180"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;signal.h&#62;

extern const char *const <CODE
CLASS="VARNAME"
>_sys_siglist</CODE
>[NSIG];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12185"
></A
><H2
>Description</H2
><P
><CODE
CLASS="VARNAME"
>_sys_siglist</CODE
> is an array containing
signal description strings ordered by signal number.</P
><P
>The <CODE
CLASS="VARNAME"
>_sys_siglist</CODE
> array 
is only in the binary standard; it is not in the source standard.
Applications wishing to access signal descriptions should use
the <TT
CLASS="FUNCTION"
>strsignal()</TT
> function.</P
></DIV
><H1
><A
NAME="BASELIB-ACCT-3"
></A
>acct</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12198"
></A
><H2
>Name</H2
>acct&nbsp;--&nbsp;switch process accounting on or off</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12201"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12204"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;dirent.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>acct</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12212"
></A
><H2
>Description</H2
><P
>When <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is the name of an existing file, 
<TT
CLASS="FUNCTION"
>acct()</TT
> turns accounting on and appends a record to
<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> for each terminating process. When
<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>,
<TT
CLASS="FUNCTION"
>acct()</TT
> turns accounting off.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12223"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12229"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12232"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOSYS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><ACRONYM
CLASS="ACRONYM"
>BSD</ACRONYM
> process accounting has not been enabled when 
the operating system kernel was compiled.  The kernel configuration 
parameter controlling this feature is 
<TT
CLASS="PARAMETER"
><I
>CONFIG_BSD_PROCESS_ACCT</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12238"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Out of memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12242"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The calling process has no permission to enable process accounting.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12246"
></A
><SPAN
STYLE="white-space: nowrap"
>EACCES</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is not a regular file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12251"
></A
><SPAN
STYLE="white-space: nowrap"
>EIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Error writing to the <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12256"
></A
><SPAN
STYLE="white-space: nowrap"
>EUSERS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There are no more free file structures or we run out of memory.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-ADJTIME-2"
></A
>adjtime</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12264"
></A
><H2
>Name</H2
>adjtime&nbsp;--&nbsp;correct the time to allow synchronization of the system clock</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12267"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12268"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;time.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>adjtime</TT
></CODE
>(const struct timeval *
  <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
>, struct timeval *
  <TT
CLASS="PARAMETER"
><I
>olddelta</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12277"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>adjtime()</TT
> makes small adjustments to the system time 
as returned by <TT
CLASS="FUNCTION"
>gettimeofday()</TT
>(2), advancing or retarding 
it by the time specified by the timeval <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
> is negative, the clock is slowed down 
by incrementing it more slowly than normal until the correction is complete. 
If <TT
CLASS="PARAMETER"
><I
>delta</I
></TT
> is positive, a larger increment than
normal is used. The skew used to perform the correction is generally a
fraction of one percent. Thus, the time is always a monotonically
increasing function. A time correction from an earlier call to
<TT
CLASS="FUNCTION"
>adjtime()</TT
> may not be finished when 
<TT
CLASS="FUNCTION"
>adjtime()</TT
> is called again. If
<TT
CLASS="PARAMETER"
><I
>olddelta</I
></TT
> is non-<TT
CLASS="LITERAL"
>NULL</TT
>, the 
structure pointed to will contain, upon return, the number of microseconds 
still to be corrected from the earlier call.</P
><P
><TT
CLASS="FUNCTION"
>adjtime()</TT
> may be used by time servers that synchronize 
the clocks of computers in a local area network. Such time servers would 
slow down the clocks of some machines and speed up the clocks of others to 
bring them to the average network time.</P
><P
>Appropriate privilege is required to adjust the system time.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12292"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12298"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12301"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An argument points outside the process's allocated address space.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12305"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process does not have appropriate privilege.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-ALPHASORT64-1"
></A
>alphasort64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12313"
></A
><H2
>Name</H2
>alphasort64&nbsp;--&nbsp;Comparison function for directory scanning (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12318"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12319"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;dirent.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>alphasort64</TT
></CODE
>(const struct dirent64 **
<TT
CLASS="PARAMETER"
><I
>d1</I
></TT
>, const struct dirent64 **
<TT
CLASS="PARAMETER"
><I
>d2</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12328"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>alpahsort64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>alphasort()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
If differs only in that the <TT
CLASS="PARAMETER"
><I
>d1</I
></TT
>
and <TT
CLASS="PARAMETER"
><I
>d2</I
></TT
> parameters are
of type <TT
CLASS="STRUCTNAME"
>dirent64</TT
> instead of type
<TT
CLASS="STRUCTNAME"
>dirent</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-ARGZ-ADD"
></A
>argz_add,
argz_add_sep,
argz_append,
argz_count,
argz_create,
argz_create_sep,
argz_delete,
argz_extract,
argz_insert,
argz_next,
argz_replace,
argz_stringify</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12342"
></A
><H2
>Name</H2
>argz_add,
argz_add_sep,
argz_append,
argz_count,
argz_create,
argz_create_sep,
argz_delete,
argz_extract,
argz_insert,
argz_next,
argz_replace,
argz_stringify&nbsp;--&nbsp;Operate on argz vectors</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12369"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12370"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;argz.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_add</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_add_sep</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>sep</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_append</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buf_len</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>size_t
<TT
CLASS="FUNCTION"
>argz_count</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_create</TT
></CODE
>(char * const 
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
>, char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_create_sep</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>sep</I
></TT
>, char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>argz_delete</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>entry</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>argz_extract</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, char **
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_insert</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>argz_insert</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>before</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>entry</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char
<TT
CLASS="FUNCTION"
>argz_next</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>entry</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>argz_replace</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>with</I
></TT
>, unsigned int *
<TT
CLASS="PARAMETER"
><I
>replace_count</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>argz_stringify</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>argz</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>argz_len</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>sep</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12490"
></A
><H2
>Description</H2
><P
>The argz functions operate on argz vectors, which are typically used
to more easily manipulate program arguments, of the form described 
in <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> in section 5.1.2.2.1, Program Startup.
While an argv is an array of character pointers to strings,
an argz vector is a set of strings, separated by
null characters, in contiguous memory; the vector is described by
a pointer to the first element and a size.  There is no limitation
that the argz must be made up of program arguments.</P
><P
>The argz functions which change argz vectors expect them to use
memory allocated using <TT
CLASS="FUNCTION"
>malloc()</TT
>, and will
themselves use <TT
CLASS="FUNCTION"
>malloc()</TT
> or <TT
CLASS="FUNCTION"
>realloc()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_create()</TT
> function converts an argv 
vector identified by <CODE
CLASS="VARNAME"
>argv</CODE
>
to an argz vector with the same elements, identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_create_sep()</TT
> function converts the
string identified by <CODE
CLASS="VARNAME"
>str</CODE
>,
spliting into a separate string at each occurence of 
<CODE
CLASS="VARNAME"
>sep</CODE
>, to an argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>. </P
><P
>The <TT
CLASS="FUNCTION"
>argz_add()</TT
> function adds the
string identified by <CODE
CLASS="VARNAME"
>str</CODE
> to the vector identified
by <CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>, updating
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_add_sep()</TT
> function adds the
string identified by <CODE
CLASS="VARNAME"
>str</CODE
>,
spliting into a separate string at each occurence of 
<CODE
CLASS="VARNAME"
>sep</CODE
>, to the vector identified
by <CODE
CLASS="VARNAME"
>argz</CODE
>, updating
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>. </P
><P
>The <TT
CLASS="FUNCTION"
>argz_append()</TT
> function appends
the argz vector identified by <CODE
CLASS="VARNAME"
>buf</CODE
> and
<CODE
CLASS="VARNAME"
>buf_len</CODE
> to the argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>,
thus updating <CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_count()</TT
> function returns the number
of strings in the argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_delete()</TT
> function removes the string
identified by <CODE
CLASS="VARNAME"
>entry</CODE
> from the 
the argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
>, <CODE
CLASS="VARNAME"
>argz_len</CODE
>, updating
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_extract()</TT
> function performs
the inverse of <TT
CLASS="FUNCTION"
>argz_create()</TT
>. It converts
an argz vector identified by 
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
> 
to an argv vector identified by <CODE
CLASS="VARNAME"
>argv</CODE
>
with the same elements.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_insert()</TT
> function inserts the string
identified by <CODE
CLASS="VARNAME"
>entry</CODE
> at position
<CODE
CLASS="VARNAME"
>before</CODE
> to the the argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>, updating
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_next()</TT
> function returns the entry
following the entry identfied by <CODE
CLASS="VARNAME"
>entry</CODE
>
in the argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.
If <CODE
CLASS="VARNAME"
>entry</CODE
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
the first entry is returned. This function can be used to
step through an argz vector by obtaining the first entry
by passing <CODE
CLASS="CONSTANT"
>NULL</CODE
>, then passing the just
obtained value to the next call, and so on. 
<CODE
CLASS="CONSTANT"
>NULL</CODE
> is returned if there is no following entry.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_replace()</TT
> function replaces each
occurrence of <CODE
CLASS="VARNAME"
>str</CODE
> in the argz vector identified by
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
> with
<CODE
CLASS="VARNAME"
>with</CODE
>, updating
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
>.
The counter pointed to by <CODE
CLASS="VARNAME"
>replace_count</CODE
> will be 
incremented by the number of replacements unless <CODE
CLASS="CONSTANT"
>NULL</CODE
>
is passed for <CODE
CLASS="VARNAME"
>replace_count</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>argz_stringify()</TT
> function performs the
inverse of <TT
CLASS="FUNCTION"
>argz_create_sep()</TT
>. It converts
the argz vector identified by 
<CODE
CLASS="VARNAME"
>argz</CODE
> and <CODE
CLASS="VARNAME"
>argz_len</CODE
> 
into a regular string, with the strings in the original
vector separated by <CODE
CLASS="VARNAME"
>sep</CODE
> in the converted string.
The conversion is done in place, so in effect each null byte in 
<CODE
CLASS="VARNAME"
>argz</CODE
> but the last one is replaced by
<CODE
CLASS="VARNAME"
>sep</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12584"
></A
><H2
>Return Value</H2
><P
>All of the argz functions that perform memory allocation return an
<SPAN
CLASS="TYPE"
>error_t</SPAN
> type. These functions return
<TT
CLASS="LITERAL"
>0</TT
> on success; if memory allocation fails,
they return <SPAN
CLASS="ERRORNAME"
>ENOMEM</SPAN
>.</P
><P
><TT
CLASS="FUNCTION"
>argz_count()</TT
> returns a count of substrings
in the argz vector as a <SPAN
CLASS="TYPE"
>size_t</SPAN
> type.</P
><P
><TT
CLASS="FUNCTION"
>argz_next()</TT
> returns a pointer to a substring
in an argz vector, or <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12596"
></A
><H2
>See Also</H2
><P
><A
HREF="#BASELIB-ENVZ-ADD"
> envz_add,
envz_entry,
envz_get,
envz_merge,
envz_remove,
envz_strip</A
></P
></DIV
><H1
><A
NAME="BASELIB-ASPRINTF"
></A
>asprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12604"
></A
><H2
>Name</H2
>asprintf&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12607"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12608"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>asprintf</TT
></CODE
>(char ** restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ptr</I
></TT
></I
></TT
>, const char * restrict
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12620"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>asprintf()</TT
> function shall behave as
<TT
CLASS="FUNCTION"
>sprintf()</TT
>, except that the output string
shall be dynamically allocated space of sufficient length to hold
the resulting string. The address of this dynamically allocated string
shall be stored in the location referenced by <TT
CLASS="PARAMETER"
><I
>ptr</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12626"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12630"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-BACKTRACE-1"
></A
>backtrace, backtrace_symbols, backtrace_symbols_fd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12638"
></A
><H2
>Name</H2
>backtrace, backtrace_symbols, backtrace_symbols_fd&nbsp;--&nbsp;runtime stack back tracing</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12647"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12648"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;execinfo.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>backtrace</TT
></CODE
>(void **<TT
CLASS="PARAMETER"
><I
>array</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char **<TT
CLASS="FUNCTION"
>backtrace_symbols</TT
></CODE
>(void *const *<TT
CLASS="PARAMETER"
><I
>array</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>backtrace_symbols_fd</TT
></CODE
>(void *const *<TT
CLASS="PARAMETER"
><I
>array</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12673"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>backtrace()</TT
>
obtains a backtrace for the current thread as a list of
pointers filled in to <TT
CLASS="PARAMETER"
><I
>array</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> parameter describes the
number of elements that will fit into <TT
CLASS="PARAMETER"
><I
>array</I
></TT
>,
<TT
CLASS="FUNCTION"
>backtrace()</TT
> will truncate the list if 
necessary.
A backtrace is a list of currently active function
calls in a thread; each function call allocates a new
stack frame and <TT
CLASS="FUNCTION"
>backtrace()</TT
>
obtains the return address from each stack frame.</P
><P
><TT
CLASS="FUNCTION"
>backtrace_symbols()</TT
>
translates the information obtained from
<TT
CLASS="FUNCTION"
>backtrace()</TT
> into an array of strings.
<TT
CLASS="PARAMETER"
><I
>array</I
></TT
> is a pointer to an
array of addresses as obtained from <TT
CLASS="FUNCTION"
>backtrace()</TT
>.
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
> is the number of entries in
<TT
CLASS="PARAMETER"
><I
>array</I
></TT
>, and should be the return
value of the call to
<TT
CLASS="FUNCTION"
>backtrace()</TT
>.
The strings contain the function name if it can be determined,
a hedxadecimal offset into the function, and the actual return
address in hexadecimal. Note that the pointer returned by
<TT
CLASS="FUNCTION"
>backtrace_symbols()</TT
> is obtained by an
internal call to <TT
CLASS="FUNCTION"
>malloc()</TT
> and should be
freed when no longer needed.</P
><P
><TT
CLASS="FUNCTION"
>backtrace_symbols_fd()</TT
>
performs the same transformation as 
<TT
CLASS="FUNCTION"
>backtrace_symbols()</TT
> given the
same argument pair
<TT
CLASS="PARAMETER"
><I
>array</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, but writes
the strings to the file descriptor contained in <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>.
This avoids the allocation of string space.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12698"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>backtrace()</TT
> returns the number of entries
placed into <TT
CLASS="PARAMETER"
><I
>array</I
></TT
>, no more than
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>.  If the value is less than
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>, the full backtrace was returned;
else it may have been truncated.</P
><P
>On success, <TT
CLASS="FUNCTION"
>backtrace_symbols()</TT
> returns a pointer to
an array of strings, which will have <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> entries.
On error, <TT
CLASS="LITERAL"
>NULL</TT
> is returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12709"
></A
><H2
>Errors</H2
><P
>No errors are defined for these functions.  If
<TT
CLASS="FUNCTION"
>backtrace_symbols_fd()</TT
> fails,
it will be due to a failure in the call to <TT
CLASS="FUNCTION"
>malloc()</TT
>,
and <CODE
CLASS="VARNAME"
>errno</CODE
> will be set accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12715"
></A
><H2
>Notes</H2
><P
>The ability to obtain useful backtrace information, in particular
function names, is dependent on a number of factors at the time
of program construction, such as compiler optimization options.
Even if the program itself is constructed so as to make symbols
visible, the call trace may descend into system libraries which
have not been so constructed.</P
><P
>Inlined functions do not have stack frames, and functions
declared as static are not exposed and so will not be available
in the backtrace.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12719"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>malloc()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-BASENAME-3"
></A
>basename</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12727"
></A
><H2
>Name</H2
>basename&nbsp;--&nbsp;return the last component of a file name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12730"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12731"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libgen.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>basename</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12738"
></A
><H2
>Description</H2
><P
>In the source standard, <TT
CLASS="FUNCTION"
>basename()</TT
> is implemented
as a macro causing it to behave as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
and is equivalent to the function <TT
CLASS="FUNCTION"
>__xpg_basename()</TT
>.
If the macro is undefined, <TT
CLASS="FUNCTION"
>basename()</TT
> from
the binary standard is used, with differences as described here:</P
><P
>The string identified by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> shall not be modified.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> is <TT
CLASS="LITERAL"
>"/"</TT
>, or ends with a 
trailing <TT
CLASS="LITERAL"
>'/'</TT
> character, the <TT
CLASS="FUNCTION"
>basename()</TT
>
function shall return a pointer to an empty string.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12752"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>basename()</TT
> function shall return a pointer to the final component of
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>. Otherwise, it shall return a null pointer.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12757"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>__xpg_basename()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-BIND-TEXTDOMAIN-CODESET"
></A
>bind_textdomain_codeset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12767"
></A
><H2
>Name</H2
>bind_textdomain_codeset&nbsp;--&nbsp;specify encoding for message retrieval</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12770"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12773"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
   <TT
CLASS="FUNCTION"
>bind_textdomain_codeset</TT
>
  </CODE
>(const char *
     <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>
  , const char *
     <TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
>
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12782"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> function can be used to
specify the output codeset for message catalogs for domain 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>.  The <TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
>
argument shall be a valid codeset name which can be used tor the
<TT
CLASS="PARAMETER"
><I
>iconv_open</I
></TT
> function, or a null pointer.
If the <TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
> argument is the null pointer, then 
function returns the currently selected codeset for the domain with the name
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>.  It shall return a null pointer if no
codeset has yet been selected.</P
><P
>Each successive call to <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
>
function overrrides the
settings made by the preceding call with the same <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> function shall return 
a pointer to a string containing the name of the selected codeset. 
The string shall be allocated
internally in the function and shall not be changed or freed by the user.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12798"
></A
><H2
>Parameters</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12801"
></A
><SPAN
STYLE="white-space: nowrap"
>domainname</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> argument 
to <TT
CLASS="PARAMETER"
><I
>textdomain</I
></TT
>, except that the selection of the 
domain is valid only for the duration of
the call.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12808"
></A
><SPAN
STYLE="white-space: nowrap"
>codeset</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of the output codeset for the selected domain, or NULL to select
the current codeset.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is the null pointer, or is an empty
string, <TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
> shall fail, but need not
set <CODE
CLASS="VARNAME"
>errno</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12816"
></A
><H2
>Return Value</H2
><P
>Returns the currently selected codeset name.  It returns a null
pointer if no codeset has yet been selected.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12819"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12822"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to allocate return value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12826"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain</P
></DIV
><H1
><A
NAME="BASELIB-BINDRESVPORT-3"
></A
>bindresvport</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12833"
></A
><H2
>Name</H2
>bindresvport&nbsp;--&nbsp;bind socket to privileged IP port</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12836"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12839"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;rpc/rpc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>bindresvport</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sd</I
></TT
></I
></TT
>, struct sockaddr_in *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sin</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12850"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege, the
<TT
CLASS="FUNCTION"
>bindresvport()</TT
> function shall bind
a socket to an anonymous privileged IP port,
that is, arbitrarily selected from the range
<TT
CLASS="LITERAL"
>512</TT
> through <TT
CLASS="LITERAL"
>1023</TT
>.</P
><P
>If the bind is successful and <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
> 
is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>, and the port number
bound to is returned in the <CODE
CLASS="STRUCTFIELD"
>sin_port</CODE
>
member of <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>.
Any caller-supplied value of <CODE
CLASS="STRUCTFIELD"
>sin_port</CODE
>
is ignored.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
the address family is taken to be
<CODE
CLASS="CONSTANT"
>AF_INET</CODE
> and an available
privileged port is bound to.
Since there is no <TT
CLASS="STRUCTNAME"
>sockaddr_in</TT
>
structure, the port number chosen cannot be returned.
The <TT
CLASS="FUNCTION"
>getsockname()</TT
> may be used to
query for this information.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12870"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
<CODE
CLASS="VARNAME"
>errno</CODE
> is set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12876"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>bindresvport()</TT
> may fail in the same
way as <TT
CLASS="FUNCTION"
>bind()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
The following additional or differing failures may occur:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12883"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EADDRINUSE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>All privileged ports are in use.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12888"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EAFNOSUPPORT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified address is not a valid address for the
address family of the specified socket, or the
address family is not supported.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12893"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EPFNOSUPPORT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The same meaning as <CODE
CLASS="CONSTANT"
>EAFNOSUPPORT</CODE
>.
Some older implementations may return this error instead.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>At this time, only <CODE
CLASS="CONSTANT"
>AF_INET</CODE
>
is supported.
Applications should be prepared for either the
<CODE
CLASS="CONSTANT"
>EAFNOSUPPORT</CODE
> or
<CODE
CLASS="CONSTANT"
>EPFNOSUPPORT</CODE
> error to be indicated.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-BINDTEXTDOMAIN"
></A
>bindtextdomain</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12908"
></A
><H2
>Name</H2
>bindtextdomain&nbsp;--&nbsp;specify the location of a message catalog</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12911"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12914"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>bindtextdomain</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12925"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> shall set the the base
directory of the hierarchy containing message catalogs for a given message
domain.</P
><P
>The <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> function specifies that the 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> message catalog can be found in the 
<TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> directory hierarchy, rather than in the 
system default locale data base.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> is not 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, the base directory for message catalogs 
belonging  to  domain 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> shall be set to 
<TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
the base directory for message catalogs shall not be altered.</P
><P
>The function shall make
copies of the argument strings as needed.</P
><P
><TT
CLASS="PARAMETER"
><I
>dirname</I
></TT
> can be an absolute or relative pathname.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Applications that wish to use <TT
CLASS="FUNCTION"
>chdir()</TT
>
should always use absolute pathnames to avoid misadvertently
selecting the wrong or non-existant directory.</P
></BLOCKQUOTE
></DIV
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is the null pointer, or is an empty
string, <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> shall fail, but need not
set <CODE
CLASS="VARNAME"
>errno</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> function shall return 
a pointer to a string containing the name of the selected directory. 
The string shall be allocated
internally in the function and shall not be changed or freed by the user.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12954"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> shall return a
pointer to a string containing the 
directory pathname currently bound to the domain. On failure, a 
<TT
CLASS="LITERAL"
>NULL</TT
> pointer is returned, and the global variable
<CODE
CLASS="VARNAME"
>errno</CODE
> may be set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12960"
></A
><H2
>Errors</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN12964"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>ENOMEM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory was available.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12969"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-CFMAKERAW-3"
></A
>cfmakeraw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12976"
></A
><H2
>Name</H2
>cfmakeraw&nbsp;--&nbsp;get and set terminal attributes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12979"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12982"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;termios.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>cfmakeraw</TT
></CODE
>(struct termios *
   <TT
CLASS="PARAMETER"
><I
>termios_p</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12989"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>cfmakeraw()</TT
> function shall set the
attributes of the <TT
CLASS="STRUCTNAME"
>termios</TT
> structure referenced
by <TT
CLASS="PARAMETER"
><I
>termios_p</I
></TT
> as follows:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  termios_p-&#62;c_iflag &#38;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);

  termios_p-&#62;c_oflag &#38;= ~OPOST;

  termios_p-&#62;c_lflag &#38;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);

  termios_p-&#62;c_cflag &#38;= ~(CSIZE|PARENB);

  termios_p-&#62;c_cflag |= CS8;</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="PARAMETER"
><I
>termios_p</I
></TT
> shall point to a 
<TT
CLASS="STRUCTNAME"
>termios</TT
> structure that contains the 
following members:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  tcflag_t c_iflag;      /* input modes */
  tcflag_t c_oflag;      /* output modes */
  tcflag_t c_cflag;      /* control modes */
  tcflag_t c_lflag;      /* local modes */
  cc_t c_cc[NCCS];       /* control chars */</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="BASELIB-CFSETSPEED-3"
></A
>cfsetspeed</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13006"
></A
><H2
>Name</H2
>cfsetspeed&nbsp;--&nbsp;set terminal input and output data rate</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13009"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13012"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;termios.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>cfsetspeed</TT
></CODE
>(struct termios *<TT
CLASS="PARAMETER"
><I
>t</I
></TT
>, speed_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>speed</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13022"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>cfsetspeed()</TT
> function shall set the input and output speeds in 
<TT
CLASS="PARAMETER"
><I
>t</I
></TT
> to the value specified by <TT
CLASS="PARAMETER"
><I
>speed</I
></TT
>.
The effects of the 
function on the terminal as described below do not become effective, 
nor are all errors detected, until the <TT
CLASS="FUNCTION"
>tcsetattr()</TT
> 
function is called. Certain values for baud rates set in 
<TT
CLASS="STRUCTNAME"
>termios</TT
> and passed to 
<TT
CLASS="FUNCTION"
>tcsetattr()</TT
> have special meanings.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13033"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13039"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13042"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid <TT
CLASS="PARAMETER"
><I
>speed</I
></TT
> argument</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-CLEARERR-UNLOCKED-1"
></A
>clearerr_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13051"
></A
><H2
>Name</H2
>clearerr_unlocked&nbsp;--&nbsp;non-thread-safe clearerr</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13056"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>clearerr_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>clearerr()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-DAEMON-3"
></A
>daemon</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13066"
></A
><H2
>Name</H2
>daemon&nbsp;--&nbsp;run in the background</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13069"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13072"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>daemon</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nochdir</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>noclose</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13083"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>daemon()</TT
> function shall create a new process,
detached from the controlling terminal. If successful, the calling process
shall exit and the new process shall continue to execute the application
in the background.
If <TT
CLASS="PARAMETER"
><I
>nochdir</I
></TT
> evaluates to true, the current directory
shall not be changed. Otherwise, 
<TT
CLASS="FUNCTION"
>daemon()</TT
> shall change the current working directory 
to the root (`/'). If <TT
CLASS="PARAMETER"
><I
>noclose</I
></TT
> evaluates to true
the standard input, standard output, and standard error file
descriptors shall not be altered. Otherwise,
<TT
CLASS="FUNCTION"
>daemon()</TT
> shall close
the standard input, standard output and standard error file descriptors
and reopen them attached to 
<TT
CLASS="FILENAME"
>/dev/null</TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13094"
></A
><H2
>Return Value</H2
><P
>On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned, and the global 
variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set to any of the errors 
specified for the library functions <TT
CLASS="FUNCTION"
>fork()</TT
> and 
<TT
CLASS="FUNCTION"
>setsid()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-DCGETTEXT"
></A
>dcgettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13105"
></A
><H2
>Name</H2
>dcgettext&nbsp;--&nbsp;perform domain and category specific lookup in message catalog</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13108"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13111"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;
#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dcgettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13125"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dcgettext()</TT
> function
is a domain specified version 
of <TT
CLASS="FUNCTION"
>gettext()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>dcgettext()</TT
>
function shall lookup the translation in the current locale of the message
identified by <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> in the domain specified by 
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> and in the locale
category specified by <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is NULL, the current default
domain shall be used. 
The <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> argument shall be a NULL-terminated 
string to be
matched in the catalogue. 
<TT
CLASS="PARAMETER"
><I
>category</I
></TT
> shall specify the locale category to be used
for retrieving message strings. 
The category parameter shall be one of <TT
CLASS="PARAMETER"
><I
>LC_CTYPE</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>LC_COLLATE</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MESSAGES</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MONETARY</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>LC_NUMERIC</I
></TT
>, 
or <TT
CLASS="PARAMETER"
><I
>LC_TIME</I
></TT
>. 
The default domain
shall not be changed by a call to <TT
CLASS="FUNCTION"
>dcgettext()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13147"
></A
><H2
>Return Value</H2
><P
>If a translation was found in one of the specified catalogs, it shall be
converted to the current locale's codeset and returned. The resulting
NULL-terminated string shall be allocated by the dcgettext function, and must
not be modified or freed. If no translation was found, or category was invalid,
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> shall be returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13151"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>dcgettext()</TT
> shall not modify the 
<CODE
CLASS="VARNAME"
>errno</CODE
> global variable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13156"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DCNGETTEXT"
></A
>dcngettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13163"
></A
><H2
>Name</H2
>dcngettext&nbsp;--&nbsp;perform domain and category specific lookup in message catalog
with plural</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13166"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13169"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;
#include &#60;locale.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dcngettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid2</I
></TT
></I
></TT
>, unsigned long int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13189"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dcngettext()</TT
> function is a domain specific version of 
gettext, capable of
returning either a singular or plural form of the message. 
The <TT
CLASS="FUNCTION"
>dcngettext()</TT
>
function shall lookup the translation in the current locale of the message
identified by <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>
in the domain specified by <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>
and in the locale
category specified by <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>. 
If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is NULL, the current default
domain shall be used. The <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>
argument shall be a NULL-terminated string to
be matched in the catalogue. <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>
shall specify the locale category to be
used for retrieving message strings. The <TT
CLASS="PARAMETER"
><I
>category</I
></TT
>
parameter shall be one of
<TT
CLASS="PARAMETER"
><I
>LC_CTYPE</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_COLLATE</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MESSAGES</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_MONETARY</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>LC_NUMERIC</I
></TT
>, or 
<TT
CLASS="PARAMETER"
><I
>LC_TIME</I
></TT
>. 
The
default domain shall not be changed by a call to <TT
CLASS="FUNCTION"
>dcngettext()</TT
>.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is 1 then the
singular version of the message is returned, otherwise one of the plural forms
is returned, depending on the value of <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> and the current locale settings.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13212"
></A
><H2
>Return Value</H2
><P
>If a translation corresponding to the value of <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>
was found in one of the
specified catalogs for <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>, 
it shall be converted to the current locale's
codeset and returned. The resulting NULL-terminated string 
shall be allocated by
the <TT
CLASS="FUNCTION"
>dcngettext()</TT
> function, 
and must not be modified or freed. If no translation
was found, or <TT
CLASS="PARAMETER"
><I
>category</I
></TT
> was invalid, 
<TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
> shall be returned 
if <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> has the value
1, otherwise <TT
CLASS="PARAMETER"
><I
>msgid2</I
></TT
> shall be returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13222"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>dcngettext()</TT
> shall not modify the 
<CODE
CLASS="VARNAME"
>errno</CODE
> global variable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13227"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DGETTEXT"
></A
>dgettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13234"
></A
><H2
>Name</H2
>dgettext&nbsp;--&nbsp;perform lookup in message catalog for the current LC_MESSAGES locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13237"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13240"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dgettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13251"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dgettext()</TT
> is a domain specified version of 
<TT
CLASS="FUNCTION"
>gettext()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>dgettext()</TT
> function shall search the currently
selected message catalogs in the domain
<TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> for a string identified by the string
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>. If a string is located,
that string shall be returned.
The domain specified by <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> applies to the 
currently active
<TT
CLASS="SYMBOL"
>LC_MESSAGE</TT
> locale. The default domain shall not
be changed by a call to <TT
CLASS="FUNCTION"
>dgettext()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The usage of <TT
CLASS="PARAMETER"
><I
>domainanme</I
></TT
> is equivalent in 
syntax and meaning to the <TT
CLASS="FUNCTION"
>textdomain()</TT
> function's
application of <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>, except that the 
selection of the domain in <TT
CLASS="FUNCTION"
>dgettext()</TT
> 
is valid only for the duration of the call.</P
></BLOCKQUOTE
></DIV
>&#13;</P
><P
>The <TT
CLASS="FUNCTION"
>dgettext()</TT
> function is equivalent to
<TT
CLASS="LITERAL"
>dcgettext(domainname, msgid, LC_MESSAGES)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13274"
></A
><H2
>Return Value</H2
><P
>On success of a <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> query, the translated 
<TT
CLASS="LITERAL"
>NULL</TT
>-terminated string is returned. On error, the 
original <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> is returned. The length of the
string returned is undetermined until <TT
CLASS="FUNCTION"
>dgettext()</TT
>
is called.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13281"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>dgettext()</TT
> shall not modify the 
<CODE
CLASS="VARNAME"
>errno</CODE
> global variable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13286"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DL-ITERATE-PHDR-1"
></A
>dl_iterate_phdr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13293"
></A
><H2
>Name</H2
>dl_iterate_phdr&nbsp;--&nbsp;iterate over a program's loaded shared objects</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13298"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13299"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;link.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>dl_iterate_phdr</TT
></CODE
>(int(*<TT
CLASS="PARAMETER"
><I
>callback</I
></TT
>)
(struct dl_phdr_info *, size_t, void *), void *<TT
CLASS="PARAMETER"
><I
>data</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13309"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dl_iterate_phdr()</TT
> allows a program to iterate
over the shared objects it has loaded.  
The function described by the <TT
CLASS="PARAMETER"
><I
>callback</I
></TT
> parameter
is called once for each loaded shared object, allowing an action
to be taken for each one.  <TT
CLASS="PARAMETER"
><I
>callback</I
></TT
> is
called with three arguments which are filled in by the implementation:
a pointer to a structure of type <TT
CLASS="STRUCTNAME"
>dl_phdr_info</TT
>
containing information about the shared object; an integer size
of the structure; and a copy of the <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>
argument to <TT
CLASS="FUNCTION"
>dl_iterate_phdr()</TT
>.  If 
<TT
CLASS="PARAMETER"
><I
>callback</I
></TT
> returns a non-zero value,
<TT
CLASS="FUNCTION"
>dl_iterate_phdr()</TT
> will stop processing, even
if there are unprocessed shared objects.  The order of
processing is unspecified.</P
><P
>The <TT
CLASS="STRUCTNAME"
>dl_phdr_info</TT
> structure has the following
members (note that on 64-bit architectures the types here shown
as <SPAN
CLASS="TYPE"
>Elf32_<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
></SPAN
> will
instead be <SPAN
CLASS="TYPE"
>Elf64_<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
></SPAN
>):
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN13326"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    Elf32_Addr dlpi_addr;
    const char *dlpi_name;
    const Elf32_Phdr *dlpi_phdr;
    Elf32_Half dlpi_phnum;
    unsigned long long int dlpi_adds;
    unsigned long long int dlpi_subs;
    size_t dlpi_tls_modid;
    void *dlpi_tls_data;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
><CODE
CLASS="STRUCTFIELD"
>dlpi_addr</CODE
> contains the base address
of the shared object.</P
><P
><CODE
CLASS="STRUCTFIELD"
>dlpi_name</CODE
> is a null-terminated string
giving the pathname from which the shared object was loaded.</P
><P
><CODE
CLASS="STRUCTFIELD"
>dlpi_phdr</CODE
> is a pointer to an array
of program headers for this shared object, while
<CODE
CLASS="STRUCTFIELD"
>dlpi_phnum</CODE
> is the number of
entries in this array.</P
><P
><CODE
CLASS="STRUCTFIELD"
>dlpi_adds</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>dlpi_subs</CODE
> are
incremented when shared objects are added or removed, respectively.</P
><P
><CODE
CLASS="STRUCTFIELD"
>dlpi_tls_modid</CODE
>
contains the module ID used in TLS relocations, 
if there is a <CODE
CLASS="CONSTANT"
>PT_TLS</CODE
> segment.
Otherwise the value shall be zero.</P
><P
><CODE
CLASS="STRUCTFIELD"
>dlpi_tls_data</CODE
>
contains the address of the calling thread's instance
of this module's <CODE
CLASS="CONSTANT"
>PT_TLS</CODE
> segment,
if there is one and it has been allocated in the calling thread.
Otherwise the value shall be a null pointer.</P
><P
>Some implementations may not provide all fields in
<TT
CLASS="STRUCTNAME"
>dl_phdr_info</TT
>, although the
first four are always mandatory.  Applications are
advised to have the callback function check the size
parameter before examining the later members.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13346"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>dl_iterate_phdr()</TT
> function returns whatever value
was  returned  by the last call to <TT
CLASS="PARAMETER"
><I
>callback</I
></TT
>.
This will be zero if processing completed normally, since processing
does not continue unless the callback function returns zero.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13351"
></A
><H2
>Errors</H2
><P
>No errors are defined by <TT
CLASS="FUNCTION"
>dl_iterate_phdr()</TT
>;
as noted the callback function must use a zero return to indicate
success but may assign any meaning it wishes to non-zero returns.</P
></DIV
><H1
><A
NAME="BASELIB-DNGETTEXT"
></A
>dngettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13359"
></A
><H2
>Name</H2
>dngettext&nbsp;--&nbsp;perform lookup in message catalog for the current locale</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13362"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13365"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>dngettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid2</I
></TT
></I
></TT
>, unsigned long int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13382"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dngettext()</TT
> shall be equivalent to a call to
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES)</PRE
></TD
></TR
></TABLE
>
See <TT
CLASS="FUNCTION"
>dcngettext()</TT
>
for more information.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13390"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-DRAND48-R-1"
></A
>drand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13397"
></A
><H2
>Name</H2
>drand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13402"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13403"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>drand48_r</TT
></CODE
>(struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, double *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13412"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>drand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>drand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>drand48_r()</TT
> shall 
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-ENDUTENT-3"
></A
>endutent</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13428"
></A
><H2
>Name</H2
>endutent&nbsp;--&nbsp;access utmp file entries</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13431"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13434"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>endutent</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13440"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>endutent()</TT
> closes the <TT
CLASS="FILENAME"
>utmp</TT
> 
file. It should be called when the user code is done accessing the 
file with the other functions.</P
></DIV
><H1
><A
NAME="BASELIB-ENVZ-ADD"
></A
>envz_add,
envz_entry,
envz_get,
envz_merge,
envz_remove,
envz_strip</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13451"
></A
><H2
>Name</H2
> envz_add,
envz_entry,
envz_get,
envz_merge,
envz_remove,
envz_strip&nbsp;--&nbsp;Operate on environment vectors</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13466"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13467"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;envz.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>envz_add</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>envz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>envz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>value</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char
<TT
CLASS="FUNCTION"
>envz_entry</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>envz</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>envz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char
<TT
CLASS="FUNCTION"
>envz_get</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>envz</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>envz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>error_t
<TT
CLASS="FUNCTION"
>envz_merge</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>envz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>envz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>envz2</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>envz2_len</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>override</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>envz_remove</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>envz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>envz_len</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>envz_strip</TT
></CODE
>(char **
<TT
CLASS="PARAMETER"
><I
>envz</I
></TT
>, size_t *
<TT
CLASS="PARAMETER"
><I
>envz_len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13527"
></A
><H2
>Description</H2
><P
>The envz functions operate on envz vectors, which are typically
used to manipulate program environment variables.</P
><P
>An envz vector is identical in makeup to an argz vector
(see <A
HREF="#BASELIB-ARGZ-ADD"
>argz_add,
argz_add_sep,
argz_append,
argz_count,
argz_create,
argz_create_sep,
argz_delete,
argz_extract,
argz_insert,
argz_next,
argz_replace,
argz_stringify</A
>)
but has the constraint that each element is a name, value pair
separated by an <TT
CLASS="LITERAL"
>=</TT
> character.   
Only the first <TT
CLASS="LITERAL"
>=</TT
> character in an element has special
meaning, any subsequent instances are part of the value string.
If no <TT
CLASS="LITERAL"
>=</TT
> character is present in an element,
the value is taken to be <CODE
CLASS="CONSTANT"
>NULL</CODE
>.
If an element has an empty value 
(an <TT
CLASS="LITERAL"
>=</TT
> character is present),
the value will return the empty string <TT
CLASS="LITERAL"
>""</TT
> when queried.</P
><P
>Since an envz vector is an argz vector, the argz functions can
be used where it makes sense.  For example, converting from
a program's environment variables (as described in Chapter 8
of the XBD volume of <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>) to an envz vector 
is done with <TT
CLASS="FUNCTION"
>argz_create()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>envz_add()</TT
> function adds a string
constructed from <CODE
CLASS="VARNAME"
>name</CODE
> and <CODE
CLASS="VARNAME"
>value</CODE
>
in the form "<CODE
CLASS="VARNAME"
>name</CODE
>=<CODE
CLASS="VARNAME"
>value</CODE
>"
to the envz vector identified by
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>, updating
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>. 
If <CODE
CLASS="VARNAME"
>value</CODE
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
> it adds 
a string of the form "<CODE
CLASS="VARNAME"
>name</CODE
>".
If an entry with the same name already exists, it is replaced..</P
><P
>The <TT
CLASS="FUNCTION"
>envz_entry()</TT
> function
searches for <CODE
CLASS="VARNAME"
>name</CODE
> in the envz vector identified by
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>,
returning the full entry if found, or <CODE
CLASS="CONSTANT"
>NULL</CODE
> if not.</P
><P
>The <TT
CLASS="FUNCTION"
>envz_get()</TT
> function
searches for <CODE
CLASS="VARNAME"
>name</CODE
> in the envz vector identified by
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>,
returning the value part of the entry if found, 
or <CODE
CLASS="CONSTANT"
>NULL</CODE
> if not. 
Note the value may be also <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>envz_merge()</TT
> function
adds each entry from the envz vector identified by
<CODE
CLASS="VARNAME"
>envz2</CODE
> and <CODE
CLASS="VARNAME"
>envz2_len</CODE
>
to the envz vector identified by
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>, updating
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>. 
The behavior is as if <TT
CLASS="FUNCTION"
>envz_add()</TT
> were called
for each entry in <CODE
CLASS="VARNAME"
>envz2</CODE
>.
If <CODE
CLASS="VARNAME"
>override</CODE
> is true, 
then values from <CODE
CLASS="VARNAME"
>envz2</CODE
> will replace those with the
same name in <CODE
CLASS="VARNAME"
>envz</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>envz_remove()</TT
> function
removes the entry for <CODE
CLASS="VARNAME"
>name</CODE
> from the 
envz vector identified by
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>
if it exists, updating
<CODE
CLASS="VARNAME"
>envz</CODE
> and <CODE
CLASS="VARNAME"
>envz_len</CODE
>. </P
><P
>The <TT
CLASS="FUNCTION"
>envz_strip()</TT
> function
removes all entries with value <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13590"
></A
><H2
>Return Value</H2
><P
>The envz functions that perform memory allocation 
(<TT
CLASS="FUNCTION"
>envz_add()</TT
> and <TT
CLASS="FUNCTION"
>envz_merge()</TT
>)
return an <SPAN
CLASS="TYPE"
>error_t</SPAN
> type. These functions return
<TT
CLASS="LITERAL"
>0</TT
> on success; if memory allocation fails,
they return <SPAN
CLASS="ERRORNAME"
>ENOMEM</SPAN
>.</P
><P
><TT
CLASS="FUNCTION"
>envz_entry()</TT
> and <TT
CLASS="FUNCTION"
>envz_get()</TT
>
return a pointer to a substring
in an envz vector, or <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13602"
></A
><H2
>See Also</H2
><P
><A
HREF="#BASELIB-ARGZ-ADD"
>argz_add,
argz_add_sep,
argz_append,
argz_count,
argz_create,
argz_create_sep,
argz_delete,
argz_extract,
argz_insert,
argz_next,
argz_replace,
argz_stringify</A
></P
></DIV
><H1
><A
NAME="BASELIB-EPOLL-CREATE-1"
></A
>epoll_create</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13610"
></A
><H2
>Name</H2
>epoll_create&nbsp;--&nbsp;open an epoll file descriptor</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13615"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13616"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/epoll.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>epoll_create</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13623"
></A
><H2
>Description</H2
><P
>The epoll API, which consists of the interfaces
<TT
CLASS="FUNCTION"
>epoll_create()</TT
>, <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
>,
and <TT
CLASS="FUNCTION"
>epoll_wait()</TT
>,
shall support all file descriptors compatible with <TT
CLASS="FUNCTION"
>poll()</TT
>.
These interfaces shall be usable in either level-triggered or edge-triggered mode.
In level-triggered mode, epoll has similar semantics to <TT
CLASS="FUNCTION"
>poll()</TT
>,
and can be used as a faster replacement for it.
In edge-triggered mode, epoll shall only report events for a file descriptor
when changes occur on it.</P
><P
>The <TT
CLASS="FUNCTION"
>epoll_create()</TT
> interface shall
open an epoll file descriptor
by allocating an event backing store 
of approximately size <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> parameter
is a hint to the kernel about how large the event storage
should be, not a rigidly-defined maximum size.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13635"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>epoll_create()</TT
> shall return
the file descriptor, a non-negative integer that
shall be used for subsequent epoll calls. It should be closed
with the <TT
CLASS="FUNCTION"
>close()</TT
> function.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>epoll_create()</TT
> shall return
<TT
CLASS="LITERAL"
>-1</TT
> and set <CODE
CLASS="VARNAME"
>errno</CODE
>
as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13644"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13647"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> parameter is not positive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13652"
></A
><SPAN
STYLE="white-space: nowrap"
>ENFILE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The maximum number of open files has been reached by the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13656"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Not enough memory to create the kernel object.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13660"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>close()</TT
>, <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
>, 
<TT
CLASS="FUNCTION"
>epoll_wait()</TT
>, <TT
CLASS="FUNCTION"
>poll()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-EPOLL-CTL-1"
></A
>epoll_ctl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13671"
></A
><H2
>Name</H2
>epoll_ctl&nbsp;--&nbsp;control an epoll file descriptor</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13676"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13677"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/epoll.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>epoll_ctl</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>op</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, struct epoll_event *
<TT
CLASS="PARAMETER"
><I
>event</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13690"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
> shall control an epoll file descriptor.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
> shall specify
the epoll file descriptor to control.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>op</I
></TT
> shall specify
the operation to perform on the specified target file descriptor.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> shall specify
the target file descriptor on which to perform the
specified operation.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>event</I
></TT
> shall specify
the object associated with the target file descriptor.
The <CODE
CLASS="VARNAME"
>events</CODE
> member of the
<TT
CLASS="PARAMETER"
><I
>event</I
></TT
> parameter is a bit set
composed of the event types listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13704"
></A
><H2
>Event types</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13707"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error condition occurred on the target file descriptor.
It shall not be necessary to set this event in
<CODE
CLASS="VARNAME"
>events</CODE
>;
this interface
shall always wait for it.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13712"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLET</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This event shall set edge-triggered behavior
for the target file descriptor.
The default epoll behavior shall be level-triggered.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13716"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLHUP</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A hang up occurred on the target file descriptor.
It shall not be necessary to set this event in
<CODE
CLASS="VARNAME"
>events</CODE
>;
this interface
shall always wait for it.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13721"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLIN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is accessible to <TT
CLASS="FUNCTION"
>read()</TT
> operations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13726"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLONESHOT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This event shall set one-shot behavior
for the target file descriptor.
After <TT
CLASS="FUNCTION"
>epoll_wait()</TT
> retrieves an event,
the file descriptor shall be disabled and epoll shall not
report any other events. 
To reenable the file descriptor with a new event mask,
the user should invoke <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
>
with <CODE
CLASS="CONSTANT"
>EPOLL_CTL_MOD</CODE
> in the
<TT
CLASS="PARAMETER"
><I
>op</I
></TT
> parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13734"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLOUT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is accessible to <TT
CLASS="FUNCTION"
>write()</TT
> operations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13739"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLPRI</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Urgent data exists for <TT
CLASS="FUNCTION"
>read()</TT
> operations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13744"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLLRDHUP</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A stream socket peer closed the connection,
or else the peer shut down the writing half
of the connection.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13748"
></A
><H2
>Values of the op parameter</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13751"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLL_CTL_ADD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Associate <TT
CLASS="PARAMETER"
><I
>event</I
></TT
>
with the file described by <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,
and add <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>
to the epoll descriptor <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13759"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLL_CTL_DEL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Remove <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> from
<TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>, and
ignore <TT
CLASS="PARAMETER"
><I
>event</I
></TT
>, which
can be <TT
CLASS="LITERAL"
>NULL</TT
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13767"
></A
><SPAN
STYLE="white-space: nowrap"
>EPOLL_CTL_MOD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Change the event <TT
CLASS="PARAMETER"
><I
>event</I
></TT
>
associated with <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13773"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
> shall return
<TT
CLASS="LITERAL"
>0</TT
>.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
> shall return
<TT
CLASS="LITERAL"
>-1</TT
> and set <CODE
CLASS="VARNAME"
>errno</CODE
>
as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13782"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13785"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
> or the
parameter <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is an invalid file descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13791"
></A
><SPAN
STYLE="white-space: nowrap"
>EEXIST</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>op</I
></TT
> was <CODE
CLASS="CONSTANT"
>EPOLL_CTL_ADD</CODE
>,
but the file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is already in
<TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13799"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
> is invalid,
or it is the same as <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,
or the operation specified by the parameter <TT
CLASS="PARAMETER"
><I
>op</I
></TT
>
is unsupported.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13806"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>op</I
></TT
> was 
<CODE
CLASS="CONSTANT"
>EPOLL_CTL_MOD</CODE
> or <CODE
CLASS="CONSTANT"
>EPOLL_CTL_DEL</CODE
>,
but the file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is not in
<TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13815"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Not enough memory for the operation specified by the parameter <TT
CLASS="PARAMETER"
><I
>op</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13820"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file specified by <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> does not support epoll.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13825"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>close()</TT
>, <TT
CLASS="FUNCTION"
>epoll_create()</TT
>, 
<TT
CLASS="FUNCTION"
>epoll_wait()</TT
>, <TT
CLASS="FUNCTION"
>poll()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-EPOLL-WAIT-1"
></A
>epoll_wait</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13836"
></A
><H2
>Name</H2
>epoll_wait&nbsp;--&nbsp;wait for I/O events on an epoll file descriptor</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13841"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13842"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/epoll.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>epoll_wait</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>, struct epoll_event *
<TT
CLASS="PARAMETER"
><I
>events</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>maxevents</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>timeout</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13855"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>epoll_wait()</TT
> shall
wait for events on the epoll file descriptor specified
by the parameter <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>.</P
><P
>Upon success, the output
parameter <TT
CLASS="PARAMETER"
><I
>events</I
></TT
> shall
refer to an area of memory containing <SPAN
CLASS="TYPE"
>epoll_event</SPAN
> structures
available to the caller.
The <CODE
CLASS="VARNAME"
>data</CODE
> members of these structures
shall contain the data set by the
user with the interface <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
>.
The <CODE
CLASS="VARNAME"
>events</CODE
> members 
shall contain the event bit field that was returned.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>maxevents</I
></TT
> shall
specify the maximum number of events that 
<TT
CLASS="FUNCTION"
>epoll_wait()</TT
>
may return in the output
parameter <TT
CLASS="PARAMETER"
><I
>events</I
></TT
>.
The value of this parameter should be greater
than <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>timeout</I
></TT
>
shall specify the maximum number of milliseconds
that <TT
CLASS="FUNCTION"
>epoll_wait()</TT
> shall
wait for events.
If the value of this parameter
is <TT
CLASS="LITERAL"
>0</TT
>, then <TT
CLASS="FUNCTION"
>epoll_wait()</TT
>
shall return immediately, even if no events are available, in which case the 
return code shall be <TT
CLASS="LITERAL"
>0</TT
>.
If the value of <TT
CLASS="PARAMETER"
><I
>timeout</I
></TT
>
is <TT
CLASS="LITERAL"
>-1</TT
>, then <TT
CLASS="FUNCTION"
>epoll_wait()</TT
>
shall block
until either a requested event occurs or the call is interrupted.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13880"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>epoll_wait()</TT
> shall return
the number of file descriptors that are ready for 
the I/O that was requested, or else <TT
CLASS="LITERAL"
>0</TT
>
if no descriptors became ready during
<TT
CLASS="PARAMETER"
><I
>timeout</I
></TT
>.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>epoll_wait()</TT
> shall return
<TT
CLASS="LITERAL"
>-1</TT
> and set <CODE
CLASS="VARNAME"
>errno</CODE
>
as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13890"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13893"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>
is not a valid file descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13898"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The area of memory referenced by the parameter
<TT
CLASS="PARAMETER"
><I
>events</I
></TT
> cannot be accessed
with write permissions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13903"
></A
><SPAN
STYLE="white-space: nowrap"
>EINTR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The call was interrupted by a signal handler before
the <TT
CLASS="PARAMETER"
><I
>timeout</I
></TT
> expired or 
any requested event took place.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN13908"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>epfd</I
></TT
>
is not a valid epoll file descriptor, or else
the parameter <TT
CLASS="PARAMETER"
><I
>maxevents</I
></TT
>
is less than or equal to <TT
CLASS="LITERAL"
>0</TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13915"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>close()</TT
>, <TT
CLASS="FUNCTION"
>epoll_ctl()</TT
>, 
<TT
CLASS="FUNCTION"
>epoll_create()</TT
>, <TT
CLASS="FUNCTION"
>poll()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-ERAND48-R-1"
></A
>erand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13926"
></A
><H2
>Name</H2
>erand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13931"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13932"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>erand48_r</TT
></CODE
>(unsigned short[3]
<TT
CLASS="PARAMETER"
><I
>xsubi</I
></TT
>, struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, double *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13943"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>erand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>erand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>erand48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-ERR-3"
></A
>err</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN13959"
></A
><H2
>Name</H2
>err&nbsp;--&nbsp;display formatted error messages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN13962"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN13965"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>err</TT
>
 </CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>eval</I
></TT
></I
></TT
>
 , const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>
 , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13977"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>err()</TT
> function
shall display a formatted error message on the standard error stream.
First, <TT
CLASS="FUNCTION"
>err()</TT
> shall write
the last component of the program name, a colon
character, and a space character.
If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is non-NULL, it shall be used as a
format string for the <TT
CLASS="FUNCTION"
>printf()</TT
>
family of functions, and <TT
CLASS="FUNCTION"
>err()</TT
> shall
write the formatted message, a colon character, and a space.
Finally,  the error message
string affiliated with the current value of the global variable 
<CODE
CLASS="VARNAME"
>errno</CODE
> shall be
written, followed by a newline character.</P
><P
>The <TT
CLASS="FUNCTION"
>err()</TT
> function shall not return, 
the program shall terminate with the exit value of <TT
CLASS="PARAMETER"
><I
>eval</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13991"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>error()</TT
>, <TT
CLASS="FUNCTION"
>errx()</TT
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13996"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13999"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-ERROR-N"
></A
>error</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14006"
></A
><H2
>Name</H2
>error&nbsp;--&nbsp;print error message</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14009"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14010"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;error.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>error</TT
>
 </CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>status</I
></TT
></I
></TT
>
 , int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>errnum</I
></TT
></I
></TT
>
 , const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>
 , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14025"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>error()</TT
> shall print a message to standard error.</P
><P
><TT
CLASS="FUNCTION"
>error()</TT
> shall build the message from the following 
elements in their specified order:
<P
></P
><OL
TYPE="1"
><LI
><P
>the program name. If the application has provided a function named 
<TT
CLASS="FUNCTION"
>error_print_progname()</TT
>, <TT
CLASS="FUNCTION"
>error()</TT
> 
shall call this to supply the program name; 
otherwise, <TT
CLASS="FUNCTION"
>error()</TT
> 
uses the content of the global variable <CODE
CLASS="VARNAME"
>program_name</CODE
>.</P
></LI
><LI
><P
>the colon and space characters, then 
the result of using the printf-style <TT
CLASS="PARAMETER"
><I
>format</I
></TT
> 
and the optional arguments.</P
></LI
><LI
><P
>if <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
> is nonzero, 
<TT
CLASS="FUNCTION"
>error()</TT
> shall add the colon and 
space characters, then the result of 
<TT
CLASS="LITERAL"
>strerror(<CODE
CLASS="VARNAME"
>errnum</CODE
>)</TT
>.</P
></LI
><LI
><P
>a newline.</P
></LI
></OL
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>status</I
></TT
> is nonzero, 
<TT
CLASS="FUNCTION"
>error()</TT
> shall call
<TT
CLASS="LITERAL"
>exit(<CODE
CLASS="VARNAME"
>status</CODE
>)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14054"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>err()</TT
>, <TT
CLASS="FUNCTION"
>errx()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-ERRX-3"
></A
>errx</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14063"
></A
><H2
>Name</H2
>errx&nbsp;--&nbsp;display formatted error message and exit</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14066"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14069"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>errx</TT
>
 </CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>eval</I
></TT
></I
></TT
>
 , const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>
 , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14081"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>errx()</TT
> function shall display a 
formatted error message on the standard error stream.
The last component of the program name, a colon 
character, and a space shall be output. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is 
non-<TT
CLASS="LITERAL"
>NULL</TT
>, it shall be used as the format string
for the <TT
CLASS="FUNCTION"
>printf()</TT
> family of functions, and
the formatted error message, a colon 
character, and a space shall be output. The output shall be followed by a 
newline character.</P
><P
><TT
CLASS="FUNCTION"
>errx()</TT
> does not return, but shall exit with the value of 
<TT
CLASS="PARAMETER"
><I
>eval</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14093"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14096"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14099"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>error()</TT
>, <TT
CLASS="FUNCTION"
>err()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-FCNTL-3"
></A
>fcntl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14108"
></A
><H2
>Name</H2
>fcntl&nbsp;--&nbsp;file control</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14111"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fcntl()</TT
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN14116"
></A
><H3
>Implementation may set <CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
></H3
><P
>According to <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
only an application sets
<TT
CLASS="FUNCTION"
>fcntl()</TT
> flags, for example 
<CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
>. However, this specification
also allows an implementation to set the <CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
> 
flag in the case where the programming environment is one of
<CODE
CLASS="CONSTANT"
>_POSIX_V6_ILP32_OFFBIG</CODE
>, <CODE
CLASS="CONSTANT"
>_POSIX_V6_LP64_OFF64</CODE
>, <CODE
CLASS="CONSTANT"
>_POSIX_V6_LPBIG_OFFBIG</CODE
>. See <B
CLASS="COMMAND"
>getconf</B
> and <B
CLASS="COMMAND"
>c99</B
>
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
for a description of these environments.
Thus, calling <TT
CLASS="FUNCTION"
>fcntl()</TT
> with the 
<TT
CLASS="PARAMETER"
><I
>F_GETFL</I
></TT
> command may return 
<CODE
CLASS="CONSTANT"
>O_LARGEFILE</CODE
> as well as flags explicitly 
set by the application in the case that both the implementation and 
the application support an <SPAN
CLASS="TYPE"
>off_t</SPAN
> of at least 64 bits.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN14138"
></A
><H3
>Additional flags</H3
><P
>In addition to the available values for <TT
CLASS="PARAMETER"
><I
>cmd</I
></TT
>, as documented in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, this specification permits the following constants.</P
><P
><CODE
CLASS="CONSTANT"
>F_GETSIG</CODE
> shall get the number of the signal to be sent when input or output can occur. If the value is <TT
CLASS="LITERAL"
>0</TT
>, then <CODE
CLASS="CONSTANT"
>SIGIO</CODE
> shall be sent. Otherwise, the value retrieved shall be the signal sent, and the signal handler can discover more information when installed with the <CODE
CLASS="CONSTANT"
>SA_SIGINFO</CODE
> flag.</P
><P
><CODE
CLASS="CONSTANT"
>F_SETSIG</CODE
> shall set the number of the signal to be sent when input or output can occur. If the value is <TT
CLASS="LITERAL"
>0</TT
>, then <CODE
CLASS="CONSTANT"
>SIGIO</CODE
> shall be sent. Otherwise, the value set shall be the signal to be sent, and the signal handler can discover more information when installed with the <CODE
CLASS="CONSTANT"
>SA_SIGINFO</CODE
> flag.</P
><P
><CODE
CLASS="CONSTANT"
>F_GETLK64</CODE
> is analogous to the <CODE
CLASS="CONSTANT"
>F_GETLK</CODE
> constant in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but shall provide a 64-bit interface on non-64-bit architectures. It is identical to <CODE
CLASS="CONSTANT"
>F_GETLK</CODE
> on a 64-bit machine, but is provided in 64-bit environments for source code consistency among architectures.</P
><P
><CODE
CLASS="CONSTANT"
>F_SETLK64</CODE
> is analogous to the <CODE
CLASS="CONSTANT"
>F_SETLK</CODE
> constant in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but shall provide a 64-bit interface on non-64-bit architectures. It is identical to <CODE
CLASS="CONSTANT"
>F_SETLK</CODE
> on a 64-bit machine, but is provided in 64-bit environments for source code consistency among architectures.</P
><P
><CODE
CLASS="CONSTANT"
>F_SETLKW64</CODE
> is analogous to the <CODE
CLASS="CONSTANT"
>F_SETLKW</CODE
> constant in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but provides a 64-bit interface on non-64-bit architectures. It is identical to <CODE
CLASS="CONSTANT"
>F_SETLKW</CODE
> on a 64-bit machine, but is provided in 64-bit environments for source code consistency among architectures.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-FEOF-UNLOCKED-1"
></A
>feof_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14172"
></A
><H2
>Name</H2
>feof_unlocked&nbsp;--&nbsp;non-thread-safe feof</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14177"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>feof_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>feof()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FERROR-UNLOCKED-1"
></A
>ferror_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14187"
></A
><H2
>Name</H2
>ferror_unlocked&nbsp;--&nbsp;non-thread-safe ferror</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14192"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>ferror_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>ferror()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FFLUSH-UNLOCKED-1"
></A
>fflush_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14202"
></A
><H2
>Name</H2
>fflush_unlocked&nbsp;--&nbsp;non thread safe fflush</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14207"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fflush_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fflush()</TT
> except that it need not be thread safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FGETC-UNLOCKED-1"
></A
>fgetc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14217"
></A
><H2
>Name</H2
>fgetc_unlocked&nbsp;--&nbsp;non-thread-safe fgetc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14222"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fgetc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fgetc()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FGETS-UNLOCKED-1"
></A
>fgets_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14232"
></A
><H2
>Name</H2
>fgets_unlocked&nbsp;--&nbsp;non-thread-safe fgets</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14237"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fgets_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fgets()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FGETWC-UNLOCKED-1"
></A
>fgetwc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14247"
></A
><H2
>Name</H2
>fgetwc_unlocked&nbsp;--&nbsp;non thread safe fgetwc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14252"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fgetwc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fgetwc()</TT
> except that it need not be thread safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FGETWS-UNLOCKED-1"
></A
>fgetws_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14262"
></A
><H2
>Name</H2
>fgetws_unlocked&nbsp;--&nbsp;non-thread-safe fgetws</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14267"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fgetws_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fgetws()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FILENO-UNLOCKED-1"
></A
>fileno_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14277"
></A
><H2
>Name</H2
>fileno_unlocked&nbsp;--&nbsp;non-thread-safe fileno</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14282"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fileno_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fileno()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FLOCK-2"
></A
>flock</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14292"
></A
><H2
>Name</H2
>flock&nbsp;--&nbsp;apply or remove an advisory lock on an open file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14295"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14298"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>flock</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>operation</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14308"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>flock()</TT
> applies or removes an advisory 
lock on the open file <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>. Valid 
<TT
CLASS="PARAMETER"
><I
>operation</I
></TT
> types are:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14317"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_SH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shared lock. More than one process may hold a shared lock for a given file at a given time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14321"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_EX</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Exclusive lock. Only one process may hold an exclusive lock for a given file at a given time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14325"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_UN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unlock.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14329"
></A
><SPAN
STYLE="white-space: nowrap"
>LOCK_NB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Don't block when locking. May be specified (by 
<I
CLASS="EMPHASIS"
>or</I
>ing) along with one of 
the other operations.</P
></TD
></TR
></TBODY
></TABLE
><P
>A single file may not simultaneously have both shared and exclusive locks.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14335"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14341"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14344"
></A
><SPAN
STYLE="white-space: nowrap"
>EWOULDBLOCK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is locked and the <TT
CLASS="LITERAL"
>LOCK_NB</TT
> flag was selected.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14349"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is not a not an open file descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14354"
></A
><SPAN
STYLE="white-space: nowrap"
>EINTR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>While waiting to acquire a lock, the  call  was  interrupted  by
delivery of a signal caught by a handler.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14358"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The operation is invalid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14362"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOLCK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The implementation ran out of memory for allocating lock records.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-FNMATCH-3"
></A
>fnmatch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14370"
></A
><H2
>Name</H2
>fnmatch&nbsp;--&nbsp;match a filename or a pathname</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14373"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fnmatch()</TT
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN14378"
></A
><H3
>Additional flags</H3
><P
>In addition to the available values that can be used to form <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>, as documented in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, this specification permits the following constants.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14384"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>FNM_CASEFOLD</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If this flag is set, the pattern is matched case-insensitively.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14389"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>FNM_FILE_NAME</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A synonym for <CODE
CLASS="CONSTANT"
>FNM_PATHNAME</CODE
> constant specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><H1
><A
NAME="BASELIB-FPUTC-UNLOCKED-1"
></A
>fputc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14400"
></A
><H2
>Name</H2
>fputc_unlocked&nbsp;--&nbsp;non-thread-safe fputc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14405"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fputc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fputc()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FPUTS-UNLOCKED-1"
></A
>fputs_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14415"
></A
><H2
>Name</H2
>fputs_unlocked&nbsp;--&nbsp;non-thread-safe fputs</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14420"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fputs_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fputs()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FPUTWC-UNLOCKED-1"
></A
>fputwc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14430"
></A
><H2
>Name</H2
>fputwc_unlocked&nbsp;--&nbsp;non-thread-safe fputwc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14435"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fputwc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fputwc()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FPUTWS-UNLOCKED-1"
></A
>fputws_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14445"
></A
><H2
>Name</H2
>fputws_unlocked&nbsp;--&nbsp;non-thread-safe fputws</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14450"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fputws_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fputws()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FREAD-UNLOCKED-1"
></A
>fread_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14460"
></A
><H2
>Name</H2
>fread_unlocked&nbsp;--&nbsp;non-thread-safe fread</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14465"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fread_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fread()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FSCANF"
></A
>fscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14475"
></A
><H2
>Name</H2
>fscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14478"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14483"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-FSTATFS-2"
></A
>fstatfs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14501"
></A
><H2
>Name</H2
>fstatfs&nbsp;--&nbsp;(deprecated)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14504"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14505"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/statfs.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>fstatfs</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, struct statfs *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14516"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>fstatfs()</TT
> function returns information about a mounted 
file system.  The file system is identified by <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,
a file descriptor of an open file within the mounted filesystem.
The results are placed in the structure pointed to by
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.</P
><P
>Fields that are undefined for a particular file system shall
be set to
<TT
CLASS="LITERAL"
>0</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Application developers should use the <TT
CLASS="FUNCTION"
>fstatvfs()</TT
> function
to obtain general file system information. Applications should only
use the <TT
CLASS="FUNCTION"
>fstatfs()</TT
> function if they must determine
the file system type, which need not be provided by 
<TT
CLASS="FUNCTION"
>fstatvfs()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14529"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>fstatfs()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> and set the fields of the
structure idenfitied by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> accordingly.
On error, the <TT
CLASS="FUNCTION"
>fstatfs()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set
<CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14538"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14541"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is not a valid open file descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14546"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> points to an invalid address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14551"
></A
><SPAN
STYLE="white-space: nowrap"
>EIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An I/O error occurred while reading from or writing to the file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14555"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOSYS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The filesystem <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is open on does not support 
<TT
CLASS="FUNCTION"
>statfs()</TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-FSTATFS64"
></A
>fstatfs64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14565"
></A
><H2
>Name</H2
>fstatfs64&nbsp;--&nbsp;(deprecated)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14568"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14569"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/statfs.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>fstatfs64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, struct statfs64 *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14580"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>fstatfs64()</TT
> function returns information about a mounted 
file system.  The file system is identified by <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,
a file descriptor of an open file within the mounted filesystem.
The results are placed in the structure pointed to by
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.</P
><P
>Fields that are undefined for a particular file system shall
be set to
<TT
CLASS="LITERAL"
>0</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>fstatfs64()</TT
> is a large-file
version of the <TT
CLASS="FUNCTION"
>fstatfs()</TT
> function.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Application developers should use the <TT
CLASS="FUNCTION"
>fstatvfs64()</TT
> function
to obtain general file system information. Applications should only
use the <TT
CLASS="FUNCTION"
>fstatfs64()</TT
> function if they must determine
the file system type, which need not be provided by 
<TT
CLASS="FUNCTION"
>fstatvfs64()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14596"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>fstatfs64()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> and set the fields of the
structure idenfitied by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> accordingly.
On error, the <TT
CLASS="FUNCTION"
>fstatfs64()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set
<CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14605"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>fstatfs()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FUTIMES"
></A
>futimes</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14613"
></A
><H2
>Name</H2
>futimes, lutimes&nbsp;--&nbsp;set file access and modification times</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14620"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14621"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/time.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>futimes</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, const struct timeval
<TT
CLASS="PARAMETER"
><I
>tv[2]</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>lutimes</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>, const struct timeval
<TT
CLASS="PARAMETER"
><I
>tv[2]</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14637"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>futimes()</TT
> and <TT
CLASS="FUNCTION"
>lutimes()</TT
> functions
shall set the access and modification times of a file to the values of 
the <CODE
CLASS="VARNAME"
>tv</CODE
> argument, which is an array of two
<SPAN
CLASS="TYPE"
>timeval</SPAN
> structures.
The behavior is as for <TT
CLASS="FUNCTION"
>utimes()</TT
>
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
>The <TT
CLASS="FUNCTION"
>futimes()</TT
> function shall change the times of of the
open file described by file descriptor <CODE
CLASS="VARNAME"
>fd</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>lutimes()</TT
> function shall change the times of of the
file pointed to by the <CODE
CLASS="VARNAME"
>filename</CODE
> argument,
except that if <CODE
CLASS="VARNAME"
>filename</CODE
> refers to a symbolic
link, then the link is not followed and the times of the
symbolic link are changed. This is similar to supplying
<CODE
CLASS="CONSTANT"
>AT_SYMLINK_NOFOLLOW</CODE
> in the <CODE
CLASS="VARNAME"
>flag</CODE
>
argument to the <TT
CLASS="FUNCTION"
>utimensat()</TT
> function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14656"
></A
><H2
>Errors</H2
><P
>As for <TT
CLASS="FUNCTION"
>utimes()</TT
>, but in addition:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14661"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>ENOSYS</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Ths implementation does not support this function 
(for <TT
CLASS="FUNCTION"
>lutimes()</TT
>).</P
><P
>The implementation could not access a resource needed to
complete the function (for <TT
CLASS="FUNCTION"
>futimes()</TT
>).</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14669"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>utimes()</TT
>,
<TT
CLASS="FUNCTION"
>utime()</TT
>,
<TT
CLASS="FUNCTION"
>utimensat()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FWRITE-UNLOCKED-1"
></A
>fwrite_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14679"
></A
><H2
>Name</H2
>fwrite_unlocked&nbsp;--&nbsp;non-thread-safe fwrite</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14684"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>fwrite_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>fwrite()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-FWSCANF"
></A
>fwscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14694"
></A
><H2
>Name</H2
>fwscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14697"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14702"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-GETCWD"
></A
>getcwd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14720"
></A
><H2
>Name</H2
>getcwd&nbsp;--&nbsp;get the pathname of the current working directory</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14723"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14724"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>getcwd</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14733"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getcwd()</TT
> functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14738"
></A
><H2
>Differences</H2
><P
>If <CODE
CLASS="VARNAME"
>buf</CODE
> is <TT
CLASS="LITERAL"
>NULL</TT
>,
memory is allocated for <CODE
CLASS="VARNAME"
>buf</CODE
>.
If <CODE
CLASS="VARNAME"
>size</CODE
> is <TT
CLASS="LITERAL"
>0</TT
>, 
the allocation size will be the size of the pathname +<TT
CLASS="LITERAL"
>1</TT
>,
else the requested <CODE
CLASS="VARNAME"
>size</CODE
> is allocated.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14748"
></A
><H2
>Changed or Added Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14751"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <CODE
CLASS="VARNAME"
>size</CODE
> argument is <TT
CLASS="LITERAL"
>0</TT
>
and <CODE
CLASS="VARNAME"
>buf</CODE
> is not a null pointer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14758"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The current working directory has been unlinked.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-GETDOMAINNAME"
></A
>getdomainname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14766"
></A
><H2
>Name</H2
>getdomainname&nbsp;--&nbsp;get NIS domain name (DEPRECATED).</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14769"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14770"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
    <TT
CLASS="FUNCTION"
>getdomainname</TT
>
  </CODE
>(char *
    <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>
  , size_t
    <TT
CLASS="PARAMETER"
><I
>namelen</I
></TT
>
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14779"
></A
><H2
>Description</H2
><P
>If the Network Information System (NIS) is in use, 
<TT
CLASS="FUNCTION"
>getdomainname()</TT
> shall
copy the NIS domain name to the supplied buffer identified by 
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>,
with maximum length <TT
CLASS="PARAMETER"
><I
>namelen</I
></TT
>. 
If the NIS domain name is not currently set, 
<TT
CLASS="FUNCTION"
>getdomainname()</TT
> shall
copy the string <TT
CLASS="LITERAL"
>"(none)"</TT
> to the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>namelen</I
></TT
> is less than
the length of the string
to be copied, <TT
CLASS="FUNCTION"
>getdomainname()</TT
>
shall either truncate the string to <TT
CLASS="PARAMETER"
><I
>namelen</I
></TT
>
characters and place it in <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>
(without a terminating null character),
or shall fail with <SPAN
CLASS="ERRORNAME"
>EINVAL</SPAN
>.</P
><P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The NIS domain name is not the same as the domain portion of
a fully qualified domain name (for example, in DNS).</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>The LSB does not include other NIS functions, nor does it specify how NIS may
affect other database functions. No conforming application can make use of this information
beyond noting whether or not the domain name has been set. If the name is set to a value
other than the string <TT
CLASS="LITERAL"
>"(none)"</TT
>, the application should not imply that
NIS is in use. Similarly, if it is set to <TT
CLASS="LITERAL"
>"(none)"</TT
>, the application should not assume
that NIS is not in use, although NIS functionality may be restricted in this case.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14799"
></A
><H2
>Return Value</H2
><P
>On success,
<TT
CLASS="FUNCTION"
>getdomainname()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>. Otherwise, it shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14806"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14809"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is a null pointer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14814"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer identified by <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>namelen</I
></TT
> is of insufficient size to store the NIS domain name string, and the implementation considers this an error.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14820"
></A
><H2
>Future Directions</H2
><P
>The LSB does not include other NIS interfaces, and a future version
of this specification may remove this interface.
Application developers should avoid using this interface where possible.</P
></DIV
><H1
><A
NAME="BASELIB-GETDTABLESIZE"
></A
>getdtablesize</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14827"
></A
><H2
>Name</H2
>getdtablesize&nbsp;--&nbsp;get file descriptor table size (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14830"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14831"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
    <TT
CLASS="FUNCTION"
>getdtablesize</TT
>
  </CODE
>(void
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14837"
></A
><H2
>Description</H2
><P
>The function <TT
CLASS="FUNCTION"
>getdtablesize()</TT
> returns
the number of files a process can have open.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>getdtablesize()</TT
> function is deprecated.
Portable applications should call <TT
CLASS="FUNCTION"
>sysconf()</TT
>
with the <CODE
CLASS="CONSTANT"
>_SC_OPEN_MAX</CODE
> option instead.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14846"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>getdtablesize()</TT
>
function returns the current soft limit as if obtained by
a call to <TT
CLASS="FUNCTION"
>sysconf()</TT
>
with the <CODE
CLASS="CONSTANT"
>_SC_OPEN_MAX</CODE
> option.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14852"
></A
><H2
>Errors</H2
><P
>No errors are defined.</P
></DIV
><H1
><A
NAME="BASELIB-GETGRENT-R-1"
></A
>getgrent_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14859"
></A
><H2
>Name</H2
>getgrent_r&nbsp;--&nbsp;reentrantly get entry in group file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14864"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14865"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getgrent_r</TT
></CODE
>(struct group *
<TT
CLASS="PARAMETER"
><I
>gbuf</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct group * *
<TT
CLASS="PARAMETER"
><I
>gbufp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14878"
></A
><H2
>Description</H2
><P
>The reentrant interface <TT
CLASS="FUNCTION"
>getgrent_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>getgrent()</TT
>, except that
<TT
CLASS="FUNCTION"
>getgrent_r()</TT
> shall
return the group name, group password, and group members
in buffers provided by the caller, rather than as a pointer to static storage.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>gbuf</I
></TT
> contains the 
<SPAN
CLASS="TYPE"
>struct group</SPAN
> that was read from the stream, if any.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> contains 
additional strings, if any.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies 
the size of <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>*gbufp</I
></TT
> returns 
a pointer to the <SPAN
CLASS="TYPE"
>struct group</SPAN
> in <TT
CLASS="PARAMETER"
><I
>*gbuf</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14896"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>getgrent_r()</TT
> shall return <TT
CLASS="LITERAL"
>0</TT
>,
and <TT
CLASS="PARAMETER"
><I
>*gbufp</I
></TT
> shall contain a pointer to the result.</P
><P
>On failure, <TT
CLASS="PARAMETER"
><I
>*gbufp</I
></TT
> shall contain 
<TT
CLASS="LITERAL"
>NULL</TT
>, and <TT
CLASS="FUNCTION"
>getgrent_r()</TT
>
shall return an error as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14906"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14909"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No more group entries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN14913"
></A
><SPAN
STYLE="white-space: nowrap"
>ERANGE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Not enough buffer space. Specify a larger buffer and try again.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-GETGROUPLIST-3"
></A
>getgrouplist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14921"
></A
><H2
>Name</H2
>getgrouplist&nbsp;--&nbsp;get groups a user belongs to</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14924"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14925"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getgrouplist</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>user</I
></TT
>, gid_t
<TT
CLASS="PARAMETER"
><I
>group</I
></TT
>, gid_t *
<TT
CLASS="PARAMETER"
><I
>groups</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14938"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getgrouplist()</TT
> function shall
fill in the array <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> with 
the supplementary groups for the user specified
by <TT
CLASS="PARAMETER"
><I
>user</I
></TT
>. On entry, 
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> shall refer to an integer
containing the maximum number of 
elements in the <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> array.
The group <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> shall also be included
in the values returned in <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
>.
It is expected that <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> would be specified as the
user's primary group from the password file (obtainable
via <TT
CLASS="FUNCTION"
>getpwnam()</TT
> or a similar function).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14952"
></A
><H2
>Return Value</H2
><P
>If on entry the value referenced by <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
>
was greater than or equal to the number of supplementary
group identifiers to be copied to the array identified by
<TT
CLASS="PARAMETER"
><I
>groups</I
></TT
>, 
<TT
CLASS="FUNCTION"
>getgrouplist()</TT
> shall return the number of 
group identifiers actually copied, and shall set the value
referenced by <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> to this value.</P
><P
>If on entry the value referenced by <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
>
was less than the number of supplementary
group identifiers, <TT
CLASS="FUNCTION"
>getgrouplist()</TT
> shall return
<CODE
CLASS="CONSTANT"
>-1</CODE
>. The initial <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
>
entries in <TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> shall be overwritten.</P
><P
>If the number of groups exceeds the input
<TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> value, then as well as returning
<CODE
CLASS="CONSTANT"
>-1</CODE
>, <TT
CLASS="PARAMETER"
><I
>ngroups</I
></TT
> shall be set
to the number of groups that would have been placed in
<TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> if it had been large enough.

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In such a case, the caller can use the information returned to make a
further <TT
CLASS="FUNCTION"
>getgrouplist()</TT
> call with a correctly sized
<TT
CLASS="PARAMETER"
><I
>groups</I
></TT
> array.</P
></BLOCKQUOTE
></DIV
>&#13;</P
><P
>If <TT
CLASS="PARAMETER"
><I
>user</I
></TT
> does not refer to a valid user on the system,
then the behavior of this function is undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14976"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14979"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>getgroups()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-GETHOSTBYADDR-R-3"
></A
>gethostbyaddr_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN14987"
></A
><H2
>Name</H2
>gethostbyaddr_r&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN14990"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN14991"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>gethostbyaddr_r</TT
></CODE
>(const void * restrict
<TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>, socklen_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>type</I
></TT
>, struct hostent * restrict
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char * restrict
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct hostent * * restrict
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15012"
></A
><H2
>Description</H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> function is deprecated;
applications should use <TT
CLASS="FUNCTION"
>getaddrinfo()</TT
> instead.</P
></BLOCKQUOTE
></DIV
><P
><TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> is a reentrant version of 
<TT
CLASS="FUNCTION"
>gethostbyaddr()</TT
> that searches the network host 
database for a host address match.</P
><P
>The <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> function shall search the network host database
for an entry of address family <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> with
the host with address <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>. The <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> argument contains the length of the address referenced by
<TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>. </P
><P
>If <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> is <CODE
CLASS="CONSTANT"
>AF_INET</CODE
>, the <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> argument shall be an
<TT
CLASS="STRUCTNAME"
>in_addr</TT
> structure. 
If <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> is <CODE
CLASS="CONSTANT"
>AF_INET6</CODE
>, the <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> argument shall be an
<TT
CLASS="STRUCTNAME"
>in6_addr</TT
> structure. 
If <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> is any other value, the behavior is unspecified.</P
><P
>The application must provide a buffer for the <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> to use during
the lookup process. The buffer is referenced by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, and is of size <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>.
If the buffer is not of sufficient size, <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> may fail and return
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>.
If a matching entry is found in the database, <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> shall
copy the relevant information to the application supplied <TT
CLASS="STRUCTNAME"
>hostent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.
Additional error information shall be set in the variable referenced by <TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15049"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> function shall return zero. If the 
return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.
If the <TT
CLASS="FUNCTION"
>gethostbyaddr_r()</TT
> function returns returns any other
value, then the variable referenced by <TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
> shall be set to indicate the cause as
for <TT
CLASS="FUNCTION"
>gethostbyaddr()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETHOSTBYNAME2-3"
></A
>gethostbyname2</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15063"
></A
><H2
>Name</H2
>gethostbyname2&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15066"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15067"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
<TT
CLASS="FUNCTION"
>gethostbyname2</TT
></CODE
>(const char * restrict 
<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>af</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15077"
></A
><H2
>Description</H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>gethostbyname2()</TT
> function is deprecated;
applications should use <TT
CLASS="FUNCTION"
>getaddrinfo()</TT
> instead.</P
></BLOCKQUOTE
></DIV
><P
>The <TT
CLASS="FUNCTION"
>gethostbyname2()</TT
> function shall search the
network host database for an entry with name <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
This function is similar to the <TT
CLASS="FUNCTION"
>gethostbyname()</TT
>
function but additionally allows the search to be restricted to
a particular address family specified by <TT
CLASS="PARAMETER"
><I
>af</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15088"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>gethostbyname2()</TT
> function shall return a
pointer to a <TT
CLASS="STRUCTNAME"
>hostent</TT
> structure if the requested entry was
found, and a null pointer otherwise.</P
><P
>On unsuccessful completion, <TT
CLASS="FUNCTION"
>gethostbyname2()</TT
> shall
set <CODE
CLASS="VARNAME"
>h_errno</CODE
> as
for <TT
CLASS="FUNCTION"
>gethostbyname()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15098"
></A
><H2
>Errors</H2
><P
>The <TT
CLASS="FUNCTION"
>gethostbyname2()</TT
> shall set <CODE
CLASS="VARNAME"
>h_errno</CODE
>
as for <TT
CLASS="FUNCTION"
>gethostbyname()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETHOSTBYNAME2-R-3"
></A
>gethostbyname2_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15109"
></A
><H2
>Name</H2
>gethostbyname2_r&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15112"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15113"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>gethostbyname2_r</TT
></CODE
>(const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>af</I
></TT
></I
></TT
>, struct hostent * restrict 
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char * restrict  
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buflen</I
></TT
></I
></TT
>, struct hostent ** restrict <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>, int * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>h_errnop</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15136"
></A
><H2
>Description</H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>gethostbyname2_r()</TT
> function is deprecated;
applications should use <TT
CLASS="FUNCTION"
>getaddrinfo()</TT
> instead.</P
></BLOCKQUOTE
></DIV
><P
>The <TT
CLASS="FUNCTION"
>gethostbyname2_r()</TT
> function shall search the
network host database for an entry with name <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
<TT
CLASS="FUNCTION"
>gethostbyname2_r()</TT
> is a reentrant version of 
<TT
CLASS="FUNCTION"
>gethostbyname2()</TT
>.  These functions are similar to
the <TT
CLASS="FUNCTION"
>gethostbyname()</TT
> and 
<TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> functions but additionally
allow the search to be restricted to a particular address family
specified by <TT
CLASS="PARAMETER"
><I
>af</I
></TT
>.</P
><P
>The application must provide a buffer for the <TT
CLASS="FUNCTION"
>gethostbyname2_r()</TT
> function to use during the lookup process. The buffer is referenced
by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, and is of size <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>.
If the buffer is not of sufficient size, <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
>
may fail and return <SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>.
If a matching entry is found in the database, 
<TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> shall
copy the relevant information to the application-supplied
<TT
CLASS="STRUCTNAME"
>hostent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this
structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall
be set to a null pointer.
Additional error information shall be set in the variable referenced
by <TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15162"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>gethostbyname2_r()</TT
> function shall
return zero. If the return value was <SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated
by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.
If the <TT
CLASS="FUNCTION"
>gethostbyname2_r()</TT
> function returns returns any other
value, then the variable referenced by <TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
>
shall be set to indicate the cause as for <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETHOSTBYNAME-R-3"
></A
>gethostbyname_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15176"
></A
><H2
>Name</H2
>gethostbyname_r&nbsp;--&nbsp;find network host database entry matching host name (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15179"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15180"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>gethostbyname_r</TT
></CODE
>(const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, struct hostent * restrict 
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char * restrict  
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buflen</I
></TT
></I
></TT
>, struct hostent ** restrict <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>, int * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>h_errnop</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15200"
></A
><H2
>Description</H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> function is deprecated;
applications should use <TT
CLASS="FUNCTION"
>getaddrinfo()</TT
> instead.</P
></BLOCKQUOTE
></DIV
><P
><TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> is a reentrant version of 
<TT
CLASS="FUNCTION"
>gethostbyname()</TT
> that searches the network host 
database for a host name match.</P
><P
>The <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> function shall search the network host database
for an entry with name <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.</P
><P
>The application must provide a buffer for the <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> to use during
the lookup process. The buffer is referenced by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, and is of size <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>.
If the buffer is not of sufficient size, <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> may fail and return
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>.
If a matching entry is found in the database, <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> shall
copy the relevant information to the application supplied <TT
CLASS="STRUCTNAME"
>hostent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.
Additional error information shall be set in the variable referenced by <TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15224"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> function shall return zero. If the 
return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.
If the <TT
CLASS="FUNCTION"
>gethostbyname_r()</TT
> function returns returns any other
value, then the variable referenced by <TT
CLASS="PARAMETER"
><I
>h_errnop</I
></TT
> shall be set to indicate the cause as
for <TT
CLASS="FUNCTION"
>gethostbyname()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETIFADDRS"
></A
>getifaddrs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15238"
></A
><H2
>Name</H2
>getifaddrs, freeifaddrs&nbsp;--&nbsp;get interface addresses</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15246"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15247"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;ifaddrs.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getifaddrs</TT
></CODE
>(struct ifaddrs **
<TT
CLASS="PARAMETER"
><I
>ifap</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>freeifaddrs</TT
></CODE
>(struct ifaddrs *
<TT
CLASS="PARAMETER"
><I
>ifa</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15259"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getifaddrs()</TT
> function creates a linked
list of structures describing the network interfaces of the
local system.  The address of the first item is stored in
memory pointed to by <CODE
CLASS="VARNAME"
>ifap</CODE
>. The data returned is dynamically
allocated, and should be freed using <TT
CLASS="FUNCTION"
>freeifaddrs()</TT
>.</P
><P
>The list consists of structures of type <TT
CLASS="STRUCTNAME"
>ifaddrs</TT
>
(see Data Definitions above).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15267"
></A
><H2
>Return Value</H2
><P
>On  success,  <TT
CLASS="FUNCTION"
>getifaddrs()</TT
> returns zero; on error, 
<TT
CLASS="LITERAL"
>-1</TT
> is returned, and
<CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15273"
></A
><H2
>Errors</H2
><P
><TT
CLASS="FUNCTION"
>getifaddrs()</TT
> may fail and set errno for
any of the errors specified for <TT
CLASS="FUNCTION"
>socket()</TT
>,
<TT
CLASS="FUNCTION"
>bind()</TT
>,  <TT
CLASS="FUNCTION"
>getsockname()</TT
>,
<TT
CLASS="FUNCTION"
>recvmsg()</TT
>, <TT
CLASS="FUNCTION"
>sendto()</TT
>,
<TT
CLASS="FUNCTION"
>malloc()</TT
>, or <TT
CLASS="FUNCTION"
>realloc()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15284"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>bind()</TT
>,
<TT
CLASS="FUNCTION"
>getsockname()</TT
>,
<TT
CLASS="FUNCTION"
>socket()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETLOADAVG-3"
></A
>getloadavg</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15294"
></A
><H2
>Name</H2
>getloadavg&nbsp;--&nbsp;get system load averages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15297"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15300"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getloadavg</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>loadavg</I
></TT
>[]</I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nelem</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15311"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getloadavg()</TT
> returns the number of processes in 
the system run queue averaged over various periods of time. Up to 
<TT
CLASS="PARAMETER"
><I
>nelem</I
></TT
> samples are retrieved and assigned to 
successive elements of <TT
CLASS="PARAMETER"
><I
>loadavg</I
></TT
>[]. The system 
imposes a maximum of <TT
CLASS="LITERAL"
>3</TT
> samples, representing 
averages over the last <TT
CLASS="LITERAL"
>1</TT
>, <TT
CLASS="LITERAL"
>5</TT
>, 
and <TT
CLASS="LITERAL"
>15</TT
> minutes, respectively.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15323"
></A
><H2
>Return Value</H2
><P
>If the load average could not be obtained, <TT
CLASS="LITERAL"
>-1</TT
> is
returned.  Otherwise, the number of samples actually retrieved 
is returned.</P
></DIV
><H1
><A
NAME="LIBUTIL-GETOPT-3"
></A
>getopt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15331"
></A
><H2
>Name</H2
>getopt&nbsp;--&nbsp;parse command line options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15336"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15339"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getopt</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * const 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argv</I
></TT
>[]</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>optstring</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>extern char <CODE
CLASS="VARNAME"
>*optarg</CODE
>;
extern int <CODE
CLASS="VARNAME"
>optind</CODE
>, <CODE
CLASS="VARNAME"
>opterr</CODE
>, <CODE
CLASS="VARNAME"
>optopt</CODE
>;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15358"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getopt()</TT
> function shall parse command line arguments
as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, with the following exceptions,
where LSB and POSIX specifications vary.
LSB systems shall
implement the modified behaviors described below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN15365"
></A
><H3
>Argument Ordering</H3
><P
>The <TT
CLASS="FUNCTION"
>getopt()</TT
> function can process command line arguments
referenced by <TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> in one of three ways:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15371"
></A
><SPAN
STYLE="white-space: nowrap"
>PERMUTE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the order of arguments in
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> is altered so that all options (and
their arguments) are moved in front of all of the operands.
This is the default behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This behavior has undefined results if 
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> is not modifiable. This is to support
historic behavior predating the use of <SPAN
CLASS="TOKEN"
>const</SPAN
> and
<A
HREF="#STD.ISOC99"
>ISO C (1999)</A
>. The function prototype was aligned
with <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> despite the fact that it modifies
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
>, 
and the library maintainers are unwilling to change this.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15383"
></A
><SPAN
STYLE="white-space: nowrap"
>REQUIRE_ORDER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The arguments in
<TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> are processed in exactly the order
given, and option processing stops when the first non-option argument
is reached, or when the element of argv is "--". This ordering
can be enforced either by setting the environment variable
<CODE
CLASS="VARNAME"
>POSIXLY_CORRECT</CODE
>, or by setting the first character
of <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> to '+'.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15390"
></A
><SPAN
STYLE="white-space: nowrap"
>RETURN_IN_ORDER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The order of arguments
is not altered, and all arguments are processed. Non-option arguments
(operands) are handled as if they were the argument to an option with
the value 1 ('\001'). This ordering is selected by setting the first
character of <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> to '-';</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN15395"
></A
><H3
>Option Characteristics</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>an element of <TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> that starts with 
"<SPAN
CLASS="TOKEN"
>-</SPAN
>" (and is not exactly "<SPAN
CLASS="TOKEN"
>-</SPAN
>" or 
"<SPAN
CLASS="TOKEN"
>--</SPAN
>") is an option element.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>characters of an option element, aside from the initial 
"<SPAN
CLASS="TOKEN"
>-</SPAN
>", are option characters.</P
></LI
></UL
></P
><P
><I
CLASS="EMPHASIS"
>POSIX</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>applications using <TT
CLASS="FUNCTION"
>getopt()</TT
> shall obey the following 
syntax guidelines:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>option name is a single alphanumeric character from the portable character set</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>option is preceded by the '<SPAN
CLASS="TOKEN"
>-</SPAN
>' delimiter character</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>options without option-arguments should be accepted when grouped behind 
one '<SPAN
CLASS="TOKEN"
>-</SPAN
>' delimiter</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>each option and option-argument is a separate argument</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>option-arguments are not optional</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>all options should precede operands on the command line</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>the argument "<SPAN
CLASS="TOKEN"
>--</SPAN
>" is accepted as a delimiter 
indicating the end of options and the consideration of subsequent 
arguments, if any, as operands</P
></LI
></UL
></P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>historical implementations of <TT
CLASS="FUNCTION"
>getopt()</TT
> support 
other characters as options as an allowed extension, but applications 
that use extensions are not maximally portable.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>support for multi-byte option characters is only possible when such 
characters can be represented as type <TT
CLASS="LITERAL"
>int</TT
>.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>applications that call any utility with a first operand starting with 
'<SPAN
CLASS="TOKEN"
>-</SPAN
>' should usually specify "<SPAN
CLASS="TOKEN"
>--</SPAN
>" 
to mark the end of the options. Standard utilities that do not support 
this guideline indicate that fact in the OPTIONS section of the utility 
description.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN15443"
></A
><H3
>Extensions</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>if a character is followed by two colons, the option takes an optional 
argument; if there is text in the current <TT
CLASS="PARAMETER"
><I
>argv</I
></TT
> element, 
it is returned in <TT
CLASS="PARAMETER"
><I
>optarg</I
></TT
>, otherwise 
<TT
CLASS="PARAMETER"
><I
>optarg</I
></TT
> is set to <TT
CLASS="LITERAL"
>0</TT
>.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>if <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> contains <TT
CLASS="LITERAL"
>W</TT
> followed 
by a semi-colon (<SPAN
CLASS="TOKEN"
>;</SPAN
>),
then <TT
CLASS="LITERAL"
>-W foo</TT
> is treated as the 
long option <TT
CLASS="LITERAL"
>--foo</TT
>. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>See <TT
CLASS="FUNCTION"
>getopt_long()</TT
> for a description
of long options.</P
></BLOCKQUOTE
></DIV
></P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>The first character of <TT
CLASS="PARAMETER"
><I
>optstring</I
></TT
> shall modify 
the behavior of <TT
CLASS="FUNCTION"
>getopt()</TT
> as follows:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>if the first character is '+', then 
<CODE
CLASS="CONSTANT"
>REQUIRE_ORDER</CODE
> processing shall be in
effect (see above)</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>if the first character is '-', then 
<CODE
CLASS="CONSTANT"
>RETURN_IN_ORDER</CODE
> processing shall be in
effect (see above)</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>if the first character is ':', then 
<TT
CLASS="FUNCTION"
>getopt()</TT
> shall return ':' instead of '?'
to indicate a missing option argument, and shall not print any
diagnostic message to <CODE
CLASS="VARNAME"
>stderr</CODE
>.</P
></LI
></UL
></P
></LI
></UL
></P
><P
><I
CLASS="EMPHASIS"
>POSIX</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>the <CODE
CLASS="OPTION"
>-W</CODE
> option is reserved for implementation extensions.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN15485"
></A
><H3
>Return Values</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies the following additional
<TT
CLASS="FUNCTION"
>getopt()</TT
> return values:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
><SPAN
CLASS="RETURNVALUE"
>'\001'</SPAN
> is returned
if <CODE
CLASS="CONSTANT"
>RETURN_IN_ORDER</CODE
> argument ordering is in effect,
and the next argument is an operand, not an option. The argument is
available in <CODE
CLASS="VARNAME"
>optarg</CODE
>.</P
></LI
></UL
>
Any other return value has the same meaning as for
<I
CLASS="EMPHASIS"
>POSIX</I
>.</P
><P
><I
CLASS="EMPHASIS"
>POSIX</I
> specifies the following 
<TT
CLASS="FUNCTION"
>getopt()</TT
> return values:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>the next option character is returned, if found successfully.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>'<SPAN
CLASS="RETURNVALUE"
>:</SPAN
>' is returned if a parameter is missing for 
one of the options and the first character of <CODE
CLASS="VARNAME"
>optstring</CODE
> is 
'<SPAN
CLASS="TOKEN"
>:</SPAN
>'.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>'<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>' is returned if an unknown option 
character not in <CODE
CLASS="VARNAME"
>optstring</CODE
> is encountered, or if 
<TT
CLASS="FUNCTION"
>getopt()</TT
> detects a missing argument and the first 
character of <CODE
CLASS="VARNAME"
>optstring</CODE
> is not '<SPAN
CLASS="TOKEN"
>:</SPAN
>'.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
><SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned for the end of the option list.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN15518"
></A
><H3
>Environment Variables</H3
><P
><I
CLASS="EMPHASIS"
>LSB</I
> specifies that:
<P
></P
><UL
><LI
STYLE="list-style-type: BULLET"
><P
>if the variable <CODE
CLASS="VARNAME"
>POSIXLY_CORRECT</CODE
> is set, option 
processing stops as soon as a non-option argument is encountered.</P
></LI
><LI
STYLE="list-style-type: BULLET"
><P
>the variable <CODE
CLASS="VARNAME"
>_<TT
CLASS="REPLACEABLE"
><I
>[PID]</I
></TT
>_GNU_nonoption_argv_flags_</CODE
>
(where <TT
CLASS="REPLACEABLE"
><I
>[PID]</I
></TT
> is the process ID for the 
current process), contains a space separated list of arguments that should
not be treated as arguments even though they appear to be so.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>This was 
used by bash 2.0 to communicate to <I
CLASS="EMPHASIS"
>GNU</I
> libc which 
arguments resulted from wildcard expansion and so should not be 
considered as options. This behavior was removed in bash version 
2.01, but the support remains in <I
CLASS="EMPHASIS"
>GNU</I
> libc.</P
></BLOCKQUOTE
></DIV
>
This behavior is DEPRECATED in this version of the LSB; future revisions
of this specification may not include this requirement.</P
></LI
></UL
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-GETOPT-LONG-3"
></A
>getopt_long</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15540"
></A
><H2
>Name</H2
>getopt_long&nbsp;--&nbsp;parse command line options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15543"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15546"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;getopt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getopt_long</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * const 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argv</I
></TT
>[]</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>opstring</I
></TT
></I
></TT
>, const struct option *
  <TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>longindex</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15565"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long()</TT
> works like <TT
CLASS="FUNCTION"
>getopt()</TT
> 
except that it also accepts long options, started out by two dashes. 
Long option names may be abbreviated if the abbreviation is unique or 
is an exact match for some defined option. A long option may take a 
parameter, of the form <TT
CLASS="LITERAL"
>--arg=param</TT
> or 
<TT
CLASS="LITERAL"
>--arg param</TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
> is a pointer to the first element of an 
array of struct <TT
CLASS="STRUCTNAME"
>option</TT
> declared in 
<TT
CLASS="FILENAME"
>getopt.h</TT
> as:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  struct option {
             const char *name;
             int has_arg;
             int *flag;
             int val;
  };</PRE
></TD
></TR
></TABLE
></P
><P
>The fields in this structure have the following meaning:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15581"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of the long option.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15586"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>has_arg</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of: 
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>no_argument</CODE
> (or 0) if the option does not take an argument,</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>required_argument</CODE
> (or 1) if the option requires an argument,  or</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>optional_argument</CODE
>  (or  2) if the option takes an optional argument.</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15598"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>flag</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies how results are returned for a long option.   
If  flag
is  <CODE
CLASS="CONSTANT"
>NULL</CODE
>,  then  
<TT
CLASS="FUNCTION"
>getopt_long()</TT
> shall return <CODE
CLASS="STRUCTFIELD"
>val</CODE
>.
(For example, the
calling program may set val to the equivalent short option character.)
Otherwise, <TT
CLASS="FUNCTION"
>getopt_long()</TT
> returns 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>, and <CODE
CLASS="STRUCTFIELD"
>flag</CODE
> shall point to
a variable which shall be set to <CODE
CLASS="STRUCTFIELD"
>val</CODE
>
if the option is found, but left unchanged if the option is not found.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15610"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>val</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The value to return, or to load into the variable pointed to
by flag.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>longindex</I
></TT
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
it points to a variable which is set to the index of the long option
relative to <TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15619"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long()</TT
> returns the option character if a short 
option was found successfully, or "<SPAN
CLASS="RETURNVALUE"
>:</SPAN
>" if 
there was a missing parameter for one of the options, or 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an unknown option character, or 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> for the end of the option list.</P
><P
>For a long option, 
<TT
CLASS="FUNCTION"
>getopt_long()</TT
> returns <CODE
CLASS="STRUCTFIELD"
>val</CODE
> 
if <CODE
CLASS="STRUCTFIELD"
>flag</CODE
> is <TT
CLASS="LITERAL"
>NULL</TT
>, and <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> 
otherwise. Error and <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> returns are the 
same as for <TT
CLASS="FUNCTION"
>getopt()</TT
>, plus 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an ambiguous match or an 
extraneous parameter.</P
></DIV
><H1
><A
NAME="BASELIB-GETOPT-LONG-ONLY-3"
></A
>getopt_long_only</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15639"
></A
><H2
>Name</H2
>getopt_long_only&nbsp;--&nbsp;parse command line options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15642"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15645"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;getopt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getopt_long_only</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argc</I
></TT
></I
></TT
>, char * const 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argv</I
></TT
>[]</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>optstring</I
></TT
></I
></TT
>, const struct option *
  <TT
CLASS="PARAMETER"
><I
>longopts</I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>longindex</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15664"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> is like 
<TT
CLASS="FUNCTION"
>getopt_long()</TT
>, but "<SPAN
CLASS="TOKEN"
>-</SPAN
>" as well as 
"<SPAN
CLASS="TOKEN"
>--</SPAN
>" can indicate a long option. If an option that 
starts with "<SPAN
CLASS="TOKEN"
>-</SPAN
>" (not "<SPAN
CLASS="TOKEN"
>--</SPAN
>") doesn't 
match a long option, but does match a short option, it is parsed as 
a short option instead.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> function is intended only
for supporting certain programs whose command line syntax was designed
before the Utility Syntax Guidelines of <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
were developed.  New programs should generally call
<TT
CLASS="FUNCTION"
>getopt_long()</TT
> instead, which provides the --option
syntax for long options, which is preferred by GNU and consistent with
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15681"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> returns the option character if the 
option was found successfully, or "<SPAN
CLASS="RETURNVALUE"
>:</SPAN
>" if 
there was a missing parameter for one of the options, or 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an unknown option character, or 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> for the end of the option list.</P
><P
><TT
CLASS="FUNCTION"
>getopt_long_only()</TT
> also returns the option character 
when a short option is recognized. For a long option, they return val 
if flag is <TT
CLASS="LITERAL"
>NULL</TT
>, and <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> 
otherwise. Error and <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> returns are the 
same as for <TT
CLASS="FUNCTION"
>getopt()</TT
>, plus 
"<SPAN
CLASS="RETURNVALUE"
>?</SPAN
>" for an ambiguous match or an 
extraneous parameter.</P
></DIV
><H1
><A
NAME="BASELIB-GETPAGESIZE"
></A
>getpagesize</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15699"
></A
><H2
>Name</H2
>getpagesize&nbsp;--&nbsp;get memory page size (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15702"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15703"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
    <TT
CLASS="FUNCTION"
>getpagesize</TT
>
  </CODE
>(void
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15709"
></A
><H2
>Description</H2
><P
>The function <TT
CLASS="FUNCTION"
>getpagesize()</TT
> returns
the number of bytes in a meory page.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="FUNCTION"
>getpagesize()</TT
> function is deprecated.
Portable applications should use
<TT
CLASS="LITERAL"
>sysconf</TT
>(<CODE
CLASS="CONSTANT"
>_SC_PAGE_SIZE</CODE
>) instead.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15718"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>getpagesize()</TT
>
function returns the current page size.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15722"
></A
><H2
>Errors</H2
><P
>No errors are defined.</P
></DIV
><H1
><A
NAME="BASELIB-GETPROTOBYNAME-R"
></A
>getprotobyname_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15729"
></A
><H2
>Name</H2
>getprotobyname_r&nbsp;--&nbsp;retrieve information from the network protocol database by protocol name, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15732"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15735"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>getprotobyname_r</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, struct protoent *
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct protoent * *
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15750"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getprotobyname_r()</TT
> function is a reentrant version 
of the <TT
CLASS="FUNCTION"
>getprotobyname()</TT
> function.</P
><P
>The <TT
CLASS="FUNCTION"
>getprotobyname_r()</TT
> function shall search the network protocol database
for an entry with the name <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.</P
><P
>If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <TT
CLASS="STRUCTNAME"
>protoent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.</P
><P
>The array <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall contain the string fields 
referenced by the <TT
CLASS="STRUCTNAME"
>protoent</TT
> structure that
was returned. The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> 
shall specify the array's size. 1024 bytes should be enough
for most uses.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15767"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>getprotobyname_r()</TT
> function 
shall return <TT
CLASS="LITERAL"
>0</TT
>. If the 
return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, 
indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.</P
></DIV
><H1
><A
NAME="BASELIB-GETPROTOBYNUMBER-R"
></A
>getprotobynumber_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15779"
></A
><H2
>Name</H2
>getprotobynumber_r&nbsp;--&nbsp;retrieve information from the network protocol database by protocol number, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15782"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15785"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>getprotobynumber_r</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
>, struct protoent *
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct protoent * *
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15800"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getprotobynumber_r()</TT
> function 
is a reentrant version of the <TT
CLASS="FUNCTION"
>getprotobynumber()</TT
> function.</P
><P
>The <TT
CLASS="FUNCTION"
>getprotobynumber_r()</TT
> function shall search the network protocol database
for an entry with protocol number <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
>.</P
><P
>If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <TT
CLASS="STRUCTNAME"
>protoent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.</P
><P
>The array <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall contain the string fields 
referenced by the <TT
CLASS="STRUCTNAME"
>protoent</TT
> structure that
was returned. The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> 
shall specify the array's size. 1024 bytes should be enough
for most uses.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15817"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>getprotobynumber_r()</TT
> function shall return <TT
CLASS="LITERAL"
>0</TT
>. If the 
return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.</P
></DIV
><H1
><A
NAME="BASELIB-GETPROTOENT-R"
></A
>getprotoent_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15829"
></A
><H2
>Name</H2
>getprotoent_r&nbsp;--&nbsp;read the next entry of the protocol database, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15832"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15835"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>getprotoent_r</TT
></CODE
>(struct protoent *
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct protoent * *
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15848"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getprotoent_r()</TT
> function 
is a reentrant version of the <TT
CLASS="FUNCTION"
>getprotoent()</TT
> function.</P
><P
>The <TT
CLASS="FUNCTION"
>getprotoent_r()</TT
> function shall search the network protocol database
for the next entry.</P
><P
>If the next entry is found in the database, this function shall
copy the relevant information to the application-supplied <TT
CLASS="STRUCTNAME"
>protoent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no next entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.</P
><P
>The array <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall contain the string fields 
referenced by the <TT
CLASS="STRUCTNAME"
>protoent</TT
> structure that
was returned. The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> 
shall specify the array's size. 1024 bytes should be enough
for most uses.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15864"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>getprotoent_r()</TT
> function shall return zero. </P
><P
>If the return value was 
<SPAN
CLASS="ERRORCODE"
>ENOENT</SPAN
>,
there were no more entries in the database.</P
><P
>If the return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.</P
></DIV
><H1
><A
NAME="BASELIB-GETPWENT-R-1"
></A
>getpwent_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15878"
></A
><H2
>Name</H2
>getpwent_r&nbsp;--&nbsp;reentrantly get entry in passwd file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15883"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15884"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pwd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getpwent_r</TT
></CODE
>(struct passwd *
<TT
CLASS="PARAMETER"
><I
>pwbuf</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct passwd * *
<TT
CLASS="PARAMETER"
><I
>pwbufp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15897"
></A
><H2
>Description</H2
><P
>The reentrant interface <TT
CLASS="FUNCTION"
>getpwent_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>getpwent()</TT
>, except that
<TT
CLASS="FUNCTION"
>getpwent_r()</TT
> shall
return the user name, user password, GECOS field, home directory, and shell program
in buffers provided by the caller, rather than as a pointer to static storage.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>pwbuf</I
></TT
> contains 
the <SPAN
CLASS="TYPE"
>struct passwd</SPAN
> that was read from the stream, if any.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> contains 
additional strings, if any.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> specifies 
the size of <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>*pwbufp</I
></TT
> returns 
a pointer to the <SPAN
CLASS="TYPE"
>struct passwd</SPAN
> in <TT
CLASS="PARAMETER"
><I
>*pwbuf</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15915"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>getpwent_r()</TT
> shall return <TT
CLASS="LITERAL"
>0</TT
>,
and <TT
CLASS="PARAMETER"
><I
>*pwbufp</I
></TT
> shall contain a pointer to the result.</P
><P
>On failure, <TT
CLASS="PARAMETER"
><I
>*pwbufp</I
></TT
> shall contain 
<TT
CLASS="LITERAL"
>NULL</TT
>, and <TT
CLASS="FUNCTION"
>getpwent_r()</TT
>
shall return an error as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15925"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15928"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No more password entries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15932"
></A
><SPAN
STYLE="white-space: nowrap"
>ERANGE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Not enough buffer space. Specify a larger buffer and try again.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-GETRLIMIT-1"
></A
>getrlimit, setrlimit</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15940"
></A
><H2
>Name</H2
>getrlimit, setrlimit&nbsp;--&nbsp;get resource consumption limits</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15947"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15948"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/resource.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getrlimit</TT
></CODE
>(__rlimit_resource_t
<TT
CLASS="PARAMETER"
><I
>__resource</I
></TT
>, struct rlimit *
<TT
CLASS="PARAMETER"
><I
>__rlimits</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>setrlimit</TT
></CODE
>(__rlimit_resource_t
<TT
CLASS="PARAMETER"
><I
>__resource</I
></TT
>, const struct rlimit *
<TT
CLASS="PARAMETER"
><I
>__rlimits</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15964"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getrlimit()</TT
> and <TT
CLASS="FUNCTION"
>setrlimit()</TT
>
are as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, 
but with differences as listed below. </P
><DIV
CLASS="REFSECT2"
><A
NAME="EXTRA.RESOURCES"
></A
><H3
>Extra Resources</H3
><P
>These additional resources extend the list in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15975"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_NPROC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The maximum number of processes (or, more precisely on Linux,
threads) that can be created for the real user ID of the calling
process. Upon encountering this limit, <TT
CLASS="FUNCTION"
>fork()</TT
>
shall fail with the error <SPAN
CLASS="ERRORCODE"
>EAGAIN</SPAN
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15981"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_MEMLOCK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The maximum number of bytes of memory that may be
locked into RAM.  In effect this limit is rounded down to the
nearest multiple of the system page size. This limit affects
<TT
CLASS="FUNCTION"
>mlock()</TT
> and <TT
CLASS="FUNCTION"
>mlockall()</TT
>, the
<TT
CLASS="FUNCTION"
>mmap()</TT
> <CODE
CLASS="CONSTANT"
>MAP_LOCKED</CODE
> operation and
the <TT
CLASS="FUNCTION"
>shmctl()</TT
> <CODE
CLASS="CONSTANT"
>SHM_LOCK</CODE
> operation.
The <TT
CLASS="FUNCTION"
>shmctl()</TT
> <CODE
CLASS="CONSTANT"
>SHM_LOCK</CODE
> locks are
accounted for separately from the per-process memory locks established
by <TT
CLASS="FUNCTION"
>mlock()</TT
>, <TT
CLASS="FUNCTION"
>mlockall()</TT
>, and
<TT
CLASS="FUNCTION"
>mmap()</TT
> <CODE
CLASS="CONSTANT"
>MAP_LOCKED</CODE
>. In the former
case, the limit sets a maximum on the total bytes in shared memory
segments (see <TT
CLASS="FUNCTION"
>shmget()</TT
>) that may be locked by the
real user ID of the calling process.  A process can lock bytes up to
this limit in each of these two categories.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15998"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_LOCKS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> A limit on the combined number of <TT
CLASS="FUNCTION"
>flock()</TT
> locks 
and <TT
CLASS="FUNCTION"
>fcntl()</TT
> leases that this process may establish.
This limit is obsolete and should not be used; support depends heavily
on the version of the operating system kernel. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16004"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_RSS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Specifies the
limit (in pages) of the process's resident set. This limit
is obsolete and should not be used; support depends heavily
on the version of the operating system kernel. It affects
only calls to <TT
CLASS="FUNCTION"
>madvise()</TT
> specifying
<CODE
CLASS="CONSTANT"
>MADV_WILLNEED</CODE
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16010"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_SIGPENDING</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies the limit on the number of signals that may be queued
for the real user ID of the calling process.  Both standard and
real-time signals are counted for the purpose of checking this
limit.  However, the limit is enforced only for <TT
CLASS="FUNCTION"
>sigqueue()</TT
>;
it is always possible to use <TT
CLASS="FUNCTION"
>kill()</TT
> to queue one 
instance of any of the signals that are not already queued to the process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16016"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_MSGQUEUE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies the limit on the number of bytes that can be allocated for
POSIX message queues for the real user ID of the calling process. This
limit is enforced for <TT
CLASS="FUNCTION"
>mq_open()</TT
>.   Each message queue
that the user creates counts (until it is removed) against this limit
according to the formula:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
	  attr.mq_maxmsg * attr.mq_msgsize</PRE
></TD
></TR
></TABLE
><P
>where attr is the mq_attr structure specified as the fourth argument
to mq_open(3).</P
><P
>The first addend in the formula, which includes sizeof(struct msg_msg *)
(4 bytes on Linux/i386), ensures that the user cannot create an unlimited
number of zero-length messages (such messages nevertheless each
consume some system memory for bookkeeping overhead).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16024"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_NICE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies a ceiling to which the process's nice value can be
raised using <TT
CLASS="FUNCTION"
>setpriority()</TT
> or <TT
CLASS="FUNCTION"
>nice()</TT
>.  
The actual ceiling for
the nice value is calculated as 20 minus the value of 
<CODE
CLASS="VARNAME"
>rlim_cur</CODE
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16031"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_RTPRIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies a ceiling on the real-time priority that may be set
for this process using sched_setscheduler(2) and sched_setparam(2).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16035"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_RTTIME</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies a limit (in microseconds) on the amount of CPU time that a
process scheduled under a real-time scheduling policy may consume without
making a blocking system call. For the purpose of this limit, each time
a process makes a blocking system call, the count of its consumed CPU
time is reset to zero.  The CPU time count is not reset if the process
continues trying to use the CPU but is preempted, its time slice expires,
or it calls <TT
CLASS="FUNCTION"
>sched_yield()</TT
>.</P
><P
>Upon reaching the soft limit, the process is sent a
<CODE
CLASS="CONSTANT"
>SIGXCPU</CODE
> signal. If the process catches or
ignores this signal and continues consuming CPU time, then
<CODE
CLASS="CONSTANT"
>SIGXCPU</CODE
> will be generated once each second until
the hard limit is reached, at which point the process is sent a
<CODE
CLASS="CONSTANT"
>SIGKILL</CODE
> signal.</P
><P
>The intended use of this limit is to stop a runaway real-time
process from locking up the system.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="EXTRA.ERRORS"
></A
><H3
>Extra Errors</H3
><P
>These additional error codes extend the list in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16050"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A pointer argument points to a location outside  the  accessible
address space.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><H1
><A
NAME="BASELIB-GETSERVBYNAME-R"
></A
>getservbyname_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16058"
></A
><H2
>Name</H2
>getservbyname_r&nbsp;--&nbsp;retrieve information from the network services database by service name, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16061"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16064"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>getservbyname_r</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
>, struct servent *
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct servent * *
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16081"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getservbyname_r()</TT
> function is a reentrant version of the 
<TT
CLASS="FUNCTION"
>getservbyname()</TT
> function. </P
><P
>The <TT
CLASS="FUNCTION"
>getservbyname_r()</TT
> function shall search the network services database
for an entry with the name <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
> parameter 
shall restrict the search to entries with the specified protocol. 
If <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>, 
<TT
CLASS="FUNCTION"
>getservbyname_r()</TT
> may return entries with any protocol.</P
><P
>If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <TT
CLASS="STRUCTNAME"
>servent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.</P
><P
>The array <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall contain the string fields 
referenced by the <TT
CLASS="STRUCTNAME"
>servent</TT
> structure that
was returned. The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> 
shall specify the array's size. 1024 bytes should be enough
for most uses.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16102"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>getservbyname_r()</TT
> function shall return zero. If the 
return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.</P
></DIV
><H1
><A
NAME="BASELIB-GETSERVBYPORT-R"
></A
>getservbyport_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16113"
></A
><H2
>Name</H2
>getservbyport_r&nbsp;--&nbsp;retrieve information from the network services database by service port, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16116"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16119"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>getservbyport_r</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
>port</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
>, struct servent *
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct servent * *
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16136"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getservbyport_r()</TT
> function is a reentrant version 
of the <TT
CLASS="FUNCTION"
>getservbyport()</TT
> function.</P
><P
>The <TT
CLASS="FUNCTION"
>getservbyport_r()</TT
> function shall search the network services database
for an entry with the port <TT
CLASS="PARAMETER"
><I
>port</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
> parameter 
shall restrict the search to entries with the specified protocol. 
If <TT
CLASS="PARAMETER"
><I
>proto</I
></TT
> is <TT
CLASS="LITERAL"
>NULL</TT
>, 
<TT
CLASS="FUNCTION"
>getservbyport_r()</TT
> may return entries with any protocol.</P
><P
>If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <TT
CLASS="STRUCTNAME"
>servent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no matching entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.</P
><P
>The array <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall contain the string fields 
referenced by the <TT
CLASS="STRUCTNAME"
>servent</TT
> structure that
was returned. The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> 
shall specify the array's size. 1024 bytes should be enough
for most uses.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16157"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>getservbyport_r()</TT
> function shall return zero. If the 
return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.</P
></DIV
><H1
><A
NAME="BASELIB-GETSERVENT-R"
></A
>getservent_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16168"
></A
><H2
>Name</H2
>getservent_r&nbsp;--&nbsp;read the next entry of the network services database, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16171"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16174"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;netdb.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>getservent_r</TT
></CODE
>(struct servent *
  <TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, struct servent * *
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16187"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getservent_r()</TT
> function is a reentrant version of the <TT
CLASS="FUNCTION"
>getservent()</TT
> function.</P
><P
>The <TT
CLASS="FUNCTION"
>getservent_r()</TT
> function shall search the network services database
for the next entry.</P
><P
>If the next entry is found in the database, this function shall
copy the relevant information to the application-supplied <TT
CLASS="STRUCTNAME"
>servent</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>result_buf</I
></TT
>, and return a pointer to this structure in *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>.
If no next entry is found, *<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> shall be set to a null pointer.</P
><P
>The array <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall contain the string fields 
referenced by the <TT
CLASS="STRUCTNAME"
>servent</TT
> structure that
was returned. The parameter <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> 
shall specify the array's size. 1024 bytes should be enough
for most uses.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16203"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>getservent_r()</TT
> function shall return <TT
CLASS="LITERAL"
>0</TT
>. </P
><P
>If the return value was 
<SPAN
CLASS="ERRORCODE"
>ENOENT</SPAN
>,
there were no more entries in the database.</P
><P
>If the return value was 
<SPAN
CLASS="ERRORCODE"
>ERANGE</SPAN
>,
the size of the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, indicated by <TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
>, was too small.</P
></DIV
><H1
><A
NAME="BASELIB-GETSOCKOPT-1"
></A
>getsockopt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16218"
></A
><H2
>Name</H2
>getsockopt&nbsp;--&nbsp;get socket options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16223"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16224"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;
#include &#60;netinet/ip.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getsockopt</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>socket</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
>, void * restrict
<TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>, socklen_t * restrict
<TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16239"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getsockopt()</TT
> function shall behave as specified in 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>, 
with the following extensions.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN16245"
></A
><H3
>IP Protocol Level Options</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> parameter is 
<CODE
CLASS="CONSTANT"
>IPPROTO_IP</CODE
>, the following values shall be supported for
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
> (see <A
HREF="#STD.RFC791"
>RFC 791:Internet Protocol</A
> for
further details):
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16253"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_OPTIONS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the Internet Protocol options sent with
every packet from this socket. 
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a
memory buffer in which the options shall be placed; 
on entry <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall point to an integer value
indicating the maximum size of the memory buffer, in bytes. On successful
return, the value referenced by <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall
be updated to the size of data copied to the buffer. For IPv4, the
maximum length of options is 40 bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16261"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TTL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the current unicast Internet Protocol
Time To Live value used when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a buffer large
enough to hold the time to live value (at least 1 byte),
and <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>
shall point to an integer value holding the maximum size of that buffer.
On successful return, the value
referenced by <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall be updated
to contain the number of bytes copied into the buffer, which shall be no
larger than the initial value,
and <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>
shall point to an integer containing the time to live value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16270"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TOS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the Internet Protocol type of service indicator
used when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a buffer large
enough to hold the type of service indicator (at least 1 byte),
and <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>
shall point to an integer value holding the maximum size of that buffer.
On successful return, the value
referenced by <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall be updated
to contain the number of bytes copied into the buffer, which shall be no
larger than the initial value,
and <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>
shall point to an integer containing the time to live value.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-GETTEXT"
></A
>gettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16283"
></A
><H2
>Name</H2
>gettext&nbsp;--&nbsp;search message catalogs for a string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16286"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16289"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>gettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16297"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gettext()</TT
> function shall search the currently 
selected message catalogs for a string identified by the string
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>. If a string is located, 
that string shall be returned.</P
><P
>The <TT
CLASS="FUNCTION"
>gettext()</TT
> function is equivalent to
<TT
CLASS="LITERAL"
>dcgettext(NULL, msgid, LC_MESSAGES)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16307"
></A
><H2
>Return Value</H2
><P
>If a string is found in the currently selected message catalogs for
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>, then a pointer to that string shall be returned.
Otherwise, a pointer to <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> shall be returned.</P
><P
>Applications shall not modify the string returned by <TT
CLASS="FUNCTION"
>gettext()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16314"
></A
><H2
>Errors</H2
><P
>None.</P
><P
>The <TT
CLASS="FUNCTION"
>gettext()</TT
> function shall not modify 
<CODE
CLASS="VARNAME"
>errno</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16320"
></A
><H2
>See Also</H2
><P
>dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-GETUTENT-3"
></A
>getutent</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16327"
></A
><H2
>Name</H2
>getutent&nbsp;--&nbsp;access user accounting database entries	</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16330"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16333"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>struct utmp
  *<TT
CLASS="FUNCTION"
>getutent</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16339"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getutent()</TT
> function shall read the
next entry from the user accounting database.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16345"
></A
><H2
>Return Value</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>getutent()</TT
>
shall return a 
pointer to a <TT
CLASS="STRUCTNAME"
>utmp</TT
> structure containing a copy
of the requested entry in the user accounting database.
Otherwise, a null pointer shall be returned. The return value may point
to a static area which is overwritten by a subsequent call to
<TT
CLASS="FUNCTION"
>getutent()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16351"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="BASELIB-GETUTENT-R-3"
></A
>getutent_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16358"
></A
><H2
>Name</H2
>getutent_r&nbsp;--&nbsp;access user accounting database entries</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16361"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16364"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>getutent_r</TT
></CODE
>(struct utmp *
  <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, struct utmp **
  <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16372"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>getutent_r()</TT
> function is a reentrant version of the 
<TT
CLASS="FUNCTION"
>getutent()</TT
> function.
On entry, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> should point to a user supplied
buffer to which the next entry in the database will be copied, and
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
> should point to a location where the
result will be stored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16381"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>getutent_r()</TT
> shall return 0 and set
the location referenced by <TT
CLASS="PARAMETER"
><I
>result</I
></TT
> to a pointer
to <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>. Otherwise, <TT
CLASS="FUNCTION"
>getutent_r()</TT
>
shall return <CODE
CLASS="CONSTANT"
>-1</CODE
> and set the location referenced
by <TT
CLASS="PARAMETER"
><I
>result</I
></TT
> to <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETWC-UNLOCKED-1"
></A
>getwc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16395"
></A
><H2
>Name</H2
>getwc_unlocked&nbsp;--&nbsp;non-thread-safe getwc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16400"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getwc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>getwc()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-GETWCHAR-UNLOCKED-1"
></A
>getwchar_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16410"
></A
><H2
>Name</H2
>getwchar_unlocked&nbsp;--&nbsp;non-thread-safe getwchar</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16415"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getwchar_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>getwchar()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-GLOB64"
></A
>glob64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16425"
></A
><H2
>Name</H2
>glob64&nbsp;--&nbsp;find pathnames matching a pattern  (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16428"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16431"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;glob.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>glob64</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
>pattern</I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>, int (*<TT
CLASS="PARAMETER"
><I
>errfunc</I
></TT
>)
  (const char *, int), glob64_t *
  <TT
CLASS="PARAMETER"
><I
>pglob</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16445"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>glob64()</TT
> is a large-file
version of the <TT
CLASS="FUNCTION"
>glob()</TT
> function defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
It shall search for pathnames matching
<TT
CLASS="PARAMETER"
><I
>pattern</I
></TT
> according to the rules used by
the shell, <TT
CLASS="FILENAME"
>/bin/sh</TT
>.
No tilde expansion or parameter substitution is done; see
<TT
CLASS="FUNCTION"
>wordexp()</TT
>.</P
><P
>The results of a <TT
CLASS="FUNCTION"
>glob64()</TT
>
call are stored in the structure pointed to by <TT
CLASS="PARAMETER"
><I
>pglob</I
></TT
>,
which is a <CODE
CLASS="VARNAME"
>glob64_t</CODE
> declared in 
<TT
CLASS="FILENAME"
>glob.h</TT
> with the following members:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>typedef struct
{
  size_t <CODE
CLASS="STRUCTFIELD"
>gl_pathc</CODE
>;
  char **<CODE
CLASS="STRUCTFIELD"
>gl_pathv</CODE
>;
  size_t <CODE
CLASS="STRUCTFIELD"
>gl_offs</CODE
>;
  int <CODE
CLASS="STRUCTFIELD"
>gl_flags</CODE
>;
  void (*<CODE
CLASS="STRUCTFIELD"
>gl_closedir</CODE
>) (void *);
  struct dirent64 *(*<CODE
CLASS="STRUCTFIELD"
>gl_readdir64</CODE
>) (void *);
  void *(*<CODE
CLASS="STRUCTFIELD"
>gl_opendir</CODE
>) (const char *);
  int (*<CODE
CLASS="STRUCTFIELD"
>gl_lstat</CODE
>) (const char *, struct stat *);
  int (*<CODE
CLASS="STRUCTFIELD"
>gl_stat</CODE
>) (const char *, struct stat *);
}
glob64_t;</PRE
></TD
></TR
></TABLE
></P
><P
>Structure members with the same name as corresponding members of a 
<CODE
CLASS="VARNAME"
>glob_t</CODE
> as
defined in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> shall have the same purpose.</P
><P
>Other members are defined as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16476"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_flags</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reserved for internal use</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16481"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_closedir</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of closing a directory opened by 
<CODE
CLASS="STRUCTFIELD"
>gl_opendir</CODE
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16487"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_readdir64</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of reading entries in a large 
directory</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16492"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_opendir</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of opening a large directory</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16497"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_stat</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of returning file status 
for a large file</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16502"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>gl_lstat</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pointer to a function capable of returning file status 
information for a large file or symbolic link</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>A large file or large directory is one with a size which cannot be
represented by a variable of type <SPAN
CLASS="TYPE"
>off_t</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16509"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. Other possible 
returns are:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16514"
></A
><SPAN
STYLE="white-space: nowrap"
>GLOB_NOSPACE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>out of memory</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16518"
></A
><SPAN
STYLE="white-space: nowrap"
>GLOB_ABORTED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>read error</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16522"
></A
><SPAN
STYLE="white-space: nowrap"
>GLOB_NOMATCH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no match found</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-GLOBFREE64"
></A
>globfree64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16530"
></A
><H2
>Name</H2
>globfree64&nbsp;--&nbsp;free memory from glob64() (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16533"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16536"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;glob.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>globfree64</TT
></CODE
>(glob64_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pglob</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16544"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>globfree64()</TT
> frees the dynamically allocated 
storage from an earlier call to <TT
CLASS="FUNCTION"
>glob64()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>globfree64()</TT
> is a large-file
version of the <TT
CLASS="FUNCTION"
>globfree()</TT
> function defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-GNU-GET-LIBC-VERSION-1"
></A
>gnu_get_libc_version, gnu_get_libc_release</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16559"
></A
><H2
>Name</H2
>gnu_get_libc_version, gnu_get_libc_release&nbsp;--&nbsp;get glibc-specific version and release</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16566"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16567"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;gnu/libc-version.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
<TT
CLASS="FUNCTION"
>gnu_get_libc_version</TT
></CODE
>(void);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
<TT
CLASS="FUNCTION"
>gnu_get_libc_release</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16577"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>gnu_get_libc_version()</TT
>
returns a string that identifies the version of the C library
running the program making the call.</P
><P
><TT
CLASS="FUNCTION"
>gnu_get_libc_release()</TT
>
returns a string indicates the release status of the C library
running the program making the call.  This will be a string such as
<TT
CLASS="LITERAL"
>"stable"</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16584"
></A
><H2
>Return Value</H2
><P
>The functions return strings.  The contents of these strings
are unspecified.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16587"
></A
><H2
>Errors</H2
><P
>No errors are defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16590"
></A
><H2
>Notes</H2
><P
>These functions are specific to GNU libc (glibc).  This specification
does not require the implementation of libc to be glibc, although it
requires these functions.</P
><P
>The string returned by <TT
CLASS="FUNCTION"
>gnu_get_libc_version()</TT
>
will be a dotted version string, which may have meaning to 
developers otherwise familiar with glibc.  These functions have
been requested to aid in portability of software which also 
runs in non-LSB contexts, but decisions based on the return value
should be tempered by an understanding of what the behavioral
requirements of this specification are.  That is, it may or may 
not be useful to discover that a running system, for example,
has version <TT
CLASS="LITERAL"
>"2.10.1"</TT
> if that implies different 
behavior than described by this specification.</P
></DIV
><H1
><A
NAME="BASELIB-HCREATE-R"
></A
>hcreate_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16600"
></A
><H2
>Name</H2
>hcreate_r&nbsp;--&nbsp;allocate space for a hash search table, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16603"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16606"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;search.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>hcreate_r</TT
></CODE
>(size_t
  <TT
CLASS="PARAMETER"
><I
>nel</I
></TT
>, struct hsearch_data *
  <TT
CLASS="PARAMETER"
><I
>htab</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16615"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>hcreate_r()</TT
> function is a reentrant version 
of the <TT
CLASS="FUNCTION"
>hcreate()</TT
> function.</P
><P
><TT
CLASS="FUNCTION"
>hcreate_r()</TT
> shall initialize the object referenced by 
<TT
CLASS="PARAMETER"
><I
>htab</I
></TT
> with a hash table containing at least 
<TT
CLASS="PARAMETER"
><I
>nel</I
></TT
> elements. Unlike its non-reentrant equivalent, 
<TT
CLASS="FUNCTION"
>hcreate()</TT
>, the <TT
CLASS="FUNCTION"
>hcreate_r()</TT
> function 
may work with more than one hash table.</P
><P
>The memory for the <TT
CLASS="PARAMETER"
><I
>htab</I
></TT
> object may be dynamically allocated. 
It must be initialized with <TT
CLASS="LITERAL"
>0</TT
> before <TT
CLASS="FUNCTION"
>hcreate_r()</TT
> is called.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16630"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>hcreate_r()</TT
> shall return a non-zero value. </P
><P
>On failure, <TT
CLASS="FUNCTION"
>hcreate_r()</TT
> shall return <TT
CLASS="LITERAL"
>0</TT
>. This usually happens 
because not enough memory was available.</P
></DIV
><H1
><A
NAME="BASELIB-HDESTROY-R"
></A
>hdestroy_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16641"
></A
><H2
>Name</H2
>hdestroy_r&nbsp;--&nbsp;dispose of a hash search table, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16644"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16647"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;search.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
  <TT
CLASS="FUNCTION"
>hdestroy_r</TT
></CODE
>(struct hsearch_data *
  <TT
CLASS="PARAMETER"
><I
>htab</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16654"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>hdestroy_r()</TT
> function is a 
reentrant version of the <TT
CLASS="FUNCTION"
>hdestroy()</TT
> function.</P
><P
><TT
CLASS="FUNCTION"
>hdestroy_r()</TT
> frees the resources allocated by 
<TT
CLASS="FUNCTION"
>hcreate_r()</TT
> for the object <TT
CLASS="PARAMETER"
><I
>htab</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-HSEARCH-R"
></A
>hsearch_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16667"
></A
><H2
>Name</H2
>hsearch_r&nbsp;--&nbsp;search a hash table, reentrantly</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16670"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16673"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;search.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>hsearch_r</TT
></CODE
>(ENTRY
  <TT
CLASS="PARAMETER"
><I
>item</I
></TT
>, ACTION
  <TT
CLASS="PARAMETER"
><I
>action</I
></TT
>, ENTRY * *
  <TT
CLASS="PARAMETER"
><I
>retval</I
></TT
>, struct hsearch_data *
  <TT
CLASS="PARAMETER"
><I
>htab</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16686"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>hsearch_r()</TT
> is a reentrant version 
of the <TT
CLASS="FUNCTION"
>hsearch()</TT
> function, 
but instead of operating on a single global hash table, 
<TT
CLASS="FUNCTION"
>hsearch_r()</TT
> operates on the table described by the object that 
<TT
CLASS="PARAMETER"
><I
>htab</I
></TT
> references. This object can be initialized with the function
<TT
CLASS="FUNCTION"
>hcreate_r()</TT
>.</P
><P
>Unlike the <TT
CLASS="FUNCTION"
>hsearch()</TT
> function, 
<TT
CLASS="FUNCTION"
>hsearch_r()</TT
> returns 
a pointer to the found entry in the variable 
referred to by <TT
CLASS="PARAMETER"
><I
>retval</I
></TT
>, rather than directly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16698"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>hsearch_r()</TT
> shall return a non-zero value.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>hsearch_r()</TT
> shall return <TT
CLASS="LITERAL"
>0</TT
>
and set <CODE
CLASS="VARNAME"
>errno</CODE
> to an appropriate value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16706"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16709"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>action</I
></TT
> was set to <CODE
CLASS="CONSTANT"
>ENTER</CODE
>, 
but the table was full.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16715"
></A
><SPAN
STYLE="white-space: nowrap"
>ESRCH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>action</I
></TT
> was set to <CODE
CLASS="CONSTANT"
>FIND</CODE
>, 
but no matching element was found in the table.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-INET-ATON-3"
></A
>inet_aton</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16725"
></A
><H2
>Name</H2
>inet_aton&nbsp;--&nbsp;Internet address manipulation routine</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16728"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16731"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;
#include &#60;netinet/in.h&#62;
#include &#60;arpa/inet.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>anet_iton</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>cp</I
></TT
></I
></TT
>, struct in_addr *
  <TT
CLASS="PARAMETER"
><I
>inp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16741"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>inet_aton()</TT
> converts the Internet host address 
<TT
CLASS="PARAMETER"
><I
>cp</I
></TT
> from the standard IPv4 numbers-and-dots 
notation into binary data and stores it in the structure that
<TT
CLASS="PARAMETER"
><I
>inp</I
></TT
> points to.</P
><P
><TT
CLASS="FUNCTION"
>inet_aton()</TT
> returns a 
nonzero value if the address is valid, 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
> if not.</P
><P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Note that on some LSB architectures, the host byte order is Least 
Significant Byte first, whereas the network byte order, 
as used on the Internet, is Most Significant Byte first.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-INITGROUPS-3"
></A
>initgroups</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16759"
></A
><H2
>Name</H2
>initgroups&nbsp;--&nbsp;initialize the supplementary group access list</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16762"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16763"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;
#include &#60;sys/types.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>initgroups</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
></I
></TT
>, gid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>group</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16774"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege,
the <TT
CLASS="FUNCTION"
>initgroups()</TT
> function shall initialize the 
Supplementary Group IDs for the current process
by reading the group database and using all groups of which 
<TT
CLASS="PARAMETER"
><I
>user</I
></TT
> is a member. The additional group 
<TT
CLASS="PARAMETER"
><I
>group</I
></TT
> is also added to the list.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16780"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16786"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16789"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The calling process does not have sufficient privileges.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16793"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory to allocate group information structure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16797"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setgroups()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-INITSTATE-R-1"
></A
>initstate_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16805"
></A
><H2
>Name</H2
>initstate_r&nbsp;--&nbsp;reentrantly initialize a state array for random number generator functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16810"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16811"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>initstate_r</TT
></CODE
>(unsigned int
<TT
CLASS="PARAMETER"
><I
>seed</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>statebuf</I
></TT
>, size_t
<TT
CLASS="PARAMETER"
><I
>statelen</I
></TT
>, struct random_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16824"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>initstate_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>initstate()</TT
>, except that
<TT
CLASS="FUNCTION"
>initstate_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
></DIV
><H1
><A
NAME="BASELIB-INOTIFY-ADD-WATCH"
></A
>inotify_add_watch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16835"
></A
><H2
>Name</H2
>inotify_add_watch&nbsp;--&nbsp;add a watch to a watch list</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN16838"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN16839"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/inotify.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>inotify_add_watch</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, uint32_t
  <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16850"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> shall add a watch to,
or modify an existing watch on,
the watch list of the inotify instance 
specified by the file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,
for the file specified by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>,
to monitor the events specified by the bitmask <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>.
The caller must have read access to the file.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16857"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> 
shall return the unique, non-negative watch descriptor
associated with the file <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>
and the inotify instance specified by the file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> was already on the watch list, 
then <TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> shall return
the existing watch descriptor.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> was not already on the watch list, 
then <TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
>
shall allocate a new watch descriptor.</P
><P
><TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> shall not work recursively. 
Monitoring subdirectories of <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>
shall require adding watches to them.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> shall return <TT
CLASS="LITERAL"
>-1</TT
>
and set <CODE
CLASS="VARNAME"
>errno</CODE
> to an appropriate value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16876"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16879"
></A
><SPAN
STYLE="white-space: nowrap"
>EACCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The caller does not have read access to <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16884"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is invalid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16889"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>path</I
></TT
> is outside of 
the address space accessible by the process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16894"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>mask</I
></TT
> contains no legal events, or 
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is not a valid inotify file descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16900"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There is not enough kernel memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16904"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOSPC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The maximum number of watches has been created for this user, 
or the kernel cannot allocate a resource.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN16908"
></A
><H2
>Application Usage</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN16910"
></A
><H3
>Reading</H3
><P
>The function <TT
CLASS="FUNCTION"
>read()</TT
> can be used 
to determine which inotify events have occurred. 
A blocking file descriptor will make 
<TT
CLASS="FUNCTION"
>read()</TT
> block until at least one event has occurred.</P
><P
>If successful, <TT
CLASS="FUNCTION"
>read()</TT
> will return at least one 
of the following <CODE
CLASS="VARNAME"
>inotify_event</CODE
> structures in a buffer:</P
><P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN16919"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct inotify_event {
    int      wd;
    uint32_t mask;
    uint32_t cookie;
    uint32_t len;
    char     path[];
};
  </PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
><CODE
CLASS="VARNAME"
>wd</CODE
> is a watch descriptor that 
specifies the watch associated with the event.
It is obtained from a previous invocation of 
<TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
>.</P
><P
><CODE
CLASS="VARNAME"
>mask</CODE
> is a bit mask describing inotify events. 
See the section on masks below.</P
><P
><CODE
CLASS="VARNAME"
>cookie</CODE
> is an integer associating related inotify events.
The integer value is unique, and currently
only enables the application to associate 
<CODE
CLASS="CONSTANT"
>IN_MOVE_FROM</CODE
> and
<CODE
CLASS="CONSTANT"
>IN_MOVE_TO</CODE
> rename events.</P
><P
><CODE
CLASS="VARNAME"
>len</CODE
> is a count of the bytes in <CODE
CLASS="VARNAME"
>path</CODE
>, 
including null bytes. 
This means that the total length of an <CODE
CLASS="VARNAME"
>inotify_event</CODE
> 
structure is
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN16934"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>sizeof(inotify_event)+len
  </PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
><CODE
CLASS="VARNAME"
>path</CODE
> is only returned when an event occurs for a file within
a watched directory. This string is null-terminated, and it may contain 
more null bytes so that future reads will be aligned properly on an
address boundary.</P
><P
>In kernels before 2.6.21, <TT
CLASS="FUNCTION"
>read()</TT
> 
returns <TT
CLASS="LITERAL"
>0</TT
> when the buffer given to it is too small
to return data about the next event. In subsequent kernels, it fails with the 
error <CODE
CLASS="CONSTANT"
>EINVAL</CODE
>.</P
><P
>For a given file descriptor, the inotify events are returned in an ordered queue.
Events on a file descriptor will always be returned in the correct order of occurrence.
If two or more inotify events for a given file descriptor have identical values for all
fields, then only one <CODE
CLASS="VARNAME"
>inotify_event</CODE
> 
will be returned to represent all of them.</P
><P
>The number of bytes that can be read from an inotify file descriptor
can be determined by making a 
<CODE
CLASS="CONSTANT"
>FIONREAD</CODE
> <TT
CLASS="FUNCTION"
>ioctl()</TT
> call.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN16947"
></A
><H3
>Masks</H3
><P
>The <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
> argument of 
<TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> and the <CODE
CLASS="VARNAME"
>mask</CODE
> field of the 
<CODE
CLASS="VARNAME"
>inotify_event</CODE
> structure are bit masks that specify inotify events. 
The bits in the list below can be set in the <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
> argument of 
<TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> and returned in the 
<CODE
CLASS="VARNAME"
>mask</CODE
> field of <CODE
CLASS="VARNAME"
>inotify_event</CODE
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16959"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_ACCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File was read.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16963"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_ALL_EVENTS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bit mask of all events in this list.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16967"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_ATTRIB</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File's metadata changed (including timestamps and permissions).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16971"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_CLOSE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Same as
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN16975"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>IN_CLOSE_WRITE | IN_CLOSE_NOWRITE
  </PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16977"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_CLOSE_WRITE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File that was opened for writing was closed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16981"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_CLOSE_NOWRITE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File that was not opened for writing was closed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16985"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_CREATE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File or directory was created in a watched directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16989"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_DELETE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File or directory was deleted in a watched directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16993"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_DELETE_SELF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Watched file or directory was deleted.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16997"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_MODIFY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File was changed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17001"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_MOVE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Same as
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN17005"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>IN_MOVED_FROM | IN_MOVED_TO
  </PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17007"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_MOVE_SELF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Watched file or directory was moved</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17011"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_MOVED_FROM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File was moved out of watched directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17015"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_MOVED_TO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File was moved into watched directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17019"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_OPEN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File was opened.</P
></TD
></TR
></TBODY
></TABLE
><P
>All of the events above, except for 
<CODE
CLASS="CONSTANT"
>IN_DELETE_SELF</CODE
> and <CODE
CLASS="CONSTANT"
>IN_MOVE_SELF</CODE
>, 
cause the name field of the <CODE
CLASS="VARNAME"
>inotify_event</CODE
> structure to contain 
the name of the file or directory being monitored.</P
><P
>The following bit is valid for <TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
> only.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17030"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_ONESHOT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Monitor path for an event, and then remove it from the watch list.</P
></TD
></TR
></TBODY
></TABLE
><P
>The following bits are valid for the <CODE
CLASS="VARNAME"
>inotify_event</CODE
> structure only.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17037"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_IGNORED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Watch was removed, either explicitly (via <TT
CLASS="FUNCTION"
>inotify_rm_watch()</TT
>) 
or implicitly (file deletion or file system unmounting).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17042"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_ISDIR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Object being watched is a directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17046"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_Q_OVERFLOW</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The event queue overflowed (<TT
CLASS="PARAMETER"
><I
>wd</I
></TT
> is set to <TT
CLASS="LITERAL"
>-1</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17052"
></A
><SPAN
STYLE="white-space: nowrap"
>IN_UNMOUNT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>File system of object being watched was unmounted.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN17056"
></A
><H3
>Notes</H3
><P
>It is possible to monitor file descriptors with the functions <TT
CLASS="FUNCTION"
>epoll()</TT
>, 
<TT
CLASS="FUNCTION"
>poll()</TT
>, and <TT
CLASS="FUNCTION"
>select()</TT
>.</P
><P
>When all of the file descriptors that point to an inotify instance
have been closed, the instance and its associated resources and 
watches are freed by the kernel.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17063"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>inotify_init()</TT
>, <TT
CLASS="FUNCTION"
>inotify_rm_watch()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-INOTIFY-INIT"
></A
>inotify_init</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17075"
></A
><H2
>Name</H2
>inotify_init&nbsp;--&nbsp;instantiate inotify</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17078"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17079"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/inotify.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>inotify_init</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17085"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>inotify_init()</TT
> shall create one instance of inotify.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17089"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inotify_init()</TT
> shall return a file descriptor pointing to the new inotify instance.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>inotify_init()</TT
> shall return -1 and set <CODE
CLASS="VARNAME"
>errno</CODE
> to an appropriate value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17096"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17099"
></A
><SPAN
STYLE="white-space: nowrap"
>EMFILE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The maximum number of inotify instances has been created for this user.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17103"
></A
><SPAN
STYLE="white-space: nowrap"
>ENFILE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The maximum number of file descriptors has been created on the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17107"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There is not enough kernel memory available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17111"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
>, <TT
CLASS="FUNCTION"
>inotify_rm_watch()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-INOTIFY-RM-WATCH"
></A
>inotify_rm_watch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17123"
></A
><H2
>Name</H2
>inotify_rm_watch&nbsp;--&nbsp;remove a watch from an inotify watch list</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17126"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17127"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/inotify.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>inotify_rm_watch</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
>wd</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17136"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>inotify_rm_watch()</TT
> shall remove the watch 
associated with the watch descriptor <TT
CLASS="PARAMETER"
><I
>wd</I
></TT
> 
from the watch list of the inotify instance 
associated with the file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>.</P
><P
>If a watch is removed, its watch descriptor shall generate the <CODE
CLASS="CONSTANT"
>IN_IGNORED</CODE
> event.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17144"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inotify_rm_watch()</TT
> shall return <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>inotify_rm_watch()</TT
> shall return <TT
CLASS="LITERAL"
>-1</TT
>
and set <CODE
CLASS="VARNAME"
>errno</CODE
> to an appropriate value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17153"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17156"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is invalid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17161"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>wd</I
></TT
> is invalid, or <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> 
is not a valid inotify file descriptor.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17167"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>inotify_add_watch()</TT
>, <TT
CLASS="FUNCTION"
>inotify_init()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-IOCTL-2"
></A
>ioctl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17179"
></A
><H2
>Name</H2
>ioctl&nbsp;--&nbsp;control device</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17182"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17185"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ioctl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>ioctl</TT
>
 </CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fildes</I
></TT
></I
></TT
>
 , int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>request</I
></TT
></I
></TT
>
 , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17197"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ioctl()</TT
> function shall manipulate the underlying device 
parameters of special files. <TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> shall be 
an open file descriptor referring to a special file.
The <TT
CLASS="FUNCTION"
>ioctl()</TT
> function shall take three parameters;
the type and value of the third parameter 
is dependent on the device and <TT
CLASS="PARAMETER"
><I
>request</I
></TT
>.</P
><P
>Conforming LSB applications shall not call <TT
CLASS="FUNCTION"
>ioctl()</TT
> 
except in situations explicitly stated in this specification.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17208"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
An <TT
CLASS="FUNCTION"
>ioctl()</TT
> may use the return value as an
output parameter and return a non-negative value on success. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17215"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17218"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EBADF</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> is not a valid descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17224"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EFAULT</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The third parameter references an inaccessible memory area.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17229"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOTTY</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> is not associated with a character special device.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17235"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOTTY </SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified request does not apply to the kind of object that
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> references.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17241"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EINVAL </SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>request</I
></TT
> or the third parameter is not valid.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17247"
></A
><H2
>Relationship to POSIX (Informative)</H2
><P
>It should be noted that <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> contains an interface 
named <TT
CLASS="FUNCTION"
>ioctl()</TT
>. The LSB only defines behavior when
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> refers to a socket 
(see <A
HREF="#BASELIB-SOCKIO-2"
>sockio</A
>)
or terminal device
(see <A
HREF="#BASELIB-TTYIO-2"
>ttyio</A
>), while 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> only defines behavior when 
<TT
CLASS="PARAMETER"
><I
>fildes</I
></TT
> refers to a STREAMS device. An implementation
may support both behaviors; the LSB does not require any STREAMS support.</P
></DIV
><H1
><A
NAME="BASELIB-SOCKIO-2"
></A
>sockio</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17261"
></A
><H2
>Name</H2
>sockio&nbsp;--&nbsp;socket ioctl commands</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17264"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17267"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ioctl.h&#62;
#include &#60;sys/socket.h&#62;
#include &#60;net/if.h&#62;
#include &#60;netinet/in.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>ioctl</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sockfd</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>request</I
></TT
></I
></TT
>, void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17281"
></A
><H2
>Description</H2
><P
>Socket <TT
CLASS="FUNCTION"
>ioctl()</TT
> commands are a subset of the 
<TT
CLASS="FUNCTION"
>ioctl()</TT
> calls, which can perform a variety of 
functions on sockets. <TT
CLASS="PARAMETER"
><I
>sockfd</I
></TT
> shall be an
open file descriptor referring to a socket (see the
<TT
CLASS="FUNCTION"
>socket()</TT
> or <TT
CLASS="FUNCTION"
>accept()</TT
> functions).</P
><P
>Socket <TT
CLASS="FUNCTION"
>ioctl()</TT
> commands apply to the underlying 
network interfaces, and affect the entire system, not just the file 
descriptor used to issue the <TT
CLASS="FUNCTION"
>ioctl()</TT
>.</P
><P
>The following values for <TT
CLASS="PARAMETER"
><I
>request</I
></TT
>
are accepted:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFCONF</TT
> (Deprecated)</DT
><DD
><P
>Get the interface configuration list for the system.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <TT
CLASS="SYMBOL"
>SIOCGIFCONF</TT
> interface is
superceded by the 
<TT
CLASS="FUNCTION"
>if_nameindex()</TT
> family of functions (see
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>).
A future version of this specification may withdraw this value
for <TT
CLASS="PARAMETER"
><I
>request</I
></TT
>.</P
></BLOCKQUOTE
></DIV
>
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifconf</TT
> structure, as described in
<TT
CLASS="FILENAME"
>&#60;net/if.h&#62;</TT
>. Before calling, the caller 
shall set the
<CODE
CLASS="STRUCTFIELD"
>ifc_ifcu.ifcu_req</CODE
> field 
to point to an array of <TT
CLASS="STRUCTNAME"
>ifreq</TT
> structures, and 
set <CODE
CLASS="STRUCTFIELD"
>ifc_len</CODE
> to the size in bytes of this allocated 
array. Upon return, <CODE
CLASS="STRUCTFIELD"
>ifc_len</CODE
> 
will contain the size in bytes of the array which was actually used.
If it is the same as the length upon calling, the caller 
should assume that the array was too small and try again with a 
larger array.</P
><P
>On success, <TT
CLASS="SYMBOL"
>SIOCGIFCONF</TT
> shall return a nonnegative value.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Historical UNIX systems disagree on the meaning of the return value.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFFLAGS</TT
></DT
><DD
><P
>Get the interface flags for the indicated interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a 
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_flags</CODE
> field is set 
with the interface flags.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFADDR</TT
></DT
><DD
><P
>Get the interface address for the given interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_addr</CODE
> field is set 
with the interface address.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFBRDADDR</TT
></DT
><DD
><P
>Get the interface broadcast address for the given interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_broadcast</CODE
> field is set 
with the interface broadcast address.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFDSTADDR</TT
></DT
><DD
><P
>Get the point-to-point address for the given interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_dstaddr</CODE
> field is set 
with the point-to-point address.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFNAME</TT
></DT
><DD
><P
>Get the name of an interface.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a 
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_ifindex</CODE
> 
field with the number (index) of the interface, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> field is set 
with the interface name.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFNETMASK</TT
></DT
><DD
><P
>Get the network mask for the given interface. 
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_netmask</CODE
> field is set 
with the network mask.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>SIOCGIFMTU</TT
></DT
><DD
><P
>Get the Maximum Transmission Unit (MTU) size for the given interface. 
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ifreq</TT
> structure. Before calling, the 
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>ifr_name</CODE
> 
field with the interface name, and upon return, the 
<CODE
CLASS="STRUCTFIELD"
>ifr_ifru.ifru_mtu</CODE
> field is set 
with the MTU.
Note: The range of valid values for MTU varies for an interface
depending on the interface type.</P
></DD
><DT
><TT
CLASS="SYMBOL"
>FIONREAD</TT
></DT
><DD
><P
>Get the amount of queued unread data in the receive buffer.
<TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall point to an integer where the result is to be placed.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Some implementations may also support the use of <TT
CLASS="SYMBOL"
>FIONREAD</TT
>
on other types of file descriptor. However, the LSB only specifies its behavior for a socket
related file descriptor.</P
></BLOCKQUOTE
></DIV
></P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17392"
></A
><H2
>Return Value</H2
><P
>On success, if <TT
CLASS="PARAMETER"
><I
>request</I
></TT
> is
<SPAN
CLASS="TOKEN"
>SIOCGIFCONF</SPAN
>, a non-negative integer shall be returned.
If request is not <SPAN
CLASS="TOKEN"
>SIOCGIFCONF</SPAN
>, on success 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17401"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17404"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>sockfd</I
></TT
> is not a valid descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17409"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> references an inaccessible memory area.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17414"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTTY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified <TT
CLASS="PARAMETER"
><I
>request</I
></TT
> does not apply to the kind of 
object that the descriptor <TT
CLASS="PARAMETER"
><I
>sockfd</I
></TT
> references.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17420"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Either <TT
CLASS="PARAMETER"
><I
>request</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
>
is invalid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17426"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTCONN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The operation is only defined on a connected socket, but the socket wasn't
connected.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-TTYIO-2"
></A
>ttyio</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17434"
></A
><H2
>Name</H2
>ttyio&nbsp;--&nbsp;tty ioctl commands</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17437"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17440"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ioctl.h&#62;
#include &#60;fcntl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>ioctl</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, unsigned long 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>request</I
></TT
></I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>argp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17454"
></A
><H2
>Description</H2
><P
>Tty <I
CLASS="EMPHASIS"
>ioctl</I
> commands are a subset of the 
<TT
CLASS="FUNCTION"
>ioctl()</TT
> calls, which can perform a variety of 
functions on tty devices. <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> shall be 
an open file descriptor referring to a terminal device.</P
><P
>The following <TT
CLASS="FUNCTION"
>ioctl()</TT
>s are provided:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17465"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="SYMBOL"
>TIOCGWINSZ</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Get the size attributes of the terminal or pseudo-terminal identified by
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>. On entry, <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall 
reference a <TT
CLASS="STRUCTNAME"
>winsize</TT
> structure.
On return, the structure will have 
<CODE
CLASS="STRUCTFIELD"
>ws_row</CODE
> set to the number of rows of text 
(i.e. lines of text) that can be viewed on the device, and
<CODE
CLASS="STRUCTFIELD"
>ws_col</CODE
> set to the number of columns (i.e. text width).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The number of columns stored in <CODE
CLASS="STRUCTFIELD"
>ws_col</CODE
>
assumes that the terminal device is using a mono-spaced font.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17478"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="SYMBOL"
>TIOCSWINSZ</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Sets the size attributes of the terminal or pseudo-terminal identified by 
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>.  On entry, <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> shall
reference a <TT
CLASS="STRUCTNAME"
>winsize</TT
> structure.  
The value of the <TT
CLASS="STRUCTNAME"
>winsize</TT
> structure's element 
<CODE
CLASS="STRUCTFIELD"
>ws_row</CODE
> shall be the number of 
rows of text (i.e. lines of text) that can be viewed on the device, 
and the element <CODE
CLASS="STRUCTFIELD"
>ws_col</CODE
> shall be
the number of columns (i.e. text width).  
Note that this call merely sets the size attributes for the kernel driver, 
not the window size itself, 
and is intended to be used to update the kernel driver when the
window size is changed.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17489"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17495"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17498"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EBADF</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> is not a valid descriptor.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17504"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EFAULT</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> references an inaccessible memory area.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17510"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EINVAL</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>request</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>argp</I
></TT
> are not valid.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-JRAND48-R-1"
></A
>jrand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17521"
></A
><H2
>Name</H2
>jrand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17526"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17527"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>jrand48_r</TT
></CODE
>(unsigned short[3]
<TT
CLASS="PARAMETER"
><I
>xsubi</I
></TT
>, struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, long int *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17538"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>jrand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>jrand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>jrand48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-KILL-3"
></A
>kill</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17554"
></A
><H2
>Name</H2
>kill&nbsp;--&nbsp;send a signal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17557"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17558"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>kill</TT
></CODE
>(pid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pid</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sig</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17569"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>kill()</TT
> is as specified in the
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN17575"
></A
><H3
>Process ID -1 doesn't affect calling process</H3
><P
>If <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> is specified as <TT
CLASS="LITERAL"
>-1</TT
>,
<TT
CLASS="PARAMETER"
><I
>sig</I
></TT
> shall not be sent to the calling process.
Other than this, the rules in the <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
> apply.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>This was a deliberate Linus decision after an unpopular experiment in
including the calling process in the 2.5.1 kernel.  See "What does it
mean to signal everybody?", Linux Weekly News, 20 December 2001,
<A
HREF="http://lwn.net/2001/1220/kernel.php3"
TARGET="_top"
>http://lwn.net/2001/1220/kernel.php3</A
></P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-LCONG48-R-1"
></A
>lcong48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17591"
></A
><H2
>Name</H2
>lcong48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17596"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17597"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>lcong48_r</TT
></CODE
>(unsigned short[7]
<TT
CLASS="PARAMETER"
><I
>param</I
></TT
>, struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17606"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>lcong48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>lcong48()</TT
>, except that
<TT
CLASS="FUNCTION"
>lcong48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
></DIV
><H1
><A
NAME="BASELIB-LINK-1"
></A
>link</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17617"
></A
><H2
>Name</H2
>link&nbsp;--&nbsp;create a link to a file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17622"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17623"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>link</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>path1</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>path2</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17632"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>link()</TT
> function shall behave as specified in 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>, 
except with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN17638"
></A
><H3
>Need Not Follow Symlinks</H3
><P
>&#13;<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> specifies that pathname resolution
shall follow symbolic links during pathname resolution unless the
function is required to act on the symbolic link itself, or certain 
arguments direct that the function act on the symbolic link itself. The
<TT
CLASS="FUNCTION"
>link()</TT
> function in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
contains no such requirement to operate on a symbolic link. 
However, a conforming
LSB implementation need not follow a symbolic link 
for the <TT
CLASS="PARAMETER"
><I
>path1</I
></TT
> argument. </P
></DIV
></DIV
><H1
><A
NAME="BASELIB-LRAND48-R-1"
></A
>lrand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17649"
></A
><H2
>Name</H2
>lrand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17654"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17655"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>lrand48_r</TT
></CODE
>(struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, long int *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17664"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>lrand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>lrand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>lrand48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-MEMMEM-3"
></A
>memmem</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17680"
></A
><H2
>Name</H2
>memmem&nbsp;--&nbsp;locate bytes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17683"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17686"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
  <TT
CLASS="FUNCTION"
>memmem</TT
></CODE
>(const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>haystack</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>haystacklen</I
></TT
></I
></TT
>, const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>needle</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>needlelen</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17703"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>memmem()</TT
> finds the start of the first 
occurrence of the byte array referenced by 
<TT
CLASS="PARAMETER"
><I
>needle</I
></TT
> 
of length <TT
CLASS="PARAMETER"
><I
>needlelen</I
></TT
> in the memory 
area <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
> of length 
<TT
CLASS="PARAMETER"
><I
>haystacklen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17713"
></A
><H2
>Return Value</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>needle</I
></TT
> is found,
<TT
CLASS="FUNCTION"
>memmem()</TT
> returns a pointer to it.
If <TT
CLASS="PARAMETER"
><I
>needlelen</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
>, 
<TT
CLASS="PARAMETER"
><I
>memmem</I
></TT
> returns <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>needle</I
></TT
> is not found in 
<TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>, <TT
CLASS="FUNCTION"
>memmem()</TT
>
returns <TT
CLASS="LITERAL"
>NULL</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17726"
></A
><H2
>Notes</H2
><P
>Earlier versions of the C library (prior to glibc 2.1) contained a
<TT
CLASS="FUNCTION"
>memmem()</TT
> with various problems, and application
developers should treat this function with care.</P
></DIV
><H1
><A
NAME="BASELIB-MEMRCHR"
></A
>memrchr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17734"
></A
><H2
>Name</H2
>memrchr&nbsp;--&nbsp;scan memory for a character</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17737"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17738"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
  <TT
CLASS="FUNCTION"
>memrchr</TT
></CODE
>(const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>c</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17752"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>memrchr()</TT
> function shall locate the last
occurence of <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> (converted to an unsigned char)
in the initial <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> bytes (each interpreted as
an unsigned char) of the object pointed to by
<TT
CLASS="PARAMETER"
><I
>s</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17759"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>memrchr()</TT
> shall return a pointer to the located
byte, or a null pointer if the byte does not occur in the object.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17763"
></A
><H2
>Errors</H2
><P
>No errors are defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17766"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>memchr()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-MKSTEMP64"
></A
>mkstemp64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17774"
></A
><H2
>Name</H2
>mkstemp64&nbsp;--&nbsp;create a unique temporary file (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17777"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17780"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>mkstemp64</TT
></CODE
>(char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>template</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17788"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>mkstemp64()</TT
> shall generates a unique temporary file
name from <TT
CLASS="PARAMETER"
><I
>template</I
></TT
>. The last six characters
of template shall be <TT
CLASS="LITERAL"
>XXXXXX</TT
> and these are replaced 
with a string that makes the file name unique; the file is
then created and an open file descriptor returned as described
for <TT
CLASS="FUNCTION"
>mkstemp()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>mkstemp64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>mkstemp()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
The only difference is 
that the temporary file is opened with <TT
CLASS="FUNCTION"
>open64()</TT
>
instead of with <TT
CLASS="FUNCTION"
>open()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17803"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>mkstemp64()</TT
> returns the file
descriptor of the temporary file.  Otherwise <TT
CLASS="FUNCTION"
>mkstemp64()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and
set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17810"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>mkstemp()</TT
> for possible error values.</P
></DIV
><H1
><A
NAME="BASELIB-MRAND48-R-1"
></A
>mrand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17818"
></A
><H2
>Name</H2
>mrand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17823"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17824"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mrand48_r</TT
></CODE
>(struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, long int *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17833"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mrand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>mrand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>mrand48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-MREMAP"
></A
>mremap</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17849"
></A
><H2
>Name</H2
>mremap&nbsp;--&nbsp;remap a virtual memory address</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17852"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17853"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/mman.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * <TT
CLASS="FUNCTION"
>mremap</TT
></CODE
>(void * <TT
CLASS="PARAMETER"
><I
>old_address</I
></TT
>, size_t <TT
CLASS="PARAMETER"
><I
>old_size</I
></TT
>, size_t <TT
CLASS="PARAMETER"
><I
>new_size</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17866"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>mremap()</TT
> function expands (or shrinks)
an existing memory mapping, potentially moving it at
the same time, depending on the flags argument and the
available virtual address space.</P
><P
><CODE
CLASS="VARNAME"
>old_address</CODE
> is the old address of the
virtual memory block to be resized. 
Note that <CODE
CLASS="VARNAME"
>old_address</CODE
> must be page aligned. 
<CODE
CLASS="VARNAME"
>old_size</CODE
> is the old size of the virtual memory block. 
<CODE
CLASS="VARNAME"
>new_size</CODE
> is the requested size of the
virtual memory block after the resize.</P
><P
>In Linux the memory is divided into pages. A user process has (one or)
several linear virtual memory segments. Each virtual memory segment
has one or more mappings to real memory pages (in the page table).
Each virtual memory segment has its own protection (access rights),
which may cause a segmentation violation if the memory is accessed
incorrectly (e.g., writing to a read-only segment). Accessing virtual
memory outside of the segments will also cause a segmentation violation.</P
><P
><TT
CLASS="FUNCTION"
>mremap()</TT
> uses the Linux page table
scheme. <TT
CLASS="FUNCTION"
>mremap()</TT
> changes the mapping between
virtual addresses and memory pages. This can be used to implement a
very efficient form of <TT
CLASS="FUNCTION"
>realloc()</TT
>.</P
><P
>The flags bit-mask argument may be 0, or include the following flag:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17882"
></A
><SPAN
STYLE="white-space: nowrap"
>MREMAP_MAYMOVE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>By default, if there is not sufficient space to expand a mapping
at its current location, then <TT
CLASS="FUNCTION"
>mremap()</TT
> fails.
If this flag is specified, then the kernel is permitted to relocate
the mapping to a new virtual address, if necessary. If the mapping
is relocated, then absolute pointers into the old mapping location
become invalid (offsets relative to the starting address of the
mapping should be employed).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17887"
></A
><SPAN
STYLE="white-space: nowrap"
>MREMAP_FIXED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This flag serves a similar purpose to the <CODE
CLASS="CONSTANT"
>MAP_FIXED</CODE
>
flag of <TT
CLASS="FUNCTION"
>mmap()</TT
>. If this flag is specified,
then <TT
CLASS="FUNCTION"
>mremap()</TT
>accepts a fifth argument,
<SPAN
CLASS="TYPE"
>void *</SPAN
><CODE
CLASS="VARNAME"
>new_address</CODE
>,
which specifies a pagealigned address to which the mapping must
be moved. Any previous mapping at the address range specified by
<CODE
CLASS="VARNAME"
>new_address</CODE
> and <CODE
CLASS="VARNAME"
>new_size</CODE
> is
unmapped. If <CODE
CLASS="CONSTANT"
>MREMAP_FIXED</CODE
> is specified, then
<CODE
CLASS="CONSTANT"
>MREMAP_MAYMOVE</CODE
> must also be specified.</P
></TD
></TR
></TBODY
></TABLE
><P
>If the memory segment specified by <CODE
CLASS="VARNAME"
>old_address</CODE
>
and <CODE
CLASS="VARNAME"
>old_size</CODE
> is locked (using
<TT
CLASS="FUNCTION"
>mlock()</TT
> or similar), then this lock is maintained
when the segment is resized and/or relocated. As a consequence, the
amount of memory locked by the process may change.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17904"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>mremap()</TT
> function returns a pointer
to the new virtual memory area on success.  On error, the value
<CODE
CLASS="CONSTANT"
>MAP_FAILED</CODE
> is returned, and <CODE
CLASS="VARNAME"
>errno</CODE
>
is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17910"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17913"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EAGAIN</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The caller tried to expand a memory segment that is locked, but this was
not possible without exceeding the <CODE
CLASS="CONSTANT"
>RLIMIT_MEMLOCK</CODE
>
resource limit.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17919"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EFAULT</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>"Segmentation fault." Some address in the range old_address to
<CODE
CLASS="VARNAME"
>old_address</CODE
>+<CODE
CLASS="VARNAME"
>old_size</CODE
> is
an invalid virtual memory address for this process. You can also get
<SPAN
CLASS="ERRORCODE"
>EFAULT</SPAN
> even if there exist mappings that cover the
whole address space requested, but those mappings are of different types.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17927"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EINVAL</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An invalid argument was given. Possible causes are:
<CODE
CLASS="VARNAME"
>old_address</CODE
> was not page aligned;
a value other than <CODE
CLASS="CONSTANT"
>MREMAP_MAYMOVE</CODE
>
or <CODE
CLASS="CONSTANT"
>MREMAP_FIXED</CODE
> was specified in
<CODE
CLASS="VARNAME"
>flags;</CODE
> <CODE
CLASS="VARNAME"
>new_size</CODE
> was zero;
<CODE
CLASS="VARNAME"
>new_size</CODE
> or <CODE
CLASS="VARNAME"
>new_address</CODE
>
was invalid;
or the new address range specified by <CODE
CLASS="VARNAME"
>new_address</CODE
>
and <CODE
CLASS="VARNAME"
>new_size</CODE
> overlapped the old address range specified
by <CODE
CLASS="VARNAME"
>old_address</CODE
> and <CODE
CLASS="VARNAME"
>old_size</CODE
>;
or <CODE
CLASS="CONSTANT"
>MREMAP_FIXED</CODE
> was specified without also specifying
<CODE
CLASS="CONSTANT"
>MREMAP_MAYMOVE.</CODE
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN17945"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The memory area cannot be expanded at the current virtual address,
and the <CODE
CLASS="CONSTANT"
>MREMAP_MAYMOVE</CODE
> flag is not set in
<CODE
CLASS="VARNAME"
>flags</CODE
>, or, there is not enough (virtual) memory
available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-NGETTEXT"
></A
>ngettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN17956"
></A
><H2
>Name</H2
>ngettext&nbsp;--&nbsp;search message catalogs for plural string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN17959"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN17962"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>ngettext</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>msgid2</I
></TT
></I
></TT
>, unsigned long int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17976"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ngettext()</TT
> function shall search the currently 
selected message catalogs for a string matching the singular string
<TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>. If a string is located, and if
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is 1, that string shall be returned.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is not 1, a pluralized version
(dependent on <TT
CLASS="PARAMETER"
><I
>n</I
></TT
>) of the string shall be returned.</P
><P
>The <TT
CLASS="FUNCTION"
>ngettext()</TT
> function is equivalent to
<TT
CLASS="FUNCTION"
>dcngettext(NULL, msgid1, msgid2, n, LC_MESSAGES)()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN17989"
></A
><H2
>Return Value</H2
><P
>If a string is found in the currently selected message catalogs for
<TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
>, then if <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is
<CODE
CLASS="CONSTANT"
>1</CODE
> a pointer to the located string shall be returned.
If <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is not <CODE
CLASS="CONSTANT"
>1</CODE
>, a pointer to an
appropriately pluralized version of the string shall be returned.
If no message could be found in the currently selected mesage catalogs,
then if <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> is <CODE
CLASS="CONSTANT"
>1</CODE
>,
a pointer to <TT
CLASS="PARAMETER"
><I
>msgid1</I
></TT
> shall be returned, otherwise
a pointer to <TT
CLASS="PARAMETER"
><I
>msgid2</I
></TT
> shall be returned.</P
><P
>Applications shall not modify the string returned by <TT
CLASS="FUNCTION"
>ngettext()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18003"
></A
><H2
>Errors</H2
><P
>None.</P
><P
>The <TT
CLASS="FUNCTION"
>ngettext()</TT
> function shall not modify 
<CODE
CLASS="VARNAME"
>errno</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18009"
></A
><H2
>See Also</H2
><P
>gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset</P
></DIV
><H1
><A
NAME="BASELIB-NRAND48-R-1"
></A
>nrand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18016"
></A
><H2
>Name</H2
>nrand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18021"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18022"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>nrand48_r</TT
></CODE
>(unsigned short[3]
<TT
CLASS="PARAMETER"
><I
>xsubi</I
></TT
>, struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, long int *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18033"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>nrand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>nrand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>nrand48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-OPENAT64"
></A
>openat64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18049"
></A
><H2
>Name</H2
>openat64&nbsp;--&nbsp;open a file relative to a directory file descriptor (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18052"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18055"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fcntl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
  <TT
CLASS="FUNCTION"
>openat64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>oflag</I
></TT
></I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18070"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>openat64()</TT
> shall establish a connection
between a file and a file descriptor. It shall be identical
<TT
CLASS="FUNCTION"
>open64()</TT
> except in the case where
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
> specifies a relative path. In
this case, the file to be opened shall be determined relative to
the directory associated with the file descriptor
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> instead of the current working directory.</P
><P
><TT
CLASS="FUNCTION"
>openat64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>openat()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
It differs from <TT
CLASS="FUNCTION"
>openat()</TT
> in the
same way that <TT
CLASS="FUNCTION"
>open64()</TT
> differs from
<TT
CLASS="FUNCTION"
>open()</TT
>, that the open is done in
large-file mode.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18086"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>openat64()</TT
> returns a new
file descriptor.
Otherwise <TT
CLASS="FUNCTION"
>openat64()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and
set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18093"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>openat()</TT
> for possible error values.</P
></DIV
><H1
><A
NAME="BASELIB-PMAP-GETPORT-3"
></A
>pmap_getport</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18101"
></A
><H2
>Name</H2
>pmap_getport&nbsp;--&nbsp;find the port number assigned to a service registered with a
portmapper.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18104"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18107"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/pmap_clnt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>u_short *
  <TT
CLASS="FUNCTION"
>pmap_getport</TT
></CODE
>(struct sockaddr_in *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>address</I
></TT
></I
></TT
>, const u_long
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>program</I
></TT
></I
></TT
>, const u_long *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>version</I
></TT
></I
></TT
>, u_int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>protocol</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18124"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function shall
return the port number assigned to a service registered with a
RPC Binding service running on a given target system,
using the protocol described in
<A
HREF="#STD.RFC1833"
>RFC 1833: Binding Protocols for ONC RPC Version 2</A
>.
The <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function shall be called given the
RPC program number <TT
CLASS="PARAMETER"
><I
>program</I
></TT
>,
the program version <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, and transport
protocol <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
>. Conforming implementations shall
support both <CODE
CLASS="CONSTANT"
>IPPROTO_UDP</CODE
> and 
<CODE
CLASS="CONSTANT"
>IPPROTO_TCP</CODE
> protocols. On entry,
<TT
CLASS="PARAMETER"
><I
>address</I
></TT
> shall specify the address of the 
system on which the portmapper to be
contacted resides. The value of <CODE
CLASS="VARNAME"
>address-&#62;sin_port</CODE
>
shall be ignored, and the standard
value for the portmapper port shall always be used.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Security and network restrictions may prevent a
conforming application from contacting a remote RPC Binding
Service.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18141"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function shall return 
the port number in host byte order of the RPC application
registered with the remote portmapper. On failure, 
if either the program was not
registered or the remote portmapper service could not be reached, 
the <TT
CLASS="FUNCTION"
>pmap_getport()</TT
> function
shall return 0. If the remote portmap service could not be reached, the status
is left in the global variable <CODE
CLASS="VARNAME"
>rpc_createerr</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB-PMAP-SET-3"
></A
>pmap_set</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18151"
></A
><H2
>Name</H2
>pmap_set&nbsp;--&nbsp;establishes mapping to machine's RPC Bind service.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18154"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18157"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/pmap_clnt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t
  <TT
CLASS="FUNCTION"
>pmap_set</TT
></CODE
>(const u_long
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>program</I
></TT
></I
></TT
>, const u_long
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>version</I
></TT
></I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>protocol</I
></TT
></I
></TT
>, u_short
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18174"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pmap_set()</TT
> establishes a mapping between the
triple <TT
CLASS="PARAMETER"
><I
>[program,version,protocol]</I
></TT
> and
<TT
CLASS="PARAMETER"
><I
>port</I
></TT
> on the machine's RPC Bind
service. The value of <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
>
is most likely <CODE
CLASS="VARNAME"
>IPPROTO_UDP</CODE
> or <CODE
CLASS="VARNAME"
>IPPROTO_TCP</CODE
>. Automatically done by <TT
CLASS="FUNCTION"
>svc_register()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18186"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>pmap_set()</TT
> returns non-zero if it suceeds, 0 otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-PMAP-UNSET-3"
></A
>pmap_unset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18194"
></A
><H2
>Name</H2
>pmap_unset&nbsp;--&nbsp;
destroys RPC Binding&#13;</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18197"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18200"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>&#13;#include &#60;rpc/pmap_clnt.h&#62;&#13;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t

  <TT
CLASS="FUNCTION"
>pmap_unset</TT
></CODE
>(u_long

  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>prognum</I
></TT
></I
></TT
>, u_long

  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>versnum</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18211"
></A
><H2
>Description&#13;</H2
><P
>&#13;As a user interface to the RPC Bind service, 

<TT
CLASS="FUNCTION"
>pmap_unset()</TT
> destroys all mapping between the triple 

[<TT
CLASS="PARAMETER"
><I
>prognum</I
></TT
>,<TT
CLASS="PARAMETER"
><I
>versnum</I
></TT
>,

<TT
CLASS="PARAMETER"
><I
>*</I
></TT
>] and <CODE
CLASS="VARNAME"
>ports</CODE
> on the machine's 

RPC Bind service.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18221"
></A
><H2
>Return Value&#13;</H2
><P
>&#13;<TT
CLASS="FUNCTION"
>pmap_unset()</TT
> returns non-zero if it succeeds, zero otherwise.&#13;</P
></DIV
><H1
><A
NAME="BASELIB-POSIX-FADVISE64"
></A
>posix_fadvise64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18229"
></A
><H2
>Name</H2
>posix_fadvise64&nbsp;--&nbsp;File advisory information (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18232"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18233"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fcntl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>posix_fadvise64</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, off64_t
<TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, off64_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>advice</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18246"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>posix_fadvise64()</TT
> function is a large-file
version of the <TT
CLASS="FUNCTION"
>posix_fadvise()</TT
> function defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
It shall advise the implementation on the expected behavior of the
application with respect to the data in the file associated with the open file descriptor, 
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, starting
at <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> and continuing for <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes. 
The specified range need not currently exist in the file. If <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>
is zero, all data following <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> is specified. 
The implementation may use this information to
optimize handling of the specified data. The <TT
CLASS="FUNCTION"
>posix_fadvise()</TT
> function shall have no effect on the
semantics of other operations on the specified data, although it may affect the performance of
other operations.</P
><P
>The advice to be applied to the data is specified by the <TT
CLASS="PARAMETER"
><I
>advice</I
></TT
> parameter, as specified
in <TT
CLASS="FUNCTION"
>posix_fadvise()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18263"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>posix_fadvise64()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>. Otherwise
an error number shall be returned to indicate the error.
See <TT
CLASS="FUNCTION"
>posix_fadvise()</TT
> for possible error values.</P
></DIV
><H1
><A
NAME="BASELIB-POSIX-FALLOCATE64"
></A
>posix_fallocate64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18273"
></A
><H2
>Name</H2
>posix_fallocate64&nbsp;--&nbsp;file space control (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18276"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18277"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fcntl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>posix_fallocate64</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, off64_t
<TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, off64_t
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18288"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>posix_fallocate64()</TT
> function is a large file version of
<TT
CLASS="FUNCTION"
>posix_fallocate()</TT
>. It shall behave as <TT
CLASS="FUNCTION"
>posix_fallocate()</TT
>
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except that the <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>
arguments are <CODE
CLASS="VARNAME"
>off64_t</CODE
> objects rather than <CODE
CLASS="VARNAME"
>off_t</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18299"
></A
><H2
>Return Value</H2
><P
>See <TT
CLASS="FUNCTION"
>posix_fallocate()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18303"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>posix_fallocate()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-PREAD64"
></A
>pread64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18311"
></A
><H2
>Name</H2
>pread64&nbsp;--&nbsp;read from a file (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18314"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18317"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t 
  <TT
CLASS="FUNCTION"
>pread64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
></I
></TT
>, off64_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>offset</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18334"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pread64()</TT
> shall read <TT
CLASS="PARAMETER"
><I
>count</I
></TT
> 
bytes into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> from the file associated with the
open file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, at the 
position specified by <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, without changing 
the file position.</P
><P
><TT
CLASS="FUNCTION"
>pread64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>pread()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
It differs from <TT
CLASS="FUNCTION"
>pread()</TT
>
in that the <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> parameter is an
<SPAN
CLASS="TYPE"
>off64_t</SPAN
> instead of an <SPAN
CLASS="TYPE"
>off_t</SPAN
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18352"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>pread64()</TT
> shall return the number 
of bytes actually read. Otherwise <TT
CLASS="FUNCTION"
>pread64()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and
set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18359"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>pread()</TT
> for possible error values.</P
></DIV
><H1
><A
NAME="BASELIB-PTRACE-1"
></A
>ptrace</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18367"
></A
><H2
>Name</H2
>ptrace&nbsp;--&nbsp;process trace</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18372"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18373"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/ptrace.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long
<TT
CLASS="FUNCTION"
>ptrace</TT
></CODE
>(enum __ptrace_request
<TT
CLASS="PARAMETER"
><I
>request</I
></TT
>, pid_t
<TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>data</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18386"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ptrace()</TT
> system call shall enable a process to
observe and control the execution of another process, as well as
examine and change certain attributes of that process.</P
><P
>This function operates via requests, which act on the traced process
using the other parameters in ways unique to each request type.  The
tracing process must initiate tracing, either via
the <CODE
CLASS="CONSTANT"
>PTRACE_TRACEME</CODE
>
or <CODE
CLASS="CONSTANT"
>PTRACE_ATTACH</CODE
> requests, before other requests
may be performed.  Except for <CODE
CLASS="CONSTANT"
>PTRACE_TRACEME</CODE
>
and <CODE
CLASS="CONSTANT"
>PTRACE_KILL</CODE
>, all requests must be performed
on a traced process that has been stopped.</P
><P
>All signals, except one, delivered to the traced process cause it to
stop, irrespective of its registered signal handling, and cause an
event to be delivered to the tracing process which can be detected
using the wait(2) system call.  The exception is
the <CODE
CLASS="CONSTANT"
>SIGKILL</CODE
> signal, which is delivered
immediately and performs its usual specified behavior.</P
><P
>The following requests are defined:

<P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_TRACEME</CODE
></DT
><DD
><P
>This request initates a trace from the perspective of the traced
process, indicating that the parent of the current process shall be
the tracing process.  When this is called, a subsequent call to
execve(2) shall cause the tracing process to receive a SIGTRAP signal,
and shall stop the current process.  This is the only request a traced
process may perform, and a tracing process may not perform this
request. The other parameters are ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_ATTACH</CODE
></DT
><DD
><P
>This request initates a trace from the perspective of the tracing
process on the process specified by <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.  After
this call succeeds, the traced process will appear to be a child of
the tracing process, although the original parent will still be
returned to the traced process via getppid(2).  The traced process
will receive a <CODE
CLASS="CONSTANT"
>SIGSTOP</CODE
> signal; the tracing
process should use wait(2) to ensure that the traced process has
stopped.  A tracing process is only guaranteed to be able to trace its
child processes; the tracing of other processes may not be allowed by
the system, and the process with process ID 1 may not be traced under
any circumstances.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>
and <TT
CLASS="PARAMETER"
><I
>data</I
></TT
> parameters are ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_CONT</CODE
></DT
><DD
><P
>This request restarts a traced process, given
in <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>, which has been stopped.
The <TT
CLASS="PARAMETER"
><I
>data</I
></TT
> parameter may point to a signal ID to
deliver to the traced process; if it is zero or SIGSTOP, no signal is
delivered to the child.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_DETACH</CODE
></DT
><DD
><P
>This request performs the same function, in the same way,
as <CODE
CLASS="CONSTANT"
>PTRACE_CONT</CODE
>, except that the tracing
relationship between the tracing and traced processes is also undone.
If the trace was initiated using <CODE
CLASS="CONSTANT"
>PTRACE_ATTACH</CODE
>,
the original parent-child relationships that existed beforehand are
restored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_KILL</CODE
></DT
><DD
><P
>This request causes a <CODE
CLASS="CONSTANT"
>SIGKILL</CODE
> signal to be sent
to the traced process specified in <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>
parameters are ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_PEEKTEXT</CODE
></DT
><DD
><P
>This request reads a word at the location <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>
of the traced process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>, and returns it to
the caller.  The <TT
CLASS="PARAMETER"
><I
>data</I
></TT
> parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_PEEKDATA</CODE
></DT
><DD
><P
>This request performs identically to
the <CODE
CLASS="CONSTANT"
>PTRACE_PEEKTEXT</CODE
> request.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_PEEKUSER</CODE
></DT
><DD
><P
>This request reads a word at offset <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> in the
USER area of the traced process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.  The
offset must be word-aligned.  The <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>
parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_POKETEXT</CODE
></DT
><DD
><P
> 
This request writes the word pointed at by <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>
to the location <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> of the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_POKEDATA</CODE
></DT
><DD
><P
>This request performs identically to
the <CODE
CLASS="CONSTANT"
>PTRACE_POKETEXT</CODE
> request.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_POKEUSER</CODE
></DT
><DD
><P
>This request writes the word pointed at by <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>
to offset <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> in the USER area of the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.  The offset must be word-aligned.
Implementations may choose to disallow some modifications to the USER
area.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_GETREGS</CODE
></DT
><DD
><P
>This request copies the general purpose registers from the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> to the tracing process at
location <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>.  This parameter may not be
available on all architectures.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>
parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_GETFPREGS</CODE
></DT
><DD
><P
>This request copies the floating point registers from the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> to the tracing process at
location <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>.  This parameter may not be
available on all architectures.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>
parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SETREGS</CODE
></DT
><DD
><P
>This request writes the general purpose registers to the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> from the tracing process at
location <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>.  This parameter may not be
available on all architectures.  Implementations may choose to
disallow some register modifications.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>
parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SETFPREGS</CODE
></DT
><DD
><P
>This request writes the floating point registers to the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> from the tracing process at
location <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>.  This parameter may not be
available on all architectures.  Implementations may choose to
disallow some register modifications.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>
parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_GETSIGINFO</CODE
></DT
><DD
><P
>This request writes information about the signal which caused the
traced process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> to stop to the tracing
process at location <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>, as a siginfo_t.
The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SETSIGINFO</CODE
></DT
><DD
><P
>This request writes signal information to the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> from a siginfo_t structure pointed
at by <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>, such that it will be used as the
signal information by the traced process when it is resumed.
The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> parameter is ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_GETEVENTMSG</CODE
></DT
><DD
><P
>This request stores information about the most recent ptrace event for
the traced process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> in the unsigned long
pointed at by <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>.
For <CODE
CLASS="CONSTANT"
>PTRACE_EVENT_EXIT</CODE
>, this is the exit status of
the traced process.
For <CODE
CLASS="CONSTANT"
>PTRACE_EVENT_FORK</CODE
>, <CODE
CLASS="CONSTANT"
>PTRACE_EVENT_VFORK</CODE
>,
or <CODE
CLASS="CONSTANT"
>PTRACE_EVENT_CLONE</CODE
>, this is the PID of the
newly created process. The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> parameter is
ignored.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SYSCALL</CODE
></DT
><DD
><P
>This request performs the same function, in the same way,
as <CODE
CLASS="CONSTANT"
>PTRACE_CONT</CODE
>, but with the additional step of
causing the traced process to stop at the next entry to or exit from a
system call.  The usual events that would also cause the traced
process to stop continue to do so.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SINGLESTEP</CODE
></DT
><DD
><P
>This request performs the same function, in the same way,
as <CODE
CLASS="CONSTANT"
>PTRACE_CONT</CODE
>, but with the additional step of
causing the traced process to stop after execution of a single
instruction.  The usual events that would also cause the traced
process to stop continue to do so.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SYSEMU</CODE
></DT
><DD
><P
>This request performs the same function, in the same way,
as <CODE
CLASS="CONSTANT"
>PTRACE_CONT</CODE
>, but with the additional step of
causing the traced process to stop on entry to the next syscall, which
will then not be executed.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SYSEMU_SINGLESTEP</CODE
></DT
><DD
><P
>This request performs the same function, in the same way,
as <CODE
CLASS="CONSTANT"
>PTRACE_CONT</CODE
>, but with the additional step of
causing the traced process to stop on entry to the next syscall, which
will then not be executed.  If the next instruction is not itself a
syscall, the traced process will stop after a single instruction is
executed.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_SETOPTIONS</CODE
></DT
><DD
><P
>This request sets <TT
CLASS="FUNCTION"
>ptrace()</TT
> options for the traced
process <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> from the location pointed to
by <TT
CLASS="PARAMETER"
><I
>data</I
></TT
>.  The <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
> is
ignored.  This location is interpreted as a bitmask of options, as
defined by the following flags:
<P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACESYSGOOD</CODE
></DT
><DD
><P
>This option, when set, causes syscall traps to set bit 7 in the signal
number.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACEFORK</CODE
></DT
><DD
><P
>This option, when set, causes the traced process to stop when it calls
fork(2).  The original traced process will stop with SIGTRAP |
PTRACE_EVENT_FORK &#60;&#60; 8, and the new process will be stopped with
SIGSTOP.  The new process will also be traced by the tracing process,
as if the tracing process had sent the PTRACE_ATTACH request for that
process.  The PID of the new process may be retrieved with the
PTRACE_GETEVENTMSG request.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACEVFORK</CODE
></DT
><DD
><P
>This option, when set, causes the traced process to stop when it calls
vfork(2).  The original traced process will stop with SIGTRAP |
PTRACE_EVENT_VFORK &#60;&#60; 8, and the new process will be stopped with
SIGSTOP.  The new process will also be traced by the tracing process,
as if the tracing process had sent the PTRACE_ATTACH request for that
process.  The PID of the new process may be retrieved with the
PTRACE_GETEVENTMSG request.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACECLONE</CODE
></DT
><DD
><P
>This option, when set, causes the traced process to stop when it calls
clone(2).  The original traced process will stop with SIGTRAP |
PTRACE_EVENT_CLONE &#60;&#60; 8, and the new process will be stopped with
SIGSTOP.  The new process will also be traced by the tracing process,
as if the tracing process had sent the PTRACE_ATTACH request for that
process.  The PID of the new process may be retrieved with the
PTRACE_GETEVENTMSG request.  Under certain circumstances, clone(2)
calls by the traced process will generate events and information
consistent with the PTRACE_O_TRACEVFORK or PTRACE_O_TRACEFORK options
above.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACEEXEC</CODE
></DT
><DD
><P
>&#13;This option, when set, causes the traced process to stop when it calls
execve(2).  The traced process will stop with SIGTRAP |
PTRACE_EVENT_EXEC &#60;&#60; 8.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACEVFORKDONE</CODE
></DT
><DD
><P
>This option, when set, causes the traced process to stop at the
completion of its next vfork(2) call.  The traced process will stop
with SIGTRAP | PTRACE_EVENT_EXEC &#60;&#60; 8.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>PTRACE_O_TRACEEXIT</CODE
></DT
><DD
><P
>This option, when set, causes the traced process to stop upon exit.
The traced process will stop with SIGTRAP | PTRACE_EVENT_EXIT &#60;&#60;
8, and its exit status can be retrieved with the PTRACE_GETEVENTMSG
request.  The stop is guaranteed to be early in the process exit
process, meaning that information such as register status at exit is
preserved.  Upon continuing, the traced process will immediately exit.</P
></DD
></DL
></DIV
></P
></DD
></DL
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18610"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>ptrace()</TT
> shall return the requested
data for <CODE
CLASS="CONSTANT"
>PTRACE_PEEK</CODE
> requests, or zero for all
other requests.  On error, all requests return -1,
with <CODE
CLASS="VARNAME"
>errno</CODE
> set to an appropriate value.  Note
that -1 may be a valid return value
for <CODE
CLASS="CONSTANT"
>PTRACE_PEEK</CODE
> requests; the application is
responsible for distinguishing between an error condition and a valid
return value in that case.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18617"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>ptrace()</TT
> shall
set <CODE
CLASS="VARNAME"
>errno</CODE
> to one of the regular error values below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18623"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EBUSY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred while allocating or freeing a debug register.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18628"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EFAULT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The request attempted to read from or write to an invalid area in the
memory space of the tracing or traced process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18633"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EIO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The request was invalid, or it attempted to read from or write to an
invalid area in the memory space of the tracing or traced process, or
it violated a word-alignment boundary, or an invalid signal was given
to continue the traced process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18638"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EINVAL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An attempt was made to set an invalid option.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18643"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EPERM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The request to trace a process was denied by the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18648"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>ESRCH</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process requested does not exist, is not being traced by the
current process, or is not stopped.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="BASELIB-PUTWC-UNLOCKED-1"
></A
>putwc_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18657"
></A
><H2
>Name</H2
>putwc_unlocked&nbsp;--&nbsp;non-thread-safe putwc</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18662"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>putwc_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>putwc()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-PUTWCHAR-UNLOCKED-1"
></A
>putwchar_unlocked</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18672"
></A
><H2
>Name</H2
>putwchar_unlocked&nbsp;--&nbsp;non-thread-safe putwchar</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18677"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>putwchar_unlocked()</TT
> is the same as
<TT
CLASS="FUNCTION"
>putwchar()</TT
>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<TT
CLASS="FUNCTION"
>getc_unlocked()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-PWRITE64"
></A
>pwrite64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18687"
></A
><H2
>Name</H2
>pwrite64&nbsp;--&nbsp;write on a file (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18690"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18693"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t 
  <TT
CLASS="FUNCTION"
>pwrite64</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fd</I
></TT
></I
></TT
>, const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
></I
></TT
>, off64_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>offset</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18710"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pwrite64()</TT
> shall write <TT
CLASS="PARAMETER"
><I
>count</I
></TT
> 
bytes from <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> to the file associated with the
open file descriptor <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>, at the 
position specified by <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, without changing 
the file position.</P
><P
><TT
CLASS="FUNCTION"
>pwrite64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>pwrite()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
It differs from <TT
CLASS="FUNCTION"
>pwrite()</TT
>
in that the <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> parameter is an
<SPAN
CLASS="TYPE"
>off64_t</SPAN
> instead of an <SPAN
CLASS="TYPE"
>off_t</SPAN
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18728"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>pwrite64()</TT
> shall return the number 
of bytes actually written. Otherwise <TT
CLASS="FUNCTION"
>pwrite()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and
set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18735"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>pwrite()</TT
> for possible error values.</P
></DIV
><H1
><A
NAME="BASELIB-RANDOM-R-1"
></A
>random_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18743"
></A
><H2
>Name</H2
>random_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18748"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18749"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>random_r</TT
></CODE
>(struct random_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>, int32_t *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18758"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>random_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>random()</TT
>, except that
<TT
CLASS="FUNCTION"
>random_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
><P
>Before it is used, <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> must be initialized, for example,
by calling <TT
CLASS="FUNCTION"
>lcong48_r()</TT
>,
<TT
CLASS="FUNCTION"
>seed48_r()</TT
>, or 
<TT
CLASS="FUNCTION"
>srand48_r()</TT
>,
or by filling it with zeroes.</P
></DIV
><H1
><A
NAME="BASELIB-READDIR64-R"
></A
>readdir64_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18774"
></A
><H2
>Name</H2
>readdir64_r&nbsp;--&nbsp;read a directory (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18777"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18778"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;dirent.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>readdir64_r</TT
></CODE
>(DIR *
<TT
CLASS="PARAMETER"
><I
>dirp</I
></TT
>, struct dirent64 *
<TT
CLASS="PARAMETER"
><I
>entry</I
></TT
>, struct dirent64 * *
<TT
CLASS="PARAMETER"
><I
>result</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18789"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>readdir64_r()</TT
> function is a large file version of
<TT
CLASS="FUNCTION"
>readdir_r()</TT
>. It shall behave as <TT
CLASS="FUNCTION"
>readdir_r()</TT
>
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except that the <TT
CLASS="PARAMETER"
><I
>entry</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>result</I
></TT
>
arguments are <CODE
CLASS="VARNAME"
>dirent64</CODE
> structures rather than <CODE
CLASS="VARNAME"
>dirent</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18800"
></A
><H2
>Return Value</H2
><P
>See <TT
CLASS="FUNCTION"
>readdir_r()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18804"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>readdir_r()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-REGEXEC-2"
></A
>regexec</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18812"
></A
><H2
>Name</H2
>regexec&nbsp;--&nbsp;regular expression matching</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18817"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>regexec()</TT
> function shall behave as specified in 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>, 
except with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN18823"
></A
><H3
>Differences</H3
><P
>Certain aspects of regular expression matching are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
>.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-SCANDIR64-1"
></A
>scandir64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18831"
></A
><H2
>Name</H2
>scandir64&nbsp;--&nbsp;scan a directory (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18836"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18837"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;dirent.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>scandir64</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>dir</I
></TT
>, const struct dirent64 **
<TT
CLASS="PARAMETER"
><I
>namelist</I
></TT
>, int (*sel)
(const struct dirent64 *), int (*<TT
CLASS="PARAMETER"
><I
>compar</I
></TT
>)
 (const struct dirent64 **, const struct dirent64 **));</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18852"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>scandir64()</TT
> is a large-file version of
the <TT
CLASS="FUNCTION"
>scandir()</TT
> function as defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
If differs only in that the <TT
CLASS="PARAMETER"
><I
>namelist</I
></TT
>
and the paramters to the selection function <TT
CLASS="PARAMETER"
><I
>sel</I
></TT
>
and comparison function <TT
CLASS="PARAMETER"
><I
>compar</I
></TT
> are 
of type <TT
CLASS="STRUCTNAME"
>dirent64</TT
> instead of type
<TT
CLASS="STRUCTNAME"
>dirent</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SCANF"
></A
>scanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18867"
></A
><H2
>Name</H2
>scanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18870"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18875"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-SCHED-GETAFFINITY"
></A
>sched_getaffinity</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18893"
></A
><H2
>Name</H2
>sched_getaffinity&nbsp;--&nbsp;retrieve the affinity mask of a process</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18896"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18899"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sched.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <TT
CLASS="FUNCTION"
>sched_getaffinity</TT
></CODE
>(pid_t
  <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>, unsigned int
  <TT
CLASS="PARAMETER"
><I
>cpusetsize</I
></TT
>, cpu_set_t *
  <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18910"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>sched_getaffinity()</TT
>
shall retrieve the affinity mask of a process.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>
specifies the ID for the process. 
If <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
>, 
then the calling process is specified instead.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>cpusetsize</I
></TT
> specifies 
the length of the data pointed to by <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>, in bytes.  
Normally, this parameter is specified as <TT
CLASS="LITERAL"
>sizeof(cpu_set_t)</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18922"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>sched_getaffinity()</TT
>
shall return <TT
CLASS="LITERAL"
>0</TT
>, and
the structure pointed to by <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>
shall contain the affinity mask of the specified process.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>sched_getaffinity()</TT
>
shall return <TT
CLASS="LITERAL"
>-1</TT
> and 
set <CODE
CLASS="VARNAME"
>errno</CODE
> as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18932"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18935"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bad address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18939"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>
does not specify any processors that exist in the system, 
or <TT
CLASS="PARAMETER"
><I
>cpusetsize</I
></TT
>
is smaller than the kernel's affinity mask. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN18945"
></A
><SPAN
STYLE="white-space: nowrap"
>ESRCH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified process could not be found.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18949"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>sched_setscheduler()</TT
>, <TT
CLASS="FUNCTION"
>sched_setaffinity()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SCHED-SETAFFINITY"
></A
>sched_setaffinity</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN18958"
></A
><H2
>Name</H2
>sched_setaffinity&nbsp;--&nbsp;set the CPU affinity mask for a process</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN18961"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN18964"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sched.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <TT
CLASS="FUNCTION"
>sched_setaffinity</TT
></CODE
>(pid_t
  <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>, unsigned int
  <TT
CLASS="PARAMETER"
><I
>cpusetsize</I
></TT
>, cpu_set_t *
  <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18975"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>sched_setaffinity()</TT
>
shall set the CPU affinity mask for a process. </P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>
specifies the ID for the process. 
If <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> is 0,
then the calling process is specified instead.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>cpusetsize</I
></TT
> specifies 
the length of the data pointed to by
<TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>, in bytes.  
Normally, this parameter is specified as
<TT
CLASS="LITERAL"
>sizeof(cpu_set_t)</TT
>.</P
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>
specifies the new value for the CPU affinity mask. 
The structure pointed to by <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
>
represents the set of CPUs on which the process may run.
If <TT
CLASS="PARAMETER"
><I
>mask</I
></TT
> does not specify one of the CPUs 
on which the specified process is currently running, 
then <TT
CLASS="FUNCTION"
>sched_setaffinity()</TT
>
shall migrate the process to one of those CPUs.</P
><P
>Setting the mask on a multiprocessor system can improve performance.
For example, 
setting the mask for one process to specify a particular CPU,
and then setting the mask of all other processes to exclude the CPU,
dedicates the CPU to the process
so that the process runs as fast as possible.
This technique also prevents loss of performance in case the process
terminates on one CPU and starts again on another, invalidating cache.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18992"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>sched_setaffinity()</TT
>
shall return <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
>On failure, <TT
CLASS="FUNCTION"
>sched_setaffinity()</TT
>
shall return <TT
CLASS="LITERAL"
>-1</TT
> and 
set <CODE
CLASS="VARNAME"
>errno</CODE
> as follows.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19001"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19004"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bad address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19008"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>mask</I
></TT
> does not specify any processors that exist in the system, 
or <TT
CLASS="PARAMETER"
><I
>cpusetsize</I
></TT
> is smaller than the kernel's affinity mask. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19014"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient privileges.
The effective user ID of the process calling
<TT
CLASS="FUNCTION"
>sched_setaffinity()</TT
>
is not equal to the user ID or effective user ID of the specified process,
and the calling process does not have appropriate privileges.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19019"
></A
><SPAN
STYLE="white-space: nowrap"
>ESRCH</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The specified process could not be found.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19023"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>sched_setscheduler()</TT
>, <TT
CLASS="FUNCTION"
>sched_getaffinity()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SCHED-SETSCHEDULER"
></A
>sched_setscheduler</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19032"
></A
><H2
>Name</H2
>sched_setscheduler&nbsp;--&nbsp;set scheduling policy and parameters</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19035"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19036"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sched.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>sched_setscheduler</TT
></CODE
>(pid_t
<TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>policy</I
></TT
>, const struct sched_param *
<TT
CLASS="PARAMETER"
><I
>param</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19047"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sched_setscheduler()</TT
> 
shall behave as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19052"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned
instead of the former scheduling policy.</P
></DIV
><H1
><A
NAME="BASELIB-SEED48-R-1"
></A
>seed48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19060"
></A
><H2
>Name</H2
>seed48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19065"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19066"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>seed48_r</TT
></CODE
>(unsigned short[3]
<TT
CLASS="PARAMETER"
><I
>seed16v</I
></TT
>, struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19075"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>seed48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>seed48()</TT
>, except that
<TT
CLASS="FUNCTION"
>seed48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
></DIV
><H1
><A
NAME="BASELIB-SENDFILE"
></A
>sendfile</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19086"
></A
><H2
>Name</H2
>sendfile&nbsp;--&nbsp;transfer data between two file descriptors</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19089"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19092"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/sendfile.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t <TT
CLASS="FUNCTION"
>sendfile</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
>out_fd</I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>, off_t *
  <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>count</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19105"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sendfile()</TT
> function shall copy data 
between the file descriptor <TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>, which must not be a socket, 
and the file descriptor <TT
CLASS="PARAMETER"
><I
>out_fd</I
></TT
>, which must be a socket. 
<TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
> should be opened for reading, 
and <TT
CLASS="PARAMETER"
><I
>out_fd</I
></TT
> should be opened for writing. </P
><P
>The <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> parameter points to 
a variable set to the file offset at which 
<TT
CLASS="FUNCTION"
>sendfile()</TT
> shall start reading from <TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>, 
unless it is <TT
CLASS="LITERAL"
>NULL</TT
>. 
On exit, this variable shall contain the offset of 
the byte immediately after the last byte read. 
<TT
CLASS="FUNCTION"
>sendfile()</TT
> shall not change the current file offset 
of <TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>, unless it is <TT
CLASS="LITERAL"
>NULL</TT
>. 
In that case, <TT
CLASS="FUNCTION"
>sendfile()</TT
> shall adjust the current file offset 
to show how many bytes were read.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>count</I
></TT
> parameter specifies how many bytes to copy.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19126"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>sendfile()</TT
> shall return 
the number of bytes written to <TT
CLASS="PARAMETER"
><I
>out_fd</I
></TT
>. </P
><P
>On failure, <TT
CLASS="FUNCTION"
>sendfile()</TT
> shall return 
<TT
CLASS="LITERAL"
>-1</TT
> and set <CODE
CLASS="VARNAME"
>errno</CODE
> appropriately, as follows. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19135"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19138"
></A
><SPAN
STYLE="white-space: nowrap"
>EAGAIN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Non-blocking I/O with <CODE
CLASS="CONSTANT"
>O_NONBLOCK</CODE
> 
has been chosen, but the write would block.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19143"
></A
><SPAN
STYLE="white-space: nowrap"
>EBADF</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The input file is not open for reading, 
or the output file is not open for writing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19147"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bad address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19151"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An <TT
CLASS="FUNCTION"
>mmap()</TT
>-like operation is unavailable for 
<TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>, or file descriptor is locked or invalid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19157"
></A
><SPAN
STYLE="white-space: nowrap"
>EIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There was an unspecified error while reading.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19161"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There is not enough memory to read from <TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19166"
></A
><H2
>Notes</H2
><P
><TT
CLASS="FUNCTION"
>sendfile()</TT
> is usually faster than combining 
<TT
CLASS="FUNCTION"
>read()</TT
> and <TT
CLASS="FUNCTION"
>write()</TT
> calls, 
because it is part of the kernel. 
However, if it fails with <CODE
CLASS="CONSTANT"
>EINVAL</CODE
>, 
falling back to <TT
CLASS="FUNCTION"
>read()</TT
> and <TT
CLASS="FUNCTION"
>write()</TT
> may be advisable.</P
><P
>It is advisable for performance reasons to use the 
<CODE
CLASS="CONSTANT"
>TCP_CORK</CODE
> option of the <TT
CLASS="FUNCTION"
>tcp()</TT
> function 
when sending header data with file contents to a TCP socket. 
This minimizes the number of packets.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19178"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>mmap()</TT
>, <TT
CLASS="FUNCTION"
>open()</TT
>, 
<TT
CLASS="FUNCTION"
>socket()</TT
>, <TT
CLASS="FUNCTION"
>splice()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SENDFILE64"
></A
>sendfile64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19189"
></A
><H2
>Name</H2
>sendfile64&nbsp;--&nbsp;transfer data between two file descriptors (Large File Support)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19192"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19195"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/sendfile.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ssize_t <TT
CLASS="FUNCTION"
>sendfile64</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
>out_fd</I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
>in_fd</I
></TT
>, off64_t *
  <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, size_t
  <TT
CLASS="PARAMETER"
><I
>count</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19208"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sendfile64()</TT
> function is a large-file version
of the <TT
CLASS="FUNCTION"
>sendfile()</TT
> function.</P
></DIV
><H1
><A
NAME="BASELIB-SETBUFFER-3"
></A
>setbuffer</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19219"
></A
><H2
>Name</H2
>setbuffer&nbsp;--&nbsp;stream buffering operation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19222"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19225"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>setbuffer</TT
></CODE
>(FILE *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>stream</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>size</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19239"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>setbuffer()</TT
> is an alias for the call to 
<TT
CLASS="FUNCTION"
>setvbuf()</TT
>. It works the same, except that the 
size of the buffer in <TT
CLASS="FUNCTION"
>setbuffer()</TT
> is up to 
the caller, rather than being determined by the default 
<TT
CLASS="PARAMETER"
><I
>BUFSIZ</I
></TT
>.  </P
></DIV
><H1
><A
NAME="BASELIB-SETGROUPS-2"
></A
>setgroups</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19252"
></A
><H2
>Name</H2
>setgroups&nbsp;--&nbsp;set list of supplementary group IDs</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19255"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19256"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;grp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>setgroups</TT
></CODE
>(size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>size</I
></TT
></I
></TT
>, const gid_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>list</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19267"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege,
the <TT
CLASS="FUNCTION"
>setgroups()</TT
> function shall set
the supplementary group IDs for 
the current process. <TT
CLASS="PARAMETER"
><I
>list</I
></TT
> shall reference
an array of <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> group IDs. A process
may have at most <CODE
CLASS="CONSTANT"
>NGROUPS_MAX</CODE
> supplementary
group IDs.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19274"
></A
><H2
>Return Value</H2
><P
>On successful completion, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the <CODE
CLASS="VARNAME"
>errno</CODE
> is set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19280"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19283"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EFAULT</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>list</I
></TT
> has an invalid address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19289"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EPERM</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process does not have appropriate privileges.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19294"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORCODE"
>EINVAL</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
> is greater than <CODE
CLASS="VARNAME"
>NGROUPS_MAX</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-SETHOSTNAME-2"
></A
>sethostname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19305"
></A
><H2
>Name</H2
>sethostname&nbsp;--&nbsp;set host name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19308"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19309"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;
#include &#60;sys/param.h.h&#62;
#include &#60;sys/utsname.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sethostname</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>len</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19320"
></A
><H2
>Description</H2
><P
>If the process has appropriate privileges, the
<TT
CLASS="FUNCTION"
>sethostname()</TT
> function shall change the host name for the 
current machine. The <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> shall point to a
null-terminated string of at most <TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes
that holds the new hostname.</P
><P
>If the symbol <CODE
CLASS="CONSTANT"
>HOST_NAME_MAX</CODE
> is defined, or if
<TT
CLASS="FUNCTION"
>sysconf(_SC_HOST_NAME_MAX)()</TT
> returns a value greater
than 0, this value shall represent the maximum length of the new hostname.
Otherwise, if the symbol <CODE
CLASS="CONSTANT"
>MAXHOSTLEN</CODE
> is defined, this value
shall represent the maximum length for the new hostname. If none of these
values are defined, the maximum length shall be the size of the
<CODE
CLASS="STRUCTFIELD"
>nodename</CODE
> field of the
<TT
CLASS="STRUCTNAME"
>utsname</TT
> structure.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19332"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19338"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19341"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
> is negative or larger than the maximum allowed size.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19346"
></A
><SPAN
STYLE="white-space: nowrap"
>EPERM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the process did not have appropriate privilege.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19350"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is an invalid address.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19355"
></A
><H2
>Rationale</H2
><P
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
guarantees that:
<A
NAME="AEN19359"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Maximum length of a host name (not including the terminating null) 
as returned from the <TT
CLASS="FUNCTION"
>gethostname()</TT
> function shall be at least 255 bytes.</P
></BLOCKQUOTE
></P
><P
>The glibc C library does not currently define <CODE
CLASS="CONSTANT"
>HOST_NAME_MAX</CODE
>,
and although it provides the name <CODE
CLASS="CONSTANT"
>_SC_HOST_NAME_MAX</CODE
>
a call to <TT
CLASS="FUNCTION"
>sysconf()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>
and does not alter <CODE
CLASS="VARNAME"
>errno</CODE
> in this case (indicating that
there is no restriction on the hostname length). However, the glibc
manual idicates that some implementations may have 
<CODE
CLASS="CONSTANT"
>MAXHOSTNAMELEN</CODE
> as a means of detecting the maximum length,
while the Linux kernel at release 2.4 and 2.6 stores this hostname
in the <TT
CLASS="STRUCTNAME"
>utsname</TT
> structure.
While the glibc manual suggests simply shortening the name until
<TT
CLASS="FUNCTION"
>sethostname()</TT
> succeeds, the LSB requires
that one of the first four mechanisms works.
Future versions of glibc may provide a more reasonable result from 
<TT
CLASS="LITERAL"
>sysconf</TT
>(<CODE
CLASS="CONSTANT"
>_SC_HOST_NAME_MAX</CODE
>).</P
></DIV
><H1
><A
NAME="BASELIB-SETSOCKOPT-2"
></A
>setsockopt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19377"
></A
><H2
>Name</H2
>setsockopt&nbsp;--&nbsp;set socket options</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19382"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19383"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/socket.h&#62;
#include &#60;netinet/ip.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>setsockopt</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>socket</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
>, const void *
<TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>, socklen_t
<TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19398"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>setsockopt()</TT
> function shall behave as specified in
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>,
with the following extensions.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN19404"
></A
><H3
>IP Protocol Level Options</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> parameter is
<CODE
CLASS="CONSTANT"
>IPPROTO_IP</CODE
>, the following values shall be supported for
<TT
CLASS="PARAMETER"
><I
>option_name</I
></TT
> (see <A
HREF="#STD.RFC791"
>RFC 791:Internet Protocol</A
> for
further details):
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19412"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_OPTIONS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the Internet Protocol options sent with
every packet from this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a
memory buffer containing the options and
<TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> shall contain the size in bytes
of that buffer.
For IPv4, the maximum length of options is 40 bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19419"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TOS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the Type of Service flags
to use when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a value
containing the type of service value. The least significant two bits
of the value shall contain the new Type of Service indicator. Use of other
bits in the value is unspecified.
The <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> parameter shall hold the size, in bytes,
of the buffer referred to by <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19427"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_TTL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the current unicast Internet Protocol
Time To Live value used when sending packets with this socket.
The <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
> shall point to a value
containing the time to live value, which shall be between
1 and 255.
The <TT
CLASS="PARAMETER"
><I
>option_len</I
></TT
> parameter shall hold the size, in bytes,
of the buffer referred to by <TT
CLASS="PARAMETER"
><I
>option_value</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19435"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_MULTICAST_TTL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Sets the Time To Live value of outgoing multicast packets for this
socket. <TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to an integer which contains
the new TTL value. If the new TTL value is <CODE
CLASS="CONSTANT"
>-1</CODE
>, the implementation
should use an unspecified default TTL value. If the new TTL value is out of the range
of acceptable values (0-255), <TT
CLASS="FUNCTION"
>setsockopt()</TT
> shall return
<CODE
CLASS="CONSTANT"
>-1</CODE
> and set <CODE
CLASS="VARNAME"
>errno</CODE
> to indicate the error.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19445"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_MULTICAST_LOOP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Sets a boolean flag indicating whether multicast packets originating locally
should be looped back to the local sockets.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to an integer which contains
the new flag value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19451"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_ADD_MEMBERSHIP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Join a multicast group.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure. Before calling, the
caller should fill in the <CODE
CLASS="STRUCTFIELD"
>imr_multiaddr</CODE
>
field with the multicast group address and the
<CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
> field with the address of the local
interface. If <CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
> is set to INADDR_ANY,
then an appropriate interface is chosen by the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19461"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_DROP_MEMBERSHIP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Leave a multicast group.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to a
<TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure containing the same values as were
used with <CODE
CLASS="CONSTANT"
>IP_ADD_MEMBERSHIP</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19469"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>IP_MULTICAST_IF</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Set the local device for a multicast socket.
<TT
CLASS="PARAMETER"
><I
>optval</I
></TT
> shall point to either an
<TT
CLASS="STRUCTNAME"
>ip_mreqn</TT
> structure or an 
<TT
CLASS="STRUCTNAME"
>in_addr</TT
> structure.  
If using the <TT
CLASS="STRUCTNAME"
>ip_mreqn</TT
> structure,
the <CODE
CLASS="STRUCTFIELD"
>imr_multiaddr</CODE
> field should be set to 
multicast group address, the <CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
> 
field to the address of the local interface,
and the <CODE
CLASS="STRUCTFIELD"
>imr_index</CODE
> field to the interface index.
If using the <TT
CLASS="STRUCTNAME"
>in_addr</TT
> structure, 
the address of the local interface shall be specified.
If <CODE
CLASS="STRUCTFIELD"
>in_addr</CODE
> or 
<CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
> is set to 
<CODE
CLASS="CONSTANT"
>INADDR_ANY</CODE
>, then an appropriate interface 
is chosen by the system.  
If <CODE
CLASS="STRUCTFIELD"
>imr_index</CODE
> is zero, 
then an appropriate interface index is chosen by the implementation.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="STRUCTNAME"
>ip_mreq</TT
> structure contains two
<TT
CLASS="STRUCTNAME"
>struct in_addr</TT
> fields:
<CODE
CLASS="STRUCTFIELD"
>imr_multiaddr</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>imr_address</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19491"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned and
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19497"
></A
><H2
>Errors</H2
><P
>As defined in <A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-SETSTATE-R-1"
></A
>setstate_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19505"
></A
><H2
>Name</H2
>setstate_r&nbsp;--&nbsp;reentrantly change the state array used by random number generator functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19510"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19511"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>setstate_r</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>statebuf</I
></TT
>, struct random_data *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19520"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>setstate_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>setstate()</TT
>, except that
<TT
CLASS="FUNCTION"
>setstate_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>statebuf</I
></TT
> instead of the global random 
number generator state.</P
></DIV
><H1
><A
NAME="BASELIB-SETUTENT-3"
></A
>setutent</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19531"
></A
><H2
>Name</H2
>setutent&nbsp;--&nbsp;access user accounting database entries</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19534"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19537"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>setutent</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19543"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>setutent()</TT
> function shall 
reset the user accounting database such that the next
call to <TT
CLASS="FUNCTION"
>getutent()</TT
> shall return the first
record in the database.
It is recommended to
call it before any of the other functions that operate on
the user accounting databases (e.g.
<TT
CLASS="FUNCTION"
>getutent()</TT
>)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19551"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-SIGANDSET"
></A
>sigandset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19558"
></A
><H2
>Name</H2
>sigandset&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical AND</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19561"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19562"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigandset</TT
></CODE
>(sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>set</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>left</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>right</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19576"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigandset()</TT
> function shall combine the two signal 
sets referenced
by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>right</I
></TT
>,
using a logical AND operation, and shall place the result in the location
referenced by <TT
CLASS="PARAMETER"
><I
>set</I
></TT
>,
The resulting signal set shall contain only signals that are in both
the set referenced by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> and the set referenced by
<TT
CLASS="PARAMETER"
><I
>right</I
></TT
>.</P
><P
>Applications shall call <TT
CLASS="FUNCTION"
>sigemptyset()</TT
> or
<TT
CLASS="FUNCTION"
>sigfillset()</TT
> at least once for each object
of type <SPAN
CLASS="TYPE"
>sigset_t</SPAN
> to initialize it.  If an uninitialized
or <TT
CLASS="LITERAL"
>NULL</TT
> object is passed to
<TT
CLASS="FUNCTION"
>sigandset()</TT
>, the results are undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19591"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>sigandset()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
There are no defined error returns.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19596"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>sigorset()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGISEMPTYSET"
></A
>sigisemptyset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19604"
></A
><H2
>Name</H2
>sigisemptyset&nbsp;--&nbsp;check for empty signal set</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19607"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19608"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigisemptyset</TT
></CODE
>(const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>set</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19616"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigisemptyset()</TT
> function shall
check for empty signal set referenced by <TT
CLASS="PARAMETER"
><I
>set</I
></TT
>. </P
><P
>Applications shall call <TT
CLASS="FUNCTION"
>sigemptyset()</TT
> or
<TT
CLASS="FUNCTION"
>sigfillset()</TT
> at least once for each object
of type <SPAN
CLASS="TYPE"
>sigset_t</SPAN
> to initialize it.  If an uninitialized
or <TT
CLASS="LITERAL"
>NULL</TT
> object is passed to
<TT
CLASS="FUNCTION"
>sigisemptyset()</TT
>, the results are undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19627"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>sigisemptyset()</TT
> function shall return
a positive non-zero value if the signal set referenced by 
<TT
CLASS="PARAMETER"
><I
>set</I
></TT
> is empty, or zero if this set is empty.
There are no defined error returns.</P
></DIV
><H1
><A
NAME="BASELIB-SIGORSET"
></A
>sigorset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19636"
></A
><H2
>Name</H2
>sigorset&nbsp;--&nbsp;build a new signal set by combining the two input sets using logical OR</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19639"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19642"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigorset</TT
></CODE
>(sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>set</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>left</I
></TT
></I
></TT
>, const sigset_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>right</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19656"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigorset()</TT
> function shall combine the two signal 
sets referenced
by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>right</I
></TT
>,
using a logical OR operation, and shall place the result in the location
referenced by <TT
CLASS="PARAMETER"
><I
>set</I
></TT
>,
The resulting signal set shall contain only signals that are in either
the set referenced by <TT
CLASS="PARAMETER"
><I
>left</I
></TT
> or the set referenced by
<TT
CLASS="PARAMETER"
><I
>right</I
></TT
>.</P
><P
>Applications shall call <TT
CLASS="FUNCTION"
>sigemptyset()</TT
> or
<TT
CLASS="FUNCTION"
>sigfillset()</TT
> at least once for each object
of type <SPAN
CLASS="TYPE"
>sigset_t</SPAN
> to initialize it.  If an uninitialized
or <TT
CLASS="LITERAL"
>NULL</TT
> object is passed to
<TT
CLASS="FUNCTION"
>sigorset()</TT
>, the results are undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19673"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>sigorset()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
There are no defined error returns.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19678"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>sigandset()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGPAUSE-3"
></A
>sigpause</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19686"
></A
><H2
>Name</H2
>sigpause&nbsp;--&nbsp;remove a signal from the signal mask and suspend the thread (deprecated)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19689"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19690"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;signal.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>sigpause</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>sig</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19697"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigpause()</TT
> function is deprecated from the LSB and
is expected to disappear from a future version of the LSB. Conforming applications
should use <TT
CLASS="FUNCTION"
>sigsuspend()</TT
> instead.</P
><P
>In the source standard, <TT
CLASS="FUNCTION"
>sigpause()</TT
> is implemented
as a macro causing it to behave as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
and is equivalent to the function <TT
CLASS="FUNCTION"
>__xpg_sigpause()</TT
>.
If the macro is undefined, <TT
CLASS="FUNCTION"
>sigpause()</TT
> from
the binary standard is used, with differences as described here:</P
><P
>The <TT
CLASS="FUNCTION"
>sigpause()</TT
> function shall block those signals
indicated by <TT
CLASS="PARAMETER"
><I
>sig</I
></TT
> and suspend execution of the
thread until a signal is delivered. When a signal is delivered,
the original signal mask shall be restored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19710"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>__xpg_sigpause()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGRETURN-2"
></A
>sigreturn</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19720"
></A
><H2
>Name</H2
>sigreturn&nbsp;--&nbsp;return from signal handler and cleanup stack frame</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19723"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19726"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>sigreturn</TT
></CODE
>(struct sigcontext *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>scp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19733"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sigreturn()</TT
> function is used by the system 
to cleanup after a signal handler has returned.
This function is not in the source standard; it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19739"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>sigreturn()</TT
> never returns.</P
></DIV
><H1
><A
NAME="BASELIB-SRAND48-R-1"
></A
>srand48_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19747"
></A
><H2
>Name</H2
>srand48_r&nbsp;--&nbsp;reentrantly generate pseudorandom numbers in a uniform distribution</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19752"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19753"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>srand48_r</TT
></CODE
>(long int
<TT
CLASS="PARAMETER"
><I
>seedval</I
></TT
>, struct drand48_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19762"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>srand48_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>srand48()</TT
>, except that
<TT
CLASS="FUNCTION"
>srand48_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
></DIV
><H1
><A
NAME="BASELIB-SRANDOM-R-1"
></A
>srandom_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19773"
></A
><H2
>Name</H2
>srandom_r&nbsp;--&nbsp;reentrantly set the seed for a new sequence of pseudorandom numbers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19778"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19779"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>srandom_r</TT
></CODE
>(unsigned int
<TT
CLASS="PARAMETER"
><I
>seed</I
></TT
>, struct random_data *
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19788"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>srandom_r()</TT
> shall function in the same
way as the interface <TT
CLASS="FUNCTION"
>srandom()</TT
>, except that
<TT
CLASS="FUNCTION"
>srandom_r()</TT
> shall
use the data in
<TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
> instead of the global random 
number generator state.</P
></DIV
><H1
><A
NAME="BASELIB-SSCANF"
></A
>sscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19799"
></A
><H2
>Name</H2
>sscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19802"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19807"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-STATFS-2"
></A
>statfs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19825"
></A
><H2
>Name</H2
>statfs&nbsp;--&nbsp;(deprecated)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19828"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19829"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/statfs.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>statfs</TT
></CODE
>(const char *<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, struct statfs *<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19838"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>statfs()</TT
> function returns information about a mounted 
file system.  The file system is identified by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>,
a path name of a file within the mounted filesystem.
The results are placed in the structure pointed to by</P
><P
>Fields that are undefined for a particular file system shall
be set to
<TT
CLASS="LITERAL"
>0</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Application developers should use the <TT
CLASS="FUNCTION"
>statvfs()</TT
> function
to obtain general file system information. Applications should only
use the <TT
CLASS="FUNCTION"
>statfs()</TT
> function if they must determine
the file system type, which need not be provided by 
<TT
CLASS="FUNCTION"
>statvfs()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19850"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>statfs()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> and set the fields of the
structure idenfitied by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> accordingly.
On error, the <TT
CLASS="FUNCTION"
>statfs()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set
<CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19859"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19862"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTDIR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A component of the path prefix of <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> is 
not a directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19867"
></A
><SPAN
STYLE="white-space: nowrap"
>ENAMETOOLONG</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>path</I
></TT
> is too long.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19872"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file referred to by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> does not exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19877"
></A
><SPAN
STYLE="white-space: nowrap"
>EACCES</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Search permission is denied for a component of the path prefix of 
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19882"
></A
><SPAN
STYLE="white-space: nowrap"
>ELOOP</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Too many symbolic links were encountered in translating 
<TT
CLASS="PARAMETER"
><I
>path</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19887"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> points to 
an invalid address.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19893"
></A
><SPAN
STYLE="white-space: nowrap"
>EIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An I/O error occurred while reading from or writing to the file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19897"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient kernel memory was available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19901"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOSYS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The filesystem <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> is on does not support 
<TT
CLASS="FUNCTION"
>statfs()</TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-STATFS64"
></A
>statfs64</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19911"
></A
><H2
>Name</H2
>statfs64&nbsp;--&nbsp;(deprecated)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19914"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19915"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/statfs.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>statfs64</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>, struct statfs64 *<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19924"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>statfs64()</TT
> function returns information about a mounted 
file system.  The file system is identified by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>,
a path name of a file within the mounted filesystem.
The results are placed in the structure pointed to by
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>statfs64()</TT
> is a large-file
version of the <TT
CLASS="FUNCTION"
>statfs()</TT
> function.</P
><P
>Fields that are undefined for a particular file system shall
be set to
<TT
CLASS="LITERAL"
>0</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Application developers should use the <TT
CLASS="FUNCTION"
>statvfs64()</TT
> function
to obtain general file system information. Applications should only
use the <TT
CLASS="FUNCTION"
>statfs64()</TT
> function if they must determine
the file system type, which need not be provided by 
<TT
CLASS="FUNCTION"
>statvfs64()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19940"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>statfs64()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> and set the fields of the
structure idenfitied by <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> accordingly.
On error, the <TT
CLASS="FUNCTION"
>statfs64()</TT
> function shall
return <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and set
<CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19949"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>fstatfs()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-STIME-2"
></A
>stime</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN19957"
></A
><H2
>Name</H2
>stime&nbsp;--&nbsp;set time</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19960"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN19963"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _SVID_SOURCE
#include &#60;time.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>stime</TT
></CODE
>(const time_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19971"
></A
><H2
>Description</H2
><P
>If the process has appropriate privilege, the <TT
CLASS="FUNCTION"
>stime()</TT
>
function shall set the system's idea of the time and date. 
Time, referenced by <TT
CLASS="PARAMETER"
><I
>t</I
></TT
>, is measured in seconds 
from the epoch (defined in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> as 00:00:00 UTC January 1, 1970).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19979"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>stime()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>stime()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> and
<CODE
CLASS="VARNAME"
>errno</CODE
> shall be set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN19987"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19990"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EPERM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process does not have appropriate privilege.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN19995"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>EINVAL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>t</I
></TT
> is a null pointer.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-STRCASESTR"
></A
>strcasestr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20005"
></A
><H2
>Name</H2
>strcasestr&nbsp;--&nbsp;locate a substring ignoring case</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20008"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20011"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strcasestr</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s1</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>s2</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20022"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strcasestr()</TT
> shall behave as 
<TT
CLASS="FUNCTION"
>strstr()</TT
>, 
except that it shall ignore the case of both strings.
The <TT
CLASS="FUNCTION"
>strcasestr()</TT
> function shall be locale aware;
that is <TT
CLASS="FUNCTION"
>strcasestr()</TT
> shall behave as if both
strings had been converted to lower case in the current locale
before the comparison is performed.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20031"
></A
><H2
>Return Value</H2
><P
>Upon successful completion, 
<TT
CLASS="FUNCTION"
>strcasestr()</TT
> shall return a pointer to the located
string or a null pointer if the string is not found. 
If <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
> points to a string
with zero length, the function shall return <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-STRERROR-R"
></A
>strerror_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20041"
></A
><H2
>Name</H2
>strerror_r&nbsp;--&nbsp;return string describing error number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20044"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20045"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strerror_r</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>errnum</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buf</I
></TT
></I
></TT
>, size_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>buflen</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20059"
></A
><H2
>Description</H2
><P
>In the source standard, <TT
CLASS="FUNCTION"
>strerror_r()</TT
> is implemented
as a macro causing it to behave as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
and is equivalent to the function <TT
CLASS="FUNCTION"
>__xpg_strerror_r()</TT
>.
If the macro is undefined, <TT
CLASS="FUNCTION"
>strerror_r()</TT
> from
the binary standard is used, with differences as described here.</P
><P
>The <TT
CLASS="FUNCTION"
>strerror_r()</TT
> function shall return a pointer to
the string corresponding to the error number <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>. 
The returned pointer may point within 
the buffer <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> (at most 
<TT
CLASS="PARAMETER"
><I
>buflen</I
></TT
> bytes).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20071"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>strerror_r()</TT
> shall return a pointer
to the generated message string (determined by the setting of the
<CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
> category in the current locale).
Otherwise, <TT
CLASS="FUNCTION"
>strerror_r()</TT
> shall return the string
corresponding to <SPAN
CLASS="RETURNVALUE"
>"Unknown error"</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20078"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>__xpg_strerror_r()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-STRPTIME-3"
></A
>strptime</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20088"
></A
><H2
>Name</H2
>strptime&nbsp;--&nbsp;parse a time string</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20091"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strptime()</TT
> shall behave as specified in the
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
> with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN20097"
></A
><H3
>Number of leading zeroes may be limited</H3
><P
>The <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
> specifies fields for which "leading zeros are
permitted but not required"; however, applications shall not expect to 
be able to supply more leading zeroes for these fields than would be 
implied by the range of the field. Implementations may choose to 
either match an input with excess leading zeroes, or treat this as a 
non-matching input.  For example, <CODE
CLASS="VARNAME"
>%j</CODE
> has a range of 
<TT
CLASS="LITERAL"
>001</TT
> to <TT
CLASS="LITERAL"
>366</TT
>, so <TT
CLASS="LITERAL"
>0</TT
>, 
<TT
CLASS="LITERAL"
>00</TT
>, <TT
CLASS="LITERAL"
>000</TT
>, <TT
CLASS="LITERAL"
>001</TT
>, 
and <TT
CLASS="LITERAL"
>045</TT
> are acceptable inputs, but inputs such as 
<TT
CLASS="LITERAL"
>0000</TT
>, <TT
CLASS="LITERAL"
>0366</TT
> and the like are not.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20112"
></A
><H2
>Rationale</H2
><P
><I
CLASS="EMPHASIS"
>glibc</I
> developers consider it appropriate behavior 
to forbid excess leading zeroes.  When trying to parse a given input
against several format strings, forbidding excess leading zeroes could
be helpful.  For example, if one matches <TT
CLASS="LITERAL"
>0011-12-26</TT
> 
against <TT
CLASS="LITERAL"
>%m-%d-%Y</TT
> and then against 
<TT
CLASS="LITERAL"
>%Y-%m-%d</TT
>, it seems useful for the first match to fail, 
as it would be perverse to parse that date as November 12, year 26.  
The second pattern parses it as December 26, year 11.</P
><P
>The <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
> is 
not explicit that an unlimited number of leading zeroes are required, 
although it may imply this. The <ACRONYM
CLASS="ACRONYM"
>LSB</ACRONYM
> explicitly 
allows implementations to have either behavior. Future versions of this 
standard may require implementations to forbid excess leading zeroes.</P
><P
>An Interpretation Request is
currently pending against <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> for this matter.</P
></DIV
><H1
><A
NAME="BASELIB-STRSEP-3"
></A
>strsep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20129"
></A
><H2
>Name</H2
>strsep&nbsp;--&nbsp;extract token from string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20132"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20135"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;string.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>strsep</TT
></CODE
>(char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>stringp</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>delim</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20146"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>strsep()</TT
> function shall find the first token
in the string referenced by the pointer <TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
>,
using the characters in <TT
CLASS="PARAMETER"
><I
>delim</I
></TT
> as delimiters.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> is <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, 
<TT
CLASS="FUNCTION"
>strsep()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>NULL</SPAN
> 
and do nothing else. </P
><P
>If <TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> is non-<SPAN
CLASS="TOKEN"
>NULL</SPAN
>, 
<TT
CLASS="FUNCTION"
>strsep()</TT
> shall find the first token in the 
string referenced by
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
>, where tokens are delimited by characters 
in the string <TT
CLASS="PARAMETER"
><I
>delim</I
></TT
>. This token shall be terminated 
with a <SPAN
CLASS="TOKEN"
>\0</SPAN
> character by overwriting the delimiter, and 
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> shall be updated to point past the token. In 
case no delimiter was found, the token is taken to be the entire string 
referenced by
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
>, and the location referenced by
<TT
CLASS="PARAMETER"
><I
>stringp</I
></TT
> is 
made <SPAN
CLASS="TOKEN"
>NULL</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20170"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>strsep()</TT
> shall return a pointer to the 
beginning of the token.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20174"
></A
><H2
>Notes</H2
><P
>The <TT
CLASS="FUNCTION"
>strsep()</TT
> function was introduced as a replacement for 
<TT
CLASS="FUNCTION"
>strtok()</TT
>, since the latter cannot handle empty 
fields. However, <TT
CLASS="FUNCTION"
>strtok()</TT
> conforms to 
<A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> and to <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> and hence is more portable.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20182"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>strtok()</TT
>, <TT
CLASS="FUNCTION"
>strtok_r()</TT
>. </P
></DIV
><H1
><A
NAME="BASELIB-STRTOQ-3"
></A
>strtoq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20191"
></A
><H2
>Name</H2
>strtoq&nbsp;--&nbsp;convert string value to a long or quad_t integer</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20194"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20197"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;limits.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long 
  <TT
CLASS="FUNCTION"
>strtoq</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20211"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>strtoq()</TT
> converts the string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> 
to a quadt value. The conversion is done according to the given base, which 
shall be between <TT
CLASS="LITERAL"
>2</TT
> and <TT
CLASS="LITERAL"
>36</TT
> inclusive, 
or be the special value <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> may begin with an arbitrary amount of white 
space (as determined by <TT
CLASS="FUNCTION"
>isspace()</TT
>), followed by a 
single optional <SPAN
CLASS="TOKEN"
>+</SPAN
> or <SPAN
CLASS="TOKEN"
>-</SPAN
> sign character. If 
<TT
CLASS="PARAMETER"
><I
>base</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
> or <TT
CLASS="LITERAL"
>16</TT
>, 
the string may then include a <SPAN
CLASS="TOKEN"
>0x</SPAN
> prefix, and the number will 
be read in base 16; otherwise, a <TT
CLASS="LITERAL"
>0</TT
> base is taken as 
10 (decimal), unless the next character is <TT
CLASS="LITERAL"
>0</TT
>, in which 
case it is taken as 8 (octal).</P
><P
>The remainder of the string is converted to a long value in the obvious 
manner, stopping at the first character which is not a valid digit in the 
given base. (In bases above 10, the letter <TT
CLASS="LITERAL"
>A</TT
> in either 
upper or lower case represents 10, <TT
CLASS="LITERAL"
>B</TT
> represents 11, and 
so forth, with <TT
CLASS="LITERAL"
>Z</TT
> representing 35.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20236"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>strtoq()</TT
> returns the result of the conversion, 
unless the value would underflow or overflow. If an underflow occurs, 
<TT
CLASS="FUNCTION"
>strtoq()</TT
> returns <CODE
CLASS="VARNAME"
>QUAD_MIN</CODE
>. If 
an overflow occurs, <TT
CLASS="FUNCTION"
>strtoq()</TT
> returns 
<CODE
CLASS="VARNAME"
>QUAD_MAX</CODE
>. In both cases, the global variable 
<CODE
CLASS="VARNAME"
>errno</CODE
> is set to <SPAN
CLASS="ERRORNAME"
>ERANGE</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20246"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN20249"
></A
><SPAN
STYLE="white-space: nowrap"
>ERANGE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The given string was out of range; the value converted has been clamped.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-STRTOUQ-3"
></A
>strtouq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20257"
></A
><H2
>Name</H2
>strtouq&nbsp;--&nbsp;convert a string to an unsigned long long</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20260"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20263"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;limits.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long 
  <TT
CLASS="FUNCTION"
>strtouq</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, char * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20277"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>strtouq()</TT
> converts the string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> 
to an <SPAN
CLASS="TYPE"
>unsigned long long</SPAN
>
value. The conversion is done according to the given base, which 
shall be between <TT
CLASS="LITERAL"
>2</TT
> and <TT
CLASS="LITERAL"
>36</TT
> inclusive, 
or be the special value <TT
CLASS="LITERAL"
>0</TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> may begin with an arbitrary amount of white 
space (as determined by <TT
CLASS="FUNCTION"
>isspace()</TT
>), followed by a 
single optional <SPAN
CLASS="TOKEN"
>+</SPAN
> or <SPAN
CLASS="TOKEN"
>-</SPAN
> sign character. If 
<TT
CLASS="PARAMETER"
><I
>base</I
></TT
> is <TT
CLASS="LITERAL"
>0</TT
> or <TT
CLASS="LITERAL"
>16</TT
>, 
the string may then include a <SPAN
CLASS="TOKEN"
>0x</SPAN
> prefix, and the number will 
be read in base 16; otherwise, a <TT
CLASS="LITERAL"
>0</TT
> base is taken as 
10 (decimal), unless the next character is <TT
CLASS="LITERAL"
>0</TT
>, in which 
case it is taken as 8 (octal).</P
><P
>The remainder of the string is converted to an unsigned long value in the 
obvious manner, stopping at the end of the string or at the first character 
that does not produce a valid digit in the given base. (In bases above 10, 
the letter <TT
CLASS="LITERAL"
>A</TT
> in either upper or lower case represents 10, 
<TT
CLASS="LITERAL"
>B</TT
> represents 11, and so forth, with <TT
CLASS="LITERAL"
>Z</TT
> 
representing 35.)</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20303"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>strtouq()</TT
> returns either the result of 
the conversion or, if there was a leading minus sign, the negation of 
the result of the conversion, unless the original (non-negated) value 
would overflow. In the case of an overflow the function returns 
<CODE
CLASS="VARNAME"
>UQUAD_MAX</CODE
> and the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> 
is set to <SPAN
CLASS="ERRORNAME"
>ERANGE</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20310"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN20313"
></A
><SPAN
STYLE="white-space: nowrap"
>ERANGE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The given string was out of range; the value converted has been clamped.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-SVC-REGISTER-3"
></A
>svc_register</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20321"
></A
><H2
>Name</H2
>svc_register&nbsp;--&nbsp;register Remote Procedure Call interface</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20324"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20327"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/rpc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t
  <TT
CLASS="FUNCTION"
>svc_register</TT
></CODE
>(SVCXPRT *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>xprt</I
></TT
></I
></TT
>, rpcprog_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>prognum</I
></TT
></I
></TT
>, rpcvers_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>versnum</I
></TT
></I
></TT
>, __dispatch_fn_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>dispatch</I
></TT
></I
></TT
>, rpcprot_t
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>protocol</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20347"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>svc_register()</TT
> function shall associate
the program identified by <TT
CLASS="PARAMETER"
><I
>prognum</I
></TT
> at version
<TT
CLASS="PARAMETER"
><I
>versnum</I
></TT
>
with the service dispatch procedure, <TT
CLASS="PARAMETER"
><I
>dispatch</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> is zero, the service is not registered with the
<CODE
CLASS="VARNAME"
>portmap</CODE
> service.  If <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
> is
non-zero, then a mapping of the triple [<TT
CLASS="PARAMETER"
><I
>prognum</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>versnum</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
>] to 
<CODE
CLASS="VARNAME"
>xprt-&#62;xp_port</CODE
> is established with the local 
<CODE
CLASS="VARNAME"
>portmap</CODE
> service.  The
procedure <TT
CLASS="PARAMETER"
><I
>dispatch</I
></TT
> has the following form:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20365"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>dispatch</TT
></CODE
>(struct svc_req *
<TT
CLASS="PARAMETER"
><I
>request</I
></TT
>, SVCXPRT *
<TT
CLASS="PARAMETER"
><I
>xprt</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20373"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>svc_register()</TT
> returns 
<SPAN
CLASS="RETURNVALUE"
>1</SPAN
> if it succeeds, and 
<SPAN
CLASS="RETURNVALUE"
>zero</SPAN
> 
otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-SVC-RUN-3"
></A
>svc_run</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20383"
></A
><H2
>Name</H2
>svc_run&nbsp;--&nbsp;waits for RPC requests to arrive and calls service procedure</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20386"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20389"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/svc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
  <TT
CLASS="FUNCTION"
>svc_run</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20395"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>svc_run()</TT
> function shall wait for RPC
requests to arrive, read and unpack each request, and dispatch
it to the appropriate registered handler.
Under normal conditions, <TT
CLASS="FUNCTION"
>svc_run()</TT
> shall not return;
it shall only return if serious errors occur that prevent further
processing.</P
></DIV
><H1
><A
NAME="BASELIB-SVC-SENDREPLY-3"
></A
>svc_sendreply</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20406"
></A
><H2
>Name</H2
>svc_sendreply&nbsp;--&nbsp;called by RPC service's dispatch routine</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20409"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20412"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>bool_t <TT
CLASS="FUNCTION"
>svc_sendreply</TT
></CODE
>(SVCXPRT *<TT
CLASS="PARAMETER"
><I
>xprt</I
></TT
>, xdrproc_t <TT
CLASS="PARAMETER"
><I
>outproc</I
></TT
>, caddr_t <TT
CLASS="PARAMETER"
><I
>out</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20422"
></A
><H2
>Description</H2
><P
>Called by an RPC service's dispatch routine to send the  results of a remote procedure call.  
The parameter <TT
CLASS="PARAMETER"
><I
>xprt</I
></TT
> is the request's associated transport handle; 
<TT
CLASS="PARAMETER"
><I
>outproc</I
></TT
> is the XDR routine which is used  to  encode  the  results;  
and  <TT
CLASS="PARAMETER"
><I
>out</I
></TT
>  is the address of the results.  
This routine returns one if it succeeds,  zero  otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-SVCTCP-CREATE-3"
></A
>svctcp_create</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20432"
></A
><H2
>Name</H2
>svctcp_create&nbsp;--&nbsp;create a TCP/IP-based RPC service transport</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20435"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20438"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/rpc.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>SVCXPRT *
  <TT
CLASS="FUNCTION"
>svctcp_create</TT
></CODE
>(int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>sock</I
></TT
></I
></TT
>, u_int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>send_buf_size</I
></TT
></I
></TT
>, u_int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>recv_buf_size</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20452"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>svctcp_create()</TT
> creates a TCP/IP-based RPC service transport, 
to which it returns a pointer.  The transport is associated with the socket
<TT
CLASS="PARAMETER"
><I
>sock</I
></TT
>, which may be <CODE
CLASS="VARNAME"
>RPC_ANYSOCK</CODE
>, in 
which case a new socket is created.  If the socket is not bound to a local TCP
port, then this routine binds it to an arbitrary port.  Upon completion, 
<CODE
CLASS="VARNAME"
>xprt-&#62;xp_sock</CODE
> is the transport's socket descriptor,
and <CODE
CLASS="VARNAME"
>xprt-&#62;xp_port</CODE
> is the transport's port number.  Since 
TCP-based RPC uses buffered I/O, users may specify the size of buffers;
values of zero choose suitable defaults.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20462"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>svctcp_create()</TT
> returns NULL if it fails, or a pointer to 
the RPC service transport otherwise.</P
></DIV
><H1
><A
NAME="BASELIB-SVCUDP-CREATE-3"
></A
>svcudp_create</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20470"
></A
><H2
>Name</H2
>svcudp_create&nbsp;--&nbsp;		create a UDP-based RPC service transport
		</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20473"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20474"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>SVCXPRT *</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="FUNCTION"
>svcudp_create</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>sock</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20481"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>svcudp_create()</TT
> function shall
create a UDP/IP-based RPC service transport, and return
a pointer to its descriptor. The transport is associated
with the socket <TT
CLASS="PARAMETER"
><I
>sock</I
></TT
>, which may be
<CODE
CLASS="CONSTANT"
>RPC_ANYSOCK</CODE
>, in which case a new socket shall
be created. If the socket is not bound to a local UDP port, then
<TT
CLASS="FUNCTION"
>svcudp_create()</TT
> shall bind it to an arbitrary port.</P
><P
>If <TT
CLASS="FUNCTION"
>svcudp_create()</TT
> returns successfully, then the
<CODE
CLASS="STRUCTFIELD"
>xp_sock</CODE
> field in the result shall be the
transport's socket descriptor, and the <CODE
CLASS="STRUCTFIELD"
>xp_port</CODE
>
field shall be the transport's port number.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20492"
></A
><H2
>Return Value</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>svcudp_create()</TT
> shall
return a pointer to a RPC service transport; otherwise, a null pointer
shall be returned.</P
></DIV
><H1
><A
NAME="BASELIB-SWSCANF"
></A
>swscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20500"
></A
><H2
>Name</H2
>swscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20503"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20508"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-SYSCONF"
></A
>sysconf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="NAME"
></A
><H2
>Name</H2
>sysconf&nbsp;--&nbsp;Get configuration information at runtime</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="SYNOPSIS"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20530"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unistd.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long <TT
CLASS="FUNCTION"
>sysconf</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="DESCRIPTION"
></A
><H2
>DESCRIPTION</H2
><P
><TT
CLASS="FUNCTION"
>sysconf()</TT
> is as specified in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="EXTRA.VARIABLES"
></A
><H3
>Extra Variables</H3
><P
>These additional values extend the list in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><I
CLASS="EMPHASIS"
></I
> - <I
CLASS="EMPHASIS"
>_SC_PHYS_PAGES</I
></DT
><DD
><P
>The number of pages of physical memory.</P
></DD
><DT
><I
CLASS="EMPHASIS"
></I
> - <I
CLASS="EMPHASIS"
>_SC_AVPHYS_PAGES</I
></DT
><DD
><P
>The number of currently available pages of physical memory.</P
></DD
><DT
><I
CLASS="EMPHASIS"
></I
> - <I
CLASS="EMPHASIS"
>_SC_NPROCESSORS_CONF</I
></DT
><DD
><P
>The number of processors configured.</P
></DD
><DT
><I
CLASS="EMPHASIS"
></I
> - <I
CLASS="EMPHASIS"
>_SC_NPROCESSORS_ONLN</I
></DT
><DD
><P
>The number of processors currently online (available).</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="EXTRA.VERSIONS"
></A
><H3
>Extra Versions</H3
><P
>While this specification only requires conformance with
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, implementations are not constrained
from moving on and claiming conformance with a subsequent edition,
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.  Thus for run-time checks using
<TT
CLASS="FUNCTION"
>sysconf()</TT
>, the wording is amended to allow
return values of 
<TT
CLASS="LITERAL"
>0</TT
>,
<TT
CLASS="LITERAL"
>-1</TT
>,
<TT
CLASS="LITERAL"
>200112L</TT
> or
<TT
CLASS="LITERAL"
>200809L</TT
> where formerly
<TT
CLASS="LITERAL"
>200809L</TT
> was not listed as allowed.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-SYSINFO-1"
></A
>sysinfo</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20586"
></A
><H2
>Name</H2
>sysinfo&nbsp;--&nbsp;return system information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20591"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20592"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/sysinfo.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>sysinfo</TT
></CODE
>(struct sysinfo *<TT
CLASS="PARAMETER"
><I
>info</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20599"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>sysinfo()</TT
> provides a way to obtain
certain system statistics.  Statistics are written into
a <TT
CLASS="STRUCTNAME"
>sysinfo</TT
> structure pointed to by
<TT
CLASS="PARAMETER"
><I
>info</I
></TT
>. Elements which take a size are sized in
units indicated by the value of the <CODE
CLASS="STRUCTFIELD"
>mem_unit</CODE
>
member of <TT
CLASS="PARAMETER"
><I
>info</I
></TT
>.  The other
members have traditional meanings as indicated in Data Definitions,
but are not formally part of this specification.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20607"
></A
><H2
>Return Value</H2
><P
>Returns zero on success.  On error, <TT
CLASS="LITERAL"
>-1</TT
> is
returned and <CODE
CLASS="VARNAME"
>errno</CODE
> is set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20612"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN20615"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>info</I
></TT
> parameter does not point to
a valid <TT
CLASS="STRUCTNAME"
>sysinfo</TT
> structure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-SYSTEM-3"
></A
>system</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20625"
></A
><H2
>Name</H2
>system&nbsp;--&nbsp;execute a shell command</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20628"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20631"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>system</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20639"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>system()</TT
> function shall behave as described in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20646"
></A
><H2
>Notes</H2
><P
>The fact that <TT
CLASS="FUNCTION"
>system()</TT
> ignores interrupts is often 
not what a program wants. <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
describes some of the consequences; an 
additional consequence is that a program calling <TT
CLASS="FUNCTION"
>system()</TT
> 
from a loop cannot be reliably interrupted. Many programs will want to use 
the <TT
CLASS="FUNCTION"
>exec()</TT
> family of functions instead.</P
><P
>Do not use <TT
CLASS="FUNCTION"
>system()</TT
> from a program with 
<CODE
CLASS="VARNAME"
>suid</CODE
> or <CODE
CLASS="VARNAME"
>sgid</CODE
> privileges, 
because unexpected values for some environment variables might be used 
to subvert system integrity. Use the <TT
CLASS="FUNCTION"
>exec()</TT
>
family of functions instead, but not <TT
CLASS="FUNCTION"
>execlp()</TT
>
or <TT
CLASS="FUNCTION"
>execvp()</TT
>. <TT
CLASS="FUNCTION"
>system()</TT
> will 
not, in fact, work properly from programs with <CODE
CLASS="VARNAME"
>suid</CODE
> 
or <CODE
CLASS="VARNAME"
>sgid</CODE
> privileges on systems on which 
<TT
CLASS="FILENAME"
>/bin/sh</TT
> is <B
CLASS="COMMAND"
>bash</B
> version 2, 
since <B
CLASS="COMMAND"
>bash</B
> 2 drops privileges on startup. 
(Debian uses a modified <B
CLASS="COMMAND"
>bash</B
> which does not do 
this when invoked as <B
CLASS="COMMAND"
>sh</B
>.)</P
><P
>The check for the availability of <TT
CLASS="FILENAME"
>/bin/sh</TT
> 
is not actually performed; it is always assumed to be available. 
<A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> specifies the check, but 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> specifies that the return shall 
always be nonzero, since a system without the 
shell is not conforming, and it is this that is implemented.</P
><P
>It is possible for the shell command to return 
<SPAN
CLASS="RETURNVALUE"
>127</SPAN
>, so that code is not a sure 
indication that the <TT
CLASS="FUNCTION"
>execve()</TT
> call failed; check 
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
> to make sure.</P
></DIV
><H1
><A
NAME="BASELIB-TEXTDOMAIN"
></A
>textdomain</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20680"
></A
><H2
>Name</H2
>textdomain&nbsp;--&nbsp;set the current default message domain</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20683"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20686"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;libintl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
  <TT
CLASS="FUNCTION"
>textdomain</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>domainname</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20694"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>textdomain()</TT
> function shall set
the current default message 
domain to <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
>. 
Subsequent calls to <TT
CLASS="FUNCTION"
>gettext()</TT
> and 
<TT
CLASS="FUNCTION"
>ngettext()</TT
> use the default message domain.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, 
the default message domain shall not be altered.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>domainname</I
></TT
> is "", <TT
CLASS="FUNCTION"
>textdomain()</TT
>
shall reset the default domain to the system default of "messages". </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20709"
></A
><H2
>Return</H2
><P
>On success, <TT
CLASS="FUNCTION"
>textdomain()</TT
> shall return the currently 
selected domain. Otherwise, a null pointer shall be returned, and
<CODE
CLASS="VARNAME"
>errno</CODE
> is set to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20714"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN20717"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>ENOMEM</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficent memory available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-UNLINK-3"
></A
>unlink</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20726"
></A
><H2
>Name</H2
>unlink&nbsp;--&nbsp;remove a directory entry</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20729"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20730"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>unlink</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20737"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>unlink()</TT
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
but with differences as listed below.</P
><P
>See also <A
HREF="#EXEC-LINK-UNLINK"
>Section 18.1, Additional behaviors: unlink/link on directory</A
>.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN20744"
></A
><H3
>May return <SPAN
CLASS="ERRORNAME"
>EISDIR</SPAN
> on directories</H3
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> specifies a directory, the
implementation may return <SPAN
CLASS="ERRORNAME"
>EISDIR</SPAN
> 
instead of <SPAN
CLASS="ERRORNAME"
>EPERM</SPAN
> as specified by
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The Linux kernel has deliberately chosen <SPAN
CLASS="ERRORNAME"
>EISDIR</SPAN
> 
for this case and does not expect to change.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="BASELIB-UTMPNAME-3"
></A
>utmpname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20760"
></A
><H2
>Name</H2
>utmpname&nbsp;--&nbsp;set user accounting database</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20763"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20764"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>utmpname</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>dbname</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20771"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>utmpname()</TT
> function shall cause the user
accounting database
used by the <TT
CLASS="FUNCTION"
>getutent()</TT
>, <TT
CLASS="FUNCTION"
>getutent_r()</TT
>, <TT
CLASS="FUNCTION"
>getutxent()</TT
>, <TT
CLASS="FUNCTION"
>getutxid()</TT
>, <TT
CLASS="FUNCTION"
>getutxline()</TT
>, and <TT
CLASS="FUNCTION"
>pututxline()</TT
> functions to be that named by <TT
CLASS="PARAMETER"
><I
>dbname</I
></TT
>,
instead of the system default database. See
<A
HREF="#FHS-USER-ACCOUNTING-DBS"
>Section 18.3</A
> for further information.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not specify the format of the user accounting database,
nor the names of the file or files that may contain it. </P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20794"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20797"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="BASELIB-VASPRINTF"
></A
>vasprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20804"
></A
><H2
>Name</H2
>vasprintf&nbsp;--&nbsp;write formatted output to a dynamically allocated string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20807"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20810"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdarg.h&#62;
#include &#60;stdio.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>vasprintf</TT
></CODE
>(char * * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ptr</I
></TT
></I
></TT
>, const char * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
></I
></TT
>, va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20824"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>vasprintf()</TT
> function shall write
formatted output to a 
dynamically allocated string, and store
the address of that string in the location
referenced by <TT
CLASS="PARAMETER"
><I
>ptr</I
></TT
>.
It shall behave as <TT
CLASS="FUNCTION"
>asprintf()</TT
>,
except that instead of being called with a variable number
of arguments, it is called with an argument list as defined
by <TT
CLASS="FILENAME"
>&#60;stdarg.h&#62;</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20833"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20837"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>fprintf()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-VERRX-3"
></A
>verrx</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20845"
></A
><H2
>Name</H2
>verrx&nbsp;--&nbsp;display formatted error message and exit</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN20848"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN20849"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdarg.h&#62;
#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>verrx</TT
>
 </CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>eval</I
></TT
></I
></TT
>
 , const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>
 , va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>args</I
></TT
></I
></TT
>
 );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20863"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>verrx()</TT
> shall behave as <TT
CLASS="FUNCTION"
>errx()</TT
>
except that instead of being called with a variable number
of arguments, it is called with an argument list as defined by
<TT
CLASS="FILENAME"
>&#60;stdarg.h&#62;</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>verrx()</TT
> does not return, but exits with the value 
of <TT
CLASS="PARAMETER"
><I
>eval</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20872"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20875"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-VFSCANF"
></A
>vfscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20882"
></A
><H2
>Name</H2
>vfscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20885"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20890"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VFWSCANF"
></A
>vfwscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20908"
></A
><H2
>Name</H2
>vfwscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20911"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20916"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSCANF"
></A
>vscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20934"
></A
><H2
>Name</H2
>vscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20937"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20942"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSSCANF"
></A
>vsscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20960"
></A
><H2
>Name</H2
>vsscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20963"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20968"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSWSCANF"
></A
>vswscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN20986"
></A
><H2
>Name</H2
>vswscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20989"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN20994"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-VSYSLOG-3"
></A
>vsyslog</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21012"
></A
><H2
>Name</H2
>vsyslog&nbsp;--&nbsp;log to system log</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21015"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21016"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;stdarg.h&#62;
#include &#60;syslog.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>vsyslog</TT
></CODE
>(int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>priority</I
></TT
></I
></TT
>, char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>message</I
></TT
></I
></TT
>, va_list 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arglist</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21030"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>vsyslog()</TT
> function
is identical to <TT
CLASS="FUNCTION"
>syslog()</TT
> 
as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that <TT
CLASS="PARAMETER"
><I
>arglist</I
></TT
> 
(as defined by <TT
CLASS="FILENAME"
>stdarg.h</TT
>) replaces the variable 
number of arguments.</P
></DIV
><H1
><A
NAME="BASELIB-VWSCANF"
></A
>vwscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21042"
></A
><H2
>Name</H2
>vwscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21045"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21050"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-WAIT4-2"
></A
>wait4</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21068"
></A
><H2
>Name</H2
>wait4&nbsp;--&nbsp;wait for process termination, BSD style</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21071"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21074"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/types.h&#62;
#include &#60;sys/resource.h&#62;
#include &#60;sys/wait.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>pid_t 
  <TT
CLASS="FUNCTION"
>wait4</TT
></CODE
>(pid_t 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pid</I
></TT
></I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>status</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
></I
></TT
>, struct rusage *
  <TT
CLASS="PARAMETER"
><I
>rusage</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21090"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>wait4()</TT
> suspends execution of the current process 
until a child (as specified by <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>) has exited, 
or until a signal is delivered whose action is to terminate the 
current process or to call a signal handling function. If a child (as 
requested by <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>) has already exited by the 
time of the call (a so-called "zombie" process), the function returns 
immediately. Any system resources used by the child are freed.</P
><P
>The value of <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
> can be one of:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21101"
></A
><SPAN
STYLE="white-space: nowrap"
>&#60; -1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for any child process whose process group ID is equal to the 
absolute value of <TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21106"
></A
><SPAN
STYLE="white-space: nowrap"
>-1</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for any child process; this is equivalent to calling 
<TT
CLASS="FUNCTION"
>wait3()</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21111"
></A
><SPAN
STYLE="white-space: nowrap"
>0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for any child process whose process group ID is equal to that of 
the calling process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21115"
></A
><SPAN
STYLE="white-space: nowrap"
>&#62; 0</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>wait for the child whose process ID is equal to the value of 
<TT
CLASS="PARAMETER"
><I
>pid</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
><P
>The value of options is a bitwise or of zero or more of the following 
constants:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21122"
></A
><SPAN
STYLE="white-space: nowrap"
>WNOHANG</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>return immediately if no child is there to be waited for.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21126"
></A
><SPAN
STYLE="white-space: nowrap"
>WUNTRACED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>return for children that are stopped, and whose status has not been 
reported.</P
></TD
></TR
></TBODY
></TABLE
><P
>If status is not <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, <TT
CLASS="FUNCTION"
>wait4()</TT
> 
stores status information in the location 
<TT
CLASS="PARAMETER"
><I
>status</I
></TT
>. This status can be evaluated with the 
following macros:
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These macros take the <CODE
CLASS="VARNAME"
>status</CODE
> value (an 
<TT
CLASS="LITERAL"
>int</TT
>) as an argument -- not a pointer to the 
value!</P
></BLOCKQUOTE
></DIV
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21139"
></A
><SPAN
STYLE="white-space: nowrap"
>WIFEXITED(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is nonzero if the child exited normally.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21143"
></A
><SPAN
STYLE="white-space: nowrap"
>WEXITSTATUS(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>evaluates to the least significant eight bits of the return code of 
the child that terminated, which may have been set as the argument to 
a call to <TT
CLASS="FUNCTION"
>exit()</TT
> or as the argument for a return 
statement in the main program. This macro can only be evaluated if 
<TT
CLASS="FUNCTION"
>WIFEXITED()</TT
> returned nonzero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21149"
></A
><SPAN
STYLE="white-space: nowrap"
>WIFSIGNALED(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns true if the child process exited because of a signal that was 
not caught.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21153"
></A
><SPAN
STYLE="white-space: nowrap"
>WTERMSIG(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns the number of the signal that caused the child process to 
terminate. This macro can only be evaluated if 
<TT
CLASS="FUNCTION"
>WIFSIGNALED()</TT
> returned nonzero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21158"
></A
><SPAN
STYLE="white-space: nowrap"
>WIFSTOPPED(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns true if the child process that caused the return is currently 
stopped; this is only possible if the call was done using 
<TT
CLASS="FUNCTION"
>WUNTRACED()</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21163"
></A
><SPAN
STYLE="white-space: nowrap"
>WSTOPSIG(status)</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>returns the number of the signal that caused the child to stop. This 
macro can only be evaluated if <TT
CLASS="FUNCTION"
>WIFSTOPPED()</TT
> 
returned nonzero.</P
></TD
></TR
></TBODY
></TABLE
><P
>If <TT
CLASS="PARAMETER"
><I
>rusage</I
></TT
> is not <SPAN
CLASS="TOKEN"
>NULL</SPAN
>, the 
struct <TT
CLASS="STRUCTNAME"
>rusage</TT
> (as defined in 
<TT
CLASS="FILENAME"
>sys/resource.h</TT
>) that it points to will be filled 
with accounting information. See <TT
CLASS="FUNCTION"
>getrusage()</TT
> 
for details.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21174"
></A
><H2
>Return Value</H2
><P
>On success, the process ID of the child that exited is returned. On 
error, <SPAN
CLASS="RETURNVALUE"
>-1</SPAN
> is returned (in particular, when 
no unwaited-for child processes of the specified kind exist), or 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
> if <TT
CLASS="FUNCTION"
>WNOHANG()</TT
> was used 
and no child was available yet. In the latter two cases, the global 
variable <CODE
CLASS="VARNAME"
>errno</CODE
> is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21181"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21184"
></A
><SPAN
STYLE="white-space: nowrap"
>ECHILD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No unwaited-for child process as specified does exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN21188"
></A
><SPAN
STYLE="white-space: nowrap"
>ERESTARTSYS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A <TT
CLASS="FUNCTION"
>WNOHANG()</TT
> was not set and an unblocked signal or
a <CODE
CLASS="VARNAME"
>SIGCHILD</CODE
> was caught. This error is returned by 
the system call. The library interface is not allowed to return 
<SPAN
CLASS="ERRORNAME"
>ERESTARTSYS</SPAN
>, but will return
<SPAN
CLASS="ERRORNAME"
>EINTR</SPAN
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-WARN-3"
></A
>warn</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21200"
></A
><H2
>Name</H2
>warn&nbsp;--&nbsp;formatted error messages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21203"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21206"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>warn</TT
>
 </CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>
 , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21215"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>warn()</TT
> function
shall display a formatted error message on the standard error stream.
The output shall consist of the last component of the program name, a colon
character, and a space character. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is non-NULL,
it shall be used as a format string for the <TT
CLASS="FUNCTION"
>printf()</TT
>
family of functions, and the formatted message, a
colon character, and a space are written to <CODE
CLASS="VARNAME"
>stderr</CODE
>.
Finally, the error message
string affiliated with the current value of the global variable 
<CODE
CLASS="VARNAME"
>errno</CODE
> shall be
written to <CODE
CLASS="VARNAME"
>stderr</CODE
>, followed by a newline character.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21226"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21229"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-WARNX-3"
></A
>warnx</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21236"
></A
><H2
>Name</H2
>warnx&nbsp;--&nbsp;formatted error messages</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21239"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21240"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;err.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>warnx</TT
>
 </CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fmt</I
></TT
></I
></TT
>
  , ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21249"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>warnx()</TT
> function shall display a 
formatted error message on the standard error stream. 
The last component of the program name, a colon 
character, and a space shall be output. If <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
> is 
non-<TT
CLASS="LITERAL"
>NULL</TT
>, it shall be used as the format string
for the <TT
CLASS="FUNCTION"
>printf()</TT
> family of functions, and
the formatted error message, a colon character, and a space shall be output.
The output shall be followed by a newline character.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21256"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21259"
></A
><H2
>Errors</H2
><P
>None.</P
></DIV
><H1
><A
NAME="BASELIB-WCSTOQ"
></A
>wcstoq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21266"
></A
><H2
>Name</H2
>wcstoq&nbsp;--&nbsp;convert wide string to long long int representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21269"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21272"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long int 
  <TT
CLASS="FUNCTION"
>wcstoq</TT
></CODE
>(const wchar_t * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t ** restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21286"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>wcstoq()</TT
> function shall convert
the initial portion of the wide 
string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> to <TT
CLASS="LITERAL"
>long long int</TT
> 
representation. It is identical to <TT
CLASS="FUNCTION"
>wcstoll()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21295"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoll()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21299"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoll()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-WCSTOUQ"
></A
>wcstouq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21307"
></A
><H2
>Name</H2
>wcstouq&nbsp;--&nbsp;convert wide string to unsigned long long int representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21310"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21313"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;wchar.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long 
  <TT
CLASS="FUNCTION"
>wcstouq</TT
></CODE
>(const wchar_t * restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>nptr</I
></TT
></I
></TT
>, wchar_t ** restrict 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>endptr</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21327"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>wcstouq()</TT
> function shall convert
the initial portion of the wide 
string <TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
> to <TT
CLASS="LITERAL"
>unsigned long long 
int</TT
> representation.
It is identical to <TT
CLASS="FUNCTION"
>wcstoull()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21336"
></A
><H2
>Return Value</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoull()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21340"
></A
><H2
>Errors</H2
><P
>Refer to <TT
CLASS="FUNCTION"
>wcstoull()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-WSCANF"
></A
>wscanf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21348"
></A
><H2
>Name</H2
>wscanf&nbsp;--&nbsp;convert formatted input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21351"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scanf()</TT
> family of functions shall behave as
described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21356"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="LITERAL"
>%s</TT
>, 
<TT
CLASS="LITERAL"
>%S</TT
> and 
<TT
CLASS="LITERAL"
>%[</TT
> conversion specifiers shall accept an 
option length modifier
<TT
CLASS="LITERAL"
>a</TT
>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>ENOMEM</SPAN
> and a 
conversion error results.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This directly conflicts with the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> usage of
<TT
CLASS="LITERAL"
>%a</TT
> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <TT
CLASS="LITERAL"
>"%aseconds"</TT
> will have a different
meaning on an LSB conforming system.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="BASELIB-XDR-U-INT-3"
></A
>xdr_u_int</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21374"
></A
><H2
>Name</H2
>xdr_u_int&nbsp;--&nbsp;library routines for external data representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21377"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21380"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>xdr_u_int</TT
></CODE
>(XDR * 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>xdrs</I
></TT
></I
></TT
>, unsigned int *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>up</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21390"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>xdr_u_int()</TT
> is a filter primitive that translates between
C unsigned integers and their external representations.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21396"
></A
><H2
>Return Value</H2
><P
>On success, <SPAN
CLASS="RETURNVALUE"
>1</SPAN
> is returned. 
On error, <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> is returned.</P
></DIV
><H1
><A
NAME="BASELIB-XDRSTDIO-CREATE-3"
></A
>xdrstdio_create</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN21405"
></A
><H2
>Name</H2
>xdrstdio_create&nbsp;--&nbsp;library routines for external data representation</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN21408"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN21409"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;rpc/xdr.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>xdrstdio_create</TT
></CODE
>(XDR *
<TT
CLASS="PARAMETER"
><I
>xdrs</I
></TT
>, FILE *
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, enum xdr_op
<TT
CLASS="PARAMETER"
><I
>op</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21420"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>xdrstdio_create()</TT
> function
shall initialize the XDR stream object referred to by <TT
CLASS="PARAMETER"
><I
>xdrs</I
></TT
>.
The XDR stream data shall be written to, or read from, the standard I/O stream associated
with <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>. If the operation <TT
CLASS="PARAMETER"
><I
>op</I
></TT
> is 
<TT
CLASS="SYMBOL"
>XDR_ENCODE</TT
>, encoded data shall be written to <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>op</I
></TT
> is <TT
CLASS="SYMBOL"
>XDR_DECODE</TT
>, encoded data shall be read from 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>op</I
></TT
> is <TT
CLASS="SYMBOL"
>XDR_FREE</TT
>, 
the XDR stream object may be used to deallocate storage allocated by a previous <TT
CLASS="SYMBOL"
>XDR_DECODE</TT
>.</P
><P
>The associated destroy function shall flush the <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> I/O stream, but not close
it.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN21439"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBM"
>14.6. Interfaces for libm</A
></H2
><P
><A
HREF="#LIB-LIBM-DEF"
>Table 14-38</A
> defines the library name and shared object name
for the libm library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBM-DEF"
></A
><P
><B
>Table 14-38. libm Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libm</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>See architecture specific part.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBM.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBM.2"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBM.3"
></A
>[SUSv4] <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN21464"
>14.6.1. Math</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN21467"
>14.6.1.1. Interfaces for Math</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Math specified in <A
HREF="#TBL-LIBM-MATH-INTS"
>Table 14-39</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBM-MATH-INTS"
></A
><P
><B
>Table 14-39. libm - Math Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__finite <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>__finitef <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>__finitel <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>__fpclassify <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fpclassifyf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>__signbit <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>__signbitf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>acos <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acosf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>acosh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>acoshf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>acoshl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acosl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>asin <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>asinf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>asinh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asinhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>asinhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>asinl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atan <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atan2 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atan2f <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atan2l <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atanf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atanh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atanhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atanhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>atanl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cabs <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cabsf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cabsl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cacos <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacosf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cacosh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cacoshf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cacoshl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacosl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>carg <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cargf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cargl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>casin <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>casinf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>casinh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>casinhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>casinhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>casinl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>catan <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>catanf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catanh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>catanhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>catanhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>catanl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cbrt <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cbrtf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cbrtl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ccos <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ccosf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ccosh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ccoshf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ccoshl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ccosl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ceil <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ceilf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ceill <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cexp <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cexpf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cexpl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cimag <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cimagf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cimagl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>clog <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>clog10 <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>clog10f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>clog10l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>clogf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>clogl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>conj <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>conjf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>conjl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>copysign <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>copysignf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>copysignl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cos <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cosf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cosh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>coshf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>coshl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cosl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cpow <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cpowf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cpowl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cproj <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cprojf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>cprojl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>creal <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>crealf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>creall <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csin <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csinf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csinh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>csinhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csinhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csinl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csqrt <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>csqrtf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>csqrtl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ctan <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ctanf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ctanh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ctanhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ctanhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ctanl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>drem <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>dremf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>dreml <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>erf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>erfc <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>erfcf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>erfcl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>erff <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>erfl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>exp <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>exp10 <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>exp10f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>exp10l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>exp2 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>exp2f <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>expf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>expl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>expm1 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>expm1f <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>expm1l <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fabs <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fabsf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fabsl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fdim <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fdimf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fdiml <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>feclearexcept <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fedisableexcept <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>feenableexcept <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>fegetenv <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fegetexcept <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>fegetexceptflag <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fegetround <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>feholdexcept <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>feraiseexcept <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fesetenv <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fesetexceptflag <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fesetround <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fetestexcept <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>feupdateenv <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>finite <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>finitef <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>finitel <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>floor <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>floorf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>floorl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fma <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fmaf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fmal <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fmax <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fmaxf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fmaxl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fmin <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fminf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fminl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fmod <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fmodf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>fmodl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>frexp <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>frexpf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>frexpl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>gamma <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>gammaf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>gammal <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>hypot <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>hypotf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>hypotl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ilogb <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ilogbf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ilogbl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>j0 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>j0f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>j0l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>j1 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>j1f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>j1l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>jn <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>jnf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>jnl <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>ldexp <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ldexpf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>ldexpl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lgamma <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lgamma_r <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>lgammaf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lgammaf_r <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>lgammal <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lgammal_r <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>llrint <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>llrintf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>llrintl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>llround <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>llroundf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>llroundl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log10 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>log10f <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log10l <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log1p <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log1pf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>log1pl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log2 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log2f <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>log2l <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>logb <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>logbf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>logbl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>logf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>logl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lrint <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lrintf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lrintl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>lround <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lroundf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>lroundl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>matherr <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>modf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>modff <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>modfl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nan <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>nanf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nanl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nearbyint <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nearbyintf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>nearbyintl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nextafter <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nextafterf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nextafterl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>nexttoward <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nexttowardf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>nexttowardl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>pow <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pow10 <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>pow10f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>pow10l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>powf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>powl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>remainder <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>remainderf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>remainderl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>remquo <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>remquof <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>remquol <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>rint <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>rintf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>rintl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>round <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>roundf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>roundl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>scalb <A
HREF="#REFSTD.LIBM.2"
>[SUSv3]</A
></TD
><TD
>scalbf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>scalbl <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>scalbln <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>scalblnf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>scalblnl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>scalbn <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>scalbnf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>scalbnl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>significand <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>significandf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>significandl <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>sin <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>sincos <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>sincosf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>sincosl <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>sinf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>sinh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>sinhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sinhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>sinl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>sqrt <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>sqrtf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sqrtl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tan <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tanf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tanh <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>tanhf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tanhl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tanl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tgamma <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>tgammaf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>tgammal <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>trunc <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>truncf <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>truncl <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>y0 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>y0f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>y0l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>y1 <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>y1f <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>y1l <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>yn <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ynf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>ynl <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Math specified in <A
HREF="#TBL-LIBM-MATH-DEPINTS"
>Table 14-40</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBM-MATH-DEPINTS"
></A
><P
><B
>Table 14-40. libm - Math Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>drem <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>dremf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>dreml <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>finite <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>finitef <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>finitel <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>gamma <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>gammaf <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gammal <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>matherr <A
HREF="#REFSTD.LIBM.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Math specified in <A
HREF="#TBL-LIBM-MATH-DATA"
>Table 14-41</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBM-MATH-DATA"
></A
><P
><B
>Table 14-41. libm - Math Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>signgam <A
HREF="#REFSTD.LIBM.3"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBM-DDEFS"
>14.7. Data Definitions for libm</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libm.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN22851"
>14.7.1. complex.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define complex	_Complex

extern double cabs(double complex);
extern float cabsf(float complex);
extern long double cabsl(long double complex);
extern double complex cacos(double complex);
extern float complex cacosf(float complex);
extern double complex cacosh(double complex);
extern float complex cacoshf(float complex);
extern long double complex cacoshl(long double complex);
extern long double complex cacosl(long double complex);
extern double carg(double complex);
extern float cargf(float complex);
extern long double cargl(long double complex);
extern double complex casin(double complex);
extern float complex casinf(float complex);
extern double complex casinh(double complex);
extern float complex casinhf(float complex);
extern long double complex casinhl(long double complex);
extern long double complex casinl(long double complex);
extern double complex catan(double complex);
extern float complex catanf(float complex);
extern double complex catanh(double complex);
extern float complex catanhf(float complex);
extern long double complex catanhl(long double complex);
extern long double complex catanl(long double complex);
extern double complex ccos(double complex);
extern float complex ccosf(float complex);
extern double complex ccosh(double complex);
extern float complex ccoshf(float complex);
extern long double complex ccoshl(long double complex);
extern long double complex ccosl(long double complex);
extern double complex cexp(double complex);
extern float complex cexpf(float complex);
extern long double complex cexpl(long double complex);
extern double cimag(double complex);
extern float cimagf(float complex);
extern long double cimagl(long double complex);
extern double complex clog(double complex);
extern double complex clog10(double complex);
extern float complex clog10f(float complex);
extern long double complex clog10l(long double complex);
extern float complex clogf(float complex);
extern long double complex clogl(long double complex);
extern double complex conj(double complex);
extern float complex conjf(float complex);
extern long double complex conjl(long double complex);
extern double complex cpow(double complex, double complex);
extern float complex cpowf(float complex, float complex);
extern long double complex cpowl(long double complex, long double complex);
extern double complex cproj(double complex);
extern float complex cprojf(float complex);
extern long double complex cprojl(long double complex);
extern double creal(double complex);
extern float crealf(float complex);
extern long double creall(long double complex);
extern double complex csin(double complex);
extern float complex csinf(float complex);
extern double complex csinh(double complex);
extern float complex csinhf(float complex);
extern long double complex csinhl(long double complex);
extern long double complex csinl(long double complex);
extern double complex csqrt(double complex);
extern float complex csqrtf(float complex);
extern long double complex csqrtl(long double complex);
extern double complex ctan(double complex);
extern float complex ctanf(float complex);
extern double complex ctanh(double complex);
extern float complex ctanhf(float complex);
extern long double complex ctanhl(long double complex);
extern long double complex ctanl(long double complex);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN22855"
>14.7.2. fenv.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int feclearexcept(int __excepts);
extern int fedisableexcept(int __excepts);
extern int feenableexcept(int __excepts);
extern int fegetenv(fenv_t * __envp);
extern int fegetexcept(void);
extern int fegetexceptflag(fexcept_t * __flagp, int __excepts);
extern int fegetround(void);
extern int feholdexcept(fenv_t * __envp);
extern int feraiseexcept(int __excepts);
extern int fesetenv(const fenv_t * __envp);
extern int fesetexceptflag(const fexcept_t * __flagp, int __excepts);
extern int fesetround(int __rounding_direction);
extern int fetestexcept(int __excepts);
extern int feupdateenv(const fenv_t * __envp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN22859"
>14.7.3. math.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define DOMAIN	1
#define SING	2

#define FP_NAN	0
#define FP_INFINITE	1
#define FP_ZERO	2
#define FP_SUBNORMAL	3
#define FP_NORMAL	4

#define isnormal(x)	(fpclassify (x) == FP_NORMAL)	/* Return nonzero value if X is neither zero, subnormal, Inf, n */

#define HUGE_VAL	0x1.0p2047
#define HUGE_VALF	0x1.0p255f

#define NAN	((float)0x7fc00000UL)
#define M_1_PI	0.31830988618379067154
#define M_LOG10E	0.43429448190325182765
#define M_2_PI	0.63661977236758134308
#define M_LN2	0.69314718055994530942
#define M_SQRT1_2	0.70710678118654752440
#define M_PI_4	0.78539816339744830962
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2	1.41421356237309504880
#define M_LOG2E	1.4426950408889634074
#define M_PI_2	1.57079632679489661923
#define M_LN10	2.30258509299404568402
#define M_E	2.7182818284590452354
#define M_PI	3.14159265358979323846
#define INFINITY	HUGE_VALF

#define MATH_ERRNO	1	/* errno set by math functions. */
#define MATH_ERREXCEPT	2	/* Exceptions raised by math functions. */

#define isunordered(u, v)	\
	(__extension__({ __typeof__(u) __u = (u); __typeof__(v) __v = (v);fpclassify (__u) == FP_NAN || fpclassify (__v) == FP_NAN; }))	/* Return nonzero value if arguments are unordered. */
#define islessgreater(x, y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; (__x &#60; __y || __y &#60; __x); }))	/* Return nonzero value if either X is less than Y or Y is less */
#define isless(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#60; __y; }))	/* Return nonzero value if X is less than Y. */
#define islessequal(x, y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#60;= __y; }))	/* Return nonzero value if X is less than or equal to Y. */
#define isgreater(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#62; __y; }))	/* Return nonzero value if X is greater than Y. */
#define isgreaterequal(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &#38;&#38; __x &#62;= __y; }))	/* Return nonzero value if X is greater than or equal to Y. */

extern int __finite(double);
extern int __finitef(float);
extern int __finitel(long double);
extern int __fpclassify(double);
extern int __fpclassifyf(float);
extern int __isinf(double);
extern int __isinff(float);
extern int __isinfl(long double);
extern int __isnan(double);
extern int __isnanf(float);
extern int __isnanl(long double);
extern int __signbit(double);
extern int __signbitf(float);
extern double acos(double);
extern float acosf(float);
extern double acosh(double);
extern float acoshf(float);
extern long double acoshl(long double);
extern long double acosl(long double);
extern double asin(double);
extern float asinf(float);
extern double asinh(double);
extern float asinhf(float);
extern long double asinhl(long double);
extern long double asinl(long double);
extern double atan(double);
extern double atan2(double, double);
extern float atan2f(float, float);
extern long double atan2l(long double, long double);
extern float atanf(float);
extern double atanh(double);
extern float atanhf(float);
extern long double atanhl(long double);
extern long double atanl(long double);
extern double cbrt(double);
extern float cbrtf(float);
extern long double cbrtl(long double);
extern double ceil(double);
extern float ceilf(float);
extern long double ceill(long double);
extern double copysign(double, double);
extern float copysignf(float, float);
extern long double copysignl(long double, long double);
extern double cos(double);
extern float cosf(float);
extern double cosh(double);
extern float coshf(float);
extern long double coshl(long double);
extern long double cosl(long double);
extern double drem(double, double);
extern float dremf(float, float);
extern long double dreml(long double, long double);
extern double erf(double);
extern double erfc(double);
extern float erfcf(float);
extern long double erfcl(long double);
extern float erff(float);
extern long double erfl(long double);
extern double exp(double);
extern double exp10(double);
extern float exp10f(float);
extern long double exp10l(long double);
extern double exp2(double);
extern float exp2f(float);
extern float expf(float);
extern long double expl(long double);
extern double expm1(double);
extern float expm1f(float);
extern long double expm1l(long double);
extern double fabs(double);
extern float fabsf(float);
extern long double fabsl(long double);
extern double fdim(double, double);
extern float fdimf(float, float);
extern long double fdiml(long double, long double);
extern int finite(double);
extern int finitef(float);
extern int finitel(long double);
extern double floor(double);
extern float floorf(float);
extern long double floorl(long double);
extern double fma(double, double, double);
extern float fmaf(float, float, float);
extern long double fmal(long double, long double, long double);
extern double fmax(double, double);
extern float fmaxf(float, float);
extern long double fmaxl(long double, long double);
extern double fmin(double, double);
extern float fminf(float, float);
extern long double fminl(long double, long double);
extern double fmod(double, double);
extern float fmodf(float, float);
extern long double fmodl(long double, long double);
extern double frexp(double, int *);
extern float frexpf(float, int *);
extern long double frexpl(long double, int *);
extern double gamma(double);
extern float gammaf(float);
extern long double gammal(long double);
extern double hypot(double, double);
extern float hypotf(float, float);
extern long double hypotl(long double, long double);
extern int ilogb(double);
extern int ilogbf(float);
extern int ilogbl(long double);
extern double j0(double);
extern float j0f(float);
extern long double j0l(long double);
extern double j1(double);
extern float j1f(float);
extern long double j1l(long double);
extern double jn(int, double);
extern float jnf(int, float);
extern long double jnl(int, long double);
extern double ldexp(double, int);
extern float ldexpf(float, int);
extern long double ldexpl(long double, int);
extern double lgamma(double);
extern double lgamma_r(double, int *);
extern float lgammaf(float);
extern float lgammaf_r(float, int *);
extern long double lgammal(long double);
extern long double lgammal_r(long double, int *);
extern long long int llrint(double);
extern long long int llrintf(float);
extern long long int llrintl(long double);
extern long long int llround(double);
extern long long int llroundf(float);
extern long long int llroundl(long double);
extern double log(double);
extern double log10(double);
extern float log10f(float);
extern long double log10l(long double);
extern double log1p(double);
extern float log1pf(float);
extern long double log1pl(long double);
extern double log2(double);
extern float log2f(float);
extern long double log2l(long double);
extern double logb(double);
extern float logbf(float);
extern long double logbl(long double);
extern float logf(float);
extern long double logl(long double);
extern long int lrint(double);
extern long int lrintf(float);
extern long int lrintl(long double);
extern long int lround(double);
extern long int lroundf(float);
extern long int lroundl(long double);
extern double modf(double, double *);
extern float modff(float, float *);
extern long double modfl(long double, long double *);
extern double nan(const char *);
extern float nanf(const char *);
extern long double nanl(const char *);
extern double nearbyint(double);
extern float nearbyintf(float);
extern long double nearbyintl(long double);
extern double nextafter(double, double);
extern float nextafterf(float, float);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern double pow(double, double);
extern double pow10(double);
extern float pow10f(float);
extern long double pow10l(long double);
extern float powf(float, float);
extern long double powl(long double, long double);
extern double remainder(double, double);
extern float remainderf(float, float);
extern long double remainderl(long double, long double);
extern double remquo(double, double, int *);
extern float remquof(float, float, int *);
extern long double remquol(long double, long double, int *);
extern double rint(double);
extern float rintf(float);
extern long double rintl(long double);
extern double round(double);
extern float roundf(float);
extern long double roundl(long double);
extern double scalb(double, double);
extern float scalbf(float, float);
extern long double scalbl(long double, long double);
extern double scalbln(double, long int);
extern float scalblnf(float, long int);
extern long double scalblnl(long double, long int);
extern double scalbn(double, int);
extern float scalbnf(float, int);
extern long double scalbnl(long double, int);
extern int signgam;
extern double significand(double);
extern float significandf(float);
extern long double significandl(long double);
extern double sin(double);
extern void sincos(double, double *, double *);
extern void sincosf(float, float *, float *);
extern void sincosl(long double, long double *, long double *);
extern float sinf(float);
extern double sinh(double);
extern float sinhf(float);
extern long double sinhl(long double);
extern long double sinl(long double);
extern double sqrt(double);
extern float sqrtf(float);
extern long double sqrtl(long double);
extern double tan(double);
extern float tanf(float);
extern double tanh(double);
extern float tanhf(float);
extern long double tanhl(long double);
extern long double tanl(long double);
extern double tgamma(double);
extern float tgammaf(float);
extern long double tgammal(long double);
extern double trunc(double);
extern float truncf(float);
extern long double truncl(long double);
extern double y0(double);
extern float y0f(float);
extern long double y0l(long double);
extern double y1(double);
extern float y1f(float);
extern long double y1l(long double);
extern double yn(int, double);
extern float ynf(int, float);
extern long double ynl(int, long double);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBMMAN"
>14.8. Interface Definitions for libm</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB---FINITE"
>__finite</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---FINITEF"
>__finitef</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---FINITEL"
>__finitel</A
>&nbsp;--&nbsp;test for infinity</DT
><DT
><A
HREF="#BASELIB---FPCLASSIFY"
>__fpclassify</A
>&nbsp;--&nbsp;Classify real floating type</DT
><DT
><A
HREF="#BASELIB---FPCLASSIFYF"
>__fpclassifyf</A
>&nbsp;--&nbsp;Classify real floating type</DT
><DT
><A
HREF="#BASELIB---SIGNBIT"
>__signbit</A
>&nbsp;--&nbsp;test sign of floating point value</DT
><DT
><A
HREF="#BASELIB---SIGNBITF"
>__signbitf</A
>&nbsp;--&nbsp;test sign of floating point value</DT
><DT
><A
HREF="#BASELIB---CLOG10"
>clog10</A
>&nbsp;--&nbsp;Logarithm of a Complex Number</DT
><DT
><A
HREF="#BASELIB---CLOG10F"
>clog10f</A
>&nbsp;--&nbsp;Logarithm of a Complex Number</DT
><DT
><A
HREF="#BASELIB---CLOG10L"
>clog10l</A
>&nbsp;--&nbsp;Logarithm of a Complex Number</DT
><DT
><A
HREF="#BASELIB-DREM"
>drem</A
>&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-DREMF"
>dremf</A
>&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-DREML"
>dreml</A
>&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-EXP10"
>exp10</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-EXP10F"
>exp10f</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-EXP10L"
>exp10l</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-FEDISABLEEXCEPT"
>fedisableexcept</A
>&nbsp;--&nbsp;disable floating point exceptions</DT
><DT
><A
HREF="#BASELIB-FEENABLEEXCEPT"
>feenableexcept</A
>&nbsp;--&nbsp;enable floating point exceptions</DT
><DT
><A
HREF="#BASELIB-FEGETEXCEPT"
>fegetexcept</A
>&nbsp;--&nbsp;query floating point exception handling state</DT
><DT
><A
HREF="#BASELIB-FINITE"
>finite</A
>&nbsp;--&nbsp;test for infinity (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-FINITEF"
>finitef</A
>&nbsp;--&nbsp;test for infinity (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-FINITEL"
>finitel</A
>&nbsp;--&nbsp;test for infinity (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GAMMA"
>gamma</A
>&nbsp;--&nbsp;log gamma function (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GAMMAF"
>gammaf</A
>&nbsp;--&nbsp;log gamma function (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-GAMMAL"
>gammal</A
>&nbsp;--&nbsp;log gamma function (DEPRECATED)</DT
><DT
><A
HREF="#BASELIB-J0F"
>j0f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-J0L"
>j0l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-J1F"
>j1f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-J1L"
>j1l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-JNF"
>jnf</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-JNL"
>jnl</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-LGAMMA-R"
>lgamma_r</A
>&nbsp;--&nbsp;log gamma functions</DT
><DT
><A
HREF="#BASELIB-LGAMMAF-R"
>lgammaf_r</A
>&nbsp;--&nbsp;log gamma functions</DT
><DT
><A
HREF="#BASELIB-LGAMMAL-R"
>lgammal_r</A
>&nbsp;--&nbsp;log gamma functions</DT
><DT
><A
HREF="#BASELIB-MATHERR-1"
>matherr</A
>&nbsp;--&nbsp;math library exception handling</DT
><DT
><A
HREF="#BASELIB-POW10"
>pow10</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-POW10F"
>pow10f</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-POW10L"
>pow10l</A
>&nbsp;--&nbsp;Base-10 power function</DT
><DT
><A
HREF="#BASELIB-SCALBF"
>scalbf</A
>&nbsp;--&nbsp;load exponent of radix-independent floating point number</DT
><DT
><A
HREF="#BASELIB-SCALBL"
>scalbl</A
>&nbsp;--&nbsp;load exponent of radix-independent floating point number</DT
><DT
><A
HREF="#BASELIB-SIGNIFICAND"
>significand</A
>&nbsp;--&nbsp;floating point mantissa</DT
><DT
><A
HREF="#BASELIB-SIGNIFICANDF"
>significandf</A
>&nbsp;--&nbsp;floating point mantissa</DT
><DT
><A
HREF="#BASELIB-SIGNIFICANDL"
>significandl</A
>&nbsp;--&nbsp;floating point mantissa</DT
><DT
><A
HREF="#BASELIB-SINCOS"
>sincos</A
>&nbsp;--&nbsp;trigonometric functions</DT
><DT
><A
HREF="#BASELIB-SINCOSF"
>sincosf</A
>&nbsp;--&nbsp;trigonometric functions</DT
><DT
><A
HREF="#BASELIB-SINCOSL"
>sincosl</A
>&nbsp;--&nbsp;trigonometric functions</DT
><DT
><A
HREF="#BASELIB-Y0F"
>y0f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-Y0L"
>y0l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-Y1F"
>y1f</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-Y1L"
>y1l</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-YNF"
>ynf</A
>&nbsp;--&nbsp;Bessel functions</DT
><DT
><A
HREF="#BASELIB-YNL"
>ynl</A
>&nbsp;--&nbsp;Bessel functions</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libm and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBM"
>Section 14.6</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB---FINITE"
></A
>__finite</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22872"
></A
><H2
>Name</H2
>__finite&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22875"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN22876"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__finite</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22884"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__finite()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isfinite()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__finite()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__finite()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FINITEF"
></A
>__finitef</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22897"
></A
><H2
>Name</H2
>__finitef&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22900"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN22901"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__finitef</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22909"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__finitef()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isfinite()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
except that the argument 
type for <TT
CLASS="FUNCTION"
>__finitef()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__finitef()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FINITEL"
></A
>__finitel</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22922"
></A
><H2
>Name</H2
>__finitel&nbsp;--&nbsp;test for infinity</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22925"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN22926"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__finitel</TT
></CODE
>(long double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22934"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__finitel()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>isfinite()</TT
> in the <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__finitel()</TT
> is known to be long double.</P
><P
><TT
CLASS="FUNCTION"
>__finitel()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FPCLASSIFY"
></A
>__fpclassify</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22947"
></A
><H2
>Name</H2
>__fpclassify&nbsp;--&nbsp;Classify real floating type</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22950"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN22951"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fpclassify</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22958"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__fpclassify()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>fpclassify()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__fpclassify()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__fpclassify()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---FPCLASSIFYF"
></A
>__fpclassifyf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22971"
></A
><H2
>Name</H2
>__fpclassifyf&nbsp;--&nbsp;Classify real floating type</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22974"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN22975"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__fpclassifyf</TT
></CODE
>(float 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN22982"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__fpclassifyf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>fpclassify()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__fpclassifyf()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__fpclassifyf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SIGNBIT"
></A
>__signbit</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN22995"
></A
><H2
>Name</H2
>__signbit&nbsp;--&nbsp;test sign of floating point value</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN22998"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN22999"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>__signbit</TT
></CODE
>(double 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>arg</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23007"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__signbit()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>signbit()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__signbit()</TT
> is known to be double.</P
><P
><TT
CLASS="FUNCTION"
>__signbit()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---SIGNBITF"
></A
>__signbitf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23020"
></A
><H2
>Name</H2
>__signbitf&nbsp;--&nbsp;test sign of floating point value</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23023"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23024"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>__signbitf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23031"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>__signbitf()</TT
> has the same specification as 
<TT
CLASS="FUNCTION"
>signbit()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that the argument 
type for <TT
CLASS="FUNCTION"
>__signbitf()</TT
> is known to be float.</P
><P
><TT
CLASS="FUNCTION"
>__signbitf()</TT
> is not in the source standard; 
it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB---CLOG10"
></A
>clog10</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23044"
></A
><H2
>Name</H2
>clog10&nbsp;--&nbsp;Logarithm of a Complex Number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23047"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23048"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;complex.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double complex
<TT
CLASS="FUNCTION"
>clog10</TT
></CODE
>(double complex
<TT
CLASS="PARAMETER"
><I
>z</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23055"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>clog10()</TT
> function shall compute the base 10 
logarithm of the complex number <TT
CLASS="PARAMETER"
><I
>z</I
></TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23060"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>clog10()</TT
> function shall return the base 10 logarithm.</P
></DIV
><H1
><A
NAME="BASELIB---CLOG10F"
></A
>clog10f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23068"
></A
><H2
>Name</H2
>clog10f&nbsp;--&nbsp;Logarithm of a Complex Number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23071"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23072"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;complex.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float complex
<TT
CLASS="FUNCTION"
>clog10f</TT
></CODE
>(float complex
<TT
CLASS="PARAMETER"
><I
>z</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23079"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>clog10f()</TT
> function shall compute the base 10 
logarithm of the complex number <TT
CLASS="PARAMETER"
><I
>z</I
></TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23084"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>clog10f()</TT
> function shall return the base 10 logarithm.</P
></DIV
><H1
><A
NAME="BASELIB---CLOG10L"
></A
>clog10l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23092"
></A
><H2
>Name</H2
>clog10l&nbsp;--&nbsp;Logarithm of a Complex Number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23095"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23096"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;complex.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double complex
<TT
CLASS="FUNCTION"
>clog10l</TT
></CODE
>(long double complex
<TT
CLASS="PARAMETER"
><I
>z</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23103"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>clog10l()</TT
> function shall compute the base 10 
logarithm of the complex number <TT
CLASS="PARAMETER"
><I
>z</I
></TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23108"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>clog10l()</TT
> function shall return the base 10 logarithm.</P
></DIV
><H1
><A
NAME="BASELIB-DREM"
></A
>drem</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23116"
></A
><H2
>Name</H2
>drem&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23119"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23120"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>drem</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, double
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23129"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>drem()</TT
> function shall return the floating point remainder,
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> REM <TT
CLASS="PARAMETER"
><I
>y</I
></TT
> as required by <A
HREF="#STD.FLTPNT"
>IEC 60559/IEEE 754 Floating Point</A
>
in the same way as <TT
CLASS="FUNCTION"
>remainder()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is included only for backwards compatibility; applications should
use <TT
CLASS="FUNCTION"
>remainder()</TT
> instead.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23140"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>remainder()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23144"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>remainder()</TT
>, <TT
CLASS="FUNCTION"
>dremf()</TT
>, <TT
CLASS="FUNCTION"
>dreml()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-DREMF"
></A
>dremf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23158"
></A
><H2
>Name</H2
>dremf&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23161"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23162"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>dremf</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, double
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23171"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dremf()</TT
> function shall return the floating point remainder,
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> REM <TT
CLASS="PARAMETER"
><I
>y</I
></TT
> as required by <A
HREF="#STD.FLTPNT"
>IEC 60559/IEEE 754 Floating Point</A
>
in the same way as <TT
CLASS="FUNCTION"
>remainderf()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is included only for backwards compatibility; applications should
use <TT
CLASS="FUNCTION"
>remainderf()</TT
> instead.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23182"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>remainderf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23186"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>remainderf()</TT
>, <TT
CLASS="FUNCTION"
>drem()</TT
>, <TT
CLASS="FUNCTION"
>dreml()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-DREML"
></A
>dreml</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23200"
></A
><H2
>Name</H2
>dreml&nbsp;--&nbsp;Floating Point Remainder (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23203"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23204"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>dreml</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, double
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23213"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dreml()</TT
> function shall return the floating point remainder,
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> REM <TT
CLASS="PARAMETER"
><I
>y</I
></TT
> as required by <A
HREF="#STD.FLTPNT"
>IEC 60559/IEEE 754 Floating Point</A
>
in the same way as <TT
CLASS="FUNCTION"
>remainderl()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is included only for backwards compatibility; applications should
use <TT
CLASS="FUNCTION"
>remainderl()</TT
> instead.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23224"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>remainderl()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23228"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>remainderl()</TT
>, <TT
CLASS="FUNCTION"
>drem()</TT
>, <TT
CLASS="FUNCTION"
>dremf()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-EXP10"
></A
>exp10</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23242"
></A
><H2
>Name</H2
>exp10&nbsp;--&nbsp;Base-10 power function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23245"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23246"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>exp10</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23253"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>exp10()</TT
> function shall return 10<SUP
><TT
CLASS="SYMBOL"
>x</TT
></SUP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is identical to <TT
CLASS="FUNCTION"
>pow10()</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23262"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>exp10()</TT
> shall return 10
rised to the power of <TT
CLASS="SYMBOL"
>x</TT
>.</P
><P
>If the correct value would cause overflow, a range error shall occur and <TT
CLASS="FUNCTION"
>exp10()</TT
>
shall return HUGE_VAL, with the same sign as the correct value of the function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23269"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>pow10()</TT
>, <TT
CLASS="FUNCTION"
>exp10f()</TT
>, <TT
CLASS="FUNCTION"
>exp10l()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-EXP10F"
></A
>exp10f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23283"
></A
><H2
>Name</H2
>exp10f&nbsp;--&nbsp;Base-10 power function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23286"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23287"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>exp10f</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23294"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>exp10f()</TT
> function shall return 10<SUP
><TT
CLASS="SYMBOL"
>x</TT
></SUP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is identical to <TT
CLASS="FUNCTION"
>pow10f()</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23303"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>exp10f()</TT
> shall return 10
rised to the power of <TT
CLASS="SYMBOL"
>x</TT
>.</P
><P
>If the correct value would cause overflow, a range error shall occur and <TT
CLASS="FUNCTION"
>exp10f()</TT
>
shall return HUGE_VALF, with the same sign as the correct value of the function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23310"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>pow10f()</TT
>, <TT
CLASS="FUNCTION"
>exp10()</TT
>, <TT
CLASS="FUNCTION"
>exp10l()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-EXP10L"
></A
>exp10l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23324"
></A
><H2
>Name</H2
>exp10l&nbsp;--&nbsp;Base-10 power function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23327"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23328"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>exp10l</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23335"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>exp10l()</TT
> function shall return 10<SUP
><TT
CLASS="SYMBOL"
>x</TT
></SUP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is identical to <TT
CLASS="FUNCTION"
>pow10l()</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23344"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>exp10l()</TT
> shall return 10
rised to the power of <TT
CLASS="SYMBOL"
>x</TT
>.</P
><P
>If the correct value would cause overflow, a range error shall occur and <TT
CLASS="FUNCTION"
>exp10l()</TT
>
shall return HUGE_VALL, with the same sign as the correct value of the function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23351"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>pow10l()</TT
>, <TT
CLASS="FUNCTION"
>exp10()</TT
>, <TT
CLASS="FUNCTION"
>exp10f()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-FEDISABLEEXCEPT"
></A
>fedisableexcept</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23365"
></A
><H2
>Name</H2
>fedisableexcept&nbsp;--&nbsp;disable floating point exceptions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23368"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23369"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fenv.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <TT
CLASS="FUNCTION"
>fedisableexcept</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>excepts</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23376"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>fedisableexcept()</TT
> function disables
traps for each of the exceptions represented by 
the mask <CODE
CLASS="VARNAME"
>excepts</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23381"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>fedisableexcept()</TT
> function returns 
the previous set of enabled exceptions on success.
On error, -1 is returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23385"
></A
><H2
>Errors</H2
><P
>No errors are defined, but the function will fail
if not supported on the architecture.</P
></DIV
><H1
><A
NAME="BASELIB-FEENABLEEXCEPT"
></A
>feenableexcept</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23392"
></A
><H2
>Name</H2
>feenableexcept&nbsp;--&nbsp;enable floating point exceptions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23395"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23396"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fenv.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <TT
CLASS="FUNCTION"
>feenableexcept</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>excepts</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23403"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>feenableexcept()</TT
> function enables
traps for each of the exceptions represented by 
the mask <CODE
CLASS="VARNAME"
>excepts</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23408"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>feenableexcept()</TT
> function returns 
the previous set of enabled exceptions on success.
On error, -1 is returned.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23412"
></A
><H2
>Errors</H2
><P
>No errors are defined, but the function will fail
if not supported on the architecture.</P
></DIV
><H1
><A
NAME="BASELIB-FEGETEXCEPT"
></A
>fegetexcept</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23419"
></A
><H2
>Name</H2
>fegetexcept&nbsp;--&nbsp;query floating point exception handling state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23422"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23423"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;fenv.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <TT
CLASS="FUNCTION"
>fegetexcept</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23429"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>fegetexcept()</TT
> function returns  
the set of all currently enabled exceptions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23433"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>fegetexcept()</TT
> function returns 
the set of all currently enabled exceptions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23437"
></A
><H2
>Errors</H2
><P
>No errors are defined, but the function will fail
if not supported on the architecture.</P
></DIV
><H1
><A
NAME="BASELIB-FINITE"
></A
>finite</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23444"
></A
><H2
>Name</H2
>finite&nbsp;--&nbsp;test for infinity (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23447"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23448"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _SVID_SOURCE
#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>finite</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23455"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>finite()</TT
> function shall test whether
its argument is neither <CODE
CLASS="CONSTANT"
>INFINITY</CODE
> nor
not a number (NaN).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23460"
></A
><H2
>Returns</H2
><P
>On success, <TT
CLASS="FUNCTION"
>finite()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>1</SPAN
>. Otherwise
the function shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> standard defines the function <TT
CLASS="FUNCTION"
>isfinite()</TT
>,
which is more general purpose. The <TT
CLASS="FUNCTION"
>finite()</TT
> function is deprecated, and applications
should use <TT
CLASS="FUNCTION"
>isfinite()</TT
> instead. A future revision of this standard may remove this function.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23472"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>isfinite()</TT
>, <TT
CLASS="FUNCTION"
>finitef()</TT
>, <TT
CLASS="FUNCTION"
>finitel()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-FINITEF"
></A
>finitef</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23486"
></A
><H2
>Name</H2
>finitef&nbsp;--&nbsp;test for infinity (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23489"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23490"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _SVID_SOURCE
#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>finitef</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23497"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>finitef()</TT
> function shall test whether
its argument is neither <CODE
CLASS="CONSTANT"
>INFINITY</CODE
> nor
not a number (NaN).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23502"
></A
><H2
>Returns</H2
><P
>On success, <TT
CLASS="FUNCTION"
>finitef()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>1</SPAN
>. Otherwise
the function shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> standard defines the function <TT
CLASS="FUNCTION"
>isfinite()</TT
>,
which is more general purpose. The <TT
CLASS="FUNCTION"
>finitef()</TT
> function is deprecated, and applications
should use <TT
CLASS="FUNCTION"
>isfinite()</TT
> instead. A future revision of this standard may remove this function.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23514"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>isfinite()</TT
>, <TT
CLASS="FUNCTION"
>finite()</TT
>, <TT
CLASS="FUNCTION"
>finitel()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-FINITEL"
></A
>finitel</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23528"
></A
><H2
>Name</H2
>finitel&nbsp;--&nbsp;test for infinity (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23531"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23532"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _SVID_SOURCE
#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>finitel</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>arg</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23539"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>finitel()</TT
> function shall test whether
its argument is neither <CODE
CLASS="CONSTANT"
>INFINITY</CODE
> nor
not a number (NaN).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23544"
></A
><H2
>Returns</H2
><P
>On success, <TT
CLASS="FUNCTION"
>finitel()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>1</SPAN
>. Otherwise
the function shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> standard defines the function <TT
CLASS="FUNCTION"
>isfinite()</TT
>,
which is more general purpose. The <TT
CLASS="FUNCTION"
>finitel()</TT
> function is deprecated, and applications
should use <TT
CLASS="FUNCTION"
>isfinite()</TT
> instead. A future revision of this standard may remove this function.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23556"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>isfinite()</TT
>, <TT
CLASS="FUNCTION"
>finite()</TT
>, <TT
CLASS="FUNCTION"
>finitef()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-GAMMA"
></A
>gamma</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23570"
></A
><H2
>Name</H2
>gamma&nbsp;--&nbsp;log gamma function (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23573"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23574"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>gammaf</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23581"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gamma()</TT
> function is identical to 
<TT
CLASS="FUNCTION"
>lgamma()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The name <TT
CLASS="FUNCTION"
>gamma()</TT
> for this function
is deprecated and should not be used.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23590"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>lgamma()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23594"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>lgamma()</TT
>, <TT
CLASS="FUNCTION"
>lgammaf()</TT
>, <TT
CLASS="FUNCTION"
>lgammal()</TT
>, <TT
CLASS="FUNCTION"
>gammaf()</TT
>, <TT
CLASS="FUNCTION"
>gammal()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-GAMMAF"
></A
>gammaf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23612"
></A
><H2
>Name</H2
>gammaf&nbsp;--&nbsp;log gamma function (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23615"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23616"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>gammaf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23623"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gammaf()</TT
> function is identical to 
<TT
CLASS="FUNCTION"
>lgammaf()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The name <TT
CLASS="FUNCTION"
>gammaf()</TT
> for this function
is deprecated and should not be used.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23632"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>lgammaf()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23636"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>lgamma()</TT
>, <TT
CLASS="FUNCTION"
>lgammaf()</TT
>, <TT
CLASS="FUNCTION"
>lgammal()</TT
>, <TT
CLASS="FUNCTION"
>gamma()</TT
>, <TT
CLASS="FUNCTION"
>gammal()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-GAMMAL"
></A
>gammal</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23654"
></A
><H2
>Name</H2
>gammal&nbsp;--&nbsp;log gamma function (DEPRECATED)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23657"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23658"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>gammal</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23665"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gammal()</TT
> function is identical to 
<TT
CLASS="FUNCTION"
>lgammal()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The name <TT
CLASS="FUNCTION"
>gammal()</TT
> for this function
is deprecated and should not be used.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23674"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>lgammal()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23678"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>lgamma()</TT
>, <TT
CLASS="FUNCTION"
>lgammaf()</TT
>, <TT
CLASS="FUNCTION"
>lgammal()</TT
>, <TT
CLASS="FUNCTION"
>gamma()</TT
>, <TT
CLASS="FUNCTION"
>gammaf()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-J0F"
></A
>j0f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23696"
></A
><H2
>Name</H2
>j0f&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23699"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23700"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>j0f</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23707"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>j0f()</TT
> function is identical to <TT
CLASS="FUNCTION"
>j0()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23714"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>j0()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23718"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-J0L"
></A
>j0l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23760"
></A
><H2
>Name</H2
>j0l&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23763"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23764"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>j0l</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23771"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>j0l()</TT
> function is identical to <TT
CLASS="FUNCTION"
>j0()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>long double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23778"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>j0()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23782"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-J1F"
></A
>j1f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23824"
></A
><H2
>Name</H2
>j1f&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23827"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23828"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>j1f</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23835"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>j1f()</TT
> function is identical to <TT
CLASS="FUNCTION"
>j1()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23842"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>j1()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23846"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-J1L"
></A
>j1l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23888"
></A
><H2
>Name</H2
>j1l&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23891"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23892"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>j1l</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23899"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>j1l()</TT
> function is identical to <TT
CLASS="FUNCTION"
>j1()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>long double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23906"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>j0()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23910"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-JNF"
></A
>jnf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN23952"
></A
><H2
>Name</H2
>jnf&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN23955"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN23956"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>jnf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23963"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>jnf()</TT
> function is identical to <TT
CLASS="FUNCTION"
>jn()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23970"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>jn()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN23974"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-JNL"
></A
>jnl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24016"
></A
><H2
>Name</H2
>jnl&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24019"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24020"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>jnl</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24027"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>jnl()</TT
> function is identical to <TT
CLASS="FUNCTION"
>jn()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>long double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24034"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>jn()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24038"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-LGAMMA-R"
></A
>lgamma_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24080"
></A
><H2
>Name</H2
>lgamma_r&nbsp;--&nbsp;log gamma functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24083"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24084"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>lgamma_r</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>signp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24093"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>lgamma_r()</TT
> function shall compute the natural logarithm
of the absolute value of the Gamma function, as <TT
CLASS="FUNCTION"
>lgamma()</TT
>.
However, instead of setting the external integer <CODE
CLASS="VARNAME"
>signgam</CODE
>
to the sign of the Gamma function, <TT
CLASS="FUNCTION"
>lgamma_r()</TT
> shall set the
integer referenced by <TT
CLASS="PARAMETER"
><I
>signp</I
></TT
> to the sign.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24101"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>lgamma()</TT
> and <CODE
CLASS="VARNAME"
>signgam</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24106"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>lgamma()</TT
>, <TT
CLASS="FUNCTION"
>lgammaf_r()</TT
>, <TT
CLASS="FUNCTION"
>lgammal_r()</TT
>, <CODE
CLASS="VARNAME"
>signgam</CODE
></P
></DIV
><H1
><A
NAME="BASELIB-LGAMMAF-R"
></A
>lgammaf_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24122"
></A
><H2
>Name</H2
>lgammaf_r&nbsp;--&nbsp;log gamma functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24125"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24126"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>lgammaf_r</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>signp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24135"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>lgammaf_r()</TT
> function shall compute the natural logarithm
of the absolute value of the Gamma function, as <TT
CLASS="FUNCTION"
>lgammaf()</TT
>.
However, instead of setting the external integer <CODE
CLASS="VARNAME"
>signgam</CODE
>
to the sign of the Gamma function, <TT
CLASS="FUNCTION"
>lgammaf_r()</TT
> shall set the
integer referenced by <TT
CLASS="PARAMETER"
><I
>signp</I
></TT
> to the sign.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24143"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>lgammaf()</TT
> and <CODE
CLASS="VARNAME"
>signgam</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24148"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>lgamma()</TT
>, <TT
CLASS="FUNCTION"
>lgamma_r()</TT
>, <TT
CLASS="FUNCTION"
>lgammal_r()</TT
>, <CODE
CLASS="VARNAME"
>signgam</CODE
></P
></DIV
><H1
><A
NAME="BASELIB-LGAMMAL-R"
></A
>lgammal_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24164"
></A
><H2
>Name</H2
>lgammal_r&nbsp;--&nbsp;log gamma functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24167"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24168"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>lgammal_r</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>signp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24177"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>lgammal_r()</TT
> function shall compute the natural logarithm
of the absolute value of the Gamma function, as <TT
CLASS="FUNCTION"
>lgammal()</TT
>.
However, instead of setting the external integer <CODE
CLASS="VARNAME"
>signgam</CODE
>
to the sign of the Gamma function, <TT
CLASS="FUNCTION"
>lgammal_r()</TT
> shall set the
integer referenced by <TT
CLASS="PARAMETER"
><I
>signp</I
></TT
> to the sign.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24185"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>lgammal()</TT
> and <CODE
CLASS="VARNAME"
>signgam</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24190"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>lgamma()</TT
>, <TT
CLASS="FUNCTION"
>lgamma_r()</TT
>, <TT
CLASS="FUNCTION"
>lgammaf_r()</TT
>, <CODE
CLASS="VARNAME"
>signgam</CODE
></P
></DIV
><H1
><A
NAME="BASELIB-MATHERR-1"
></A
>matherr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24206"
></A
><H2
>Name</H2
>matherr&nbsp;--&nbsp;math library exception handling</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24211"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24212"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>matherr</TT
></CODE
>(struct exception *<TT
CLASS="PARAMETER"
><I
>__exc</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24219"
></A
><H2
>Description</H2
><P
>The System V Interface Definition (SVID) Issue 3 specifies that various math
functions should invoke a function called 
<TT
CLASS="FUNCTION"
>matherr()</TT
> if a math exception is detected.
This function is called before the math function returns;
after <TT
CLASS="FUNCTION"
>matherr()</TT
> returns, 
the system then returns to the math function,
which in turn returns to the caller.</P
><P
><TT
CLASS="FUNCTION"
>matherr()</TT
> is obsolete; indeed it was withdrawn
in the System V Interface Definition (SVID) Issue 4, and is
required only by this specification for historical compatibility,
and will be removed in a future version.  The floating point
environment function group including 
<TT
CLASS="FUNCTION"
>fesetenv()</TT
> should be used instead.</P
><P
><TT
CLASS="FUNCTION"
>matherr()</TT
> is not in the source standard;
it is only in the binary standard.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24229"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>fesetenv()</TT
>,
<TT
CLASS="FUNCTION"
>fegetenv()</TT
>,
<TT
CLASS="FUNCTION"
>feupdateenv()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-POW10"
></A
>pow10</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24239"
></A
><H2
>Name</H2
>pow10&nbsp;--&nbsp;Base-10 power function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24242"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24243"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>pow10</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24250"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pow10()</TT
> function shall return 10<SUP
><TT
CLASS="SYMBOL"
>x</TT
></SUP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is identical to <TT
CLASS="FUNCTION"
>exp10()</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24259"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>pow10()</TT
> shall return 10
rised to the power of <TT
CLASS="SYMBOL"
>x</TT
>.</P
><P
>If the correct value would cause overflow, a range error shall occur and <TT
CLASS="FUNCTION"
>pow10()</TT
>
shall return HUGE_VAL, with the same sign as the correct value of the function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24266"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>exp10()</TT
>, <TT
CLASS="FUNCTION"
>pow10f()</TT
>, <TT
CLASS="FUNCTION"
>pow10l()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-POW10F"
></A
>pow10f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24280"
></A
><H2
>Name</H2
>pow10f&nbsp;--&nbsp;Base-10 power function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24283"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24284"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>pow10f</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24291"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pow10f()</TT
> function shall return 10<SUP
><TT
CLASS="SYMBOL"
>x</TT
></SUP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is identical to <TT
CLASS="FUNCTION"
>exp10f()</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24300"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>pow10f()</TT
> shall return 10
rised to the power of <TT
CLASS="SYMBOL"
>x</TT
>.</P
><P
>If the correct value would cause overflow, a range error shall occur and <TT
CLASS="FUNCTION"
>pow10f()</TT
>
shall return HUGE_VALF, with the same sign as the correct value of the function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24307"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>exp10f()</TT
>, <TT
CLASS="FUNCTION"
>pow10()</TT
>, <TT
CLASS="FUNCTION"
>pow10l()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-POW10L"
></A
>pow10l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24321"
></A
><H2
>Name</H2
>pow10l&nbsp;--&nbsp;Base-10 power function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24324"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24325"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>pow10l</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24332"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pow10l()</TT
> function shall return 10<SUP
><TT
CLASS="SYMBOL"
>x</TT
></SUP
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is identical to <TT
CLASS="FUNCTION"
>exp10l()</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24341"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>pow10l()</TT
> shall return 10
rised to the power of <TT
CLASS="SYMBOL"
>x</TT
>.</P
><P
>If the correct value would cause overflow, a range error shall occur and <TT
CLASS="FUNCTION"
>pow10l()</TT
>
shall return HUGE_VALL, with the same sign as the correct value of the function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24348"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>exp10l()</TT
>, <TT
CLASS="FUNCTION"
>pow10()</TT
>, <TT
CLASS="FUNCTION"
>pow10f()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SCALBF"
></A
>scalbf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24362"
></A
><H2
>Name</H2
>scalbf&nbsp;--&nbsp;load exponent of radix-independent floating point number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24365"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24366"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>scalbf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, double
<TT
CLASS="PARAMETER"
><I
>exp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24375"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scalbf()</TT
> function is identical
to <TT
CLASS="FUNCTION"
>scalb()</TT
>, except that the argument
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value is of type <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24382"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>scalb()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SCALBL"
></A
>scalbl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24390"
></A
><H2
>Name</H2
>scalbl&nbsp;--&nbsp;load exponent of radix-independent floating point number</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24393"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24394"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>scalbl</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, double
<TT
CLASS="PARAMETER"
><I
>exp</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24403"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>scalbl()</TT
> function is identical
to <TT
CLASS="FUNCTION"
>scalb()</TT
>, except that the argument
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value is of type <SPAN
CLASS="TYPE"
>long
double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24410"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>scalb()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SIGNIFICAND"
></A
>significand</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24418"
></A
><H2
>Name</H2
>significand&nbsp;--&nbsp;floating point mantissa</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24421"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24422"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double
<TT
CLASS="FUNCTION"
>significand</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24429"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>significand()</TT
> function shall return the mantissa of
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, <TT
CLASS="SYMBOL"
>sig</TT
> such that
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> &#8801; <TT
CLASS="SYMBOL"
>sig</TT
>  2<SUP
>n</SUP
>
scaled such that 1 &#8804; <TT
CLASS="SYMBOL"
>sig</TT
> &#60; 2.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is intended for testing conformance to <A
HREF="#STD.FLTPNT"
>IEC 60559/IEEE 754 Floating Point</A
>, and its use is not otherwise
recommended.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>This function is equivalent to <TT
CLASS="LITERAL"
>scalb(x, (double)-ilogb(x))</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24444"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>significand()</TT
> shall return the mantissa of <TT
CLASS="PARAMETER"
><I
>x</I
></TT
>
in the range
1 &#8804; <TT
CLASS="SYMBOL"
>sig</TT
> &#60; 2.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> is 0, HUGE_VAL, or NaN, the result is undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24452"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>significandf()</TT
>, <TT
CLASS="FUNCTION"
>significandl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGNIFICANDF"
></A
>significandf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24464"
></A
><H2
>Name</H2
>significandf&nbsp;--&nbsp;floating point mantissa</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24467"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24468"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>significandf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24475"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>significandf()</TT
> function shall return the mantissa of
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, <TT
CLASS="SYMBOL"
>sig</TT
> such that
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> &#8801; <TT
CLASS="SYMBOL"
>sig</TT
>  2<SUP
>n</SUP
>
scaled such that 1 &#8804; <TT
CLASS="SYMBOL"
>sig</TT
> &#60; 2.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is intended for testing conformance to <A
HREF="#STD.FLTPNT"
>IEC 60559/IEEE 754 Floating Point</A
>, and its use is not otherwise
recommended.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>This function is equivalent to <TT
CLASS="LITERAL"
>scalb(x, (double)-ilogb(x))</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24490"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>significandf()</TT
> shall return the mantissa of <TT
CLASS="PARAMETER"
><I
>x</I
></TT
>
in the range
1 &#8804; <TT
CLASS="SYMBOL"
>sig</TT
> &#60; 2.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> is 0, HUGE_VALF, or NaN, the result is undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24498"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>significand()</TT
>, <TT
CLASS="FUNCTION"
>significandl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SIGNIFICANDL"
></A
>significandl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24510"
></A
><H2
>Name</H2
>significandl&nbsp;--&nbsp;floating point mantissa</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24513"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24514"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>significandl</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24521"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>significandl()</TT
> function shall return the mantissa of
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, <TT
CLASS="SYMBOL"
>sig</TT
> such that
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
> &#8801; <TT
CLASS="SYMBOL"
>sig</TT
>  2<SUP
>n</SUP
>
scaled such that 1 &#8804; <TT
CLASS="SYMBOL"
>sig</TT
> &#60; 2.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This function is intended for testing conformance to <A
HREF="#STD.FLTPNT"
>IEC 60559/IEEE 754 Floating Point</A
>, and its use is not otherwise
recommended.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>This function is equivalent to <TT
CLASS="LITERAL"
>scalb(x, (double)-ilogb(x))</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24536"
></A
><H2
>Returns</H2
><P
>Upon successful completion, <TT
CLASS="FUNCTION"
>significandl()</TT
> shall return the mantissa of <TT
CLASS="PARAMETER"
><I
>x</I
></TT
>
in the range
1 &#8804; <TT
CLASS="SYMBOL"
>sig</TT
> &#60; 2.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> is 0, HUGE_VALL, or NaN, the result is undefined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24544"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>significand()</TT
>, <TT
CLASS="FUNCTION"
>significandf()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SINCOS"
></A
>sincos</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24556"
></A
><H2
>Name</H2
>sincos&nbsp;--&nbsp;trigonometric functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24559"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24560"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>sincos</TT
></CODE
>(double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, double *
<TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>, double *
<TT
CLASS="PARAMETER"
><I
>cos</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24571"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sincos()</TT
> function shall calculate both the sine and cosine of
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>. 
The sine shall be stored in the location referenced by <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>,
and the cosine in the location referenced by <TT
CLASS="PARAMETER"
><I
>cosine</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24578"
></A
><H2
>Returns</H2
><P
>None. See <TT
CLASS="FUNCTION"
>sin()</TT
> and <TT
CLASS="FUNCTION"
>cos()</TT
> for possible error conditions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24583"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>cos()</TT
>, <TT
CLASS="FUNCTION"
>sin()</TT
>, <TT
CLASS="FUNCTION"
>sincosf()</TT
>, <TT
CLASS="FUNCTION"
>sincosl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SINCOSF"
></A
>sincosf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24599"
></A
><H2
>Name</H2
>sincosf&nbsp;--&nbsp;trigonometric functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24602"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24603"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>sincosf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, float *
<TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>, float *
<TT
CLASS="PARAMETER"
><I
>cos</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24614"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sincosf()</TT
> function shall calculate both the sine and cosine of
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>. 
The sine shall be stored in the location referenced by <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>,
and the cosine in the location referenced by <TT
CLASS="PARAMETER"
><I
>cosine</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24621"
></A
><H2
>Returns</H2
><P
>None. See <TT
CLASS="FUNCTION"
>sin()</TT
> and <TT
CLASS="FUNCTION"
>cos()</TT
> for possible error conditions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24626"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>cos()</TT
>, <TT
CLASS="FUNCTION"
>sin()</TT
>, <TT
CLASS="FUNCTION"
>sincos()</TT
>, <TT
CLASS="FUNCTION"
>sincosl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-SINCOSL"
></A
>sincosl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24642"
></A
><H2
>Name</H2
>sincosl&nbsp;--&nbsp;trigonometric functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24645"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24646"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#define _GNU_SOURCE
#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>sincosl</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, long double *
<TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>, long double *
<TT
CLASS="PARAMETER"
><I
>cos</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24657"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>sincosl()</TT
> function shall calculate both the sine and cosine of
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>. 
The sine shall be stored in the location referenced by <TT
CLASS="PARAMETER"
><I
>sin</I
></TT
>,
and the cosine in the location referenced by <TT
CLASS="PARAMETER"
><I
>cosine</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24664"
></A
><H2
>Returns</H2
><P
>None. See <TT
CLASS="FUNCTION"
>sin()</TT
> and <TT
CLASS="FUNCTION"
>cos()</TT
> for possible error conditions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24669"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>cos()</TT
>, <TT
CLASS="FUNCTION"
>sin()</TT
>, <TT
CLASS="FUNCTION"
>sincos()</TT
>, <TT
CLASS="FUNCTION"
>sincosl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-Y0F"
></A
>y0f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24685"
></A
><H2
>Name</H2
>y0f&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24688"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24689"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>y0f</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24696"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>y0f()</TT
> function is identical to <TT
CLASS="FUNCTION"
>y0()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24703"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>y0()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24707"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-Y0L"
></A
>y0l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24749"
></A
><H2
>Name</H2
>y0l&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24752"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24753"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>y0l</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24760"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>y0l()</TT
> function is identical to <TT
CLASS="FUNCTION"
>y0()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>long double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24767"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>y0()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24771"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-Y1F"
></A
>y1f</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24813"
></A
><H2
>Name</H2
>y1f&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24816"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24817"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>y1f</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24824"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>y1f()</TT
> function is identical to <TT
CLASS="FUNCTION"
>y1()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24831"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>y1()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24835"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-Y1L"
></A
>y1l</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24877"
></A
><H2
>Name</H2
>y1l&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24880"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24881"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>y1l</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24888"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>y1l()</TT
> function is identical to <TT
CLASS="FUNCTION"
>y1()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>long double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24895"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>j0()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24899"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-YNF"
></A
>ynf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN24941"
></A
><H2
>Name</H2
>ynf&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN24944"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN24945"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float
<TT
CLASS="FUNCTION"
>ynf</TT
></CODE
>(float
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24952"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ynf()</TT
> function is identical to <TT
CLASS="FUNCTION"
>yn()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>float</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24959"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>yn()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN24963"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynl()</TT
></P
></DIV
><H1
><A
NAME="BASELIB-YNL"
></A
>ynl</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN25005"
></A
><H2
>Name</H2
>ynl&nbsp;--&nbsp;Bessel functions</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN25008"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN25009"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;math.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long double
<TT
CLASS="FUNCTION"
>ynl</TT
></CODE
>(long double
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25016"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>ynl()</TT
> function is identical to <TT
CLASS="FUNCTION"
>yn()</TT
>, except that
the argument <TT
CLASS="PARAMETER"
><I
>x</I
></TT
> and the return value
is a <SPAN
CLASS="TYPE"
>long double</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25023"
></A
><H2
>Returns</H2
><P
>See <TT
CLASS="FUNCTION"
>yn()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25027"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>j0()</TT
>, <TT
CLASS="FUNCTION"
>j0f()</TT
>, <TT
CLASS="FUNCTION"
>j0l()</TT
>, <TT
CLASS="FUNCTION"
>j1()</TT
>, <TT
CLASS="FUNCTION"
>j1f()</TT
>, <TT
CLASS="FUNCTION"
>j1l()</TT
>, <TT
CLASS="FUNCTION"
>jn()</TT
>, <TT
CLASS="FUNCTION"
>jnf()</TT
>, <TT
CLASS="FUNCTION"
>jnl()</TT
>, <TT
CLASS="FUNCTION"
>y0()</TT
>, <TT
CLASS="FUNCTION"
>y0f()</TT
>, <TT
CLASS="FUNCTION"
>y0l()</TT
>, <TT
CLASS="FUNCTION"
>y1()</TT
>, <TT
CLASS="FUNCTION"
>y1f()</TT
>, <TT
CLASS="FUNCTION"
>y1l()</TT
>, <TT
CLASS="FUNCTION"
>yn()</TT
>, <TT
CLASS="FUNCTION"
>ynf()</TT
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPTHREAD"
>14.9. Interfaces for libpthread</A
></H2
><P
><A
HREF="#LIB-LIBPTHREAD-DEF"
>Table 14-42</A
> defines the library name and shared object name
for the libpthread library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBPTHREAD-DEF"
></A
><P
><B
>Table 14-42. libpthread Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libpthread</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libpthread.so.0</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.1"
></A
>[LFS] <A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.2"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.3"
></A
>[SUSv3] <A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBPTHREAD.4"
></A
>[SUSv4] <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25089"
>14.9.1. Realtime Threads</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25092"
>14.9.1.1. Interfaces for Realtime Threads</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Realtime Threads specified in <A
HREF="#TBL-LIBPTHREAD-REALT-INTS"
>Table 14-43</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-REALT-INTS"
></A
><P
><B
>Table 14-43. libpthread - Realtime Threads Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pthread_attr_getinheritsched <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_getschedpolicy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_getscope <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_setinheritsched <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedpolicy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_setscope <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_getschedparam <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_getprioceiling(GLIBC_2.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_mutex_setprioceiling(GLIBC_2.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getprioceiling(GLIBC_2.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getprotocol(GLIBC_2.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_setprioceiling(GLIBC_2.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_mutexattr_setprotocol(GLIBC_2.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_setschedparam <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_setschedprio(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25165"
>14.9.2. Advanced Realtime Threads</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25168"
>14.9.2.1. Interfaces for Advanced Realtime Threads</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Advanced Realtime Threads specified in <A
HREF="#TBL-LIBPTHREAD-ADVAN-INTS"
>Table 14-44</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-ADVAN-INTS"
></A
><P
><B
>Table 14-44. libpthread - Advanced Realtime Threads Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pthread_barrier_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_barrier_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_barrier_wait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_barrierattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_barrierattr_getpshared(GLIBC_2.3.3) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_barrierattr_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_barrierattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_getcpuclockid <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_spin_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_lock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_trylock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_spin_unlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25235"
>14.9.3. Posix Threads</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25238"
>14.9.3.1. Interfaces for Posix Threads</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Posix Threads specified in <A
HREF="#TBL-LIBPTHREAD-POSIX-INTS"
>Table 14-45</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-POSIX-INTS"
></A
><P
><B
>Table 14-45. libpthread - Posix Threads Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_pthread_cleanup_pop <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>_pthread_cleanup_push <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>pthread_attr_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_getdetachstate <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getguardsize <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_getschedparam <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_getstack <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_getstackaddr <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstacksize <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_setdetachstate <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_setguardsize <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedparam <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_setstack <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_attr_setstackaddr <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setstacksize <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_cancel <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_cond_broadcast <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_cond_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_cond_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_cond_signal <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_cond_timedwait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_cond_wait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_condattr_getclock(GLIBC_2.3.3) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_getpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_setclock(GLIBC_2.3.3) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_condattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_create <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_detach <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_equal <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_exit <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_getconcurrency <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_getspecific <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_join <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_key_create <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_key_delete <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_kill <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_consistent(GLIBC_2.12) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_mutex_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_lock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_timedlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_mutex_trylock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_unlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_mutexattr_getrobust(GLIBC_2.12) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_gettype <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_mutexattr_setrobust(GLIBC_2.12) <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_settype <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_once <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_rwlock_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_rdlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_timedrdlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_timedwrlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_rwlock_tryrdlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_trywrlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_unlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_wrlock <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_rwlockattr_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_getpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_setpshared <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_self <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_setcancelstate <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_setcanceltype <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_setconcurrency <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_setspecific <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_sigmask <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pthread_testcancel <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_close <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sem_destroy <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_getvalue <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_init <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_open <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sem_post <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_timedwait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_trywait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sem_unlink <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sem_wait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Posix Threads specified in <A
HREF="#TBL-LIBPTHREAD-POSIX-DEPINTS"
>Table 14-46</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-POSIX-DEPINTS"
></A
><P
><B
>Table 14-46. libpthread - Posix Threads Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pthread_attr_getstackaddr <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>pthread_attr_setstackaddr <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25630"
>14.9.4. Thread aware versions of libc interfaces</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25633"
>14.9.4.1. Interfaces for Thread aware versions of libc interfaces</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Thread aware versions of libc interfaces specified in <A
HREF="#TBL-LIBPTHREAD-THREA-INTS"
>Table 14-47</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-THREA-INTS"
></A
><P
><B
>Table 14-47. libpthread - Thread aware versions of libc interfaces Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>lseek64 <A
HREF="#REFSTD.LIBPTHREAD.1"
>[LFS]</A
></TD
><TD
>open64 <A
HREF="#REFSTD.LIBPTHREAD.1"
>[LFS]</A
></TD
><TD
>pread <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pread64 <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>pwrite <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>pwrite64 <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25669"
>14.9.5. GNU Extensions for libpthread</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25672"
>14.9.5.1. Interfaces for GNU Extensions for libpthread</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for GNU Extensions for libpthread specified in <A
HREF="#TBL-LIBPTHREAD-GNU-E-INTS"
>Table 14-48</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-GNU-E-INTS"
></A
><P
><B
>Table 14-48. libpthread - GNU Extensions for libpthread Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pthread_getattr_np <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>pthread_mutex_consistent_np <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>pthread_mutexattr_getrobust_np <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>pthread_mutexattr_setrobust_np <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
></TR
><TR
><TD
>pthread_rwlockattr_getkind_np <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>pthread_rwlockattr_setkind_np <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25708"
>14.9.6. System Calls</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25711"
>14.9.6.1. Interfaces for System Calls</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for System Calls specified in <A
HREF="#TBL-LIBPTHREAD-SYSTE-INTS"
>Table 14-49</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-SYSTE-INTS"
></A
><P
><B
>Table 14-49. libpthread - System Calls Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>close <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>fcntl <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>fork <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>fsync <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>lseek <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>msync <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>nanosleep <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>open <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pause <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>read <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>vfork <A
HREF="#REFSTD.LIBPTHREAD.3"
>[SUSv3]</A
></TD
><TD
>wait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>waitpid <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>write <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25781"
>14.9.7. Standard I/O</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25784"
>14.9.7.1. Interfaces for Standard I/O</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Standard I/O specified in <A
HREF="#TBL-LIBPTHREAD-STAND-INTS"
>Table 14-50</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-STAND-INTS"
></A
><P
><B
>Table 14-50. libpthread - Standard I/O Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>flockfile <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25800"
>14.9.8. Signal Handling</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25803"
>14.9.8.1. Interfaces for Signal Handling</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Signal Handling specified in <A
HREF="#TBL-LIBPTHREAD-SIGNA-INTS"
>Table 14-51</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-SIGNA-INTS"
></A
><P
><B
>Table 14-51. libpthread - Signal Handling Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__libc_current_sigrtmax <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>__libc_current_sigrtmin <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>raise <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sigaction <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>siglongjmp <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sigwait <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25839"
>14.9.9. Standard Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25842"
>14.9.9.1. Interfaces for Standard Library</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Standard Library specified in <A
HREF="#TBL-LIBPTHREAD-STANE-INTS"
>Table 14-52</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-STANE-INTS"
></A
><P
><B
>Table 14-52. libpthread - Standard Library Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__errno_location <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>ftrylockfile <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>funlockfile <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>longjmp <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>system <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25875"
>14.9.10. Socket Interface</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25878"
>14.9.10.1. Interfaces for Socket Interface</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Socket Interface specified in <A
HREF="#TBL-LIBPTHREAD-SOCKE-INTS"
>Table 14-53</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-SOCKE-INTS"
></A
><P
><B
>Table 14-53. libpthread - Socket Interface Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__h_errno_location <A
HREF="#REFSTD.LIBPTHREAD.2"
>[LSB]</A
></TD
><TD
>accept <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>connect <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>recv <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>recvfrom <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>recvmsg <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>send <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>sendmsg <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>sendto <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25928"
>14.9.11. Terminal Interface Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN25931"
>14.9.11.1. Interfaces for Terminal Interface Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Terminal Interface Functions specified in <A
HREF="#TBL-LIBPTHREAD-TERMI-INTS"
>Table 14-54</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPTHREAD-TERMI-INTS"
></A
><P
><B
>Table 14-54. libpthread - Terminal Interface Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>tcdrain <A
HREF="#REFSTD.LIBPTHREAD.4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPTHREAD-DDEFS"
>14.10. Data Definitions for libpthread</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libpthread.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25953"
>14.10.1. lsb/pthread.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef unsigned long int pthread_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25957"
>14.10.2. pthread.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define PTHREAD_MUTEX_DEFAULT	0
#define PTHREAD_MUTEX_NORMAL	0
#define PTHREAD_SCOPE_SYSTEM	0
#define PTHREAD_MUTEX_RECURSIVE	1
#define PTHREAD_SCOPE_PROCESS	1
#define PTHREAD_MUTEX_ERRORCHECK	2
#define __SIZEOF_PTHREAD_BARRIERATTR_T	4
#define __SIZEOF_PTHREAD_CONDATTR_T	4
#define __SIZEOF_PTHREAD_MUTEXATTR_T	4
#define __SIZEOF_PTHREAD_COND_T	48
#define __SIZEOF_PTHREAD_RWLOCKATTR_T	8
#define pthread_cleanup_push(routine,arg)	\
        {struct _pthread_cleanup_buffer _buffer;\
        _pthread_cleanup_push(&#38;_buffer,(routine),(arg));
#define pthread_cleanup_pop(execute)	_pthread_cleanup_pop(&#38;_buffer,(execute));}
#define PTHREAD_COND_INITIALIZER	{ { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }

struct _pthread_cleanup_buffer {
    void (*__routine) (void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef volatile int pthread_spinlock_t;
typedef union {
    char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
    int __align;
} pthread_barrierattr_t;
enum {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
};
enum {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
};
enum {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};

typedef union {
    struct __pthread_mutex_s __data;
    char __size[__SIZEOF_PTHREAD_MUTEX_T];
    long int __align;
} pthread_mutex_t;
typedef union {
    char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
    int __align;
} pthread_mutexattr_t;

typedef union {
    char __size[__SIZEOF_PTHREAD_ATTR_T];
    long int __align;
} pthread_attr_t;

typedef union {
    struct {
	int __lock;
	unsigned int __futex;
	unsigned long long int __total_seq;
	unsigned long long int __wakeup_seq;
	unsigned long long int __woken_seq;
	void *__mutex;
	unsigned int __nwaiters;
	unsigned int __broadcast_seq;
    } __data;
    char __size[__SIZEOF_PTHREAD_COND_T];
    long long int __align;
} pthread_cond_t;
typedef union {
    char __size[__SIZEOF_PTHREAD_CONDATTR_T];
    int __align;
} pthread_condattr_t;

typedef union {
    char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
    long int __align;
} pthread_rwlockattr_t;

#define PTHREAD_CREATE_JOINABLE	0
#define PTHREAD_INHERIT_SCHED	0
#define PTHREAD_ONCE_INIT	0
#define PTHREAD_PROCESS_PRIVATE	0
#define PTHREAD_CREATE_DETACHED	1
#define PTHREAD_EXPLICIT_SCHED	1
#define PTHREAD_PROCESS_SHARED	1

#define PTHREAD_CANCELED	((void*)-1)
#define PTHREAD_CANCEL_DEFERRED	0
#define PTHREAD_CANCEL_ENABLE	0
#define PTHREAD_CANCEL_ASYNCHRONOUS	1
#define PTHREAD_CANCEL_DISABLE	1

extern int __register_atfork(void (*)(void), void (*)(void),
			     void (*)(void), void *);
extern void _pthread_cleanup_pop(struct _pthread_cleanup_buffer *, int);
extern void _pthread_cleanup_push(struct _pthread_cleanup_buffer *,
				  void (*)(void *), void *);
extern int pthread_atfork(void (*__prepare) (void),
			  void (*__parent) (void), void (*__child) (void));
extern int pthread_attr_destroy(pthread_attr_t * __attr);
extern int pthread_attr_getdetachstate(const pthread_attr_t * __attr,
				       int *__detachstate);
extern int pthread_attr_getguardsize(const pthread_attr_t * __attr,
				     size_t * __guardsize);
extern int pthread_attr_getinheritsched(const pthread_attr_t * __attr,
					int *__inherit);
extern int pthread_attr_getschedparam(const pthread_attr_t * __attr,
				      struct sched_param *__param);
extern int pthread_attr_getschedpolicy(const pthread_attr_t * __attr,
				       int *__policy);
extern int pthread_attr_getscope(const pthread_attr_t * __attr,
				 int *__scope);
extern int pthread_attr_getstack(const pthread_attr_t * __attr,
				 void **__stackaddr, size_t * __stacksize);
extern int pthread_attr_getstackaddr(const pthread_attr_t * __attr,
				     void **__stackaddr);
extern int pthread_attr_getstacksize(const pthread_attr_t * __attr,
				     size_t * __stacksize);
extern int pthread_attr_init(pthread_attr_t * __attr);
extern int pthread_attr_setdetachstate(pthread_attr_t * __attr,
				       int __detachstate);
extern int pthread_attr_setguardsize(pthread_attr_t * __attr,
				     size_t __guardsize);
extern int pthread_attr_setinheritsched(pthread_attr_t * __attr,
					int __inherit);
extern int pthread_attr_setschedparam(pthread_attr_t * __attr,
				      const struct sched_param *__param);
extern int pthread_attr_setschedpolicy(pthread_attr_t * __attr,
				       int __policy);
extern int pthread_attr_setscope(pthread_attr_t * __attr, int __scope);
extern int pthread_attr_setstack(pthread_attr_t * __attr,
				 void *__stackaddr, size_t __stacksize);
extern int pthread_attr_setstackaddr(pthread_attr_t * __attr,
				     void *__stackaddr);
extern int pthread_attr_setstacksize(pthread_attr_t * __attr,
				     size_t __stacksize);
extern int pthread_barrier_destroy(pthread_barrier_t * __barrier);
extern int pthread_barrier_init(pthread_barrier_t * __barrier,
				const pthread_barrierattr_t * __attr,
				unsigned int __count);
extern int pthread_barrier_wait(pthread_barrier_t * __barrier);
extern int pthread_barrierattr_destroy(pthread_barrierattr_t * __attr);
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *
					  __attr, int *__pshared);
extern int pthread_barrierattr_init(pthread_barrierattr_t * __attr);
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t * __attr,
					  int __pshared);
extern int pthread_cancel(pthread_t __th);
extern int pthread_cond_broadcast(pthread_cond_t * __cond);
extern int pthread_cond_destroy(pthread_cond_t * __cond);
extern int pthread_cond_init(pthread_cond_t * __cond,
			     const pthread_condattr_t * __cond_attr);
extern int pthread_cond_signal(pthread_cond_t * __cond);
extern int pthread_cond_timedwait(pthread_cond_t * __cond,
				  pthread_mutex_t * __mutex,
				  const struct timespec *__abstime);
extern int pthread_cond_wait(pthread_cond_t * __cond,
			     pthread_mutex_t * __mutex);
extern int pthread_condattr_destroy(pthread_condattr_t * __attr);
extern int pthread_condattr_getclock(const pthread_condattr_t * attr,
				     clockid_t * clock_id);
extern int pthread_condattr_getpshared(const pthread_condattr_t * __attr,
				       int *__pshared);
extern int pthread_condattr_init(pthread_condattr_t * __attr);
extern int pthread_condattr_setclock(pthread_condattr_t * attr,
				     clockid_t clock_id);
extern int pthread_condattr_setpshared(pthread_condattr_t * __attr,
				       int __pshared);
extern int pthread_create(pthread_t * __newthread,
			  const pthread_attr_t * __attr,
			  void *(*__start_routine) (void *), void *__arg);
extern int pthread_detach(pthread_t __th);
extern int pthread_equal(pthread_t __thread1, pthread_t __thread2);
extern void pthread_exit(void *__retval);
extern int pthread_getattr_np(pthread_t thread, pthread_attr_t * attr);
extern int pthread_getconcurrency(void);
extern int pthread_getcpuclockid(pthread_t __thread_id,
				 clockid_t * __clock_id);
extern int pthread_getschedparam(pthread_t __target_thread, int *__policy,
				 struct sched_param *__param);
extern void *pthread_getspecific(pthread_key_t __key);
extern int pthread_join(pthread_t __th, void **__thread_return);
extern int pthread_key_create(pthread_key_t * __key,
			      void (*__destr_function) (void *));
extern int pthread_key_delete(pthread_key_t __key);
extern int pthread_mutex_consistent(pthread_mutex_t * mutex);
extern int pthread_mutex_consistent_np(pthread_mutex_t * __mutex);
extern int pthread_mutex_destroy(pthread_mutex_t * __mutex);
extern int pthread_mutex_getprioceiling(const pthread_mutex_t * __mutex,
					int *__prioceiling);
extern int pthread_mutex_init(pthread_mutex_t * __mutex,
			      const pthread_mutexattr_t * __mutexattr);
extern int pthread_mutex_lock(pthread_mutex_t * __mutex);
extern int pthread_mutex_setprioceiling(pthread_mutex_t * __mutex,
					int __prioceiling,
					int *__old_ceiling);
extern int pthread_mutex_timedlock(pthread_mutex_t * __mutex,
				   const struct timespec *__abstime);
extern int pthread_mutex_trylock(pthread_mutex_t * __mutex);
extern int pthread_mutex_unlock(pthread_mutex_t * __mutex);
extern int pthread_mutexattr_destroy(pthread_mutexattr_t * __attr);
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *
					    __attr, int *__prioceiling);
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *
					 __attr, int *__protocol);
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t * __attr,
					int *__pshared);
extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t * attr,
				       int *robust);
extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *
					  __attr, int *__robustness);
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t * __attr,
				     int *__kind);
extern int pthread_mutexattr_init(pthread_mutexattr_t * __attr);
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * __attr,
					    int __prioceiling);
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t * __attr,
					 int __protocol);
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t * __attr,
					int __pshared);
extern int pthread_mutexattr_setrobust(pthread_mutexattr_t * attr,
				       int robust);
extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * __attr,
					  int __robustness);
extern int pthread_mutexattr_settype(pthread_mutexattr_t * __attr,
				     int __kind);
extern int pthread_once(pthread_once_t * __once_control,
			void (*__init_routine) (void));
extern int pthread_rwlock_destroy(pthread_rwlock_t * __rwlock);
extern int pthread_rwlock_init(pthread_rwlock_t * __rwlock,
			       const pthread_rwlockattr_t * __attr);
extern int pthread_rwlock_rdlock(pthread_rwlock_t * __rwlock);
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t * __rwlock,
				      const struct timespec *__abstime);
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t * __rwlock,
				      const struct timespec *__abstime);
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t * __rwlock);
extern int pthread_rwlock_trywrlock(pthread_rwlock_t * __rwlock);
extern int pthread_rwlock_unlock(pthread_rwlock_t * __rwlock);
extern int pthread_rwlock_wrlock(pthread_rwlock_t * __rwlock);
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t * __attr);
extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *
					 __attr, int *__pref);
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *
					 __attr, int *__pshared);
extern int pthread_rwlockattr_init(pthread_rwlockattr_t * __attr);
extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t * __attr,
					 int __pref);
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * __attr,
					 int __pshared);
extern pthread_t pthread_self(void);
extern int pthread_setcancelstate(int __state, int *__oldstate);
extern int pthread_setcanceltype(int __type, int *__oldtype);
extern int pthread_setconcurrency(int __level);
extern int pthread_setschedparam(pthread_t __target_thread, int __policy,
				 const struct sched_param *__param);
extern int pthread_setschedprio(pthread_t __target_thread, int __prio);
extern int pthread_setspecific(pthread_key_t __key, const void *__pointer);
extern int pthread_spin_destroy(pthread_spinlock_t * __lock);
extern int pthread_spin_init(pthread_spinlock_t * __lock, int __pshared);
extern int pthread_spin_lock(pthread_spinlock_t * __lock);
extern int pthread_spin_trylock(pthread_spinlock_t * __lock);
extern int pthread_spin_unlock(pthread_spinlock_t * __lock);
extern void pthread_testcancel(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN25961"
>14.10.3. semaphore.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef union {
    char __size[__SIZEOF_SEM_T];
    long int __align;
} sem_t;

#define SEM_FAILED	((sem_t*)0)

#define SEM_VALUE_MAX	((int)((~0u)&#62;&#62;1))

extern int sem_close(sem_t * __sem);
extern int sem_destroy(sem_t * __sem);
extern int sem_getvalue(sem_t * __sem, int *__sval);
extern int sem_init(sem_t * __sem, int __pshared, unsigned int __value);
extern sem_t *sem_open(const char *__name, int __oflag, ...);
extern int sem_post(sem_t * __sem);
extern int sem_timedwait(sem_t * __sem, const struct timespec *__abstime);
extern int sem_trywait(sem_t * __sem);
extern int sem_unlink(const char *__name);
extern int sem_wait(sem_t * __sem);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPTHREADMAN"
>14.11. Interface Definitions for libpthread</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-POP"
>_pthread_cleanup_pop</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
><DT
><A
HREF="#BASELIB--PTHREAD-CLEANUP-PUSH"
>_pthread_cleanup_push</A
>&nbsp;--&nbsp;establish cancellation handlers</DT
><DT
><A
HREF="#BASELIB-PTHREAD-GETATTR-NP-1"
>pthread_getattr_np</A
>&nbsp;--&nbsp;get thread attributes</DT
><DT
><A
HREF="#BASELIB-PTHREAD-MUTEX-CONSISTENT-NP-1"
>pthread_mutex_consistent_np</A
>&nbsp;--&nbsp;mark state protected by robust mutex as consistent</DT
><DT
><A
HREF="#BASELIB-PTHREAD-MUTEXATTR-GETROBUST-NP-1"
>pthread_mutexattr_getrobust_np, pthread_mutexattr_setrobust_np</A
>&nbsp;--&nbsp;get and set the mutex robust attribute</DT
><DT
><A
HREF="#BASELIB-PTHREAD-RWLOCKATTR-GETKIND-NP-1"
>pthread_rwlockattr_getkind_np, pthread_rwlockattr_setkind_np</A
>&nbsp;--&nbsp;get/set the read-write lock kind of the thread read-write lock attribute object</DT
><DT
><A
HREF="#BASELIB-WAITPID-3"
>waitpid</A
>&nbsp;--&nbsp;wait for child process</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libpthread and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBPTHREAD"
>Section 14.9</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB--PTHREAD-CLEANUP-POP"
></A
>_pthread_cleanup_pop</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN25974"
></A
><H2
>Name</H2
>_pthread_cleanup_pop&nbsp;--&nbsp;establish cancellation handlers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN25977"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN25978"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>_pthread_cleanup_pop</TT
></CODE
>(struct _pthread_cleanup_buffer *, int);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN25985"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_pop()</TT
> function provides
an implementation of the <TT
CLASS="FUNCTION"
>pthread_cleanup_pop()</TT
> macro
described in
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>.</P
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_pop()</TT
> function is not in the
source standard; it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB--PTHREAD-CLEANUP-PUSH"
></A
>_pthread_cleanup_push</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN25998"
></A
><H2
>Name</H2
>_pthread_cleanup_push&nbsp;--&nbsp;establish cancellation handlers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26001"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26002"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>_pthread_cleanup_push</TT
></CODE
>(struct _pthread_cleanup_buffer *, void (*) (void *), void *);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26010"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_push()</TT
> function provides
an implementation of the <TT
CLASS="FUNCTION"
>pthread_cleanup_push()</TT
> macro
described in
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>.</P
><P
>The <TT
CLASS="FUNCTION"
>_pthread_cleanup_push()</TT
> function is not in the
source standard; it is only in the binary standard.</P
></DIV
><H1
><A
NAME="BASELIB-PTHREAD-GETATTR-NP-1"
></A
>pthread_getattr_np</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26023"
></A
><H2
>Name</H2
>pthread_getattr_np&nbsp;--&nbsp;get thread attributes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26028"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26029"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pthread_getattr_np</TT
></CODE
>(pthread_t <TT
CLASS="PARAMETER"
><I
>thread</I
></TT
>, pthread_attr_t *<TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26038"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pthread_getattr_np()</TT
>
fills in the thread attribute object <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>
with attribute values describing the running thread
<TT
CLASS="PARAMETER"
><I
>thread</I
></TT
>.  This is useful to detect
runtime changes from the values specified in the
thread attributes object used to create the thread with
<TT
CLASS="FUNCTION"
>pthread_create()</TT
>.
The following differences may be noted:</P
><P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>The detach state, since
a joinable thread may  have  detached  itself after creation.
Use <TT
CLASS="FUNCTION"
>pthread_attr_getdetachstate()</TT
> to extract
from <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>The stack size,
which the implementation may align to a suitable boundary.
Use <TT
CLASS="FUNCTION"
>pthread_attr_getstack()</TT
> to extract
from <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>The guard size,
which the implementation may round upwards to a
multiple of the page size, or ignore (i.e., treat as 0), 
if the application is allocating its own stack.
Use <TT
CLASS="FUNCTION"
>pthread_attr_getguardsize()</TT
> to extract
from <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>.</P
></LI
></UL
><P
>If the stack address attribute was not set in the thread attributes
object  used to create the thread, then the thread attributes
object returned by
<TT
CLASS="FUNCTION"
>pthread_getattr_np()</TT
>
will show the actual stack address the implementation
selected for the thread.
Use <TT
CLASS="FUNCTION"
>pthread_attr_getstack()</TT
> to extract
from <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>.</P
><P
>The thread attributes object <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>
should be destroyed using <TT
CLASS="FUNCTION"
>pthread_attr_destroy()</TT
>
when it is no longer needed.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26065"
></A
><H2
>Return Value</H2
><P
>On success,
<TT
CLASS="FUNCTION"
>pthread_getattr_np()</TT
>
returns 0; on error, it returns a non-zero error number.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26069"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26072"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory to complete the operation.</P
></TD
></TR
></TBODY
></TABLE
><P
>In addition, if <TT
CLASS="PARAMETER"
><I
>thread</I
></TT
> refers to the
main thread, then
<TT
CLASS="FUNCTION"
>pthread_getattr_np()</TT
>
may also fail due to errors from various underlying calls:
<TT
CLASS="FUNCTION"
>fopen()</TT
>, if
the pseudo-file containing the memory region map cannot be opened;
<TT
CLASS="FUNCTION"
>getrlimit()</TT
> if the <CODE
CLASS="CONSTANT"
>RLIMIT_STACK</CODE
>
resource limit it not supported.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26082"
></A
><H2
>Notes</H2
><P
>This function is a <TT
CLASS="LITERAL"
>GNU</TT
> extension.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26086"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>pthread_attr_destroy()</TT
>,
<TT
CLASS="FUNCTION"
>pthread_attr_getdetachstate()</TT
>,
<TT
CLASS="FUNCTION"
>pthread_attr_getguardsize()</TT
>,
<TT
CLASS="FUNCTION"
>pthread_attr_getstack()</TT
>,
<TT
CLASS="FUNCTION"
>pthread_create()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-PTHREAD-MUTEX-CONSISTENT-NP-1"
></A
>pthread_mutex_consistent_np</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26098"
></A
><H2
>Name</H2
>pthread_mutex_consistent_np&nbsp;--&nbsp;mark state protected by robust mutex as consistent</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26103"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26104"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pthread_mutex_consistent_np</TT
></CODE
>(pthread_mutex_t *
<TT
CLASS="PARAMETER"
><I
>__mutex</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26111"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pthread_mutex_consistent_np()</TT
> 
shall behave as described for
<TT
CLASS="FUNCTION"
>pthread_mutex_consistent()</TT
> 
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-PTHREAD-MUTEXATTR-GETROBUST-NP-1"
></A
>pthread_mutexattr_getrobust_np, pthread_mutexattr_setrobust_np</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26121"
></A
><H2
>Name</H2
>pthread_mutexattr_getrobust_np, pthread_mutexattr_setrobust_np&nbsp;--&nbsp;get and set the mutex robust attribute</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26128"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26129"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pthread_mutexattr_getrobust_np</TT
></CODE
>(const pthread_mutexattr_t *
<TT
CLASS="PARAMETER"
><I
>__attr</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>__robustness</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pthread_mutexattr_setrobust_np</TT
></CODE
>(const pthread_mutexattr_t *
<TT
CLASS="PARAMETER"
><I
>__attr</I
></TT
>, int 
<TT
CLASS="PARAMETER"
><I
>__robustness</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26145"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pthread_mutexattr_setrobust_np()</TT
> 
shall behave as described for
<TT
CLASS="FUNCTION"
>pthread_mutexattr_setrobust()</TT
> 
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
><TT
CLASS="FUNCTION"
>pthread_mutexattr_getrobust_np()</TT
> 
shall behave as described for
<TT
CLASS="FUNCTION"
>pthread_mutexattr_getrobust()</TT
> 
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
>Two additional valid values are defined for 
<TT
CLASS="PARAMETER"
><I
>__robustness</I
></TT
>:
<CODE
CLASS="CONSTANT"
>PTHREAD_MUTEX_STALLED_NP</CODE
>,
which is identical to 
<CODE
CLASS="CONSTANT"
>PTHREAD_MUTEX_STALLED</CODE
>
and
<CODE
CLASS="CONSTANT"
>PTHREAD_MUTEX_ROBUST_NP</CODE
>,
which is identical to 
<CODE
CLASS="CONSTANT"
>PTHREAD_MUTEX_ROBUST</CODE
>.</P
></DIV
><H1
><A
NAME="BASELIB-PTHREAD-RWLOCKATTR-GETKIND-NP-1"
></A
>pthread_rwlockattr_getkind_np, pthread_rwlockattr_setkind_np</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26165"
></A
><H2
>Name</H2
>pthread_rwlockattr_getkind_np, pthread_rwlockattr_setkind_np&nbsp;--&nbsp;get/set the read-write lock kind of the thread read-write lock attribute object</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26172"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26173"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pthread.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pthread_rwlockattr_getkind_np</TT
></CODE
>(const pthread_rwlockattr_t *
<TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>pref</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pthread_rwlockattr_setkind_np</TT
></CODE
>(pthread_rwlockattr_t *
<TT
CLASS="PARAMETER"
><I
>attr</I
></TT
>, int *
<TT
CLASS="PARAMETER"
><I
>pref</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26189"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pthread_rwlockattr_setkind_np()</TT
> function sets the kind 
of read-write lock of the thread read-write lock attribute object referred to
by attr to the value specified with pref. The argument pref may be set
to <CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_READER_NP</CODE
>,
<CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</CODE
>,
or <CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_WRITER_NP</CODE
>.
The default lock setting is <CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_READER_NP</CODE
>.
A thread may hold multiple read locks, i.e. read locks are recursive.
According to The Single Unix Specification, the behavior is unspecified when 
a reader tries to place a lock, and there is no write lock but writers are 
waiting. Giving preference to the reader, as is set by default with 
the <CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_READER_NP</CODE
> value implies
that the reader will receive the requested lock, even if a writer is waiting.
As long as there are readers the writer will be starved. Setting the kind to
<CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</CODE
>, avoids writer
starvation as long as any read locking is not done in a recursive fashion.

The <TT
CLASS="FUNCTION"
>pthread_rwlockattr_getkind_np()</TT
> function returns the 
value of the read-write lock attribute of the thread read-write lock attribute
object referred to by <TT
CLASS="PARAMETER"
><I
>attr</I
></TT
> in the pointer <TT
CLASS="PARAMETER"
><I
>pref</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26202"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>pthread_rwlockattr_setkind_np()</TT
> function returns 0 on success; on error, it returns a non-zero error number.

<TT
CLASS="FUNCTION"
>pthread_rwlockattr_setkind_np()</TT
> function always returns 0.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26207"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26210"
></A
><SPAN
STYLE="white-space: nowrap"
>EINVAL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>pref</I
></TT
> is set to an unsupported value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26215"
></A
><H2
>Notes</H2
><P
>Setting the value read-write lock kind to <CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_WRITER_NP</CODE
>,
results in the same behavior as setting the value to
<CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_READER_NP</CODE
>. As long as a reader thread holds the
lock the thread holding a write lock will be starved. Setting the kind
value to <CODE
CLASS="CONSTANT"
>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</CODE
>, allows the
writer to run. However, the writer may not be recursive as is implied by the name. </P
></DIV
><H1
><A
NAME="BASELIB-WAITPID-3"
></A
>waitpid</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26225"
></A
><H2
>Name</H2
>waitpid&nbsp;--&nbsp;wait for child process</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26228"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>waitpid()</TT
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN26233"
></A
><H3
>Need not support <TT
CLASS="SYMBOL"
>WCONTINUED</TT
> or
<TT
CLASS="SYMBOL"
>WIFCONTINUED</TT
></H3
><P
>Implementations need not support the XSI optional functionality of 
<TT
CLASS="FUNCTION"
>WCONTINUED()</TT
> or <TT
CLASS="FUNCTION"
>WIFCONTINUED()</TT
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBGCC-S"
>14.12. Interfaces for libgcc_s</A
></H2
><P
><A
HREF="#LIB-LIBGCC-S-DEF"
>Table 14-55</A
> defines the library name and shared object name
for the libgcc_s library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBGCC-S-DEF"
></A
><P
><B
>Table 14-55. libgcc_s Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libgcc_s</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libgcc_s.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBGCC.S.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26258"
>14.12.1. Unwind Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26261"
>14.12.1.1. Interfaces for Unwind Library</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Unwind Library specified in <A
HREF="#TBL-LIBGCC-S-UNWIN-INTS"
>Table 14-56</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBGCC-S-UNWIN-INTS"
></A
><P
><B
>Table 14-56. libgcc_s - Unwind Library Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Unwind_Backtrace <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_DeleteException <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_FindEnclosingFunction <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_ForcedUnwind <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_GetCFA <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_GetGR <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_GetIP <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_GetIPInfo(GCC_4.2.0) <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_GetLanguageSpecificData <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_GetRegionStart <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_RaiseException <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_Resume <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_Resume_or_Rethrow <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_SetGR <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>_Unwind_SetIP <A
HREF="#REFSTD.LIBGCC.S.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBGCC-S-DDEFS"
>14.13. Data Definitions for libgcc_s</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libgcc_s.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26340"
>14.13.1. unwind.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct _Unwind_Context;
struct _Unwind_Exception;

typedef unsigned int _Unwind_Ptr __attribute__ ((__mode__(__pointer__)));
typedef unsigned int _Unwind_Word __attribute__ ((__mode__(__word__)));
typedef unsigned int _Unwind_Exception_Class
    __attribute__ ((__mode__(__DI__)));

typedef enum {
    _URC_NO_REASON = 0,
    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
    _URC_FATAL_PHASE2_ERROR = 2,
    _URC_FATAL_PHASE1_ERROR = 3,
    _URC_NORMAL_STOP = 4,
    _URC_END_OF_STACK = 5,
    _URC_HANDLER_FOUND = 6,
    _URC_INSTALL_CONTEXT = 7,
    _URC_CONTINUE_UNWIND = 8
} _Unwind_Reason_Code;

typedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,
					      struct _Unwind_Exception *);

struct _Unwind_Exception {
    _Unwind_Exception_Class exception_class;
    _Unwind_Exception_Cleanup_Fn exception_cleanup;
    _Unwind_Word private_1;
    _Unwind_Word private_2;
} __attribute__ ((__aligned__));

#define _UA_SEARCH_PHASE	1
#define _UA_END_OF_STACK	16
#define _UA_CLEANUP_PHASE	2
#define _UA_HANDLER_FRAME	4
#define _UA_FORCE_UNWIND	8

typedef int _Unwind_Action;

typedef _Unwind_Reason_Code(*_Unwind_Stop_Fn) (int version,
					       _Unwind_Action actions,
					       _Unwind_Exception_Class
					       exceptionClass,
					       struct _Unwind_Exception *
					       exceptionObject,
					       struct _Unwind_Context *
					       context,
					       void *stop_parameter);

typedef _Unwind_Reason_Code(*_Unwind_Trace_Fn) (struct _Unwind_Context *,
						void *);
extern _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn, void *);
extern void _Unwind_DeleteException(struct _Unwind_Exception *);
extern void *_Unwind_FindEnclosingFunction(void *);
extern _Unwind_Reason_Code _Unwind_ForcedUnwind(struct _Unwind_Exception *,
						_Unwind_Stop_Fn, void *);
extern _Unwind_Word _Unwind_GetCFA(struct _Unwind_Context *);
extern _Unwind_Word _Unwind_GetGR(struct _Unwind_Context *, int);
extern _Unwind_Ptr _Unwind_GetIP(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetIPInfo(struct _Unwind_Context *, int *);
extern void *_Unwind_GetLanguageSpecificData(struct _Unwind_Context *);
extern _Unwind_Ptr _Unwind_GetRegionStart(struct _Unwind_Context *);
extern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception
						  *);
extern void _Unwind_Resume(struct _Unwind_Exception *);
extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct
						     _Unwind_Exception *);
extern void _Unwind_SetGR(struct _Unwind_Context *, int, u_int64_t);
extern void _Unwind_SetIP(struct _Unwind_Context *, _Unwind_Ptr);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBGCC-SMAN"
>14.14. Interface Definitions for libgcc_s</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB--UNWIND-BACKTRACE"
>_Unwind_Backtrace</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-DELETEEXCEPTION"
>_Unwind_DeleteException</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-FINDENCLOSINGFUNCTION"
>_Unwind_FindEnclosingFunction</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-FORCEDUNWIND-1"
>_Unwind_ForcedUnwind</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETCFA"
>_Unwind_GetCFA</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETGR"
>_Unwind_GetGR</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETIP"
>_Unwind_GetIP</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETIPINFO"
>_Unwind_GetIPInfo</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETLANGUAGESPECIFICDATA-1"
>_Unwind_GetLanguageSpecificData</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-GETREGIONSTART"
>_Unwind_GetRegionStart</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-RAISEEXCEPTION"
>_Unwind_RaiseException</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-RESUME"
>_Unwind_Resume</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-RESUME-OR-RETHROW"
>_Unwind_Resume_or_Rethrow</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-SETGR"
>_Unwind_SetGR</A
>&nbsp;--&nbsp;private C++ error handling method</DT
><DT
><A
HREF="#BASELIB--UNWIND-SETIP-1"
>_Unwind_SetIP</A
>&nbsp;--&nbsp;private C++ error handling method</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libgcc_s and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBGCC-S"
>Section 14.12</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB--UNWIND-BACKTRACE"
></A
>_Unwind_Backtrace</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26353"
></A
><H2
>Name</H2
>_Unwind_Backtrace&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26356"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26359"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Reason_Code
  <TT
CLASS="FUNCTION"
>_Unwind_Backtrace</TT
></CODE
>(_Unwind_Trace_Fn
  <TT
CLASS="PARAMETER"
><I
>trace</I
></TT
>, void *
  <TT
CLASS="PARAMETER"
><I
>trace_argument</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26367"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_Backtrace()</TT
> 
performs a stack backtrace using unwind data.
The <TT
CLASS="PARAMETER"
><I
>trace</I
></TT
> callback is called for 
every stack frame in the call chain.

No cleanup actions are performed.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-DELETEEXCEPTION"
></A
>_Unwind_DeleteException</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26378"
></A
><H2
>Name</H2
>_Unwind_DeleteException&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26381"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26384"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void 
  <TT
CLASS="FUNCTION"
>_Unwind_DeleteException</TT
></CODE
>(struct _Unwind_Exception *
  <TT
CLASS="PARAMETER"
><I
>object</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26390"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_DeleteException()</TT
> deletes the given exception
<TT
CLASS="PARAMETER"
><I
>object</I
></TT
>. If a given runtime resumes normal
execution after catching a foreign exception, it will not know how to
delete that exception. Such an exception shall be deleted by calling
<TT
CLASS="FUNCTION"
>_Unwind_DeleteException()</TT
>. This is a convenience
function that calls the function pointed to by the 
<I
CLASS="EMPHASIS"
>exception_cleanup</I
> field of the exception header.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-FINDENCLOSINGFUNCTION"
></A
>_Unwind_FindEnclosingFunction</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26403"
></A
><H2
>Name</H2
>_Unwind_FindEnclosingFunction&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26406"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26409"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
  <TT
CLASS="FUNCTION"
>_Unwind_FindEnclosingFunction</TT
></CODE
>(void *
  <TT
CLASS="PARAMETER"
><I
>ip</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26415"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_FindEnclosingFunction()</TT
> 
Find the start address of the procedure containing the specified
<TT
CLASS="PARAMETER"
><I
>ip</I
></TT
> or NULL if it cannot be found 
(for example, because the function has no unwind info).</P
><P
>Note that there is not necessarily a one-to-one correspondence between 
source level functions and procedures. Some functions do not have
unwind-info and others are split into multiple procedures.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-FORCEDUNWIND-1"
></A
>_Unwind_ForcedUnwind</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26427"
></A
><H2
>Name</H2
>_Unwind_ForcedUnwind&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26432"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26433"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unwind.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Reason_Code
<TT
CLASS="FUNCTION"
>_Unwind_ForcedUnwind</TT
></CODE
>(struct _Unwind_Exception *
<TT
CLASS="PARAMETER"
><I
>object</I
></TT
>, _Unwind_Stop_Fn
<TT
CLASS="PARAMETER"
><I
>stop</I
></TT
>, void *
<TT
CLASS="PARAMETER"
><I
>stop_parameter</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26444"
></A
><H2
>Description</H2
><P
>Forced unwinding is a single-phase process. <TT
CLASS="PARAMETER"
><I
>stop</I
></TT
>
and <TT
CLASS="PARAMETER"
><I
>stop_parameter</I
></TT
> control the termination of the
unwind process instead of the usual personality routine query.
Stop function <TT
CLASS="PARAMETER"
><I
>stop</I
></TT
> is called for each unwind frame,
with the parameteres described for the usual personality routine below,
plus an additional <TT
CLASS="PARAMETER"
><I
>stop_parameter</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26451"
></A
><H2
>Return Value</H2
><P
>When <TT
CLASS="PARAMETER"
><I
>stop</I
></TT
> identifies the destination frame, it
transfers control to the user code as appropriate without returning,
normally after calling <TT
CLASS="FUNCTION"
>_Unwind_DeleteException()</TT
>. If not,
then it should return an <CODE
CLASS="VARNAME"
>_Unwind_Reason_Code</CODE
> value.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>stop</I
></TT
> returns any reason code other than
<TT
CLASS="SYMBOL"
>_URC_NO_REASON</TT
>, then the stack state is indeterminate
from the point of view of the caller of
<TT
CLASS="FUNCTION"
>_Unwind_ForcedUnwind()</TT
>. Rather than attempt to return,
therefore, the unwind library should use the
<CODE
CLASS="STRUCTFIELD"
>exception_cleanup</CODE
> entry in 
<TT
CLASS="PARAMETER"
><I
>object</I
></TT
>, and then
call <TT
CLASS="FUNCTION"
>abort()</TT
>.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>_URC_NO_REASON</DT
><DD
><P
>This is not the destination from. The unwind runtime will call frame's
personality routine with the <CODE
CLASS="VARNAME"
>_UA_FORCE_UNWIND</CODE
>
and <CODE
CLASS="VARNAME"
>_UA_CLEANUP_PHASE</CODE
> flag set in
<I
CLASS="EMPHASIS"
>actions</I
>, and then unwind to the next frame
and call the <TT
CLASS="FUNCTION"
>stop()</TT
> function again.</P
></DD
><DT
>_URC_END_OF_STACK</DT
><DD
><P
>In order to allow <TT
CLASS="FUNCTION"
>_Unwind_ForcedUnwind()</TT
> to
perform special processing when it reaches the end of the stack, the
unwind runtime will call it after the last frame is rejected, with a
<CODE
CLASS="CONSTANT"
>NULL</CODE
> stack pointer in the context, and the
<TT
CLASS="FUNCTION"
>STOP()</TT
> FUNCTION SHALL CATCH THIS CONDITION. iT MAY
return this code if it cannot handle end-of-stack.</P
></DD
><DT
>_URC_FATAL_PHASE2_ERROR</DT
><DD
><P
>The <TT
CLASS="FUNCTION"
>stop()</TT
> function may return this code for other fatal
conditions like stack corruption.</P
></DD
></DL
></DIV
></DIV
><H1
><A
NAME="BASELIB--UNWIND-GETCFA"
></A
>_Unwind_GetCFA</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26489"
></A
><H2
>Name</H2
>_Unwind_GetCFA&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26492"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26495"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Word
  <TT
CLASS="FUNCTION"
>_Unwind_GetCFA</TT
></CODE
>(struct _Unwind_Context *
  <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26501"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_GetCFA()</TT
> 
shall retrieve the value of the Canonical Frame Address (CFA)
of the given <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-GETGR"
></A
>_Unwind_GetGR</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26512"
></A
><H2
>Name</H2
>_Unwind_GetGR&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26515"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26518"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Word
  <TT
CLASS="FUNCTION"
>_Unwind_GetGR</TT
></CODE
>(struct _Unwind_Context *
  <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>index</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26527"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_GetGR()</TT
> returns data at
<TT
CLASS="PARAMETER"
><I
>index</I
></TT
> found in <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>.
The register is identified by its index: <TT
CLASS="LITERAL"
>0</TT
> to 
<TT
CLASS="LITERAL"
>31</TT
> are for the fixed registers, and 
<TT
CLASS="LITERAL"
>32</TT
> to <TT
CLASS="LITERAL"
>127</TT
> are for the stacked 
registers.</P
><P
>During the two phases of unwinding, only <SPAN
CLASS="TOKEN"
>GR1</SPAN
> has 
a guaranteed value, which is the global pointer of the frame referenced 
by the unwind <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>. If the register has its 
<SPAN
CLASS="TOKEN"
>NAT</SPAN
> bit set, the behavior is unspecified.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-GETIP"
></A
>_Unwind_GetIP</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26547"
></A
><H2
>Name</H2
>_Unwind_GetIP&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26550"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26553"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Ptr
  <TT
CLASS="FUNCTION"
>_Unwind_GetIP</TT
></CODE
>(struct _Unwind_Context *
  <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26559"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_GetIP()</TT
> 
returns the instruction pointer value for the routine identified by the 
unwind <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-GETIPINFO"
></A
>_Unwind_GetIPInfo</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26570"
></A
><H2
>Name</H2
>_Unwind_GetIPInfo&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26573"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26576"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Ptr
  <TT
CLASS="FUNCTION"
>_Unwind_GetIPInfo</TT
></CODE
>(struct _Unwind_Context *
  <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>, int *
  <TT
CLASS="PARAMETER"
><I
>ip_before_insn</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26584"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_GetIPInfo()</TT
> 
returns the instruction pointer value for the routine identified by the 
unwind <TT
CLASS="PARAMETER"
><I
>context</I
></TT
> and sets 
<TT
CLASS="PARAMETER"
><I
>ip_before_insn</I
></TT
> flag indicating whether that IP 
is before or after first not yet fully executed instruction.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-GETLANGUAGESPECIFICDATA-1"
></A
>_Unwind_GetLanguageSpecificData</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26596"
></A
><H2
>Name</H2
>_Unwind_GetLanguageSpecificData&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26601"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26602"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unwind.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Ptr
<TT
CLASS="FUNCTION"
>_Unwind_GetLanguageSpecificData</TT
></CODE
>(struct _Unwind_Context *
<TT
CLASS="PARAMETER"
><I
>context</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26609"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_GetLanguageSpecificData()</TT
>
returns the address of the language specific data area for the
current stack frame described by <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-GETREGIONSTART"
></A
>_Unwind_GetRegionStart</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26618"
></A
><H2
>Name</H2
>_Unwind_GetRegionStart&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26621"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26624"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Ptr
  <TT
CLASS="FUNCTION"
>_Unwind_GetRegionStart</TT
></CODE
>(struct _Unwind_Context *
  <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26630"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_GetRegionStart()</TT
> routine returns the address 
(i.e., <TT
CLASS="LITERAL"
>0</TT
>) of the beginning of the procedure or code
fragment described by the current unwind descriptor block.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-RAISEEXCEPTION"
></A
>_Unwind_RaiseException</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26641"
></A
><H2
>Name</H2
>_Unwind_RaiseException&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26644"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26647"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Reason_Code
  <TT
CLASS="FUNCTION"
>_Unwind_RaiseException</TT
></CODE
>(struct _Unwind_Exception *
  <TT
CLASS="PARAMETER"
><I
>object</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26653"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_RaiseException()</TT
> 
raises an exception, passing along the given exception 
<TT
CLASS="PARAMETER"
><I
>object</I
></TT
>, which should have its 
<CODE
CLASS="STRUCTFIELD"
>exception_class</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>exception_cleanup</CODE
> fields set. 
The exception object has been allocated by the language-specific
runtime, and has a language-specific format, exception that it shall
contain an <CODE
CLASS="VARNAME"
>_Unwind_Exception</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26663"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_RaiseException()</TT
> does not return unless an
error condition is found. If an error condition occurs, an 
<CODE
CLASS="VARNAME"
>_Unwind_Reason_Code</CODE
> is returnd:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>_URC_END_OF_STACK</DT
><DD
><P
>The unwinder encountered the end of the stack during phase one without 
finding a handler. The unwind runtime will not have modified the stack. 
The C++ runtime will normally call <TT
CLASS="FUNCTION"
>uncaught_exception()</TT
> 
in this case.</P
></DD
><DT
>_URC_FATAL_PHASE1_ERROR</DT
><DD
><P
>The unwinder encountered an unexpected error during phase one, because
of something like stack corruption. The unwind runtime will not have 
modified the stack. The C++ runtime will normally call 
<TT
CLASS="FUNCTION"
>terminate()</TT
> in this case.</P
></DD
><DT
>_URC_FATAL_PHASE2_ERROR</DT
><DD
><P
>The unwinder encountered an unexpected error during phase two.
This is usually a <I
CLASS="EMPHASIS"
>throw</I
>, which will call 
<TT
CLASS="FUNCTION"
>terminate()</TT
>.</P
></DD
></DL
></DIV
></DIV
><H1
><A
NAME="BASELIB--UNWIND-RESUME"
></A
>_Unwind_Resume</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26689"
></A
><H2
>Name</H2
>_Unwind_Resume&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26692"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26695"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
  <TT
CLASS="FUNCTION"
>_Unwind_Resume</TT
></CODE
>(struct _Unwind_Exception *
  <TT
CLASS="PARAMETER"
><I
>object</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26701"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_Resume()</TT
> 
resumes propagation of an existing exception <TT
CLASS="PARAMETER"
><I
>object</I
></TT
>.
A call to this routine is inserted as the end of a landing pad that
performs cleanup, but does not resume normal execution. It causes
unwinding to proceed further.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-RESUME-OR-RETHROW"
></A
>_Unwind_Resume_or_Rethrow</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26712"
></A
><H2
>Name</H2
>_Unwind_Resume_or_Rethrow&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26715"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26718"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>_Unwind_Reason_Code
  <TT
CLASS="FUNCTION"
>_Unwind_Resume_or_Rethrow</TT
></CODE
>(struct _Unwind_Exception *
  <TT
CLASS="PARAMETER"
><I
>exception_object</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26724"
></A
><H2
>Description</H2
><P
>If the unwind was initiated due to a forced unwind,
<TT
CLASS="FUNCTION"
>_Unwind_Resume_or_Rethrow()</TT
> 
shall resume that operation, else it shall re-raise the exception.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-SETGR"
></A
>_Unwind_SetGR</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26734"
></A
><H2
>Name</H2
>_Unwind_SetGR&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26737"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26740"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
  <TT
CLASS="FUNCTION"
>_Unwind_SetGR</TT
></CODE
>(struct _Unwind_Context *
  <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>index</I
></TT
></I
></TT
>, uint
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26752"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_SetGR()</TT
> 
sets the <TT
CLASS="PARAMETER"
><I
>value</I
></TT
> of the register 
<TT
CLASS="PARAMETER"
><I
>index</I
></TT
>ed for the routine identified 
by the unwind <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>.</P
></DIV
><H1
><A
NAME="BASELIB--UNWIND-SETIP-1"
></A
>_Unwind_SetIP</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26765"
></A
><H2
>Name</H2
>_Unwind_SetIP&nbsp;--&nbsp;private C++ error handling method</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26770"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26771"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;unwind.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>_Unwind_SetIP</TT
></CODE
>(struct _Unwind_Context *
<TT
CLASS="PARAMETER"
><I
>context</I
></TT
>, _Unwind_Ptr
<TT
CLASS="PARAMETER"
><I
>value</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26780"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>_Unwind_SetIP()</TT
> sets the instruction pointer for
the routine identified by the unwind <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>
to <TT
CLASS="PARAMETER"
><I
>value</I
></TT
>.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBDL"
>14.15. Interfaces for libdl</A
></H2
><P
><A
HREF="#LIB-LIBDL-DEF"
>Table 14-57</A
> defines the library name and shared object name
for the libdl library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBDL-DEF"
></A
><P
><B
>Table 14-57. libdl Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libdl</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libdl.so.2</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBDL.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBDL.2"
></A
>[SUSv4] <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26806"
>14.15.1. Dynamic Loader</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN26809"
>14.15.1.1. Interfaces for Dynamic Loader</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Dynamic Loader specified in <A
HREF="#TBL-LIBDL-DYNAM-INTS"
>Table 14-58</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBDL-DYNAM-INTS"
></A
><P
><B
>Table 14-58. libdl - Dynamic Loader Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>dladdr <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
><TD
>dlclose <A
HREF="#REFSTD.LIBDL.2"
>[SUSv4]</A
></TD
><TD
>dlerror <A
HREF="#REFSTD.LIBDL.2"
>[SUSv4]</A
></TD
><TD
>dlopen <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>dlsym <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
><TD
>dlvsym <A
HREF="#REFSTD.LIBDL.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBDL-DDEFS"
>14.16. Data Definitions for libdl</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libdl.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN26851"
>14.16.1. dlfcn.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RTLD_NEXT	((void *) -1l)
#define RTLD_DEFAULT	((void *) 0)
#define RTLD_LOCAL	0
#define RTLD_LAZY	0x00001
#define RTLD_NOW	0x00002
#define RTLD_NOLOAD	0x00004
#define RTLD_DEEPBIND	0x00008
#define RTLD_GLOBAL	0x00100
#define RTLD_NODELETE	0x01000

typedef struct {
    char *dli_fname;
    void *dli_fbase;
    char *dli_sname;
    void *dli_saddr;
} Dl_info;
extern int dladdr(const void *__address, Dl_info * __info);
extern int dlclose(void *__handle);
extern char *dlerror(void);
extern void *dlopen(const char *__file, int __mode);
extern void *dlsym(void *__handle, const char *__name);
extern void *dlvsym(void *handle, const char *name, const char *version);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBDLMAN"
>14.17. Interface Definitions for libdl</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB-DLADDR-3"
>dladdr</A
>&nbsp;--&nbsp;find the shared object containing a given address</DT
><DT
><A
HREF="#BASELIB-DLOPEN-1"
>dlopen</A
>&nbsp;--&nbsp;open dynamic object</DT
><DT
><A
HREF="#BASELIB-DLSYM-1"
>dlsym</A
>&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DT
><DT
><A
HREF="#BASELIB-DLVSYM-1"
>dlvsym</A
>&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libdl and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBDL"
>Section 14.15</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB-DLADDR-3"
></A
>dladdr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26864"
></A
><H2
>Name</H2
>dladdr&nbsp;--&nbsp;find the shared object containing a given address</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26867"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;dlfcn.h&#62;

typedef struct {
             const char  <CODE
CLASS="STRUCTFIELD"
>*dli_fname</CODE
>;
             void        <CODE
CLASS="STRUCTFIELD"
>*dli_fbase</CODE
>;
             const char  <CODE
CLASS="STRUCTFIELD"
>*dli_sname</CODE
>;
             void        <CODE
CLASS="STRUCTFIELD"
>*dli_saddr</CODE
>;
} <TT
CLASS="STRUCTNAME"
>Dl_info</TT
>;</PRE
></TD
></TR
></TABLE
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26876"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>dladdr</TT
></CODE
>(const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>addr</I
></TT
></I
></TT
>, Dl_info *
  <TT
CLASS="PARAMETER"
><I
>dlip</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26885"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dladdr()</TT
> function shall query the dynamic
linker for information about the shared object containing the 
address <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>. The information shall be returned
in the user supplied data structure referenced by <TT
CLASS="PARAMETER"
><I
>dlip</I
></TT
>.</P
><P
>The structure shall contain at least the following members:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26895"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_fname</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The pathname of the shared object containing the address</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26900"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_fbase</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The base address at which the shared object is
mapped into the address space of the calling process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26905"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The name of the nearest runtime symbol with  value
less than or equal to <TT
CLASS="PARAMETER"
><I
>addr</I
></TT
>.
Where possible, the symbol name shall be returned as it
would appear in C source code.</P
><P
>If no symbol with a suitable value is found,
both this field and <CODE
CLASS="STRUCTFIELD"
>dli_saddr</CODE
>
shall be set to <TT
CLASS="LITERAL"
>NULL</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26914"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>dli_saddr</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The address of the symbol returned in
<CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
>. This address has type 
"pointer to <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>", where
<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> is the type of the symbol
<CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Example: </B
>If the symbol in <CODE
CLASS="STRUCTFIELD"
>dli_sname</CODE
> is a function,
then the type of <CODE
CLASS="STRUCTFIELD"
>dli_saddr</CODE
> is of type
"pointer to function".</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The behavior of <TT
CLASS="FUNCTION"
>dladdr()</TT
> is only
specified in dynamically linked programs.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26930"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>dladdr()</TT
> shall return non-zero, and
the structure referenced by <TT
CLASS="PARAMETER"
><I
>dlip</I
></TT
> shall be filled in
as described. Otherwise, <TT
CLASS="FUNCTION"
>dladdr()</TT
> shall return zero,
and the cause of the error can be fetched with <TT
CLASS="FUNCTION"
>dlerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26937"
></A
><H2
>Errors</H2
><P
>See <TT
CLASS="FUNCTION"
>dlerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26941"
></A
><H2
>Environment</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN26944"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="LITERAL"
>LD_LIBRARY_PATH</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>directory search-path for object files</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="BASELIB-DLOPEN-1"
></A
>dlopen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN26953"
></A
><H2
>Name</H2
>dlopen&nbsp;--&nbsp;open dynamic object</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN26958"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>#include &#60;dlfcn.h&#62;</PRE
></TD
></TR
></TABLE
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN26962"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void * 
  <TT
CLASS="FUNCTION"
>dlopen</TT
></CODE
>(const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></I
></TT
>, int
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flag</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN26972"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>dlopen()</TT
> function shall behave as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with additional behaviors listed below.</P
><P
>If the file argument does not contain a &#60;slash&#62; character, then the
system shall look for a library of that name in at least the following
directories, and use the first one which is found:

<P
></P
><UL
><LI
><P
>The directories specified by the 
<CODE
CLASS="CONSTANT"
>DT_RPATH</CODE
> dynamic entry.</P
></LI
><LI
><P
>The directories specified in the 
<CODE
CLASS="CONSTANT"
>LD_LIBRARY_PATH</CODE
>
environment variable (which is a colon separated list of pathnames).
This step shall be skipped for setuid
and setgid executables.</P
></LI
><LI
><P
>A set of directories sufficient to contain the
libraries specified in this standard.

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Traditionally, <TT
CLASS="FILENAME"
>/lib</TT
> and
<TT
CLASS="FILENAME"
>/usr/lib</TT
>.  This case would also cover cases in
which the system used the mechanism of
<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
> and
<TT
CLASS="FILENAME"
>/etc/ld.so.cache</TT
> to provide access.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Example: An application which is not linked against libm may
choose to dlopen libm.</P
></BLOCKQUOTE
></DIV
></P
></LI
></UL
>&#13;</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN26994"
></A
><H3
>Additional flags</H3
><P
>In addition to the available values for <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>
as documented in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, the following values may
also be ORed into <TT
CLASS="PARAMETER"
><I
>flag</I
></TT
>:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27001"
></A
><SPAN
STYLE="white-space: nowrap"
>RTLD_NODELETE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do not unload the library during
<TT
CLASS="FUNCTION"
>dlclose()</TT
>. Consequently, the library's static
variables are not reinitialized if the library is reloaded with
<TT
CLASS="FUNCTION"
>dlopen()</TT
> at a later time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27007"
></A
><SPAN
STYLE="white-space: nowrap"
>RTLD_NOLOAD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do not load the library. This can be used to test if the
library is already resident. <TT
CLASS="FUNCTION"
>dlopen()</TT
> returns a
<CODE
CLASS="CONSTANT"
>NULL</CODE
> pointer if it is not resident;
it returns the library's handle if it is resident. 
This flag can also be used to promote the flags on
a library that is already loaded. For example, a library that was
previously loaded with <CODE
CLASS="CONSTANT"
>RTLD_LOCAL</CODE
> can be reopened
using <CODE
CLASS="CONSTANT"
>RTLD_NOLOAD|RTLD_GLOBAL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27015"
></A
><SPAN
STYLE="white-space: nowrap"
>RTLD_DEEPBIND</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Place the lookup scope of the symbols in this library ahead of the global
scope. This means that a self-contained library will use its own symbols
in preference to global symbols with the same name contained in libraries
that have already been loaded.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><H1
><A
NAME="BASELIB-DLSYM-1"
></A
>dlsym</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27023"
></A
><H2
>Name</H2
>dlsym&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27028"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dlsym()</TT
> is as specified in the
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN27033"
></A
><H3
>RTLD_NEXT, RTLD_DEFAULT Required</H3
><P
>The values <CODE
CLASS="CONSTANT"
>RTLD_NEXT</CODE
> and
<CODE
CLASS="CONSTANT"
>RTLD_DEFAULT</CODE
>, described as
reserved for future use in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
are required, with behavior as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
></DIV
><H1
><A
NAME="BASELIB-DLVSYM-1"
></A
>dlvsym</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27044"
></A
><H2
>Name</H2
>dlvsym&nbsp;--&nbsp;obtain the address of a symbol from a dlopen object</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27049"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27050"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;dlfcn.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void *
<TT
CLASS="FUNCTION"
>dlvsym</TT
></CODE
>(void *
<TT
CLASS="PARAMETER"
><I
>handle</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>version</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27061"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>dlvsym()</TT
> does the same as dlsym()
but takes a version string as an additional argument.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBRT"
>14.18. Interfaces for librt</A
></H2
><P
><A
HREF="#LIB-LIBRT-DEF"
>Table 14-59</A
> defines the library name and shared object name
for the librt library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBRT-DEF"
></A
><P
><B
>Table 14-59. librt Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>librt</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>librt.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBRT.1"
></A
>[LFS] <A
HREF="#STD.LFS"
>Large File Support</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBRT.2"
></A
>[SUSv4] <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27085"
>14.18.1. Shared Memory Objects</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27088"
>14.18.1.1. Interfaces for Shared Memory Objects</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Shared Memory Objects specified in <A
HREF="#TBL-LIBRT-SHARE-INTS"
>Table 14-60</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-SHARE-INTS"
></A
><P
><B
>Table 14-60. librt - Shared Memory Objects Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>shm_open <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>shm_unlink <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27107"
>14.18.2. Asynchronous I/O</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27110"
>14.18.2.1. Interfaces for Asynchronous I/O</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Asynchronous I/O specified in <A
HREF="#TBL-LIBRT-ASYNC-INTS"
>Table 14-61</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-ASYNC-INTS"
></A
><P
><B
>Table 14-61. librt - Asynchronous I/O Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>aio_cancel <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_cancel64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
><TD
>aio_error <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_error64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>aio_fsync <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_fsync64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
><TD
>aio_read <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_read64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>aio_return <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_return64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
><TD
>aio_suspend <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_suspend64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
></TR
><TR
><TD
>aio_write <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>aio_write64 <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
><TD
>lio_listio(GLIBC_2.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>lio_listio64(GLIBC_2.4) <A
HREF="#REFSTD.LIBRT.1"
>[LFS]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27186"
>14.18.3. Clock</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27189"
>14.18.3.1. Interfaces for Clock</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Clock specified in <A
HREF="#TBL-LIBRT-CLOCK-INTS"
>Table 14-62</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-CLOCK-INTS"
></A
><P
><B
>Table 14-62. librt - Clock Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>clock_getcpuclockid <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>clock_getres <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>clock_gettime <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>clock_nanosleep <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clock_settime <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27222"
>14.18.4. Timers</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27225"
>14.18.4.1. Interfaces for Timers</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Timers specified in <A
HREF="#TBL-LIBRT-TIMER-INTS"
>Table 14-63</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-TIMER-INTS"
></A
><P
><B
>Table 14-63. librt - Timers Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>timer_create <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>timer_delete <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>timer_getoverrun <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>timer_gettime <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>timer_settime <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27258"
>14.18.5. Message Queues</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27261"
>14.18.5.1. Interfaces for Message Queues</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Message Queues specified in <A
HREF="#TBL-LIBRT-MESSA-INTS"
>Table 14-64</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBRT-MESSA-INTS"
></A
><P
><B
>Table 14-64. librt - Message Queues Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>mq_close(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_getattr(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_notify(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_open(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mq_receive(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_send(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_setattr(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_timedreceive(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>mq_timedsend(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>mq_unlink(GLIBC_2.3.4) <A
HREF="#REFSTD.LIBRT.2"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBRT-DDEFS"
>14.19. Data Definitions for librt</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in librt.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27320"
>14.19.1. aio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define AIO_CANCELED	0
#define AIO_NOTCANCELED	1
#define AIO_ALLDONE	2

#define LIO_READ	0
#define LIO_WRITE	1
#define LIO_NOP	2

#define LIO_WAIT	0
#define LIO_NOWAIT	1

struct aiocb {
    int aio_fildes;		/* File desriptor */
    int aio_lio_opcode;		/* Operation to be performed */
    int aio_reqprio;		/* Request priority offset */
    void *aio_buf;		/* Location of buffer */
    size_t aio_nbytes;		/* Length of transfer */
    struct sigevent aio_sigevent;	/* Signal number and value */
    struct aiocb *__next_prio;	/* internal, do not use */
    int __abs_prio;		/* internal, do not use */
    int __policy;		/* internal, do not use */
    int __error_code;		/* internal, do not use */
    ssize_t __return_value;	/* internal, do not use */
    off_t aio_offset;		/* File offset */
    char __pad[sizeof(off64_t) - sizeof(off_t)];
    char __unused[32];
};
struct aiocb64 {
    int aio_fildes;		/* File desriptor */
    int aio_lio_opcode;		/* Operation to be performed */
    int aio_reqprio;		/* Request priority offset */
    void *aio_buf;		/* Location of buffer */
    size_t aio_nbytes;		/* Length of transfer */
    struct sigevent aio_sigevent;	/* Signal number and value */
    struct aiocb *__next_prio;	/* internal, do not use */
    int __abs_prio;		/* internal, do not use */
    int __policy;		/* internal, do not use */
    int __error_code;		/* internal, do not use */
    ssize_t __return_value;	/* internal, do not use */
    off64_t aio_offset;		/* File offset */
    char __unused[32];
};
extern int aio_cancel(int fildes, struct aiocb *aiocbp);
extern int aio_cancel64(int fildes, struct aiocb64 *aiocbp);
extern int aio_error(struct aiocb *aiocbp);
extern int aio_error64(struct aiocb64 *aiocbp);
extern int aio_fsync(int operation, struct aiocb *aiocbp);
extern int aio_fsync64(int operation, struct aiocb64 *aiocbp);
extern int aio_read(struct aiocb *aiocbp);
extern int aio_read64(struct aiocb64 *aiocbp);
extern int aio_return(struct aiocb *aiocbp);
extern int aio_return64(struct aiocb64 *aiocbp);
extern int aio_suspend(struct aiocb *list[], int nent,
		       struct timespec *timeout);
extern int aio_suspend64(struct aiocb64 *list[], int nent,
			 struct timespec *timeout);
extern int aio_write(struct aiocb *aiocbp);
extern int aio_write64(struct aiocb64 *aiocbp);
extern int lio_listio(int mode, struct aiocb *list[], int nent,
		      struct sigevent *sig);
extern int lio_listio64(int mode, struct aiocb64 *list[], int nent,
			struct sigevent *sig);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27324"
>14.19.2. mqueue.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef int mqd_t;
struct mq_attr {
    long int mq_flags;
    long int mq_maxmsg;
    long int mq_msgsize;
    long int mq_curmsgs;
    long int __pad[4];
};
extern int mq_close(mqd_t __mqdes);
extern int mq_getattr(mqd_t __mqdes, struct mq_attr *__mqstat);
extern int mq_notify(mqd_t __mqdes, const struct sigevent *__notification);
extern mqd_t mq_open(const char *__name, int __oflag, ...);
extern ssize_t mq_receive(mqd_t __mqdes, char *__msg_ptr, size_t __msg_len,
			  unsigned int *__msg_prio);
extern int mq_send(mqd_t __mqdes, const char *__msg_ptr, size_t __msg_len,
		   unsigned int __msg_prio);
extern int mq_setattr(mqd_t __mqdes, const struct mq_attr *__mqstat,
		      struct mq_attr *__omqstat);
extern ssize_t mq_timedreceive(mqd_t __mqdes, char *__msg_ptr,
			       size_t __msg_len, unsigned int *__msg_prio,
			       const struct timespec *__abs_timeout);
extern int mq_timedsend(mqd_t __mqdes, const char *__msg_ptr,
			size_t __msg_len, unsigned int __msg_prio,
			const struct timespec *__abs_timeout);
extern int mq_unlink(const char *__name);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBCRYPT"
>14.20. Interfaces for libcrypt</A
></H2
><P
><A
HREF="#LIB-LIBCRYPT-DEF"
>Table 14-65</A
> defines the library name and shared object name
for the libcrypt library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBCRYPT-DEF"
></A
><P
><B
>Table 14-65. libcrypt Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libcrypt</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libcrypt.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBCRYPT.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBCRYPT.2"
></A
>[SUSv4] <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27348"
>14.20.1. Encryption</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27351"
>14.20.1.1. Interfaces for Encryption</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Encryption specified in <A
HREF="#TBL-LIBCRYPT-ENCRY-INTS"
>Table 14-66</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBCRYPT-ENCRY-INTS"
></A
><P
><B
>Table 14-66. libcrypt - Encryption Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>crypt <A
HREF="#REFSTD.LIBCRYPT.2"
>[SUSv4]</A
></TD
><TD
>crypt_r <A
HREF="#REFSTD.LIBCRYPT.1"
>[LSB]</A
></TD
><TD
>encrypt <A
HREF="#REFSTD.LIBCRYPT.2"
>[SUSv4]</A
></TD
><TD
>encrypt_r <A
HREF="#REFSTD.LIBCRYPT.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>setkey <A
HREF="#REFSTD.LIBCRYPT.2"
>[SUSv4]</A
></TD
><TD
>setkey_r <A
HREF="#REFSTD.LIBCRYPT.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBCRYPT-DDEFS"
>14.21. Data Definitions for libcrypt</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libcrypt.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27393"
>14.21.1. crypt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct crypt_data {
    char keysched[128];
    char sb0[32768];
    char sb1[32768];
    char sb2[32768];
    char sb3[32768];
    char crypt_3_buf[14];
    char current_salt[2];
    long int current_saltbits;
    int direction;
    int initialized;
};
extern char *crypt_r(const char *key, const char *salt,
		     struct crypt_data *data);
extern void encrypt_r(const char *block, int edflag,
		      struct crypt_data *data);
extern void setkey_r(const char *key, struct crypt_data *data);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBCRYPTMAN"
>14.22. Interface Definitions for libcrypt</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB-CRYPT-R-1"
>crypt_r</A
>&nbsp;--&nbsp;Cryptographic string encoding function</DT
><DT
><A
HREF="#BASELIB-ENCRYPT-R-1"
>encrypt_r</A
>&nbsp;--&nbsp;Cryptographic encoding function</DT
><DT
><A
HREF="#BASELIB-SETKEY-R-1"
>setkey_r</A
>&nbsp;--&nbsp;Set cryptographic encoding key</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libcrypt and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBCRYPT"
>Section 14.20</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB-CRYPT-R-1"
></A
>crypt_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27406"
></A
><H2
>Name</H2
>crypt_r&nbsp;--&nbsp;Cryptographic string encoding function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27411"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27412"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;crypt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *
<TT
CLASS="FUNCTION"
>crypt_r</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>key</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>salt</I
></TT
>, struct crypt_data *
<TT
CLASS="PARAMETER"
><I
>data</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27423"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>crypt_r()</TT
> function is a re-entrant version of the
<TT
CLASS="FUNCTION"
>crypt()</TT
> function.
<TT
CLASS="FUNCTION"
>crypt_r()</TT
> shall behave as specified 
for <TT
CLASS="FUNCTION"
>crypt()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, 
but with an additional parameter, a pointer to a structure
which is used to store result data and bookkeeping information.</P
><P
>The caller should set the <CODE
CLASS="STRUCTFIELD"
>initialized</CODE
>
field of the <TT
CLASS="STRUCTNAME"
>crypt_data</TT
> structure to zero 
before the first call to <TT
CLASS="FUNCTION"
>crypt_r()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27435"
></A
><H2
>Notes</H2
><P
>INSERT TEXT HERE</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27438"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>crypt()</TT
>,
<TT
CLASS="FUNCTION"
>setkey_r()</TT
>,
<TT
CLASS="FUNCTION"
>encrypt_r()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-ENCRYPT-R-1"
></A
>encrypt_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27448"
></A
><H2
>Name</H2
>encrypt_r&nbsp;--&nbsp;Cryptographic encoding function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27453"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27454"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;crypt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>encrypt_r</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>block</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>edflag</I
></TT
>, struct crypt_data *
<TT
CLASS="PARAMETER"
><I
>data</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27465"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>encrypt_r()</TT
> function is a re-entrant version of the
<TT
CLASS="FUNCTION"
>encrypt()</TT
> function.
<TT
CLASS="FUNCTION"
>encrypt_r()</TT
> shall behave as specified 
for <TT
CLASS="FUNCTION"
>encrypt()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, 
but with an additional parameter, a pointer to a structure
which is used to store result data and bookkeeping information.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27473"
></A
><H2
>Notes</H2
><P
>INSERT TEXT HERE</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27476"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>encrypt()</TT
>,
<TT
CLASS="FUNCTION"
>crypt_r()</TT
>,
<TT
CLASS="FUNCTION"
>setkey_r()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-SETKEY-R-1"
></A
>setkey_r</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27486"
></A
><H2
>Name</H2
>setkey_r&nbsp;--&nbsp;Set cryptographic encoding key</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27491"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27492"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;crypt.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
<TT
CLASS="FUNCTION"
>setkey_r</TT
></CODE
>(const char *
<TT
CLASS="PARAMETER"
><I
>key</I
></TT
>, struct crypt_data *
<TT
CLASS="PARAMETER"
><I
>data</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27501"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>setkey_r()</TT
> function is a re-entrant version of the
<TT
CLASS="FUNCTION"
>setkey()</TT
> function.
<TT
CLASS="FUNCTION"
>setkey_r()</TT
> shall behave as specified 
for <TT
CLASS="FUNCTION"
>setkey()</TT
> in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, 
but with an additional parameter, a pointer to a structure
which is used to store result data and bookkeeping information.</P
><P
>The caller should set the <CODE
CLASS="STRUCTFIELD"
>initialized</CODE
>
field of the <TT
CLASS="STRUCTNAME"
>crypt_data</TT
> structure to zero 
before the first call to <TT
CLASS="FUNCTION"
>setkey_r()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27513"
></A
><H2
>Notes</H2
><P
>INSERT TEXT HERE</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27516"
></A
><H2
>See Also</H2
><P
><TT
CLASS="FUNCTION"
>setkey()</TT
>,
<TT
CLASS="FUNCTION"
>crypt_r()</TT
>,
<TT
CLASS="FUNCTION"
>encrypt_r()</TT
>.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPAM"
>14.23. Interfaces for libpam</A
></H2
><P
><A
HREF="#LIB-LIBPAM-DEF"
>Table 14-67</A
> defines the library name and shared object name
for the libpam library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBPAM-DEF"
></A
><P
><B
>Table 14-67. libpam Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libpam</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libpam.so.0</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Pluggable Authentication Module (PAM) interfaces allow
applications to request authentication via a system administrator
defined mechanism, known as a <I
CLASS="FIRSTTERM"
>service</I
>.</P
><P
>A single service name, <CODE
CLASS="VARNAME"
>other</CODE
>, shall always be present.
The behavior of this service shall be determined by the system administrator.
Additional service names may also exist.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Future versions of this specification might define additional
service names.</P
></BLOCKQUOTE
></DIV
></P
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBPAM.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBPAM.2"
></A
>[PAM] <A
HREF="#STD.PAM"
>PAM</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27548"
>14.23.1. Pluggable Authentication API</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN27551"
>14.23.1.1. Interfaces for Pluggable Authentication API</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Pluggable Authentication API specified in <A
HREF="#TBL-LIBPAM-PLUGG-INTS"
>Table 14-68</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBPAM-PLUGG-INTS"
></A
><P
><B
>Table 14-68. libpam - Pluggable Authentication API Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pam_acct_mgmt(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_authenticate(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_chauthtok(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_close_session(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_end(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_fail_delay(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_get_data(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.2"
>[PAM]</A
></TD
><TD
>pam_get_item(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_get_user(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.2"
>[PAM]</A
></TD
><TD
>pam_getenv(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_getenvlist(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_open_session(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_putenv(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_set_data(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.2"
>[PAM]</A
></TD
><TD
>pam_set_item(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_setcred(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_start(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>pam_strerror(LIBPAM_1.0) <A
HREF="#REFSTD.LIBPAM.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPAM-DDEFS"
>14.24. Data Definitions for libpam</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libpam.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27644"
>14.24.1. security/_pam_types.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct pam_handle pam_handle_t;
struct pam_message {
    int msg_style;
    const char *msg;
};
struct pam_response {
    char *resp;
    int resp_retcode;		/* currently un-used, zero expected */
};

struct pam_conv {
    int (*conv) (int num_msg, const struct pam_message * *msg,
		 struct pam_response * *resp, void *appdata_ptr);
    void *appdata_ptr;
};

#define PAM_PROMPT_ECHO_OFF	1
#define PAM_PROMPT_ECHO_ON	2
#define PAM_ERROR_MSG	3
#define PAM_TEXT_INFO	4

#define PAM_SERVICE	1	/* The service name */
#define PAM_USER	2	/* The user name */
#define PAM_TTY	3		/* The tty name */
#define PAM_RHOST	4	/* The remote host name */
#define PAM_CONV	5	/* The pam_conv structure */
#define PAM_RUSER	8	/* The remote user name */
#define PAM_USER_PROMPT	9	/* the prompt for getting a username */

#define PAM_SUCCESS	0	/* Successful function return */
#define PAM_OPEN_ERR	1	/* dlopen() failure */
#define PAM_USER_UNKNOWN	10	/* User not known to the underlying authenticaiton module */
#define PAM_MAXTRIES	11	/* An authentication service has maintained a retry count which */
#define PAM_NEW_AUTHTOK_REQD	12	/* New authentication token required */
#define PAM_ACCT_EXPIRED	13	/* User account has expired */
#define PAM_SESSION_ERR	14	/* Can not make/remove an entry for  the specified session */
#define PAM_CRED_UNAVAIL	15	/* Underlying authentication service can not retrieve user cred */
#define PAM_CRED_EXPIRED	16	/* User credentials expired */
#define PAM_CRED_ERR	17	/* Failure setting user credentials */
#define PAM_CONV_ERR	19	/* Conversation error */
#define PAM_SYMBOL_ERR	2	/* Symbol not found */
#define PAM_AUTHTOK_ERR	20	/* Authentication token manipulation error */
#define PAM_AUTHTOK_RECOVER_ERR	21	/* Authentication information cannot be recovered */
#define PAM_AUTHTOK_LOCK_BUSY	22	/* Authentication token lock busy */
#define PAM_AUTHTOK_DISABLE_AGING	23	/* Authentication token aging disabled */
#define PAM_TRY_AGAIN	24	/* Preliminary check by password service */
#define PAM_ABORT	26	/* Critical error (?module fail now request) */
#define PAM_AUTHTOK_EXPIRED	27	/* user's authentication token has expired */
#define PAM_BAD_ITEM	29	/* Bad item passed to pam_*_item() */
#define PAM_SERVICE_ERR	3	/* Error in service module */
#define PAM_SYSTEM_ERR	4	/* System error */
#define PAM_BUF_ERR	5	/* Memory buffer error */
#define PAM_PERM_DENIED	6	/* Permission denied */
#define PAM_AUTH_ERR	7	/* Authentication failure */
#define PAM_CRED_INSUFFICIENT	8	/* Can not access authentication data due to insufficient crede */
#define PAM_AUTHINFO_UNAVAIL	9	/* Underlying authentication service can not retrieve authentic */

#define PAM_DISALLOW_NULL_AUTHTOK	0x0001U
#define PAM_ESTABLISH_CRED	0x0002U	/* Set user credentials for an authentication service */
#define PAM_DELETE_CRED	0x0004U	/* Delete user credentials associated with an authentication se */
#define PAM_REINITIALIZE_CRED	0x0008U	/* Reinitialize user credentials */
#define PAM_REFRESH_CRED	0x0010U	/* Extend lifetime of user credentials */
#define PAM_CHANGE_EXPIRED_AUTHTOK	0x0020U	/* Extend lifetime of user credentials */
#define PAM_SILENT	0x8000U	/* Authentication service should not generate any messages */

extern int pam_fail_delay(pam_handle_t *, unsigned int);
extern int pam_get_item(const pam_handle_t *, int, const void **);
extern const char *pam_getenv(pam_handle_t *, const char *);
extern char **pam_getenvlist(pam_handle_t *);
extern int pam_putenv(pam_handle_t *, const char *);
extern int pam_set_item(pam_handle_t *, int, const void *);
extern const char *pam_strerror(pam_handle_t *, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27648"
>14.24.2. security/pam_appl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int pam_acct_mgmt(pam_handle_t *, int);
extern int pam_authenticate(pam_handle_t *, int);
extern int pam_chauthtok(pam_handle_t *, int);
extern int pam_close_session(pam_handle_t *, int);
extern int pam_end(pam_handle_t *, int);
extern int pam_open_session(pam_handle_t *, int);
extern int pam_setcred(pam_handle_t *, int);
extern int pam_start(const char *, const char *, const struct pam_conv *,
		     pam_handle_t * *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN27652"
>14.24.3. security/pam_modules.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int pam_get_data(const pam_handle_t *, const char *, const void **);
extern int pam_get_user(pam_handle_t *, const char **, const char *);
extern int pam_set_data(pam_handle_t *, const char *, void *,
			void (*)(pam_handle_t *, void *, int));</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBPAMMAN"
>14.25. Interface Definitions for libpam</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#BASELIB-PAM-ACCT-MGMT"
>pam_acct_mgmt</A
>&nbsp;--&nbsp;establish the status of a user's account</DT
><DT
><A
HREF="#BASELIB-PAM-AUTHENTICATE"
>pam_authenticate</A
>&nbsp;--&nbsp;authenticate the user</DT
><DT
><A
HREF="#BASELIB-PAM-CHAUTHTOK"
>pam_chauthtok</A
>&nbsp;--&nbsp;change the authentication token for a given user</DT
><DT
><A
HREF="#BASELIB-PAM-CLOSE-SESSION"
>pam_close_session</A
>&nbsp;--&nbsp;indicate that an authenticated session has ended</DT
><DT
><A
HREF="#BASELIB-PAM-END"
>pam_end</A
>&nbsp;--&nbsp;terminate the use of the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-FAIL-DELAY"
>pam_fail_delay</A
>&nbsp;--&nbsp;specify delay time to use on authentication error</DT
><DT
><A
HREF="#BASELIB-PAM-GET-ITEM"
>pam_get_item</A
>&nbsp;--&nbsp;obtain the value of the indicated item.</DT
><DT
><A
HREF="#BASELIB-PAM-GETENV"
>pam_getenv</A
>&nbsp;--&nbsp;get a PAM environment variable</DT
><DT
><A
HREF="#BASELIB-PAM-GETENVLIST"
>pam_getenvlist</A
>&nbsp;--&nbsp;returns a pointer to the complete PAM environment.</DT
><DT
><A
HREF="#BASELIB-PAM-OPEN-SESSION"
>pam_open_session</A
>&nbsp;--&nbsp;indicate session has started</DT
><DT
><A
HREF="#BASELIB-PAM-PUTENV"
>pam_putenv</A
>&nbsp;--&nbsp;Add, replace or delete a PAM environment variable</DT
><DT
><A
HREF="#BASELIB-PAM-SET-ITEM"
>pam_set_item</A
>&nbsp;--&nbsp;(re)set the value of an item.</DT
><DT
><A
HREF="#BASELIB-PAM-SETCRED"
>pam_setcred</A
>&nbsp;--&nbsp;set the module-specific credentials of the user</DT
><DT
><A
HREF="#BASELIB-PAM-START"
>pam_start</A
>&nbsp;--&nbsp;initialize the PAM library</DT
><DT
><A
HREF="#BASELIB-PAM-STRERROR"
>pam_strerror</A
>&nbsp;--&nbsp;returns a string describing the PAM error</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libpam and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBPAM"
>Section 14.23</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="BASELIB-PAM-ACCT-MGMT"
></A
>pam_acct_mgmt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27665"
></A
><H2
>Name</H2
>pam_acct_mgmt&nbsp;--&nbsp;establish the status of a user's account</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27668"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27671"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_acct_mgmt</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27682"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_acct_mgmt()</TT
> establishes the account's usability 
and the user's accessibility to the system. It is typically called 
after the user has been authenticated.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be specified as any valid flag (namely, 
one of those applicable to the <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> argument of 
<TT
CLASS="FUNCTION"
>pam_authenticate()</TT
>). Additionally, the value of 
<TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be logically or'd 
with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27694"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27697"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27701"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_NEW_AUTHTOK_REQD</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is valid, but user's authentication token has expired.
The correct response to this return-value is to require that the
user satisfy the <TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
> function before 
obtaining service. It may not be possible for an application to do 
this. In such a case, the user should be denied access until the
account password is updated.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27706"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_ACCT_EXPIRED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is no longer permitted access to the system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27710"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_AUTH_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Authentication error.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27714"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is not permitted to gain access at this time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27718"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER_UNKNOWN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is not known to a module's account management component.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-AUTHENTICATE"
></A
>pam_authenticate</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27729"
></A
><H2
>Name</H2
>pam_authenticate&nbsp;--&nbsp;authenticate the user</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27732"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27735"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_authenticate</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27746"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_authenticate()</TT
> serves as an interface to the 
authentication mechanisms of the loaded modules. </P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> is an optional parameter that may
be specified by the following value:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_DISALLOW_NULL_AUTHTOK</DT
><DD
><P
>Instruct the authentication modules to return <CODE
CLASS="CONSTANT"
>PAM_AUTH_ERR</CODE
>
if the user does not have a registered authorization token.</P
></DD
></DL
></DIV
><P
>Additionally, the value of <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be 
logically or'd with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
><P
>The process may need to be privileged in order to successfully
call this function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27764"
></A
><H2
>Return Value</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_SUCCESS</DT
><DD
><P
>Success.</P
></DD
><DT
>PAM_AUTH_ERR</DT
><DD
><P
>User was not authenticated or process did not have sufficient privileges
to perform authentication.</P
></DD
><DT
>PAM_CRED_INSUFFICIENT</DT
><DD
><P
>Application does not have sufficient credentials to
authenticate the user.</P
></DD
><DT
>PAM_AUTHINFO_UNAVAIL</DT
><DD
><P
>Modules were not able to access the authentication information. This
might be due to a network or hardware failure, etc.</P
></DD
><DT
>PAM_USER_UNKNOWN</DT
><DD
><P
>Supplied username is not known to the authentication service.</P
></DD
><DT
>PAM_MAXTRIES</DT
><DD
><P
>One or more authentication modules has reached its limit of tries
authenticating the user. Do not try again.</P
></DD
><DT
>PAM_ABORT</DT
><DD
><P
>One or more authentication modules failed to load.</P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-CHAUTHTOK"
></A
>pam_chauthtok</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27802"
></A
><H2
>Name</H2
>pam_chauthtok&nbsp;--&nbsp;change the authentication token for a given user</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27805"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27808"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_chauthtok</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, const int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27819"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
> is used to change the 
authentication token for a given user as indicated by the state 
associated with the handle <TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
>.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> is an optional parameter that may
be specified by the following value:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_CHANGE_EXPIRED_AUTHTOK</DT
><DD
><P
>User's authentication token should only be changed if it has expired.</P
></DD
></DL
></DIV
><P
>Additionally, the value of <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be 
logically or'd with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27836"
></A
><H2
>RETURN VALUE</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_SUCCESS</DT
><DD
><P
>Success.</P
></DD
><DT
>PAM_AUTHTOK_ERR</DT
><DD
><P
>A module was unable to obtain the new authentication token.</P
></DD
><DT
>PAM_AUTHTOK_RECOVER_ERR</DT
><DD
><P
>A module was unable to obtain the old authentication token.</P
></DD
><DT
>PAM_AUTHTOK_LOCK_BUSY</DT
><DD
><P
>One or more modules were unable to change the authentication token
since it is currently locked.</P
></DD
><DT
>PAM_AUTHTOK_DISABLE_AGING</DT
><DD
><P
>Authentication token aging has been disabled for at least one of the modules.</P
></DD
><DT
>PAM_PERM_DENIED</DT
><DD
><P
>Permission denied.</P
></DD
><DT
>PAM_TRY_AGAIN</DT
><DD
><P
>Not all modules were in a position to update the authentication
token(s). In such a case, none of the user's authentication tokens 
are updated.</P
></DD
><DT
>PAM_USER_UNKNOWN</DT
><DD
><P
>User is not known to the authentication token changing service.</P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-CLOSE-SESSION"
></A
>pam_close_session</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27878"
></A
><H2
>Name</H2
>pam_close_session&nbsp;--&nbsp;indicate that an authenticated session has ended</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27881"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27884"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_close_session</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27895"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_close_session()</TT
> is used to indicate that 
an authenticated session has ended. It is used to inform the module 
that the user is exiting a session. It should be possible for the 
PAM library to open a session and close the same session from 
different applications.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may have the value
<CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
> to indicate that no output 
should be generated as a result of this function call.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27904"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27907"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27911"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SESSION_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of the required loaded modules was unable to close a session for the user.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-END"
></A
>pam_end</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27922"
></A
><H2
>Name</H2
>pam_end&nbsp;--&nbsp;terminate the use of the PAM library</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27925"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27928"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_end</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pam_status</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27939"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_end()</TT
> terminates use of the PAM library.
On success, the contents of <TT
CLASS="PARAMETER"
><I
>*pamh</I
></TT
> are no 
longer valid, and all memory associated with it is invalid.</P
><P
>Normally, <TT
CLASS="PARAMETER"
><I
>pam_status</I
></TT
> is passed the value 
<CODE
CLASS="CONSTANT"
>PAM_SUCCESS</CODE
>, but in the event of an
unsuccessful service application, the appropriate PAM error 
return value should be used.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27949"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27952"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-FAIL-DELAY"
></A
>pam_fail_delay</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN27963"
></A
><H2
>Name</H2
>pam_fail_delay&nbsp;--&nbsp;specify delay time to use on authentication error</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN27966"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN27969"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_fail_delay</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, unsigned int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>micro_sec</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27980"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_fail_delay()</TT
> specifies the minimum delay for the 
PAM library to use when an authentication error occurs. The actual delay 
can vary by as much at 25%. If this function is called multiple times, 
the longest time specified by any of the call will be used.</P
><P
>The delay is invoked if an authentication error occurs during the
<TT
CLASS="FUNCTION"
>pam_authenticate()</TT
> or <TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
>
function calls.</P
><P
>Independent of the success of
<TT
CLASS="FUNCTION"
>pam_authenticate()</TT
> or <TT
CLASS="FUNCTION"
>pam_chauthtok()</TT
>,
the delay time is reset to its default value of 0 when the PAM library returns 
control to the application from these two functions.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN27992"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN27995"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-GET-ITEM"
></A
>pam_get_item</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28006"
></A
><H2
>Name</H2
>pam_get_item&nbsp;--&nbsp;obtain the value of the indicated item.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28009"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28012"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_get_item</TT
></CODE
>(const pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item_type</I
></TT
></I
></TT
>, const void * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28026"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_get_item()</TT
> obtains the value of the indicated
<TT
CLASS="PARAMETER"
><I
>item_type</I
></TT
>. The possible values of
<TT
CLASS="PARAMETER"
><I
>item_type</I
></TT
> are the same as listed for
<TT
CLASS="FUNCTION"
>pam_set_item()</TT
>.</P
><P
>On success, <TT
CLASS="PARAMETER"
><I
>item</I
></TT
> contains a pointer to the
value of the corresponding item. Note that this is a pointer to the 
actual data and should not be <TT
CLASS="FUNCTION"
>free()</TT
>'d or over-written.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28038"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28041"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28045"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Application passed a <CODE
CLASS="CONSTANT"
>NULL</CODE
> pointer for
<CODE
CLASS="VARNAME"
>item</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28051"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BAD_ITEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Application attempted to get an undefined item.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-GETENV"
></A
>pam_getenv</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28062"
></A
><H2
>Name</H2
>pam_getenv&nbsp;--&nbsp;get a PAM environment variable</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28065"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28066"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
<TT
CLASS="FUNCTION"
>pam_getenv</TT
></CODE
>(const pam_handle_t *
<TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28075"
></A
><H2
>Description</H2
><P
>The
<TT
CLASS="FUNCTION"
>pam_getenv()</TT
> function shall search the environment
associated with the PAM handle <TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
> for the
environment variable <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>. 
If the specified environment variable cannot be found, a null pointer shall
be returned. The application shall ensure that it does not modify the string pointed to by the
<TT
CLASS="FUNCTION"
>pam_getenv()</TT
> function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28084"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>pam_getenv()</TT
> returns a pointer to a string of the form
<SPAN
CLASS="SYSTEMITEM"
>name=value</SPAN
>.</P
></DIV
><H1
><A
NAME="BASELIB-PAM-GETENVLIST"
></A
>pam_getenvlist</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28093"
></A
><H2
>Name</H2
>pam_getenvlist&nbsp;--&nbsp;returns a pointer to the complete PAM environment.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28096"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28099"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char * const *
  <TT
CLASS="FUNCTION"
>pam_getenvlist</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28107"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_getenvlist()</TT
> returns a pointer to the complete 
PAM environment. This pointer points to an array of pointers to
<CODE
CLASS="CONSTANT"
>NUL</CODE
>-terminated strings and must be terminated by a
<CODE
CLASS="CONSTANT"
>NULL</CODE
> pointer. Each string has the form "name=value".</P
><P
>The PAM library module allocates memory for the returned value and the
associated strings. The calling application is responsible for freeing this
memory. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28116"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>pam_getenvlist()</TT
> returns an array of string pointers 
containing the PAM environment. On error, <CODE
CLASS="CONSTANT"
>NULL</CODE
> 
is returned.</P
></DIV
><H1
><A
NAME="BASELIB-PAM-OPEN-SESSION"
></A
>pam_open_session</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28125"
></A
><H2
>Name</H2
>pam_open_session&nbsp;--&nbsp;indicate session has started</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28128"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28131"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_open_session</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28142"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>pam_open_session()</TT
> function is used to indicate that an 
authenticated session has begun, after the user has been
identified (see <TT
CLASS="FUNCTION"
>pam_authenticate()</TT
>) and,
if necessary, granted credentials (see <TT
CLASS="FUNCTION"
>pam_setcred()</TT
>).
It is used to inform the module that 
the user is currently in a session. It should be possible for the PAM 
library to open a session and close the same session from different 
applications.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may have the value
<CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
> to indicate that no output be
generated as a result of this function call.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28153"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28156"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28160"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SESSION_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>One of the loaded modules was unable to open a session for the user.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-PUTENV"
></A
>pam_putenv</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28171"
></A
><H2
>Name</H2
>pam_putenv&nbsp;--&nbsp;Add, replace or delete a PAM environment variable</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28174"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28175"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>pam_putenv</TT
></CODE
>(const pam_handle_t *
<TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>name_value</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28184"
></A
><H2
>Description</H2
><P
>The
<TT
CLASS="FUNCTION"
>pam_putenv()</TT
> function 
shall modify the environment list associated with
<TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>name_value</I
></TT
> contains
an <TT
CLASS="LITERAL"
>'='</TT
> character, the characters to the left of the first
<TT
CLASS="LITERAL"
>'='</TT
> character represent the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>, and the remaining
characters after the <TT
CLASS="LITERAL"
>'='</TT
> represent the <TT
CLASS="PARAMETER"
><I
>value</I
></TT
>.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> environment variable exists in the environment associated with
<TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
>, it shall be modified to have the value <TT
CLASS="PARAMETER"
><I
>value</I
></TT
>.
Otherwise, the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> shall be added to the environment associated
with <TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
> with the value <TT
CLASS="PARAMETER"
><I
>value</I
></TT
>.</P
><P
>If there is no <TT
CLASS="LITERAL"
>'='</TT
> character in <TT
CLASS="PARAMETER"
><I
>name_value</I
></TT
>, the variable
in the environment associated with <TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
> named <TT
CLASS="PARAMETER"
><I
>name_value</I
></TT
>
shall be deleted.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28209"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>pam_putenv()</TT
> function shall return <SPAN
CLASS="RETURNVALUE"
>PAM_SUCCESS</SPAN
>.
Otherwise the return value indicates the error:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28215"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>name_value</I
></TT
> argument is a null pointer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28220"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BAD_ITEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The PAM environment varable named <TT
CLASS="PARAMETER"
><I
>name_value</I
></TT
> does not exist and therefore cannot be deleted.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28225"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_ABORT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The PAM handle identifed by <TT
CLASS="PARAMETER"
><I
>pamh</I
></TT
> is corrupt.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28230"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BUF_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Memory buffer error.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="BASELIB-PAM-SET-ITEM"
></A
>pam_set_item</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28238"
></A
><H2
>Name</H2
>pam_set_item&nbsp;--&nbsp;(re)set the value of an item.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28241"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28244"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_set_item</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item_type</I
></TT
></I
></TT
>, const void *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28258"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_set_item()</TT
> (re)sets the value of one of the 
following item_types:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28265"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SERVICE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>service name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28269"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>user name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28273"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_TTY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>terminal name</P
><P
>The value for a device file should include the <TT
CLASS="FILENAME"
>/dev/</TT
> 
prefix. The value for graphical, X-based, applications should be the 
<CODE
CLASS="VARNAME"
>$DISPLAY</CODE
> variable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28280"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_RHOST</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>remote host name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28284"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CONV</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>conversation structure</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28288"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_RUSER</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>remote user name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28292"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER_PROMPT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>string to be used when prompting for a user's name</P
><P
>The default value for this string is <TT
CLASS="LITERAL"
>Please enter 
username: </TT
>.</P
></TD
></TR
></TBODY
></TABLE
><P
>For all <TT
CLASS="PARAMETER"
><I
>item_types</I
></TT
> other than
<CODE
CLASS="CONSTANT"
>PAM_CONV</CODE
>, <TT
CLASS="PARAMETER"
><I
>item</I
></TT
> is a pointer 
to a <CODE
CLASS="CONSTANT"
>NULL</CODE
>-terminated character string. In the case 
of <CODE
CLASS="CONSTANT"
>PAM_CONV</CODE
>, <TT
CLASS="PARAMETER"
><I
>item</I
></TT
> points to
an initialized <TT
CLASS="STRUCTNAME"
>pam_conv</TT
> structure.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28306"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28309"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28313"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_PERM_DENIED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An attempt was made to replace the conversation structure with a
<CODE
CLASS="CONSTANT"
>NULL</CODE
> value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28318"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BUF_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Function ran out of memory making a copy of the item.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28322"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BAD_ITEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Application attempted to set an undefined item.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-SETCRED"
></A
>pam_setcred</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28333"
></A
><H2
>Name</H2
>pam_setcred&nbsp;--&nbsp;set the module-specific credentials of the user</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28336"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28339"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>extern int 
  <TT
CLASS="FUNCTION"
>pam_setcred</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28350"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_setcred()</TT
> sets the module-specific credentials of 
the user. It is usually called after the user has been authenticated,
after the account management function has been called and after a
session has been opened for the user.</P
><P
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> maybe specified from among the following 
values:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PAM_ESTABLISH_CRED</DT
><DD
><P
>set credentials for the authentication service</P
></DD
><DT
>PAM_DELETE_CRED</DT
><DD
><P
>delete credentials associated with the authentication service</P
></DD
><DT
>PAM_REINITIALIZE_CRED</DT
><DD
><P
>reinitialize the user credentials</P
></DD
><DT
>PAM_REFRESH_CRED</DT
><DD
><P
>extend lifetime of the user credentials</P
></DD
></DL
></DIV
><P
>Additionally, the value of <TT
CLASS="PARAMETER"
><I
>flags</I
></TT
> may be 
logically or'd with <CODE
CLASS="CONSTANT"
>PAM_SILENT</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28378"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28381"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28385"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CRED_UNAVAIL</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Module cannot retrieve the user's credentials.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28389"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CRED_EXPIRED</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User's credentials have expired.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28393"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_USER_UNKNOWN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>User is not known to an authentication module.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28397"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_CRED_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Module was unable to set the credentials of the user.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Errors may be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="BASELIB-PAM-START"
></A
>pam_start</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28408"
></A
><H2
>Name</H2
>pam_start&nbsp;--&nbsp;initialize the PAM library</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28411"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28414"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int 
  <TT
CLASS="FUNCTION"
>pam_start</TT
></CODE
>(const char * 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>service_name</I
></TT
></I
></TT
>, const char *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
></I
></TT
>, const struct pam_conv *
  <TT
CLASS="PARAMETER"
><I
>pam_conversation</I
></TT
>, pam_handle_t * *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28430"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_start()</TT
> is used to initialize the PAM 
library. It must be called prior to any other usage of the PAM 
library. On success, <TT
CLASS="PARAMETER"
><I
>*pamh</I
></TT
> becomes a handle 
that provides continuity for successive calls to the PAM library. 
<TT
CLASS="FUNCTION"
>pam_start()</TT
> expects arguments as follows: the 
<TT
CLASS="PARAMETER"
><I
>service_name</I
></TT
> of the program, the 
<TT
CLASS="PARAMETER"
><I
>username</I
></TT
> of the individual to be
authenticated, a pointer to an application-supplied
<TT
CLASS="STRUCTNAME"
>pam_conv</TT
> structure, and a pointer to a
<TT
CLASS="PARAMETER"
><I
>pam_handle_t</I
></TT
> pointer.</P
><P
>An application must provide the <I
CLASS="EMPHASIS"
>conversation function</I
> 
used for direct communication between a loaded module and the application. 
The application also typically provides a means for the module to prompt 
the user for a password, etc.</P
><P
>The structure, pam_conv, is defined to be,
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  struct pam_conv {
               int (*conv) (int num_msg,
                            const struct pam_message * *msg,
                            struct pam_response * *resp,
                            void *appdata_ptr);
               void *appdata_ptr;
  };</PRE
></TD
></TR
></TABLE
>
It is initialized by the application before it is passed to the
library. The contents of this structure are attached to the
<TT
CLASS="PARAMETER"
><I
>*pamh</I
></TT
> handle. The point of this argument is to
provide a mechanism for any loaded module to interact directly with the
application program; this is why it is called a conversation structure.</P
><P
>When a module calls the referenced <TT
CLASS="FUNCTION"
>conv()</TT
> function, 
<TT
CLASS="PARAMETER"
><I
>appdata_ptr</I
></TT
> is set to the second element of this
structure.</P
><P
>The other arguments of a call to <TT
CLASS="FUNCTION"
>conv()</TT
> 
concern the information exchanged by module and application. 
<TT
CLASS="PARAMETER"
><I
>num_msg</I
></TT
> holds the length of the array of
pointers passed via <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
>. On success,
the pointer <TT
CLASS="PARAMETER"
><I
>resp</I
></TT
> points to an array of
<TT
CLASS="PARAMETER"
><I
>num_msg</I
></TT
> <TT
CLASS="STRUCTNAME"
>pam_response</TT
>
structures, holding the application-supplied text. Note that 
<TT
CLASS="PARAMETER"
><I
>resp</I
></TT
> is a struct 
<TT
CLASS="STRUCTNAME"
>pam_response</TT
> array and not an array of 
pointers.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28459"
></A
><H2
>Return Value</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28462"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_SUCCESS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Success.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28466"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_BUF_ERR</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Memory allocation error.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28470"
></A
><SPAN
STYLE="white-space: nowrap"
>PAM_ABORT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Internal failure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28474"
></A
><H2
>ERRORS</H2
><P
>May be translated to text with <TT
CLASS="FUNCTION"
>pam_strerror()</TT
>.</P
></DIV
><H1
><A
NAME="BASELIB-PAM-STRERROR"
></A
>pam_strerror</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28482"
></A
><H2
>Name</H2
>pam_strerror&nbsp;--&nbsp;returns a string describing the PAM error</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28485"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28488"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;security/pam_appl.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
  <TT
CLASS="FUNCTION"
>pam_strerror</TT
></CODE
>(pam_handle_t *
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>pamh</I
></TT
></I
></TT
>, int 
  <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>errnum</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28499"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>pam_strerror()</TT
> returns a string describing the PAM 
error associated with <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28506"
></A
><H2
>Return Value</H2
><P
>On success, this function returns a description of the indicated error.
The application 
should not free or modify this string. 
Otherwise, a string
indicating that the error is unknown shall be returned.
It is unspecified whether or not the string returned is translated according to
the setting of <CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
>.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCUTILLIB"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>IV. Utility Libraries</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>15. <A
HREF="#UTILLIB"
>Utility Libraries</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#AEN28514"
>Introduction</A
></DT
><DT
>15.2. <A
HREF="#LIBZ"
>Interfaces for libz</A
></DT
><DD
><DL
><DT
>15.2.1. <A
HREF="#AEN28546"
>Compression Library</A
></DT
></DL
></DD
><DT
>15.3. <A
HREF="#LIBZ-DDEFS"
>Data Definitions for libz</A
></DT
><DD
><DL
><DT
>15.3.1. <A
HREF="#AEN28775"
>zconf.h</A
></DT
><DT
>15.3.2. <A
HREF="#AEN28779"
>zlib.h</A
></DT
></DL
></DD
><DT
>15.4. <A
HREF="#LIBZMAN"
>Interface Definitions for libz</A
></DT
><DD
><DL
><DT
><A
HREF="#ZLIB-ADLER32-1"
>adler32</A
>&nbsp;--&nbsp;compute Adler 32 Checksum</DT
><DT
><A
HREF="#ZLIB-COMPRESS-1"
>compress</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-COMPRESS2-1"
>compress2</A
>&nbsp;--&nbsp;compress data at a specified level</DT
><DT
><A
HREF="#ZLIB-COMPRESSBOUND-1"
>compressBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-CRC32-1"
>crc32</A
>&nbsp;--&nbsp;compute CRC-32 Checksum</DT
><DT
><A
HREF="#ZLIB-DEFLATE-1"
>deflate</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-DEFLATEBOUND-1"
>deflateBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-DEFLATECOPY-1"
>deflateCopy</A
>&nbsp;--&nbsp;copy compression stream</DT
><DT
><A
HREF="#ZLIB-DEFLATEEND-1"
>deflateEnd</A
>&nbsp;--&nbsp;free compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT2"
>deflateInit2_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT"
>deflateInit_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEPARAMS-1"
>deflateParams</A
>&nbsp;--&nbsp;set compression parameters</DT
><DT
><A
HREF="#ZLIB-DEFLATERESET-1"
>deflateReset</A
>&nbsp;--&nbsp;reset compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATESETDICTIONARY-1"
>deflateSetDictionary</A
>&nbsp;--&nbsp;initialize compression dictionary</DT
><DT
><A
HREF="#ZLIB-GET-CRC-TABLE-1"
>get_crc_table</A
>&nbsp;--&nbsp;generate a table for crc calculations</DT
><DT
><A
HREF="#ZLIB-GZCLOSE-1"
>gzclose</A
>&nbsp;--&nbsp;close a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZDOPEN-1"
>gzdopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZEOF-1"
>gzeof</A
>&nbsp;--&nbsp;check for end-of-file on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZERROR-1"
>gzerror</A
>&nbsp;--&nbsp;decode an error on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZFLUSH-1"
>gzflush</A
>&nbsp;--&nbsp;flush a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZGETC-1"
>gzgetc</A
>&nbsp;--&nbsp;read a character from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZGETS-1"
>gzgets</A
>&nbsp;--&nbsp;read a string from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZOPEN-1"
>gzopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPRINTF-1"
>gzprintf</A
>&nbsp;--&nbsp;format data and compress</DT
><DT
><A
HREF="#ZLIB-GZPUTC-1"
>gzputc</A
>&nbsp;--&nbsp;write character to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPUTS-1"
>gzputs</A
>&nbsp;--&nbsp;string write to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREAD-1"
>gzread</A
>&nbsp;--&nbsp;read from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREWIND-1"
>gzrewind</A
>&nbsp;--&nbsp;reset the file-position indicator on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSEEK-1"
>gzseek</A
>&nbsp;--&nbsp;reposition a file-position indicator in a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSETPARAMS-1"
>gzsetparams</A
>&nbsp;--&nbsp;dynamically set compression parameters</DT
><DT
><A
HREF="#ZLIB-GZTELL-1"
>gztell</A
>&nbsp;--&nbsp;find position on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZWRITE-1"
>gzwrite</A
>&nbsp;--&nbsp;write to a compressed file</DT
><DT
><A
HREF="#ZLIB-INFLATE-1"
>inflate</A
>&nbsp;--&nbsp;decompress data</DT
><DT
><A
HREF="#ZLIB-INFLATEEND-1"
>inflateEnd</A
>&nbsp;--&nbsp;free decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT2"
>inflateInit2_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT"
>inflateInit_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATERESET-1"
>inflateReset</A
>&nbsp;--&nbsp;reset decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATESETDICTIONARY-1"
>inflateSetDictionary</A
>&nbsp;--&nbsp;initialize decompression dictionary</DT
><DT
><A
HREF="#ZLIB-INFLATESYNC-1"
>inflateSync</A
>&nbsp;--&nbsp;advance compression stream to next sync point</DT
><DT
><A
HREF="#ZLIB-INFLATESYNCPOINT-1"
>inflateSyncPoint</A
>&nbsp;--&nbsp;test for synchronization point</DT
><DT
><A
HREF="#ZLIB-UNCOMPRESS-1"
>uncompress</A
>&nbsp;--&nbsp;uncompress data</DT
><DT
><A
HREF="#ZLIB-ZERROR-1"
>zError</A
>&nbsp;--&nbsp;translate error number to string</DT
><DT
><A
HREF="#ZLIB-ZLIBVERSION-1"
>zlibVersion</A
>&nbsp;--&nbsp;discover library version at run time</DT
></DL
></DD
><DT
>15.5. <A
HREF="#LIBNCURSES"
>Interfaces for libncurses</A
></DT
><DD
><DL
><DT
>15.5.1. <A
HREF="#AEN31699"
>Curses</A
></DT
></DL
></DD
><DT
>15.6. <A
HREF="#LIBNCURSES-DDEFS"
>Data Definitions for libncurses</A
></DT
><DD
><DL
><DT
>15.6.1. <A
HREF="#AEN32970"
>curses.h</A
></DT
><DT
>15.6.2. <A
HREF="#AEN32974"
>term.h</A
></DT
></DL
></DD
><DT
>15.7. <A
HREF="#LIBNCURSESMAN"
>Interface Definitions for libncurses</A
></DT
><DD
><DL
><DT
><A
HREF="#CURSES-INCHNSTR-1"
>inchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-INCHSTR-1"
>inchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-INSTR-1"
>instr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#LIBNCURSES-MVCUR-1"
>mvcur</A
>&nbsp;--&nbsp;send cursor movement commands to terminal</DT
><DT
><A
HREF="#CURSES-MVINCHNSTR-1"
>mvinchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVINCHSTR-1"
>mvinchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVINSTR-1"
>mvinstr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#CURSES-MVSCANW-1"
>mvscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-MVWINCHNSTR-1"
>mvwinchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVWINCHSTR-1"
>mvwinchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVWINSTR-1"
>mvwinstr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#CURSES-MVWSCANW-1"
>mvwscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-RIPOFFLINE-1"
>ripoffline</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-SCANW-1"
>scanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-VW-SCANW-1"
>vw_scanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-VWSCANW-1"
>vwscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-WINCHNSTR-1"
>winchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-WINCHSTR-1"
>winchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-WINSTR-1"
>winstr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#CURSES-WSCANW-1"
>wscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
></DL
></DD
><DT
>15.8. <A
HREF="#LIBNCURSESW"
>Interfaces for libncursesw</A
></DT
><DD
><DL
><DT
>15.8.1. <A
HREF="#AEN33575"
>Curses Wide</A
></DT
></DL
></DD
><DT
>15.9. <A
HREF="#LIBNCURSESW-DDEFS"
>Data Definitions for libncursesw</A
></DT
><DD
><DL
><DT
>15.9.1. <A
HREF="#AEN35339"
>ncursesw/curses.h</A
></DT
><DT
>15.9.2. <A
HREF="#AEN35343"
>ncursesw/ncurses_dll.h</A
></DT
><DT
>15.9.3. <A
HREF="#AEN35347"
>ncursesw/term.h</A
></DT
><DT
>15.9.4. <A
HREF="#AEN35351"
>ncursesw/unctrl.h</A
></DT
></DL
></DD
><DT
>15.10. <A
HREF="#LIBNCURSESWMAN"
>Interface Definitions for libncursesw</A
></DT
><DT
>15.11. <A
HREF="#LIBUTIL"
>Interfaces for libutil</A
></DT
><DD
><DL
><DT
>15.11.1. <A
HREF="#AEN35378"
>Utility Functions</A
></DT
></DL
></DD
><DT
>15.12. <A
HREF="#LIBUTIL-DDEFS"
>Data Definitions for libutil</A
></DT
><DD
><DL
><DT
>15.12.1. <A
HREF="#AEN35423"
>pty.h</A
></DT
></DL
></DD
><DT
>15.13. <A
HREF="#LIBUTILMAN"
>Interface Definitions for libutil</A
></DT
><DD
><DL
><DT
><A
HREF="#UTILLIB-FORKPTY-3"
>forkpty</A
>&nbsp;--&nbsp;Create a new process attached to an available pseudo-terminal</DT
><DT
><A
HREF="#UTILLIB-LOGIN-3"
>login</A
>&nbsp;--&nbsp;login utility function</DT
><DT
><A
HREF="#UTILLIB-LOGIN-TTY-3"
>login_tty</A
>&nbsp;--&nbsp;Prepare a terminal for login</DT
><DT
><A
HREF="#UTILLIB-LOGOUT-3"
>logout</A
>&nbsp;--&nbsp;logout utility function</DT
><DT
><A
HREF="#UTILLIB-LOGWTMP-3"
>logwtmp</A
>&nbsp;--&nbsp;append an entry to the wtmp file</DT
><DT
><A
HREF="#UTILLIB-OPENPTY-3"
>openpty</A
>&nbsp;--&nbsp;find and open an available pseudo-terminal</DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="UTILLIB"
></A
>Chapter 15. Utility Libraries</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN28514"
>15.1. Introduction</A
></H2
><P
>An LSB-conforming implementation shall also support the following
utility libraries which are built on top of the interfaces provided
by the base libraries. These libraries implement common functionality,
and hide additional system dependent information such as file formats
and device names.

<P
></P
><UL
><LI
><P
>libz</P
></LI
><LI
><P
>libncurses</P
></LI
><LI
><P
>libncursesw</P
></LI
><LI
><P
>libutil</P
></LI
></UL
></P
><P
>The structure of the definitions for these libraries follows the
same model as used for <A
HREF="#BASELIB"
>Base Libraries</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBZ"
>15.2. Interfaces for libz</A
></H2
><P
><A
HREF="#LIB-LIBZ-DEF"
>Table 15-1</A
> defines the library name and shared object name
for the libz library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBZ-DEF"
></A
><P
><B
>Table 15-1. libz Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libz</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libz.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBZ.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN28546"
>15.2.1. Compression Library</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN28549"
>15.2.1.1. Interfaces for Compression Library</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Compression Library specified in <A
HREF="#TBL-LIBZ-COMPR-INTS"
>Table 15-2</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBZ-COMPR-INTS"
></A
><P
><B
>Table 15-2. libz - Compression Library Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>adler32 <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>compress <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>compress2 <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>compressBound(ZLIB_1.2.0) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>crc32 <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflate <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateBound(ZLIB_1.2.0) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateCopy <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateEnd <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateInit2_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateInit_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateParams <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflatePrime(ZLIB_1.2.0.8) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateReset <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>deflateSetDictionary <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>get_crc_table <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzclearerr(ZLIB_1.2.0.2) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzclose <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzdopen <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzeof <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzerror <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzflush <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzgetc <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzgets <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzopen <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzprintf <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzputc <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzputs <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gzread <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzrewind <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzseek <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzsetparams <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>gztell <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>gzwrite <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflate <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateBack(ZLIB_1.2.0) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>inflateBackEnd(ZLIB_1.2.0) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateBackInit_(ZLIB_1.2.0) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateCopy(ZLIB_1.2.0) <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateEnd <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>inflateInit2_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateInit_ <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateReset <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateSetDictionary <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>inflateSync <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>inflateSyncPoint <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>uncompress <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>zError <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>zlibVersion <A
HREF="#REFSTD.LIBZ.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBZ-DDEFS"
>15.3. Data Definitions for libz</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libz.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN28775"
>15.3.1. zconf.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ZEXPORT
#define ZEXPORTVA
#define OF(args)	args
#define ZEXTERN	extern</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN28779"
>15.3.2. zlib.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ZLIB_VERSION	"1.2.2"
#define Z_NULL	0
#define MAX_WBITS	15	/* 32K LZ77 window */
#define MAX_MEM_LEVEL	9	/* Maximum value for memLevel in deflateInit2 */
#define deflateInit2(strm,level,method,windowBits,memLevel,strategy)	\
	deflateInit2_((strm),(level),(method),(windowBits),(memLevel),(strategy),ZLIB_VERSION,sizeof(z_stream))
#define deflateInit(strm,level)	\
	deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm,windowBits)	\
	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm)	\
	inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define inflateBackInit(strm, windowBits, window)	\
        inflateBackInit_((strm), (windowBits), (window), \
                                            ZLIB_VERSION, sizeof(z_stream))

typedef char charf;
typedef int intf;

typedef void *voidpf;
typedef unsigned int uInt;
typedef unsigned long int uLong;
typedef uLong uLongf;
typedef void *voidp;
typedef unsigned char Byte;
typedef off_t z_off_t;
typedef void *const voidpc;

typedef voidpf(*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);
struct internal_state {
    int dummy;
};
typedef Byte Bytef;
typedef uInt uIntf;
typedef unsigned int (*in_func) (void *, unsigned char **);
typedef int (*out_func) (void *, unsigned char *, unsigned int);

typedef struct z_stream_s {
    Bytef *next_in;		/* next input byte */
    uInt avail_in;		/* number of bytes available at next_in */
    uLong total_in;		/* total nb of input bytes read so far */
    Bytef *next_out;		/* next output byte should be put there */
    uInt avail_out;		/* remaining free space at next_out */
    uLong total_out;		/* total nb of bytes output so far */
    char *msg;			/* last error message, NULL if no error */
    struct internal_state *state;	/* not visible by applications */
    alloc_func zalloc;		/* used to allocate the internal state */
    free_func zfree;		/* used to free the internal state */
    voidpf opaque;		/* private data object passed to zalloc and zfree */
    int data_type;		/* best guess about the data type: ascii or binary */
    uLong adler;		/* adler32 value of the uncompressed data */
    uLong reserved;		/* reserved for future use */
} z_stream;

typedef z_stream *z_streamp;
typedef voidp gzFile;

#define Z_NO_FLUSH	0
#define Z_PARTIAL_FLUSH	1
#define Z_SYNC_FLUSH	2
#define Z_FULL_FLUSH	3
#define Z_FINISH	4
#define Z_BLOCK	5

#define Z_ERRNO	(-1)
#define Z_STREAM_ERROR	(-2)
#define Z_DATA_ERROR	(-3)
#define Z_MEM_ERROR	(-4)
#define Z_BUF_ERROR	(-5)
#define Z_VERSION_ERROR	(-6)
#define Z_OK	0
#define Z_STREAM_END	1
#define Z_NEED_DICT	2

#define Z_DEFAULT_COMPRESSION	(-1)
#define Z_NO_COMPRESSION	0
#define Z_BEST_SPEED	1
#define Z_BEST_COMPRESSION	9

#define Z_DEFAULT_STRATEGY	0
#define Z_FILTERED	1
#define Z_HUFFMAN_ONLY	2

#define Z_BINARY	0
#define Z_ASCII	1
#define Z_UNKNOWN	2

#define Z_DEFLATED	8

extern uLong adler32(uLong adler, const Bytef * buf, uInt len);
extern int compress(Bytef * dest, uLongf * destLen, const Bytef * source,
		    uLong sourceLen);
extern int compress2(Bytef * dest, uLongf * destLen, const Bytef * source,
		     uLong sourceLen, int level);
extern uLong compressBound(uLong sourceLen);
extern uLong crc32(uLong crc, const Bytef * buf, uInt len);
extern int deflate(z_streamp strm, int flush);
extern uLong deflateBound(z_streamp strm, uLong sourceLen);
extern int deflateCopy(z_streamp dest, z_streamp source);
extern int deflateEnd(z_streamp strm);
extern int deflateInit2_(z_streamp strm, int level, int method,
			 int windowBits, int memLevel, int strategy,
			 const char *version, int stream_size);
extern int deflateInit_(z_streamp strm, int level, const char *version,
			int stream_size);
extern int deflateParams(z_streamp strm, int level, int strategy);
extern int deflatePrime(z_streamp strm, int bits, int value);
extern int deflateReset(z_streamp strm);
extern int deflateSetDictionary(z_streamp strm, const Bytef * dictionary,
				uInt dictLength);
extern const uLongf *get_crc_table(void);
extern void gzclearerr(gzFile file);
extern int gzclose(gzFile file);
extern gzFile gzdopen(int fd, const char *mode);
extern int gzeof(gzFile file);
extern const char *gzerror(gzFile file, int *errnum);
extern int gzflush(gzFile file, int flush);
extern int gzgetc(gzFile file);
extern char *gzgets(gzFile file, char *buf, int len);
extern gzFile gzopen(const char *path, const char *mode);
extern int gzprintf(gzFile file, const char *format, ...);
extern int gzputc(gzFile file, int c);
extern int gzputs(gzFile file, const char *s);
extern int gzread(gzFile file, voidp buf, unsigned int len);
extern int gzrewind(gzFile file);
extern z_off_t gzseek(gzFile file, z_off_t offset, int whence);
extern int gzsetparams(gzFile file, int level, int strategy);
extern z_off_t gztell(gzFile file);
extern int gzwrite(gzFile file, voidpc buf, unsigned int len);
extern int inflate(z_streamp strm, int flush);
extern int inflateBack(z_streamp strm, in_func in, void *in_desc,
		       out_func out, void *out_desc);
extern int inflateBackEnd(z_streamp strm);
extern int inflateBackInit_(z_streamp strm, int windowBits,
			    unsigned char *window, const char *version,
			    int stream_size);
extern int inflateCopy(z_streamp dest, z_streamp source);
extern int inflateEnd(z_streamp strm);
extern int inflateInit2_(z_streamp strm, int windowBits,
			 const char *version, int stream_size);
extern int inflateInit_(z_streamp strm, const char *version,
			int stream_size);
extern int inflateReset(z_streamp strm);
extern int inflateSetDictionary(z_streamp strm, const Bytef * dictionary,
				uInt dictLength);
extern int inflateSync(z_streamp strm);
extern int inflateSyncPoint(z_streamp z);
extern int uncompress(Bytef * dest, uLongf * destLen, const Bytef * source,
		      uLong sourceLen);
extern const char *zError(int);
extern const char *zlibVersion(void);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBZMAN"
>15.4. Interface Definitions for libz</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#ZLIB-ADLER32-1"
>adler32</A
>&nbsp;--&nbsp;compute Adler 32 Checksum</DT
><DT
><A
HREF="#ZLIB-COMPRESS-1"
>compress</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-COMPRESS2-1"
>compress2</A
>&nbsp;--&nbsp;compress data at a specified level</DT
><DT
><A
HREF="#ZLIB-COMPRESSBOUND-1"
>compressBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-CRC32-1"
>crc32</A
>&nbsp;--&nbsp;compute CRC-32 Checksum</DT
><DT
><A
HREF="#ZLIB-DEFLATE-1"
>deflate</A
>&nbsp;--&nbsp;compress data</DT
><DT
><A
HREF="#ZLIB-DEFLATEBOUND-1"
>deflateBound</A
>&nbsp;--&nbsp;compute compressed data size</DT
><DT
><A
HREF="#ZLIB-DEFLATECOPY-1"
>deflateCopy</A
>&nbsp;--&nbsp;copy compression stream</DT
><DT
><A
HREF="#ZLIB-DEFLATEEND-1"
>deflateEnd</A
>&nbsp;--&nbsp;free compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT2"
>deflateInit2_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEINIT"
>deflateInit_</A
>&nbsp;--&nbsp;initialize compression system</DT
><DT
><A
HREF="#ZLIB-DEFLATEPARAMS-1"
>deflateParams</A
>&nbsp;--&nbsp;set compression parameters</DT
><DT
><A
HREF="#ZLIB-DEFLATERESET-1"
>deflateReset</A
>&nbsp;--&nbsp;reset compression stream state</DT
><DT
><A
HREF="#ZLIB-DEFLATESETDICTIONARY-1"
>deflateSetDictionary</A
>&nbsp;--&nbsp;initialize compression dictionary</DT
><DT
><A
HREF="#ZLIB-GET-CRC-TABLE-1"
>get_crc_table</A
>&nbsp;--&nbsp;generate a table for crc calculations</DT
><DT
><A
HREF="#ZLIB-GZCLOSE-1"
>gzclose</A
>&nbsp;--&nbsp;close a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZDOPEN-1"
>gzdopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZEOF-1"
>gzeof</A
>&nbsp;--&nbsp;check for end-of-file on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZERROR-1"
>gzerror</A
>&nbsp;--&nbsp;decode an error on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZFLUSH-1"
>gzflush</A
>&nbsp;--&nbsp;flush a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZGETC-1"
>gzgetc</A
>&nbsp;--&nbsp;read a character from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZGETS-1"
>gzgets</A
>&nbsp;--&nbsp;read a string from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZOPEN-1"
>gzopen</A
>&nbsp;--&nbsp;open a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPRINTF-1"
>gzprintf</A
>&nbsp;--&nbsp;format data and compress</DT
><DT
><A
HREF="#ZLIB-GZPUTC-1"
>gzputc</A
>&nbsp;--&nbsp;write character to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZPUTS-1"
>gzputs</A
>&nbsp;--&nbsp;string write to a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREAD-1"
>gzread</A
>&nbsp;--&nbsp;read from a compressed file</DT
><DT
><A
HREF="#ZLIB-GZREWIND-1"
>gzrewind</A
>&nbsp;--&nbsp;reset the file-position indicator on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSEEK-1"
>gzseek</A
>&nbsp;--&nbsp;reposition a file-position indicator in a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZSETPARAMS-1"
>gzsetparams</A
>&nbsp;--&nbsp;dynamically set compression parameters</DT
><DT
><A
HREF="#ZLIB-GZTELL-1"
>gztell</A
>&nbsp;--&nbsp;find position on a compressed file stream</DT
><DT
><A
HREF="#ZLIB-GZWRITE-1"
>gzwrite</A
>&nbsp;--&nbsp;write to a compressed file</DT
><DT
><A
HREF="#ZLIB-INFLATE-1"
>inflate</A
>&nbsp;--&nbsp;decompress data</DT
><DT
><A
HREF="#ZLIB-INFLATEEND-1"
>inflateEnd</A
>&nbsp;--&nbsp;free decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT2"
>inflateInit2_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATEINIT"
>inflateInit_</A
>&nbsp;--&nbsp;initialize decompression system</DT
><DT
><A
HREF="#ZLIB-INFLATERESET-1"
>inflateReset</A
>&nbsp;--&nbsp;reset decompression stream state</DT
><DT
><A
HREF="#ZLIB-INFLATESETDICTIONARY-1"
>inflateSetDictionary</A
>&nbsp;--&nbsp;initialize decompression dictionary</DT
><DT
><A
HREF="#ZLIB-INFLATESYNC-1"
>inflateSync</A
>&nbsp;--&nbsp;advance compression stream to next sync point</DT
><DT
><A
HREF="#ZLIB-INFLATESYNCPOINT-1"
>inflateSyncPoint</A
>&nbsp;--&nbsp;test for synchronization point</DT
><DT
><A
HREF="#ZLIB-UNCOMPRESS-1"
>uncompress</A
>&nbsp;--&nbsp;uncompress data</DT
><DT
><A
HREF="#ZLIB-ZERROR-1"
>zError</A
>&nbsp;--&nbsp;translate error number to string</DT
><DT
><A
HREF="#ZLIB-ZLIBVERSION-1"
>zlibVersion</A
>&nbsp;--&nbsp;discover library version at run time</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libz and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBZ"
>Section 15.2</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="ZLIB-ADLER32-1"
></A
>adler32</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28792"
></A
><H2
>Name</H2
>adler32&nbsp;--&nbsp;compute Adler 32 Checksum</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28797"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28798"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>uLong
<TT
CLASS="FUNCTION"
>adler32</TT
></CODE
>(uLong
<TT
CLASS="PARAMETER"
><I
>adler</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28809"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>adler32()</TT
> function shall compute a running
Adler-32 checksum (as described in <A
HREF="#STD.RFC1950"
>RFC 1950: ZLIB Compressed Data Format Specication</A
>).
On entry, <TT
CLASS="PARAMETER"
><I
>adler</I
></TT
> is the previous value for the
checksum, and <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall point to an array of
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes of data to be added to this checksum.
The <TT
CLASS="FUNCTION"
>adler32()</TT
> function shall return the new checksum.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
> (or 
<CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>), <TT
CLASS="FUNCTION"
>adler32()</TT
>
shall return the initial checksum.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28823"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>adler32()</TT
> function shall return  
the new checksum value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28827"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28830"
></A
><H2
>Application Usage (informative)</H2
><P
>The following code fragment demonstrates typical usage of
the <TT
CLASS="FUNCTION"
>adler32()</TT
> function:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-COMPRESS-1"
></A
>compress</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28839"
></A
><H2
>Name</H2
>compress&nbsp;--&nbsp;compress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28844"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28845"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>compress</TT
></CODE
>(Bytef *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, uLongf *
<TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28858"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>compress()</TT
> function shall attempt to compress
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data in the buffer 
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, placing the result in the buffer
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. </P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
> should point to a value describing
the size of the <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer. 
The application should ensure that this value
be at least 
<TT
CLASS="GRAPHIC"
>(sourceLen  1.001) + 12</TT
>.
On successful exit, the variable referenced by <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>
shall be updated to hold the length of compressed data in
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>compress()</TT
> function is equivalent to 
<TT
CLASS="FUNCTION"
>compress2()</TT
> with a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28878"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>compress()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>compress()</TT
> shall return a value to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28884"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>compress()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28889"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was not large enough to hold the
compressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28895"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-COMPRESS2-1"
></A
>compress2</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28904"
></A
><H2
>Name</H2
>compress2&nbsp;--&nbsp;compress data at a specified level</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28909"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28910"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>compress2</TT
></CODE
>(Bytef *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, uLongf *
<TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28925"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>compress2()</TT
> function shall attempt to compress
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data in the buffer 
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, placing the result in the buffer
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, at the level described by 
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>. 
The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.</P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
> should point to a value describing
the size of the <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer. 
The application should ensure that this value
be at least 
<TT
CLASS="GRAPHIC"
>(sourceLen  1.001) + 12</TT
>.
On successful exit, the variable referenced by <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>
shall be updated to hold the length of compressed data in
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>compress()</TT
> function is equivalent to 
<TT
CLASS="FUNCTION"
>compress2()</TT
> with a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28956"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>compress2()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>compress2()</TT
> shall return a value to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN28962"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>compress2()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28967"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was not large enough to hold the
compressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28973"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN28978"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> was not <CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>,
or was not between 0 and 9.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-COMPRESSBOUND-1"
></A
>compressBound</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN28989"
></A
><H2
>Name</H2
>compressBound&nbsp;--&nbsp;compute compressed data size</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN28994"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN28995"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>compressBound</TT
></CODE
>(uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29002"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>compressBound()</TT
> function shall estimate the size
of buffer required to compress <TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>
bytes of data using the <TT
CLASS="FUNCTION"
>compress()</TT
>
or <TT
CLASS="FUNCTION"
>compress2()</TT
> functions.
If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data, using the
parameters stored in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, 
in a single
call to <TT
CLASS="FUNCTION"
>compress()</TT
> or 
<TT
CLASS="FUNCTION"
>compress2()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29013"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>compressBound()</TT
> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <TT
CLASS="FUNCTION"
>compress()</TT
>
or <TT
CLASS="FUNCTION"
>compress2()</TT
>.
This function may return a conservative value that may be larger than 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29020"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-CRC32-1"
></A
>crc32</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29027"
></A
><H2
>Name</H2
>crc32&nbsp;--&nbsp;compute CRC-32 Checksum</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29032"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29033"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>uLong
<TT
CLASS="FUNCTION"
>crc32</TT
></CODE
>(uLong
<TT
CLASS="PARAMETER"
><I
>crc</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29044"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>crc32()</TT
> function shall compute a running
Cyclic Redundancy Check checksum, as defined in <A
HREF="#STD.ITUV42"
>ITU-T V.42</A
>.
On entry, <TT
CLASS="PARAMETER"
><I
>crc</I
></TT
> is the previous value for the
checksum, and <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall point to an array of
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes of data to be added to this checksum.
The <TT
CLASS="FUNCTION"
>crc32()</TT
> function shall return the new checksum.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
> (or 
<CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>), <TT
CLASS="FUNCTION"
>crc32()</TT
>
shall return the initial checksum.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29058"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>crc32()</TT
> function shall return  
the new checksum value.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29062"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29065"
></A
><H2
>Application Usage (informative)</H2
><P
>The following code fragment demonstrates typical usage of
the <TT
CLASS="FUNCTION"
>crc32()</TT
> function:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();</PRE
></TD
></TR
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATE-1"
></A
>deflate</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29074"
></A
><H2
>Name</H2
>deflate&nbsp;--&nbsp;compress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29079"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29080"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflate</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29089"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall attempt to compress
data until either the input buffer is empty or the output buffer is full.
The <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> references a
<TT
CLASS="STRUCTNAME"
>z_stream</TT
> structure. Before the first call to
<TT
CLASS="FUNCTION"
>deflate()</TT
>, this structure
should have been initialized by a call to 
<TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> is only in the binary standard; source
level applications should initialize <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
via a call to <TT
CLASS="FUNCTION"
>deflateInit()</TT
> or 
<TT
CLASS="FUNCTION"
>deflateInit2()</TT
>.</P
></BLOCKQUOTE
></DIV
>
In addition, the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> input and output buffers
should have been initialized as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29105"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to the data to be compressed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29110"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the number of bytes of data in the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29116"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to a buffer where compressed data may be placed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29121"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the size in bytes of the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="FUNCTION"
>deflate()</TT
> function
shall perform one or both of the following actions:
<P
></P
><OL
TYPE="1"
><LI
><P
>Compress input data from <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>
and update <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> to reflect the data that has been 
compressed.</P
></LI
><LI
><P
>Fill the output buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
and update <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
> to reflect the compressed data that 
has been placed there. If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is not
<CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).</P
></LI
></OL
></P
><P
>The <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall return when either
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> reaches zero (indicating that all the input
data has been compressed), or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> reaches
zero (indicating that the output buffer is full).</P
><P
>On success, the <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall set the
<CODE
CLASS="STRUCTFIELD"
>adler</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
to the <TT
CLASS="FUNCTION"
>adler32()</TT
> checksum of all the input data compressed
so far (represented by <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
>).</P
><P
>If the <TT
CLASS="FUNCTION"
>deflate()</TT
> function shall attempt to determine
the type of input data, and set field <CODE
CLASS="STRUCTFIELD"
>data_type</CODE
>
in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to <CODE
CLASS="CONSTANT"
>Z_ASCII</CODE
> if the
majority of the data bytes fall within the ASCII (ISO 646) printable
character range. Otherwise, it shall set <CODE
CLASS="STRUCTFIELD"
>data_type</CODE
>
to <CODE
CLASS="CONSTANT"
>Z_BINARY</CODE
>.
This data type is informational only, and does not affect the compression
algorithm.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Future versions of the LSB may remove this requirement, since it is based
on an outdated character set that does not support Internationalization,
and does not affect the algorithm. It is included for information
only at this release. Applications should not depend on this field.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN29164"
></A
><H3
>Flush Operation</H3
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> determines when compressed bits 
are added to the output buffer in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>.
If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>deflate()</TT
>
may return with some data pending output, and not yet added to the 
output buffer.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>deflate()</TT
> shall flush all pending output to
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and align the output to a byte 
boundary. A synchronization point is generated in  the output.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>,
all output shall be flushed, as for <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
and the compression state shall be reset. 
A synchronization point is generated in  the output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
><CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.</P
></BLOCKQUOTE
></DIV
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>,
all pending input shall be processed and <TT
CLASS="FUNCTION"
>deflate()</TT
>
shall return with <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
> if there is
sufficient space in the output buffer at <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
as indicated by <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>. If
<TT
CLASS="FUNCTION"
>deflate()</TT
> is called with <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>
set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
> and there is insufficient space to store
the compressed data, and no other error has occurred during compression,
<TT
CLASS="FUNCTION"
>deflate()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>,
and the application should call <TT
CLASS="FUNCTION"
>deflate()</TT
> again with
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> unchanged, and having updated <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>.</P
><P
>If all the compression is to be done in a single step, 
<TT
CLASS="FUNCTION"
>deflate()</TT
>
may be called with <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> set to 
<CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
> immediately after the stream
has been initialized if <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>
is set to at least the value returned by <TT
CLASS="FUNCTION"
>deflateBound()</TT
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29208"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflate()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, unless <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> was set 
to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
> and there was sufficient space in the output buffer
to compress all of the input data. In this case, <TT
CLASS="FUNCTION"
>deflate()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
>.
On error, <TT
CLASS="FUNCTION"
>deflate()</TT
> shall return a value to indicate
the error.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If <TT
CLASS="FUNCTION"
>deflate()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>
and has set <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> to zero, the function should
be called again with the same value for <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>, and with
updated <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> until <TT
CLASS="FUNCTION"
>deflate()</TT
>
returns with <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
> (or <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
>
if <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>) and a non-zero 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29232"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflate()</TT
> shall return a value as described 
below, and set the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to point to a string describing the error:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29239"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No progress is possible; either <CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
>
or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> was zero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29246"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29251"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEBOUND-1"
></A
>deflateBound</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29263"
></A
><H2
>Name</H2
>deflateBound&nbsp;--&nbsp;compute compressed data size</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29268"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29269"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateBound</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29278"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateBound()</TT
> function shall estimate the size
of buffer required to compress <TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>
bytes of data. If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data, using the
parameters stored in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, 
in a single
call to <TT
CLASS="FUNCTION"
>deflate()</TT
> with flush set to
<CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>.</P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
should
have been initialized via a call to <TT
CLASS="FUNCTION"
>deflateInit_()</TT
>
or <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29291"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateBound()</TT
> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <TT
CLASS="FUNCTION"
>deflate()</TT
>.
If the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is not correctly initialized,
or is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, then <TT
CLASS="FUNCTION"
>deflateBound()</TT
>
may return a conservative value that may be larger than 
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29300"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATECOPY-1"
></A
>deflateCopy</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29307"
></A
><H2
>Name</H2
>deflateCopy&nbsp;--&nbsp;copy compression stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29312"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29313"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateCopy</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, z_streamp
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29322"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateCopy()</TT
> function shall copy the compression state
information in <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> to the uninitialized
<TT
CLASS="STRUCTNAME"
>z_stream</TT
> structure referenced by 
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
><P
>On successful return, <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> will be an exact copy
of the stream referenced by <TT
CLASS="PARAMETER"
><I
>source</I
></TT
>. The input and
output buffer pointers in <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> will reference the same data.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29334"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateCopy()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return a value less than zero to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29339"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateCopy()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29344"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state in <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> is inconsistent, or
either <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> or
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29353"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29358"
></A
><H2
>Application Usage (informative)</H2
><P
>This function can be useful when several compression strategies will
be tried, for example when there are several ways of pre-processing the
input data with a filter. The streams that will be discarded should then
be freed by calling <TT
CLASS="FUNCTION"
>deflateEnd()</TT
>. Note that 
<TT
CLASS="FUNCTION"
>deflateCopy()</TT
> duplicates the
internal compression state which can be quite large, so this strategy
may be slow and can consume lots of memory.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEEND-1"
></A
>deflateEnd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29367"
></A
><H2
>Name</H2
>deflateEnd&nbsp;--&nbsp;free compression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29372"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29373"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateEnd</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29380"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateEnd()</TT
> function shall free all allocated
state information referenced by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output is discarded, and unprocessed input is ignored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29385"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateEnd()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, or <SPAN
CLASS="RETURNVALUE"
>Z_DATA_ERROR</SPAN
>
if there was pending output discarded or input unprocessed.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29392"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateEnd()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent or inappropriate.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEINIT2"
></A
>deflateInit2_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29409"
></A
><H2
>Name</H2
>deflateInit2_&nbsp;--&nbsp;initialize compression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29414"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29415"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>deflateInit2_</TT
>
  </CODE
>(z_streamp <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>method</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>memLevel</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
>, char * <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29436"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> function shall initialize the compression
system.
On entry, <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
> shall refer to a user supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29444"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29451"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29459"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and <CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with the version
implemented, or if the size of the <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size in the library 
implementation, <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>method</I
></TT
> selects the compression algorithm to use. LSB
conforming implementation shall support the <CODE
CLASS="CONSTANT"
>Z_DEFLATED</CODE
> method,
and may support other implementation defined methods.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
> parameter shall be a base 2 logarithm of the window 
size to use, and shall be a value between <CODE
CLASS="CONSTANT"
>8</CODE
> and <CODE
CLASS="CONSTANT"
>15</CODE
>.
A smaller value will use less memory, but will result in a poorer compression ratio, 
while a higher value will
give better compression but utilize more memory.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>memLevel</I
></TT
> parameter specifies how much memory to use for the 
internal state. The value of <TT
CLASS="PARAMETER"
><I
>memLevel</I
></TT
> shall be between
<CODE
CLASS="CONSTANT"
>1</CODE
> and <CODE
CLASS="CONSTANT"
>MAX_MEM_LEVEL</CODE
>. Smaller values
use less memory but are slower, while higher values use more memory to gain compression speed.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
> parameter selects the compression strategy to use:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29501"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use the system default compression strategy. <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>
is particularly appropriate for text data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29507"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
> uses more Huffman encoding
and less string matching than <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29514"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_HUFFMAN_ONLY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>force Huffman encoding only, with no string match.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>deflateInit2()</TT
> macro.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29522"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29528"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29533"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29538"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29543"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEINIT"
></A
>deflateInit_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29556"
></A
><H2
>Name</H2
>deflateInit_&nbsp;--&nbsp;initialize compression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29561"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29562"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateInit_</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29575"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function shall initialize 
the compression
system.
On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall refer to a user 
supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). 
The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29583"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29590"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory
allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is
<CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29598"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data
that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with
the version implemented, or if the size of the
<TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size
in the library
implementation, <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.</P
><P
>The <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>deflateInit()</TT
> macro.</P
><P
>The <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function is equivalent to
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> deflateInit2_(stream, level, Z_DEFLATED, MAX_WBITS, MAX_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29631"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29637"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29642"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29647"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29652"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-DEFLATEPARAMS-1"
></A
>deflateParams</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29665"
></A
><H2
>Name</H2
>deflateParams&nbsp;--&nbsp;set compression parameters</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29670"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29671"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateParams</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29682"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateParams()</TT
> function shall dynamically
alter the compression parameters for the compression stream object
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall refer to a user supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure), already initialized
via a call to <TT
CLASS="FUNCTION"
>deflateInit_()</TT
> or
<TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> supplied shall be a value between
<CODE
CLASS="CONSTANT"
>0</CODE
> and <CODE
CLASS="CONSTANT"
>9</CODE
>, or the value
<CODE
CLASS="CONSTANT"
>Z_DEFAULT_COMPRESSION</CODE
>. A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>1</CODE
> requests the highest speed, while a <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>
of <CODE
CLASS="CONSTANT"
>9</CODE
> requests the highest compression.
A <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> of <CODE
CLASS="CONSTANT"
>0</CODE
> indicates that no
compression should be used, and the output shall be the same as the input.
If the compression level is altered by <TT
CLASS="FUNCTION"
>deflateParams()</TT
>,
and some data has already been compressed with this <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
(i.e. <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> is not zero),
and the new <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> requires a different
underlying compression method, then <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
shall be flushed by a call to <TT
CLASS="FUNCTION"
>deflate()</TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
> parameter selects the compression strategy to use:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29712"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use the system default compression strategy. <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>
is particularly appropriate for text data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29718"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <CODE
CLASS="CONSTANT"
>Z_FILTERED</CODE
> uses more Huffman encoding
and less string matching than <CODE
CLASS="CONSTANT"
>Z_DEFAULT_STRATEGY</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29725"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_HUFFMAN_ONLY</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>force Huffman encoding only, with no string match.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29731"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>deflateParams()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>deflateParams()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29737"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateParams()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29742"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29747"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29752"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient space in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
to flush the current output.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29761"
></A
><H2
>Application Usage (Informative)</H2
><P
>Applications should ensure that the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is flushed,
e.g. by a call to <KBD
CLASS="USERINPUT"
>deflate(stream, Z_SYNC_FLUSH)</KBD
>
before calling <TT
CLASS="FUNCTION"
>deflateParams()</TT
>, or ensure that there is
sufficient space in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> (as identified by
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>) to ensure that all pending output and
all uncompressed input can be flushed in a single call to
<TT
CLASS="FUNCTION"
>deflate()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Although the <TT
CLASS="FUNCTION"
>deflateParams()</TT
> function should flush pending output
and compress all pending input, the result is unspecified if there is insufficient
space in the output buffer. Applications should only call <TT
CLASS="FUNCTION"
>deflateParams()</TT
>
when the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is effectively empty (flushed).</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>The <TT
CLASS="FUNCTION"
>deflateParams()</TT
> can be used to switch between
compression and straight copy of the
input data, or to switch to a different kind of input data requiring a
different strategy.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATERESET-1"
></A
>deflateReset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29782"
></A
><H2
>Name</H2
>deflateReset&nbsp;--&nbsp;reset compression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29787"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29788"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateReset</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29795"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateReset()</TT
> function shall reset all state
associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output shall be discarded, and the counts of processed
bytes (<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
>) shall be reset to zero.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29802"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateReset()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29808"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateReset()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent or inappropriate.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-DEFLATESETDICTIONARY-1"
></A
>deflateSetDictionary</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29825"
></A
><H2
>Name</H2
>deflateSetDictionary&nbsp;--&nbsp;initialize compression dictionary</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29830"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29831"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>deflateSetDictionary</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29842"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
> function shall initialize the
compression dictionary associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
using the <TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
> bytes referenced by
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>.</P
><P
>The implementation may silently use a subset of the provided dictionary
if the dictionary cannot fit in the current window associated with
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> (see <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
>).
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.</P
><P
>If the dictionary is successfully set, the Adler32 checksum of the entire
provided dictionary
shall be stored in the <CODE
CLASS="STRUCTFIELD"
>adler</CODE
> member of 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>. This value may be used by the decompression
system to select the correct dictionary. The compression and decompression 
systems must use the same dictionary.</P
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall reference an initialized compression
stream, with <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> zero (i.e. no data
has been compressed since the stream was initialized).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29858"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate an error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29864"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29869"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29877"
></A
><H2
>Application Usage (informative)</H2
><P
>The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.</P
><P
>The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.</P
></DIV
><H1
><A
NAME="ZLIB-GET-CRC-TABLE-1"
></A
>get_crc_table</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29885"
></A
><H2
>Name</H2
>get_crc_table&nbsp;--&nbsp;generate a table for crc calculations</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29890"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29891"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const uLongf *
<TT
CLASS="FUNCTION"
>get_crc_table</TT
></CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29897"
></A
><H2
>Description</H2
><P
>Generate tables for a byte-wise 32-bit CRC calculation based on the polynomial:
<TT
CLASS="LITERAL"
>x<SUP
>32</SUP
>+x<SUP
>26</SUP
>+x<SUP
>23</SUP
>+x<SUP
>22</SUP
>+x<SUP
>16</SUP
>+x<SUP
>12</SUP
>+x<SUP
>11</SUP
>+x<SUP
>10</SUP
>+x<SUP
>8</SUP
>+x<SUP
>7</SUP
>+x<SUP
>5</SUP
>+x<SUP
>4</SUP
>+x<SUP
>2</SUP
>+x+1</TT
></P
><P
>In a multi-threaded application, <TT
CLASS="FUNCTION"
>get_crc_table()</TT
>
should be called by one thread to initialize the tables before any other
thread calls any <TT
CLASS="LITERAL"
>libz</TT
> function.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29917"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>get_crc_table()</TT
> function shall return a
pointer to the first of a set of tables used internally to calculate
CRC-32 values (see <TT
CLASS="FUNCTION"
>crc32()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29922"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-GZCLOSE-1"
></A
>gzclose</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29929"
></A
><H2
>Name</H2
>gzclose&nbsp;--&nbsp;close a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29934"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29935"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzclose</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29942"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzclose()</TT
> function shall close the compressed file stream
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> was open for writing, <TT
CLASS="FUNCTION"
>gzclose()</TT
>
shall first flush any pending output. Any state information allocated shall
be freed.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29949"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzclose()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>gzclose()</TT
> shall return an error value as described below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN29955"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzclose()</TT
> may set
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.
The <TT
CLASS="FUNCTION"
>gzclose()</TT
> shall return a value other than <CODE
CLASS="CONSTANT"
>Z_OK</CODE
>
on error.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29963"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
> (or <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>),
or did not refer to an open compressed file stream.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29971"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred in the underlying base libraries, and the application should check
<CODE
CLASS="VARNAME"
>errno</CODE
> for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN29977"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible during buffer flush (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZDOPEN-1"
></A
>gzdopen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN29987"
></A
><H2
>Name</H2
>gzdopen&nbsp;--&nbsp;open a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN29992"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN29993"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   gzFile <TT
CLASS="FUNCTION"
>gzdopen</TT
>
  </CODE
>( int <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>,  const char *<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30002"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzdopen()</TT
> function shall attempt to associate
the open file
referenced by <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> with a <SPAN
CLASS="TYPE"
>gzFile</SPAN
>
object.
The <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> argument is based on that of 
<TT
CLASS="FUNCTION"
>fopen()</TT
>, but the 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> parameter may also contain the following characters:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30012"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression level to <TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> for further details.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30019"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression strategy to <TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
>.
The letter <TT
CLASS="LITERAL"
>f</TT
> corresponds to filtered data, 
the letter <TT
CLASS="LITERAL"
>h</TT
>
corresponds to Huffman only compression, and 
the letter <TT
CLASS="LITERAL"
>R</TT
>
corresponds to Run Length Encoding.
See <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> for further details.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
><P
>If <TT
CLASS="PARAMETER"
><I
>fd</I
></TT
> refers to an uncompressed file, and 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> refers to a read mode, 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall attempt to open the file and return
a <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object suitable for reading directly from the file
without any decompression.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>
is <TT
CLASS="LITERAL"
>NULL</TT
>, or if <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> does not contain
one of <TT
CLASS="LITERAL"
>r</TT
>, <TT
CLASS="LITERAL"
>w</TT
>, or <TT
CLASS="LITERAL"
>a</TT
>,
<TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>,
and need not set any other error condition.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30047"
></A
><H2
>Example</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>gzdopen(fileno(stdin), "r");</PRE
></TD
></TR
></TABLE
>
Attempt to associate the standard input with a <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30052"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall return a 
<SPAN
CLASS="TYPE"
>gzFile</SPAN
> object. On failure, 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
> and
may set <CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>At version 1.2.2, <CODE
CLASS="VARNAME"
>zlib</CODE
>
does not set <CODE
CLASS="VARNAME"
>errno</CODE
> for several
error conditions. Applications may not be able to
determine the cause of an error.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30064"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzdopen()</TT
> may set
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><H1
><A
NAME="ZLIB-GZEOF-1"
></A
>gzeof</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30073"
></A
><H2
>Name</H2
>gzeof&nbsp;--&nbsp;check for end-of-file on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30078"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30079"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzeof</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30086"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzeof()</TT
> function shall test the compressed file stream
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> for end of file.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30091"
></A
><H2
>Return Value</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> was open for reading
and end of file has been reached, <TT
CLASS="FUNCTION"
>gzeof()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>1</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>gzeof()</TT
> shall return <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30099"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-GZERROR-1"
></A
>gzerror</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30106"
></A
><H2
>Name</H2
>gzerror&nbsp;--&nbsp;decode an error on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30111"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30112"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   const char * <TT
CLASS="FUNCTION"
>gzerror</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int * <TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30121"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzerror()</TT
> function shall return a string describing
the last error to have occurred associated with the open compressed file stream
referred to by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
It shall also set the location referenced by
<TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
> to an integer value that further identifies the
error.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30127"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>gzerror()</TT
> function shall return a string that
describes the last error associated with the given
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> compressed file stream.
This string shall have the format
<TT
CLASS="LITERAL"
>"%s: %s"</TT
>, with the name of the file, followed by a colon,
a space, and the description of the error. If the compressed file stream
was opened by a call to <TT
CLASS="FUNCTION"
>gzdopen()</TT
>, the format of the
filename is unspecified.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>Although in all current implementations of libz file descriptors
are named <TT
CLASS="LITERAL"
>"&#60;fd:%d&#62;"</TT
>, the code suggests that this
is for debugging purposes only, and may change in a future release.</P
></BLOCKQUOTE
></DIV
></P
><P
>It is unspecified if the string returned is determined by the setting
of the <CODE
CLASS="CONSTANT"
>LC_MESSAGES</CODE
> category in the current locale.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30140"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-GZFLUSH-1"
></A
>gzflush</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30147"
></A
><H2
>Name</H2
>gzflush&nbsp;--&nbsp;flush a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30152"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30153"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>gzflush</TT
></CODE
>(gzFile
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30162"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzflush()</TT
> function shall flush pending
output to the compressed file stream identified by
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which must be open for writing.&#13;</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN30167"
></A
><H3
>Flush Operation</H3
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> determines which compressed bits 
are added to the output file.
If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>gzflush()</TT
>
may return with some data pending output, and not yet written to the file.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>gzflush()</TT
> shall flush all pending output to
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> and align the output to a byte 
boundary.
There may still be data pending compression that is not flushed.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>,
all output shall be flushed, as for <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
and the compression state shall be reset.
There may still be data pending compression that is not flushed.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
><CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.</P
></BLOCKQUOTE
></DIV
></P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>,
all pending uncompressed data shall be compressed
and all output shall be flushed.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30191"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzflush()</TT
> shall return the value
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise <TT
CLASS="FUNCTION"
>gzflush()</TT
> shall return
a value to indicate the error, and may set the error number
associated with the compressed file stream 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>
and the flush operation is successful, <TT
CLASS="FUNCTION"
>gzflush()</TT
>
will return <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, but the compressed
file stream error value may be set to <CODE
CLASS="CONSTANT"
>Z_STREAM_END</CODE
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30205"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzflush()</TT
> shall return an error
value, and may set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications may use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30213"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30219"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, is not open for writing, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30224"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30230"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to compress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZGETC-1"
></A
>gzgetc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30239"
></A
><H2
>Name</H2
>gzgetc&nbsp;--&nbsp;read a character from a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30244"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30245"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzgetc</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30252"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzgetc()</TT
> function shall read the next single
character from the compressed file stream
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a read mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30259"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzgetc()</TT
> shall return the uncompressed
character read,
otherwise, on end of file or error, <TT
CLASS="FUNCTION"
>gzgetc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30265"
></A
><H2
>Errors</H2
><P
>On end of file or error, <TT
CLASS="FUNCTION"
>gzgetc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>. Further information can be found
by calling <TT
CLASS="FUNCTION"
>gzerror()</TT
> with a pointer to the 
compressed file stream.</P
></DIV
><H1
><A
NAME="ZLIB-GZGETS-1"
></A
>gzgets</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30275"
></A
><H2
>Name</H2
>gzgets&nbsp;--&nbsp;read a string from a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30280"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30281"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   char * <TT
CLASS="FUNCTION"
>gzgets</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, char * <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30292"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzgets()</TT
> function shall attempt to read
data from the compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>,
uncompressing it into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> until
either <TT
CLASS="PARAMETER"
><I
>len</I
></TT
><TT
CLASS="LITERAL"
>-1</TT
> bytes
have been inserted into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, or until
a newline character has been uncompressed into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
A null byte shall be appended to the uncompressed data. The
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
> shall have been opened
in for reading (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30305"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzgets()</TT
> shall return a pointer to 
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. Otherwise, <TT
CLASS="FUNCTION"
>gzgets()</TT
>
shall return <SPAN
CLASS="RETURNVALUE"
>Z_NULL</SPAN
>.
Applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30313"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzgets()</TT
> shall 
return <SPAN
CLASS="RETURNVALUE"
>Z_NULL</SPAN
>. The following conditions shall
always be treated as an error:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
or does not refer to a file open for reading;</TD
></TR
><TR
><TD
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>;</TD
></TR
><TR
><TD
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
> is less than or equal to zero.</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></DIV
><H1
><A
NAME="ZLIB-GZOPEN-1"
></A
>gzopen</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30331"
></A
><H2
>Name</H2
>gzopen&nbsp;--&nbsp;open a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30336"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30337"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   gzFile <TT
CLASS="FUNCTION"
>gzopen</TT
>
  </CODE
>(const char *<TT
CLASS="PARAMETER"
><I
>path</I
></TT
> , const char *<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30346"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzopen()</TT
> function shall open the compressed file
named by <TT
CLASS="PARAMETER"
><I
>path</I
></TT
>.
The <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> argument is based on that of 
<TT
CLASS="FUNCTION"
>fopen()</TT
>, but the 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> parameter may also contain the following characters:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30355"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression level to <TT
CLASS="REPLACEABLE"
><I
>digit</I
></TT
>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> for further details.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30362"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>set the compression strategy to <TT
CLASS="REPLACEABLE"
><I
>[fhR]</I
></TT
>.
The letter <TT
CLASS="LITERAL"
>f</TT
> corresponds to filtered data, 
the letter <TT
CLASS="LITERAL"
>h</TT
>
corresponds to Huffman only compression, and 
the letter <TT
CLASS="LITERAL"
>R</TT
>
corresponds to Run Length Encoding.
See <TT
CLASS="FUNCTION"
>deflateInit2_()</TT
> for further details.</P
></TD
></TR
></TBODY
></TABLE
>&#13;</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> refers to an uncompressed file, and 
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> refers to a read mode, 
<TT
CLASS="FUNCTION"
>gzopen()</TT
> shall attempt to open the file and return
a <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object suitable for reading directly from the file
without any decompression.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>path</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>
is <TT
CLASS="LITERAL"
>NULL</TT
>, or if <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
> does not contain
one of <TT
CLASS="LITERAL"
>r</TT
>, <TT
CLASS="LITERAL"
>w</TT
>, or <TT
CLASS="LITERAL"
>a</TT
>,
<TT
CLASS="FUNCTION"
>gzopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
>,
and need not set any other error condition.</P
><P
>The <SPAN
CLASS="TYPE"
>gzFile</SPAN
> object is also referred to as a compressed file stream.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30393"
></A
><H2
>Example</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>gzopen("file.gz", "w6h");</PRE
></TD
></TR
></TABLE
>
Attempt to create a new compressed file, <TT
CLASS="FILENAME"
>file.gz</TT
>,
at compression level 6 using Huffman only compression.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30398"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzopen()</TT
> shall return a 
<SPAN
CLASS="TYPE"
>gzFile</SPAN
> object (also known as a <I
CLASS="EMPHASIS"
>compressed
file stream</I
>). On failure, 
<TT
CLASS="FUNCTION"
>gzopen()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_NULL</CODE
> and
may set <CODE
CLASS="VARNAME"
>errno</CODE
> accordingly.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>At version 1.2.2, <CODE
CLASS="VARNAME"
>zlib</CODE
>
does not set <CODE
CLASS="VARNAME"
>errno</CODE
> for several
error conditions. Applications may not be able to
determine the cause of an error.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30411"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzopen()</TT
> may set
the global variable <CODE
CLASS="VARNAME"
>errno</CODE
>
to indicate the error.</P
></DIV
><H1
><A
NAME="ZLIB-GZPRINTF-1"
></A
>gzprintf</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30420"
></A
><H2
>Name</H2
>gzprintf&nbsp;--&nbsp;format data and compress</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30425"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30426"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzprintf</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, const char * <TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, ...);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30436"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzprintf()</TT
> function shall format data as for
<TT
CLASS="FUNCTION"
>fprintf()</TT
>, and write the resulting string to the compressed
file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30442"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>gzprintf()</TT
> function
shall return the number of uncompressed bytes
actually written, or a value less than or equal to 
<CODE
CLASS="CONSTANT"
>0</CODE
> in the event of an error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30447"
></A
><H2
>Errors</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, or refers to a 
compressed file stream that has not been opened for writing,
<TT
CLASS="FUNCTION"
>gzprintf()</TT
> shall return <TT
CLASS="LITERAL"
>Z_STREAM_ERROR</TT
>.
Otherwise, errors are as for <TT
CLASS="FUNCTION"
>gzwrite()</TT
>.</P
></DIV
><H1
><A
NAME="ZLIB-GZPUTC-1"
></A
>gzputc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30459"
></A
><H2
>Name</H2
>gzputc&nbsp;--&nbsp;write character to a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30464"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30465"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzputc</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>c</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30474"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzputc()</TT
> function shall write the single
character <TT
CLASS="PARAMETER"
><I
>c</I
></TT
>, converted from integer to unsigned
character, to the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a write mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30482"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzputc()</TT
> shall return the value
written, otherwise <TT
CLASS="FUNCTION"
>gzputc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30488"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzputc()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.</P
></DIV
><H1
><A
NAME="ZLIB-GZPUTS-1"
></A
>gzputs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30497"
></A
><H2
>Name</H2
>gzputs&nbsp;--&nbsp;string write to a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30502"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30503"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzputs</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, const char * <TT
CLASS="PARAMETER"
><I
>s</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30512"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzputs()</TT
> function shall write the null terminated
string <TT
CLASS="PARAMETER"
><I
>s</I
></TT
> to
the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a write mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).
The terminating null character shall not be written.
The <TT
CLASS="FUNCTION"
>gzputs()</TT
> function shall return the number of 
uncompressed bytes actually written.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30521"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzputs()</TT
> shall return the number of uncompressed
bytes actually written to <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
On error <TT
CLASS="FUNCTION"
>gzputs()</TT
> shall return a value
less than or equal to <CODE
CLASS="CONSTANT"
>0</CODE
>.
Applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30529"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzputs()</TT
> shall set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications should use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.
If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, 
<TT
CLASS="FUNCTION"
>gzputs()</TT
> shall return <CODE
CLASS="CONSTANT"
>Z_STREAM_ERR</CODE
>.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30541"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30547"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, is not open for writing, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30552"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30558"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to compress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZREAD-1"
></A
>gzread</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30567"
></A
><H2
>Name</H2
>gzread&nbsp;--&nbsp;read from a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30572"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30573"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzread</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, voidp <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, unsigned int <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30584"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzread()</TT
> function shall read data from
the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a read mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).
The <TT
CLASS="FUNCTION"
>gzread()</TT
> function shall read data from
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, and uncompress it into 
<TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>. At most, <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>
bytes of uncompressed data shall be copied to <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
If the file is not compressed, <TT
CLASS="FUNCTION"
>gzread()</TT
> shall simply
copy data from <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> to <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>
without alteration.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30599"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzread()</TT
> shall return the number of bytes
decompressed into <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>.
If <TT
CLASS="FUNCTION"
>gzread()</TT
> returns <CODE
CLASS="CONSTANT"
>0</CODE
>,
either the end-of-file has been reached
or an underlying read error has occurred. Applications
should use <TT
CLASS="FUNCTION"
>gzerror()</TT
> or <TT
CLASS="FUNCTION"
>gzeof()</TT
>
to determine which occurred.
On other errors, 
<TT
CLASS="FUNCTION"
>gzread()</TT
> shall return a value less than 
<CODE
CLASS="CONSTANT"
>0</CODE
> and applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30611"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzread()</TT
> shall set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications should use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30619"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30625"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_END</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>End of file has been reached on input.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30630"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A CRC error occurred when reading data; the file is corrupt.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30635"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30640"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_NEED_DICT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A dictionary is needed (see <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30646"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to decompress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZREWIND-1"
></A
>gzrewind</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30655"
></A
><H2
>Name</H2
>gzrewind&nbsp;--&nbsp;reset the file-position indicator on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30660"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30661"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>gzrewind</TT
></CODE
>(gzFile
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30668"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzrewind()</TT
> function shall set the starting position
for the next read
on compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> to the beginning
of file. <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> must be open for reading.</P
><P
><TT
CLASS="FUNCTION"
>gzrewind()</TT
> is equivalent to 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>(int)gzseek(file, 0L, SEEK_SET)</PRE
></TD
></TR
></TABLE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30677"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzrewind()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>.
On error, <TT
CLASS="FUNCTION"
>gzrewind()</TT
> shall return -1, and
may set the error value for <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30684"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzrewind()</TT
> shall return <CODE
CLASS="CONSTANT"
>-1</CODE
>,
indicating that <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, or does not represent
an open compressed file stream, or represents a compressed file stream
that is open for writing and is not currently at the beginning of file.</P
></DIV
><H1
><A
NAME="ZLIB-GZSEEK-1"
></A
>gzseek</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30695"
></A
><H2
>Name</H2
>gzseek&nbsp;--&nbsp;reposition a file-position indicator in a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30700"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30701"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>z_off_t
<TT
CLASS="FUNCTION"
>gzseek</TT
></CODE
>(gzFile
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, z_off_t
<TT
CLASS="PARAMETER"
><I
>offset</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>whence</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30712"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzseek()</TT
> function shall set the file-position
indicator for the compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
The file-position indicator controls where the next
read or write operation on the compressed file stream shall take place.
The <TT
CLASS="PARAMETER"
><I
>offset</I
></TT
> indicates a byte offset in the
uncompressed data. The <TT
CLASS="PARAMETER"
><I
>whence</I
></TT
> parameter
may be one of:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30720"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>SEEK_SET</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the offset is relative to the start of the uncompressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30725"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>SEEK_CUR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the offset is relative to the current positition in the uncompressed data.</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The value <CODE
CLASS="CONSTANT"
>SEEK_END</CODE
> need not be supported.</P
></BLOCKQUOTE
></DIV
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is open for writing, the new offset
must be greater than or equal to the current offset. In this case, 
<TT
CLASS="FUNCTION"
>gzseek()</TT
> shall compress a sequence of null bytes
to fill the gap from the previous offset to the new offset.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30736"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzseek()</TT
> shall return the resulting
offset in the file expressed
as a byte position in the <I
CLASS="EMPHASIS"
>uncompressed</I
> data stream.
On error, <TT
CLASS="FUNCTION"
>gzseek()</TT
> shall return -1, and
may set the error value for <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30743"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzseek()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>-1</SPAN
>.
The following conditions shall always result in an error:
<P
></P
><UL
><LI
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is <CODE
CLASS="CONSTANT"
>NULL</CODE
></P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> does not represent
an open compressed file stream.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
> refers to a compressed file stream that is open
for writing, and the newly computed offset is less than the current offset.</P
></LI
><LI
><P
>The newly computed offset is less than zero.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>whence</I
></TT
> is not one of the supported values.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30764"
></A
><H2
>Application Usage (informative)</H2
><P
>If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is open for reading, the implementation
may still need to uncompress all of the data up to the new offset.
As a result, <TT
CLASS="FUNCTION"
>gzseek()</TT
> may be extremely slow
in some circumstances.</P
></DIV
><H1
><A
NAME="ZLIB-GZSETPARAMS-1"
></A
>gzsetparams</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30773"
></A
><H2
>Name</H2
>gzsetparams&nbsp;--&nbsp;dynamically set compression parameters</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30778"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30779"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzsetparams</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>level</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30790"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzsetparams()</TT
> function shall set the compression level and
compression strategy on the compressed file stream referenced by
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>. The compressed file stream shall have been opened
in a write mode.
The <TT
CLASS="PARAMETER"
><I
>level</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>strategy</I
></TT
> are as defined
in <A
HREF="#ZLIB-DEFLATEINIT2"
>deflateInit2.</A
>.
If there is any data pending writing, it shall be flushed before the parameters are
updated.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30798"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>gzsetparams()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30803"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzsetparams()</TT
> shall return one of the
following error indications:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30808"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter, or <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> not open for writing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30814"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An internal inconsistency was detected while flushing the previous buffer.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-GZTELL-1"
></A
>gztell</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30823"
></A
><H2
>Name</H2
>gztell&nbsp;--&nbsp;find position on a compressed file stream</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30828"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30829"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   z_off_t <TT
CLASS="FUNCTION"
>gztell</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30836"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gztell()</TT
> function shall return the starting position
for the next read or write operation
on compressed file stream <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>. This position represents
the number of bytes from the beginning of file in the uncompressed data.</P
><P
><TT
CLASS="FUNCTION"
>gztell()</TT
> is equivalent to 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>gzseek(file, 0L, SEEK_CUR)</PRE
></TD
></TR
></TABLE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30844"
></A
><H2
>Return Value</H2
><P
><TT
CLASS="FUNCTION"
>gztell()</TT
> shall return the current offset in the file expressed
as a byte position in the <I
CLASS="EMPHASIS"
>uncompressed</I
> data stream.
On error, <TT
CLASS="FUNCTION"
>gztell()</TT
> shall return -1, and
may set the error value for <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> accordingly.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30851"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gztell()</TT
> shall return <CODE
CLASS="CONSTANT"
>-1</CODE
>,
indicating that <TT
CLASS="PARAMETER"
><I
>file</I
></TT
> is 
<CODE
CLASS="CONSTANT"
>NULL</CODE
>, or does not represent
an open compressed file stream.</P
></DIV
><H1
><A
NAME="ZLIB-GZWRITE-1"
></A
>gzwrite</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30862"
></A
><H2
>Name</H2
>gzwrite&nbsp;--&nbsp;write to a compressed file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30867"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30868"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>gzwrite</TT
>
  </CODE
>(gzFile <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, voidpc <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>, unsigned int <TT
CLASS="PARAMETER"
><I
>len</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30879"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>gzwrite()</TT
> function shall write data to
the compressed file
referenced by <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>, which shall have been opened
in a write mode (see <TT
CLASS="FUNCTION"
>gzopen()</TT
> and 
<TT
CLASS="FUNCTION"
>gzdopen()</TT
>).
On entry, <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> shall point to a buffer containing
<TT
CLASS="PARAMETER"
><I
>len</I
></TT
> bytes of uncompressed data.
The <TT
CLASS="FUNCTION"
>gzwrite()</TT
> function shall compress this data and
write it to
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
The <TT
CLASS="FUNCTION"
>gzwrite()</TT
> function shall return the number of 
uncompressed bytes actually written.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30891"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall return the number of 
uncompressed bytes actually written to <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>.
On error <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall return a value
less than or equal to <CODE
CLASS="CONSTANT"
>0</CODE
>.
Applications may examine the cause using <TT
CLASS="FUNCTION"
>gzerror()</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30899"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>gzwrite()</TT
> shall set
the error number associated with the stream identified by 
<TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
to indicate the error. Applications should use <TT
CLASS="FUNCTION"
>gzerror()</TT
>
to access this error value.</P
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30907"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_ERRNO</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An underlying base library function has indicated an error.
The global variable <CODE
CLASS="VARNAME"
>errno</CODE
> may be examined 
for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30913"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The stream is invalid, is not open for writing, or is in an invalid state.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30918"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>no compression progress is possible (see <TT
CLASS="FUNCTION"
>deflate()</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30924"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available to compress.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATE-1"
></A
>inflate</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN30933"
></A
><H2
>Name</H2
>inflate&nbsp;--&nbsp;decompress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN30938"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN30939"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflate</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN30948"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflate()</TT
> function shall attempt to decompress
data until either the input buffer is empty or the output buffer is full.
The <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> references a
<TT
CLASS="STRUCTNAME"
>z_stream</TT
> structure. Before the first call to
<TT
CLASS="FUNCTION"
>inflate()</TT
>, this structure
should have been initialized by a call to 
<TT
CLASS="FUNCTION"
>inflateInit2_()</TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
><TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> is only in the binary standard; source
level applications should initialize <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
via a call to <TT
CLASS="FUNCTION"
>inflateInit()</TT
> or 
<TT
CLASS="FUNCTION"
>inflateInit2()</TT
>.</P
></BLOCKQUOTE
></DIV
>
In addition, the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> input and output buffers
should have been initialized as follows:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30964"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to the data to be decompressed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30969"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the number of bytes of data in the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30975"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should point to a buffer where decompressed data may be placed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN30980"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>should contain the size in bytes of the
buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
></P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <TT
CLASS="FUNCTION"
>inflate()</TT
> function
shall perform one or both of the following actions:
<P
></P
><OL
TYPE="1"
><LI
><P
>Decompress input data from <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>
and update <CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> and
<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> to reflect the data that has been 
decompressed.</P
></LI
><LI
><P
>Fill the output buffer referenced by <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
and update <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
> to reflect the decompressed data that 
has been placed there. If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is not
<CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).</P
></LI
></OL
></P
><P
>The <TT
CLASS="FUNCTION"
>inflate()</TT
> function shall return when either
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
> reaches zero (indicating that all the input
data has been compressed), or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> reaches
zero (indicating that the output buffer is full).</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN31008"
></A
><H3
>Flush Operation</H3
><P
>The parameter <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> determines when uncompressed bytes
are added to the output buffer in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>.
If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_NO_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>inflate()</TT
>
may return with some data pending output, and not yet added to the 
output buffer.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
>,
<TT
CLASS="FUNCTION"
>inflate()</TT
> shall flush all pending output to
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>, and update 
<CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>
and <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> accordingly.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_BLOCK</CODE
>,
<TT
CLASS="FUNCTION"
>inflate()</TT
> shall stop adding data to the output
buffer if and when the next compressed block boundary is reached
(see <A
HREF="#STD.RFC1951"
>RFC 1951: DEFLATE Compressed Data Format Specification</A
>).</P
><P
>If <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
> is set to <CODE
CLASS="CONSTANT"
>Z_FINISH</CODE
>,
all of the compressed input shall be decompressed and added to
the output. If there is insufficient output space (i.e. the compressed
input data uncompresses to more than <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>
bytes), then <TT
CLASS="FUNCTION"
>inflate()</TT
> shall fail and return
<SPAN
CLASS="RETURNVALUE"
>Z_BUF_ERROR</SPAN
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31034"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
> if decompression progress has been made,
or <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
> if all of the input data
has been decompressed and there was sufficient space in the output
buffer to store the uncompressed result.

On error, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall return a value to indicate
the error.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If <TT
CLASS="FUNCTION"
>inflate()</TT
> returns <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>
and has set <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> to zero, the function should
be called again with the same value for <TT
CLASS="PARAMETER"
><I
>flush</I
></TT
>, and with
updated <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> until <TT
CLASS="FUNCTION"
>inflate()</TT
>
returns with either <SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
> 
or <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_END</SPAN
>
and a non-zero 
<CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
>.</P
></BLOCKQUOTE
></DIV
></P
><P
>On success, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall set the 
<CODE
CLASS="STRUCTFIELD"
>adler</CODE
> to the Adler-32 checksum of
the output produced so far (i.e. <CODE
CLASS="STRUCTFIELD"
>total_out</CODE
>
bytes).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31057"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflate()</TT
> shall return a value as described 
below, and may set the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of 
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to point to a string describing the error:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31064"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No progress is possible; either <CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
>
or <CODE
CLASS="STRUCTFIELD"
>avail_out</CODE
> was zero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31071"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31076"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31084"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_NEED_DICT</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A preset dictionary is required. The <CODE
CLASS="STRUCTFIELD"
>adler</CODE
>
field shall be set to the Adler-32 checksum of the dictionary chosen
by the compressor.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATEEND-1"
></A
>inflateEnd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31094"
></A
><H2
>Name</H2
>inflateEnd&nbsp;--&nbsp;free decompression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31099"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31100"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateEnd</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31107"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateEnd()</TT
> function shall free all allocated
state information referenced by <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output is discarded, and unprocessed input is ignored.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31112"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateEnd()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31118"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateEnd()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>zfree</CODE
> function pointer is
<CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATEINIT2"
></A
>inflateInit2_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31139"
></A
><H2
>Name</H2
>inflateInit2_&nbsp;--&nbsp;initialize decompression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31144"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31145"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   int <TT
CLASS="FUNCTION"
>inflateInit2_</TT
>
  </CODE
>(z_streamp <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
>, char * <TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31158"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> function shall initialize the decompression
system.
On entry, <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
> shall refer to a user supplied <SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31166"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31173"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31181"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and <CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with the version
implemented, or if the size of the <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size in the library 
implementation, <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>windowBits</I
></TT
> parameter shall be a base 2 logarithm of the maximum
window 
size to use, and shall be a value between <CODE
CLASS="CONSTANT"
>8</CODE
> and <CODE
CLASS="CONSTANT"
>15</CODE
>.
If the input data was compressed with a larger window size, subsequent attempts to
decompress this data will fail with <CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
>, rather than try to
allocate a larger window.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>inflateInit2()</TT
> macro.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31205"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31211"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateInit2_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31216"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31221"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31226"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-INFLATEINIT"
></A
>inflateInit_</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31239"
></A
><H2
>Name</H2
>inflateInit_&nbsp;--&nbsp;initialize decompression system</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31244"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31245"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateInit_</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, const char *
<TT
CLASS="PARAMETER"
><I
>version</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31256"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> function shall initialize the
decompression system.
On entry, <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall refer to a user supplied
<SPAN
CLASS="TYPE"
>z_stream</SPAN
>
object (a <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure). The following fields shall be
set on entry:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31264"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to an <SPAN
CLASS="TYPE"
>alloc_func</SPAN
> function, used to allocate state information.
If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>, a default allocation function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31271"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>zfree</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>a pointer to a <SPAN
CLASS="TYPE"
>free_func</SPAN
> function, used to free memory allocated by the
<CODE
CLASS="STRUCTFIELD"
>zalloc</CODE
> function. If this is <CODE
CLASS="CONSTANT"
>NULL</CODE
>
a default free function will be used.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31279"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>opaque</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If <CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> is not <CODE
CLASS="CONSTANT"
>NULL</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>opaque</CODE
> is a user supplied pointer to data that will be passed to the
<CODE
CLASS="STRUCTFIELD"
>alloc_func</CODE
> and <CODE
CLASS="STRUCTFIELD"
>free_func</CODE
> functions.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If the <TT
CLASS="PARAMETER"
><I
>version</I
></TT
> requested is not compatible with the version
implemented, or if the size of the <TT
CLASS="STRUCTNAME"
>z_stream_s</TT
> structure
provided in <TT
CLASS="PARAMETER"
><I
>stream_size</I
></TT
> does not match the size in the library 
implementation, <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall fail, and return
<CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<TT
CLASS="FUNCTION"
>inflateInit()</TT
> macro.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall be equivalent to 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>inflateInit2_(strm, MAX_WBITS, version, stream_size);</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31301"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> function shall return 
<CODE
CLASS="CONSTANT"
>Z_OK</CODE
>. 
Otherwise, <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall return
a value as described below to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31307"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateInit_()</TT
> shall return one
of the following error indicators:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31312"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Invalid parameter.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31317"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31322"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_VERSION_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version requested is not compatible with the library version,
or the <SPAN
CLASS="TYPE"
>z_stream</SPAN
> size differs from that used by the library.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>In addition, the <CODE
CLASS="STRUCTFIELD"
>msg</CODE
> field of the <TT
CLASS="PARAMETER"
><I
>strm</I
></TT
>
may be set to an error message.</P
></DIV
><H1
><A
NAME="ZLIB-INFLATERESET-1"
></A
>inflateReset</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31335"
></A
><H2
>Name</H2
>inflateReset&nbsp;--&nbsp;reset decompression stream state</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31340"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31341"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateReset</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31348"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateReset()</TT
> function shall reset all state
associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>.
All pending output shall be discarded, and the counts of processed
bytes (<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> and 
<CODE
CLASS="STRUCTFIELD"
>total_out</CODE
>) shall be reset to zero.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31355"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateReset()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return <SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>
to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31361"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateReset()</TT
> shall return 
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
>. The following conditions
shall be treated as an error:
<P
></P
><UL
><LI
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent or inappropriate.</P
></LI
><LI
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
is <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></LI
></UL
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATESETDICTIONARY-1"
></A
>inflateSetDictionary</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31378"
></A
><H2
>Name</H2
>inflateSetDictionary&nbsp;--&nbsp;initialize decompression dictionary</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31383"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31384"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateSetDictionary</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>, uInt
<TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31395"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> function shall initialize the
decompression dictionary associated with <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>
using the <TT
CLASS="PARAMETER"
><I
>dictlen</I
></TT
> bytes referenced by
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> function should be called
immediately after a call to <TT
CLASS="FUNCTION"
>inflate()</TT
> has failed
with return value <SPAN
CLASS="RETURNVALUE"
>Z_NEED_DICT</SPAN
>. The 
<TT
CLASS="PARAMETER"
><I
>dictionary</I
></TT
> must have the same Adler-32
checksum as the dictionary used for
the compression (see <TT
CLASS="FUNCTION"
>deflateSetDictionary()</TT
>).</P
><P
><TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> shall reference an initialized decompression
stream, with <CODE
CLASS="STRUCTFIELD"
>total_in</CODE
> zero (i.e. no data
has been decompressed since the stream was initialized).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31411"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise it shall return a value as indicated below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31416"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateSetDictionary()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31421"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> 
was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31429"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The Adler-32 checksum of the supplied dictionary does not match that used
for the compression.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31434"
></A
><H2
>Application Usage (informative)</H2
><P
>The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.</P
><P
>The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.</P
></DIV
><H1
><A
NAME="ZLIB-INFLATESYNC-1"
></A
>inflateSync</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31442"
></A
><H2
>Name</H2
>inflateSync&nbsp;--&nbsp;advance compression stream to next sync point</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31447"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31448"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateSync</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31455"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateSync()</TT
> function shall advance through the
compressed data in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>, skipping any invalid
compressed data, until the next full flush point is reached, or all
input is exhausted. See the
description for <TT
CLASS="FUNCTION"
>deflate()</TT
> with flush level
<CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>.
No output is placed in <CODE
CLASS="STRUCTFIELD"
>next_out</CODE
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31463"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>inflateSync()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>, and update the
<CODE
CLASS="STRUCTFIELD"
>next_in</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>avail_in</CODE
>, and
<CODE
CLASS="STRUCTFIELD"
>total_in</CODE
>
fields of <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> to reflect the number
of bytes of compressed data that have been skipped.
Otherwise, <TT
CLASS="FUNCTION"
>inflateSync()</TT
>
shall return a value as described below to indicate the
error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31473"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateSync()</TT
> shall return a value
as described below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31478"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31486"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There is no data available to skip over.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31491"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No sync point was found.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-INFLATESYNCPOINT-1"
></A
>inflateSyncPoint</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31500"
></A
><H2
>Name</H2
>inflateSyncPoint&nbsp;--&nbsp;test for synchronization point</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31505"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31506"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inflateSyncPoint</TT
></CODE
>(z_streamp
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31513"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> function shall return a non-zero
value if the compressed data stream referenced by
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is at a synchronization point. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31518"
></A
><H2
>Return Value</H2
><P
>If the compressed data in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is at 
a synchronization point (see <TT
CLASS="FUNCTION"
>deflate()</TT
>
with a flush level of <CODE
CLASS="CONSTANT"
>Z_SYNC_FLUSH</CODE
> or
<CODE
CLASS="CONSTANT"
>Z_FULL_FLUSH</CODE
>), <TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> 
shall return  a non-zero value, other than <CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
>. 
Otherwise, if the <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is valid,
<TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> shall return 0.
If <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> is invalid, or in an invalid state,
<TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> shall return
<SPAN
CLASS="RETURNVALUE"
>Z_STREAM_ERROR</SPAN
> to indicate the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31532"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>inflateSyncPoint()</TT
> shall return a value
as described below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31537"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_STREAM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The state (as represented in <TT
CLASS="PARAMETER"
><I
>stream</I
></TT
>) is inconsistent, or
<TT
CLASS="PARAMETER"
><I
>stream</I
></TT
> was <CODE
CLASS="CONSTANT"
>NULL</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-UNCOMPRESS-1"
></A
>uncompress</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31549"
></A
><H2
>Name</H2
>uncompress&nbsp;--&nbsp;uncompress data</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31554"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31555"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>uncompress</TT
></CODE
>(Bytef *
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, uLongf *
<TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>, const Bytef *
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, uLong
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31568"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>uncompress()</TT
> function shall attempt to uncompress
<TT
CLASS="PARAMETER"
><I
>sourceLen</I
></TT
> bytes of data in the buffer 
<TT
CLASS="PARAMETER"
><I
>source</I
></TT
>, placing the result in the buffer
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. </P
><P
>On entry, <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
> should point to a value describing
the size of the <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer. 
The application should ensure that this value is large enough to hold
the entire uncompressed data.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not describe any mechanism by which a compressor can
communicate the size required to the uncompressor. </P
></BLOCKQUOTE
></DIV
>
On successful exit, the variable referenced by <TT
CLASS="PARAMETER"
><I
>destLen</I
></TT
>
shall be updated to hold the length of uncompressed data in
<TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31582"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>uncompress()</TT
> shall return  
<SPAN
CLASS="RETURNVALUE"
>Z_OK</SPAN
>.
Otherwise, <TT
CLASS="FUNCTION"
>uncompress()</TT
> shall return a value to indicate
the error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31588"
></A
><H2
>Errors</H2
><P
>On error, <TT
CLASS="FUNCTION"
>uncompress()</TT
> shall return a value as described 
below:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31593"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_BUF_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The buffer <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> was not large enough to hold the
uncompressed data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31599"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_MEM_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN31604"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>Z_DATA_ERROR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The compressed data (referenced by <TT
CLASS="PARAMETER"
><I
>source</I
></TT
>) was corrupted.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="ZLIB-ZERROR-1"
></A
>zError</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31614"
></A
><H2
>Name</H2
>zError&nbsp;--&nbsp;translate error number to string</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31619"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31620"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *
<TT
CLASS="FUNCTION"
>zError</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>err</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31627"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>zError()</TT
> function shall return the string
identifying the error associated with <TT
CLASS="PARAMETER"
><I
>err</I
></TT
>.
This allows for conversion from error code to string for functions
such as <TT
CLASS="FUNCTION"
>compress()</TT
> and <TT
CLASS="FUNCTION"
>uncompress()</TT
>,
that do not always set the string version of an error.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31634"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>zError()</TT
> function shall return a 
the string identifying the error associated with 
<TT
CLASS="PARAMETER"
><I
>err</I
></TT
>, or <SPAN
CLASS="RETURNVALUE"
>NULL</SPAN
> if
<TT
CLASS="PARAMETER"
><I
>err</I
></TT
> is not a valid error code.</P
><P
>It is unspecified if the string returned is determined by the setting
of the <CODE
CLASS="CONSTANT"
>LC_MESSAGES</CODE
> category in the current locale.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31643"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
><H1
><A
NAME="ZLIB-ZLIBVERSION-1"
></A
>zlibVersion</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN31650"
></A
><H2
>Name</H2
>zlibVersion&nbsp;--&nbsp;discover library version at run time</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN31655"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN31656"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;zlib.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>   const char * <TT
CLASS="FUNCTION"
>zlibVersion</TT
>
  </CODE
>(void);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31662"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>zlibVersion()</TT
> function shall return the string
identifying the interface version at the time the library was built.</P
><P
>Applications should compare the value returned from 
<TT
CLASS="FUNCTION"
>zlibVersion()</TT
> with the macro constant 
<CODE
CLASS="CONSTANT"
>ZLIB_VERSION</CODE
> for compatibility.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31669"
></A
><H2
>Return Value</H2
><P
>The <TT
CLASS="FUNCTION"
>zlibVersion()</TT
> function shall return a 
the string identifying the version of the library currently implemented.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN31673"
></A
><H2
>Errors</H2
><P
>None defined.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSES"
>15.5. Interfaces for libncurses</A
></H2
><P
><A
HREF="#LIB-LIBNCURSES-DEF"
>Table 15-3</A
> defines the library name and shared object name
for the libncurses library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBNCURSES-DEF"
></A
><P
><B
>Table 15-3. libncurses Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libncurses</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libncurses.so.5</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The parameters or return types of the following interfaces 
have had the const qualifier added as shown here, as 
compared to the specification in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>extern const char *keyname (int);
extern SCREEN *newterm (const char *, FILE *, FILE *);
extern const char *unctrl (chtype);

extern int mvprintw (int, int, const char *, ...);
extern int mvwprintw (WINDOW *, int, int, const char *, ...);
extern int printw (const char *, ...);
extern int vwprintw (WINDOW *, const char *, va_list);
extern int vw_printw (WINDOW *, const char *, va_list);
extern int wprintw (WINDOW *, const char *, ...);

extern int mvscanw (int, int, const char *, ...);
extern int mvwscanw (WINDOW *, int, int, const char *, ...);
extern int scanw (const char *, ...);
extern int vwscanw (WINDOW *, const char *, va_list);
extern int vw_scanw (WINDOW *, const char *, va_list);
extern int wscanw (WINDOW *, const char *, ...);</PRE
></TD
></TR
></TABLE
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBNCURSES.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBNCURSES.2"
></A
>[X-CURSES] <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN31699"
>15.5.1. Curses</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN31702"
>15.5.1.1. Interfaces for Curses</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Curses specified in <A
HREF="#TBL-LIBNCURSES-CURSE-INTS"
>Table 15-4</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSES-CURSE-INTS"
></A
><P
><B
>Table 15-4. libncurses - Curses Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>addch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>addchnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>addchstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>addnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>addstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>attr_get <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>attr_off <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>attr_on <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attr_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>attroff <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>attron <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>attrset <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>baudrate <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>beep <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>bkgd <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>bkgdset <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>border <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>box <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>can_change_color <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>cbreak <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>chgat <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>clear <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>clearok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>clrtobot <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>clrtoeol <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>color_content <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>color_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>copywin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>curs_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>def_prog_mode <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>def_shell_mode <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>del_curterm <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>delay_output <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>delch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>deleteln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>delscreen <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>delwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>derwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>doupdate <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>dupwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>echo <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>echochar <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>endwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>erase <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>erasechar <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>filter <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>flash <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>flushinp <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getbkgd <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>getch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>getnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>getstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>halfdelay <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>has_colors <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>has_ic <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>has_il <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>hline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>idcok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>idlok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>immedok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>inch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>inchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>inchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>init_color <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>init_pair <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>initscr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>innstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>insch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>insdelln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>insertln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>insnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>insstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>instr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>intrflush <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>is_linetouched <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>is_wintouched <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>isendwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>keyname <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>keypad <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>killchar <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>leaveok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>longname <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>meta <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>move <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvaddch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvaddchnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvaddchstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvaddstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvchgat <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvcur <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>mvdelch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvderwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvgetch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvgetnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvgetstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvhline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvinch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvinchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>mvinchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>mvinnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvinsch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvinsnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvinsstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvinstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>mvprintw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>mvvline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwaddch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwaddchnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwaddchstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvwaddnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwaddstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwchgat <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwdelch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvwgetch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwgetnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwgetstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwhline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwinch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwinchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>mvwinchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>mvwinnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwinsch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwinsnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwinsstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvwinstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>mvwprintw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>mvwscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>mvwvline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>napms <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>newpad <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>newterm <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>newwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>nl <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>nocbreak <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>nodelay <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>noecho <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>nonl <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>noqiflush <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>noraw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>notimeout <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>overlay <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>overwrite <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>pair_content <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>pechochar <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>pnoutrefresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>prefresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>printw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>putp <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>putwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>qiflush <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>raw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>redrawwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>refresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>reset_prog_mode <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>reset_shell_mode <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>resetty <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>restartterm <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>ripoffline <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>savetty <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>scanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>scr_dump <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>scr_init <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>scr_restore <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>scr_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>scrl <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>scroll <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>scrollok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>set_curterm <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>set_term <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>setscrreg <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>setupterm <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_attr_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>slk_attroff <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_attron <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_attrset <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_clear <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>slk_color <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_init <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_label <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_noutrefresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>slk_refresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_restore <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>slk_touch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>standend <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>standout <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>start_color <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>subpad <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>subwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>syncok <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>termattrs <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>termname <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>tgetent <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tgetflag <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tgetnum <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tgetstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>tgoto <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tigetflag <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tigetnum <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tigetstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>timeout <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>touchline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>touchwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tparm <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>tputs <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>typeahead <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>unctrl <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>ungetch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>untouchwin <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>use_env <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>vidattr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>vidputs <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>vline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>vw_printw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>vw_scanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>vwprintw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>vwscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>waddch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>waddchnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>waddchstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>waddnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>waddstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wattr_get <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wattr_off <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wattr_on <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wattr_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wattroff <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wattron <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wattrset <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wbkgd <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wbkgdset <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wborder <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wchgat <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wclear <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wclrtobot <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wclrtoeol <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wcolor_set <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wcursyncup <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wdelch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wdeleteln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wechochar <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>werase <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wgetch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wgetnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wgetstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>whline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winchnstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>winchstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>winnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winsch <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winsdelln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>winsertln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winsnstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winsstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>winstr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>wmove <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wnoutrefresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wprintw <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wredrawln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wrefresh <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wscanw <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
><TD
>wscrl <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wsetscrreg <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wstandend <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wstandout <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wsyncdown <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wsyncup <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>wtimeout <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wtouchln <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>wvline <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Curses specified in <A
HREF="#TBL-LIBNCURSES-CURSE-DEPINTS"
>Table 15-5</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSES-CURSE-DEPINTS"
></A
><P
><B
>Table 15-5. libncurses - Curses Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>tgetent <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tgetflag <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tgetnum <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>tgetstr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>tgoto <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Curses specified in <A
HREF="#TBL-LIBNCURSES-CURSE-DATA"
>Table 15-6</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSES-CURSE-DATA"
></A
><P
><B
>Table 15-6. libncurses - Curses Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>COLORS <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>COLOR_PAIRS <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>COLS <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>LINES <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>acs_map <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>cur_term <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>curscr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>newscr <A
HREF="#REFSTD.LIBNCURSES.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>stdscr <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>ttytype <A
HREF="#REFSTD.LIBNCURSES.2"
>[X-CURSES]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSES-DDEFS"
>15.6. Data Definitions for libncurses</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libncurses.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN32970"
>15.6.1. curses.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define getattrs(win)	((win)?(win)-&#62;_attrs:A_NORMAL)
#define ERR	(-1)
#define OK	(0)
#define ACS_RARROW	(acs_map['+'])
#define ACS_LARROW	(acs_map[','])
#define ACS_UARROW	(acs_map['-'])
#define ACS_DARROW	(acs_map['.'])
#define ACS_BLOCK	(acs_map['0'])
#define ACS_CKBOARD	(acs_map['a'])
#define ACS_DEGREE	(acs_map['f'])
#define ACS_PLMINUS	(acs_map['g'])
#define ACS_BOARD	(acs_map['h'])
#define ACS_LANTERN	(acs_map['i'])
#define ACS_LRCORNER	(acs_map['j'])
#define ACS_URCORNER	(acs_map['k'])
#define ACS_ULCORNER	(acs_map['l'])
#define ACS_LLCORNER	(acs_map['m'])
#define ACS_PLUS	(acs_map['n'])
#define ACS_S1	(acs_map['o'])
#define ACS_HLINE	(acs_map['q'])
#define ACS_S9	(acs_map['s'])
#define ACS_LTEE	(acs_map['t'])
#define ACS_RTEE	(acs_map['u'])
#define ACS_BTEE	(acs_map['v'])
#define ACS_TTEE	(acs_map['w'])
#define ACS_VLINE	(acs_map['x'])
#define ACS_DIAMOND	(acs_map['`'])
#define ACS_BULLET	(acs_map['~'])
#define setsyx(y,x)	do{if((y)==-1&#38;&#38;(x)==-1)newscr-&#62;_leaveok=TRUE;else{newscr-&#62;_leaveok=FALSE;wmove(newscr,(y),(x));}}while(0)
#define getsyx(y,x)	do{if(newscr-&#62;_leaveok)(y)=(x)=-1;elsegetyx(newscr,(y),(x));}while(0)
#define vid_attr(a,pair,opts)	vidattr(a)
#define getmaxyx(win,y,x)	\
	(y=(win)?((win)-&#62;_maxy+1):ERR,x=(win)?((win)-&#62;_maxx+1):ERR)
#define getbegyx(win,y,x)	\
	(y=(win)?(win)-&#62;_begy:ERR,x=(win)?(win)-&#62;_begx:ERR)
#define getyx(win,y,x)	\
	(y=(win)?(win)-&#62;_cury:ERR,x=(win)?(win)-&#62;_curx:ERR)
#define getparyx(win,y,x)	\
	(y=(win)?(win)-&#62;_pary:ERR,x=(win)?(win)-&#62;_parx:ERR)

#define __NCURSES_H	1
#define NCURSES_EXPORT(type)	type
#define NCURSES_EXPORT_VAR(type)	type

#define WA_ALTCHARSET	A_ALTCHARSET
#define WA_ATTRIBUTES	A_ATTRIBUTES
#define WA_BLINK	A_BLINK
#define WA_BOLD	A_BOLD
#define WA_DIM	A_DIM
#define WA_HORIZONTAL	A_HORIZONTAL
#define WA_INVIS	A_INVIS
#define WA_LEFT	A_LEFT
#define WA_LOW	A_LOW
#define WA_NORMAL	A_NORMAL
#define WA_PROTECT	A_PROTECT
#define WA_REVERSE	A_REVERSE
#define WA_RIGHT	A_RIGHT
#define WA_STANDOUT	A_STANDOUT
#define WA_TOP	A_TOP
#define WA_UNDERLINE	A_UNDERLINE
#define WA_VERTICAL	A_VERTICAL
#define A_REVERSE	NCURSES_BITS(1UL,10)

#define COLOR_BLACK	0
#define COLOR_RED	1
#define COLOR_GREEN	2
#define COLOR_YELLOW	3
#define COLOR_BLUE	4
#define COLOR_MAGENTA	5
#define COLOR_CYAN	6
#define COLOR_WHITE	7

#define _SUBWIN	0x01
#define _ENDLINE	0x02
#define _FULLWIN	0x04
#define _SCROLLWIN	0x08
#define _ISPAD	0x10
#define _HASMOVED	0x20

typedef unsigned char bool;

typedef unsigned long int chtype;
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef struct {
    attr_t attr;
    wchar_t chars[5];
} cchar_t;
struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};

struct _win_st {
    short _cury;		/* current cursor position */
    short _curx;
    short _maxy;		/* maximums of x and y, NOT window size */
    short _maxx;
    short _begy;		/* screen coords of upper-left-hand corner */
    short _begx;
    short _flags;		/* window state flags */
    attr_t _attrs;		/* current attribute for non-space character */
    chtype _bkgd;		/* current background char/attribute pair */
    bool _notimeout;		/* no time out on function-key entry? */
    bool _clear;		/* consider all data in the window invalid? */
    bool _leaveok;		/* OK to not reset cursor on exit? */
    bool _scroll;		/* OK to scroll this window? */
    bool _idlok;		/* OK to use insert/delete line? */
    bool _idcok;		/* OK to use insert/delete char? */
    bool _immed;		/* window in immed mode? (not yet used) */
    bool _sync;			/* window in sync mode? */
    bool _use_keypad;		/* process function keys into KEY_ symbols? */
    int _delay;			/* 0 = nodelay, &#60;0 = blocking, &#62;0 = delay */
    struct ldat *_line;		/* the actual line data */
    short _regtop;		/* top line of scrolling region */
    short _regbottom;		/* bottom line of scrolling region */
    int _parx;			/* x coordinate of this window in parent */
    int _pary;			/* y coordinate of this window in parent */
    WINDOW *_parent;		/* pointer to parent if a sub-window */
    struct pdat _pad;
    short _yoffset;		/* real begy is _begy + _yoffset */
    cchar_t _bkgrnd;		/* current background char/attribute pair */
};

#define KEY_F(n)	(KEY_F0+(n))
#define KEY_CODE_YES	0400
#define KEY_BREAK	0401
#define KEY_MIN	0401
#define KEY_DOWN	0402
#define KEY_UP	0403
#define KEY_LEFT	0404
#define KEY_RIGHT	0405
#define KEY_HOME	0406
#define KEY_BACKSPACE	0407
#define KEY_F0	0410
#define KEY_DL	0510
#define KEY_IL	0511
#define KEY_DC	0512
#define KEY_IC	0513
#define KEY_EIC	0514
#define KEY_CLEAR	0515
#define KEY_EOS	0516
#define KEY_EOL	0517
#define KEY_SF	0520
#define KEY_SR	0521
#define KEY_NPAGE	0522
#define KEY_PPAGE	0523
#define KEY_STAB	0524
#define KEY_CTAB	0525
#define KEY_CATAB	0526
#define KEY_ENTER	0527
#define KEY_SRESET	0530
#define KEY_RESET	0531
#define KEY_PRINT	0532
#define KEY_LL	0533
#define KEY_A1	0534
#define KEY_A3	0535
#define KEY_B2	0536
#define KEY_C1	0537
#define KEY_C3	0540
#define KEY_BTAB	0541
#define KEY_BEG	0542
#define KEY_CANCEL	0543
#define KEY_CLOSE	0544
#define KEY_COMMAND	0545
#define KEY_COPY	0546
#define KEY_CREATE	0547
#define KEY_END	0550
#define KEY_EXIT	0551
#define KEY_FIND	0552
#define KEY_HELP	0553
#define KEY_MARK	0554
#define KEY_MESSAGE	0555
#define KEY_MOVE	0556
#define KEY_NEXT	0557
#define KEY_OPEN	0560
#define KEY_OPTIONS	0561
#define KEY_PREVIOUS	0562
#define KEY_REDO	0563
#define KEY_REFERENCE	0564
#define KEY_REFRESH	0565
#define KEY_REPLACE	0566
#define KEY_RESTART	0567
#define KEY_RESUME	0570
#define KEY_SAVE	0571
#define KEY_SBEG	0572
#define KEY_SCANCEL	0573
#define KEY_SCOMMAND	0574
#define KEY_SCOPY	0575
#define KEY_SCREATE	0576
#define KEY_SDC	0577
#define KEY_SDL	0600
#define KEY_SELECT	0601
#define KEY_SEND	0602
#define KEY_SEOL	0603
#define KEY_SEXIT	0604
#define KEY_SFIND	0605
#define KEY_SHELP	0606
#define KEY_SHOME	0607
#define KEY_SIC	0610
#define KEY_SLEFT	0611
#define KEY_SMESSAGE	0612
#define KEY_SMOVE	0613
#define KEY_SNEXT	0614
#define KEY_SOPTIONS	0615
#define KEY_SPREVIOUS	0616
#define KEY_SPRINT	0617
#define KEY_SREDO	0620
#define KEY_SREPLACE	0621
#define KEY_SRIGHT	0622
#define KEY_SRSUME	0623
#define KEY_SSAVE	0624
#define KEY_SSUSPEND	0625
#define KEY_SUNDO	0626
#define KEY_SUSPEND	0627
#define KEY_UNDO	0630
#define KEY_MOUSE	0631
#define KEY_RESIZE	0632
#define KEY_MAX	0777

#define PAIR_NUMBER(a)	(((a)&#38;A_COLOR)&#62;&#62;8)
#define NCURSES_BITS(mask,shift)	((mask)&#60;&#60;((shift)+8))
#define A_CHARTEXT	(NCURSES_BITS(1UL,0)-1UL)
#define A_NORMAL	0L
#define NCURSES_ATTR_SHIFT	8
#define A_COLOR	NCURSES_BITS(((1UL)&#60;&#60;8)-1UL,0)
#define A_BLINK	NCURSES_BITS(1UL,11)
#define A_DIM	NCURSES_BITS(1UL,12)
#define A_BOLD	NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS	NCURSES_BITS(1UL,15)
#define A_PROTECT	NCURSES_BITS(1UL,16)
#define A_HORIZONTAL	NCURSES_BITS(1UL,17)
#define A_LEFT	NCURSES_BITS(1UL,18)
#define A_LOW	NCURSES_BITS(1UL,19)
#define A_RIGHT	NCURSES_BITS(1UL,20)
#define A_TOP	NCURSES_BITS(1UL,21)
#define A_VERTICAL	NCURSES_BITS(1UL,22)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define COLOR_PAIR(n)	NCURSES_BITS(n,0)
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL-1UL),0)

extern int COLORS;
extern int COLOR_PAIRS;
extern int COLS;
extern int LINES;
extern chtype acs_map[];
extern int addch(const chtype);
extern int addchnstr(const chtype *, int);
extern int addchstr(const chtype *);
extern int addnstr(const char *, int);
extern int addstr(const char *);
extern int attr_get(attr_t *, short *, void *);
extern int attr_off(attr_t, void *);
extern int attr_on(attr_t, void *);
extern int attr_set(attr_t, short, void *);
extern int attroff(int);
extern int attron(int);
extern int attrset(int);
extern int baudrate(void);
extern int beep(void);
extern int bkgd(chtype);
extern void bkgdset(chtype);
extern int border(chtype, chtype, chtype, chtype, chtype, chtype, chtype,
		  chtype);
extern int box(WINDOW *, chtype, chtype);
extern bool can_change_color(void);
extern int cbreak(void);
extern int chgat(int, attr_t, short, const void *);
extern int clear(void);
extern int clearok(WINDOW *, bool);
extern int clrtobot(void);
extern int clrtoeol(void);
extern int color_content(short, short *, short *, short *);
extern int color_set(short, void *);
extern int copywin(const WINDOW *, WINDOW *, int, int, int, int, int, int,
		   int);
extern int curs_set(int);
extern WINDOW *curscr;
extern int def_prog_mode(void);
extern int def_shell_mode(void);
extern int delay_output(int);
extern int delch(void);
extern int deleteln(void);
extern void delscreen(SCREEN *);
extern int delwin(WINDOW *);
extern WINDOW *derwin(WINDOW *, int, int, int, int);
extern int doupdate(void);
extern WINDOW *dupwin(WINDOW *);
extern int echo(void);
extern int echochar(const chtype);
extern int endwin(void);
extern int erase(void);
extern char erasechar(void);
extern void filter(void);
extern int flash(void);
extern int flushinp(void);
extern chtype getbkgd(WINDOW *);
extern int getch(void);
extern int getnstr(char *, int);
extern int getstr(char *);
extern WINDOW *getwin(FILE *);
extern int halfdelay(int);
extern bool has_colors(void);
extern bool has_ic(void);
extern bool has_il(void);
extern int hline(chtype, int);
extern void idcok(WINDOW *, bool);
extern int idlok(WINDOW *, bool);
extern void immedok(WINDOW *, bool);
extern chtype inch(void);
extern int inchnstr(chtype *, int);
extern int inchstr(chtype *);
extern int init_color(short, short, short, short);
extern int init_pair(short, short, short);
extern WINDOW *initscr(void);
extern int innstr(char *, int);
extern int insch(chtype);
extern int insdelln(int);
extern int insertln(void);
extern int insnstr(const char *, int);
extern int insstr(const char *);
extern int instr(char *);
extern int intrflush(WINDOW *, bool);
extern bool is_linetouched(WINDOW *, int);
extern bool is_wintouched(WINDOW *);
extern bool isendwin(void);
extern const char *keyname(int);
extern int keypad(WINDOW *, bool);
extern char killchar(void);
extern int leaveok(WINDOW *, bool);
extern char *longname(void);
extern int meta(WINDOW *, bool);
extern int move(int, int);
extern int mvaddch(int, int, const chtype);
extern int mvaddchnstr(int, int, const chtype *, int);
extern int mvaddchstr(int, int, const chtype *);
extern int mvaddnstr(int, int, const char *, int);
extern int mvaddstr(int, int, const char *);
extern int mvchgat(int, int, int, attr_t, short, const void *);
extern int mvcur(int, int, int, int);
extern int mvdelch(int, int);
extern int mvderwin(WINDOW *, int, int);
extern int mvgetch(int, int);
extern int mvgetnstr(int, int, char *, int);
extern int mvgetstr(int, int, char *);
extern int mvhline(int, int, chtype, int);
extern chtype mvinch(int, int);
extern int mvinchnstr(int, int, chtype *, int);
extern int mvinchstr(int, int, chtype *);
extern int mvinnstr(int, int, char *, int);
extern int mvinsch(int, int, chtype);
extern int mvinsnstr(int, int, const char *, int);
extern int mvinsstr(int, int, const char *);
extern int mvinstr(int, int, char *);
extern int mvprintw(int, int, const char *, ...);
extern int mvscanw(int, int, const char *, ...);
extern int mvvline(int, int, chtype, int);
extern int mvwaddch(WINDOW *, int, int, const chtype);
extern int mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr(WINDOW *, int, int, const chtype *);
extern int mvwaddnstr(WINDOW *, int, int, const char *, int);
extern int mvwaddstr(WINDOW *, int, int, const char *);
extern int mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch(WINDOW *, int, int);
extern int mvwgetch(WINDOW *, int, int);
extern int mvwgetnstr(WINDOW *, int, int, char *, int);
extern int mvwgetstr(WINDOW *, int, int, char *);
extern int mvwhline(WINDOW *, int, int, chtype, int);
extern int mvwin(WINDOW *, int, int);
extern chtype mvwinch(WINDOW *, int, int);
extern int mvwinchnstr(WINDOW *, int, int, chtype *, int);
extern int mvwinchstr(WINDOW *, int, int, chtype *);
extern int mvwinnstr(WINDOW *, int, int, char *, int);
extern int mvwinsch(WINDOW *, int, int, chtype);
extern int mvwinsnstr(WINDOW *, int, int, const char *, int);
extern int mvwinsstr(WINDOW *, int, int, const char *);
extern int mvwinstr(WINDOW *, int, int, char *);
extern int mvwprintw(WINDOW *, int, int, const char *, ...);
extern int mvwscanw(WINDOW *, int, int, const char *, ...);
extern int mvwvline(WINDOW *, int, int, chtype, int);
extern int napms(int);
extern WINDOW *newpad(int, int);
extern WINDOW *newscr;
extern SCREEN *newterm(const char *, FILE *, FILE *);
extern WINDOW *newwin(int, int, int, int);
extern int nl(void);
extern int nocbreak(void);
extern int nodelay(WINDOW *, bool);
extern int noecho(void);
extern int nonl(void);
extern void noqiflush(void);
extern int noraw(void);
extern int notimeout(WINDOW *, bool);
extern int overlay(const WINDOW *, WINDOW *);
extern int overwrite(const WINDOW *, WINDOW *);
extern int pair_content(short, short *, short *);
extern int pechochar(WINDOW *, chtype);
extern int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
extern int prefresh(WINDOW *, int, int, int, int, int, int);
extern int printw(const char *, ...);
extern int putwin(WINDOW *, FILE *);
extern void qiflush(void);
extern int raw(void);
extern int redrawwin(WINDOW *);
extern int refresh(void);
extern int reset_prog_mode(void);
extern int reset_shell_mode(void);
extern int resetty(void);
extern int ripoffline(int, int (*)(WINDOW *, int));
extern int savetty(void);
extern int scanw(const char *, ...);
extern int scr_dump(const char *);
extern int scr_init(const char *);
extern int scr_restore(const char *);
extern int scr_set(const char *);
extern int scrl(int);
extern int scroll(WINDOW *);
extern int scrollok(WINDOW *, bool);
extern SCREEN *set_term(SCREEN *);
extern int setscrreg(int, int);
extern attr_t slk_attr(void);
extern int slk_attr_set(const attr_t, short, void *);
extern int slk_attroff(const chtype);
extern int slk_attron(const chtype);
extern int slk_attrset(const chtype);
extern int slk_clear(void);
extern int slk_color(short);
extern int slk_init(int);
extern char *slk_label(int);
extern int slk_noutrefresh(void);
extern int slk_refresh(void);
extern int slk_restore(void);
extern int slk_set(int, const char *, int);
extern int slk_touch(void);
extern int standend(void);
extern int standout(void);
extern int start_color(void);
extern WINDOW *stdscr;
extern WINDOW *subpad(WINDOW *, int, int, int, int);
extern WINDOW *subwin(WINDOW *, int, int, int, int);
extern int syncok(WINDOW *, bool);
extern chtype termattrs(void);
extern char *termname(void);
extern void timeout(int);
extern int touchline(WINDOW *, int, int);
extern int touchwin(WINDOW *);
extern int typeahead(int);
extern const char *unctrl(chtype);
extern int ungetch(int);
extern int untouchwin(WINDOW *);
extern void use_env(bool);
extern int vidattr(chtype);
extern int vidputs(chtype, int (*)(int));
extern int vline(chtype, int);
extern int vw_printw(WINDOW *, const char *, va_list);
extern int vw_scanw(WINDOW *, const char *, va_list);
extern int vwprintw(WINDOW *, const char *, va_list);
extern int vwscanw(WINDOW *, const char *, va_list);
extern int waddch(WINDOW *, const chtype);
extern int waddchnstr(WINDOW *, const chtype *, int);
extern int waddchstr(WINDOW *, const chtype *);
extern int waddnstr(WINDOW *, const char *, int);
extern int waddstr(WINDOW *, const char *);
extern int wattr_get(WINDOW *, attr_t *, short *, void *);
extern int wattr_off(WINDOW *, attr_t, void *);
extern int wattr_on(WINDOW *, attr_t, void *);
extern int wattr_set(WINDOW *, attr_t, short, void *);
extern int wattroff(WINDOW *, int);
extern int wattron(WINDOW *, int);
extern int wattrset(WINDOW *, int);
extern int wbkgd(WINDOW *, chtype);
extern void wbkgdset(WINDOW *, chtype);
extern int wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype,
		   chtype, chtype, chtype);
extern int wchgat(WINDOW *, int, attr_t, short, const void *);
extern int wclear(WINDOW *);
extern int wclrtobot(WINDOW *);
extern int wclrtoeol(WINDOW *);
extern int wcolor_set(WINDOW *, short, void *);
extern void wcursyncup(WINDOW *);
extern int wdelch(WINDOW *);
extern int wdeleteln(WINDOW *);
extern int wechochar(WINDOW *, const chtype);
extern int werase(WINDOW *);
extern int wgetch(WINDOW *);
extern int wgetnstr(WINDOW *, char *, int);
extern int wgetstr(WINDOW *, char *);
extern int whline(WINDOW *, chtype, int);
extern chtype winch(WINDOW *);
extern int winchnstr(WINDOW *, chtype *, int);
extern int winchstr(WINDOW *, chtype *);
extern int winnstr(WINDOW *, char *, int);
extern int winsch(WINDOW *, chtype);
extern int winsdelln(WINDOW *, int);
extern int winsertln(WINDOW *);
extern int winsnstr(WINDOW *, const char *, int);
extern int winsstr(WINDOW *, const char *);
extern int winstr(WINDOW *, char *);
extern int wmove(WINDOW *, int, int);
extern int wnoutrefresh(WINDOW *);
extern int wprintw(WINDOW *, const char *, ...);
extern int wredrawln(WINDOW *, int, int);
extern int wrefresh(WINDOW *);
extern int wscanw(WINDOW *, const char *, ...);
extern int wscrl(WINDOW *, int);
extern int wsetscrreg(WINDOW *, int, int);
extern int wstandend(WINDOW *);
extern int wstandout(WINDOW *);
extern void wsyncdown(WINDOW *);
extern void wsyncup(WINDOW *);
extern void wtimeout(WINDOW *, int);
extern int wtouchln(WINDOW *, int, int, int);
extern int wvline(WINDOW *, chtype, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN32974"
>15.6.2. term.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern TERMINAL *cur_term;
extern int del_curterm(TERMINAL *);
extern int putp(const char *);
extern int restartterm(char *, int, int *);
extern TERMINAL *set_curterm(TERMINAL *);
extern int setupterm(char *, int, int *);
extern int tgetent(char *, const char *);
extern int tgetflag(char *);
extern int tgetnum(char *);
extern char *tgetstr(char *, char **);
extern char *tgoto(const char *, int, int);
extern int tigetflag(const char *);
extern int tigetnum(const char *);
extern char *tigetstr(const char *);
extern char *tparm(const char *, ...);
extern int tputs(const char *, int, int (*)(int));
extern char ttytype[];</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSESMAN"
>15.7. Interface Definitions for libncurses</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#CURSES-INCHNSTR-1"
>inchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-INCHSTR-1"
>inchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-INSTR-1"
>instr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#LIBNCURSES-MVCUR-1"
>mvcur</A
>&nbsp;--&nbsp;send cursor movement commands to terminal</DT
><DT
><A
HREF="#CURSES-MVINCHNSTR-1"
>mvinchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVINCHSTR-1"
>mvinchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVINSTR-1"
>mvinstr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#CURSES-MVSCANW-1"
>mvscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-MVWINCHNSTR-1"
>mvwinchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVWINCHSTR-1"
>mvwinchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-MVWINSTR-1"
>mvwinstr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#CURSES-MVWSCANW-1"
>mvwscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-RIPOFFLINE-1"
>ripoffline</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-SCANW-1"
>scanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-VW-SCANW-1"
>vw_scanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-VWSCANW-1"
>vwscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
><DT
><A
HREF="#CURSES-WINCHNSTR-1"
>winchnstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-WINCHSTR-1"
>winchstr</A
>&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DT
><DT
><A
HREF="#CURSES-WINSTR-1"
>winstr</A
>&nbsp;--&nbsp;obtain a string of characters from a curses window</DT
><DT
><A
HREF="#CURSES-WSCANW-1"
>wscanw</A
>&nbsp;--&nbsp;convert formatted input from a curses window</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libncurses and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBNCURSES"
>Section 15.5</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="CURSES-INCHNSTR-1"
></A
>inchnstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN32987"
></A
><H2
>Name</H2
>inchnstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN32992"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN32993"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inchnstr</TT
></CODE
>(chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33002"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>inchnstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>inchnstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-INCHSTR-1"
></A
>inchstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33012"
></A
><H2
>Name</H2
>inchstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33017"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33018"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>inchstr</TT
></CODE
>(chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33025"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>inchstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>inchstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-INSTR-1"
></A
>instr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33035"
></A
><H2
>Name</H2
>instr&nbsp;--&nbsp;obtain a string of characters from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33040"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33041"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>instr</TT
></CODE
>(char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33048"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>instr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>instr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="LIBNCURSES-MVCUR-1"
></A
>mvcur</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33058"
></A
><H2
>Name</H2
>mvcur&nbsp;--&nbsp;send cursor movement commands to terminal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33063"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33064"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvcur</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>oldrow</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>oldcol</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>newrow</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>newcol</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33077"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvcur()</TT
> shall behave
as described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that if (<TT
CLASS="PARAMETER"
><I
>newrow</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>newcol</I
></TT
>) is not a valid
address for the terminal in use, the results of the 
<TT
CLASS="FUNCTION"
>mvcur()</TT
> function are
unspecified.</P
></DIV
><H1
><A
NAME="CURSES-MVINCHNSTR-1"
></A
>mvinchnstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33089"
></A
><H2
>Name</H2
>mvinchnstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33094"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33095"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvinchnstr</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33108"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvinchnstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>mvinchnstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-MVINCHSTR-1"
></A
>mvinchstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33118"
></A
><H2
>Name</H2
>mvinchstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33123"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33124"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvinchstr</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33135"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvinchstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>mvinchstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-MVINSTR-1"
></A
>mvinstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33145"
></A
><H2
>Name</H2
>mvinstr&nbsp;--&nbsp;obtain a string of characters from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33150"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33151"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvinstr</TT
></CODE
>(int
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33162"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvinstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>mvinstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-MVSCANW-1"
></A
>mvscanw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33172"
></A
><H2
>Name</H2
>mvscanw&nbsp;--&nbsp;convert formatted input from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33177"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33178"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvscanw</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, const char *<TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>...</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33191"
></A
><H2
>Description</H2
><P
>The scanw family of functions shall behave as
described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33195"
></A
><H2
>Differences</H2
><P
>This function returns <CODE
CLASS="CONSTANT"
>ERR</CODE
> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>, which
indicates this function returns <CODE
CLASS="CONSTANT"
>OK</CODE
>
on success.</P
></DIV
><H1
><A
NAME="CURSES-MVWINCHNSTR-1"
></A
>mvwinchnstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33205"
></A
><H2
>Name</H2
>mvwinchnstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33210"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33211"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvwinchnstr</TT
></CODE
>(WINDOW *
<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33226"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvwinchnstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>mvwinchnstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-MVWINCHSTR-1"
></A
>mvwinchstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33236"
></A
><H2
>Name</H2
>mvwinchstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33241"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33242"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvwinchstr</TT
></CODE
>(WINDOW *
<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33255"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvwinchstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>mvwinchstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-MVWINSTR-1"
></A
>mvwinstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33265"
></A
><H2
>Name</H2
>mvwinstr&nbsp;--&nbsp;obtain a string of characters from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33270"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33271"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvwinstr</TT
></CODE
>(WINDOW *
<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33284"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>mvwinstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>mvwinstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-MVWSCANW-1"
></A
>mvwscanw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33294"
></A
><H2
>Name</H2
>mvwscanw&nbsp;--&nbsp;convert formatted input from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33299"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33300"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>mvwscanw</TT
></CODE
>(WINDOW *<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>y</I
></TT
>, int <TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, const char *<TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>...</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33315"
></A
><H2
>Description</H2
><P
>The scanw family of functions shall behave as
described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33319"
></A
><H2
>Differences</H2
><P
>This function returns <CODE
CLASS="CONSTANT"
>ERR</CODE
> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>, which
indicates this function returns <CODE
CLASS="CONSTANT"
>OK</CODE
>
on success.</P
></DIV
><H1
><A
NAME="CURSES-RIPOFFLINE-1"
></A
>ripoffline</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33329"
></A
><H2
>Name</H2
>ripoffline&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33334"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33335"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <TT
CLASS="FUNCTION"
>ripoffline</TT
></CODE
>(int <TT
CLASS="PARAMETER"
><I
>line</I
></TT
>, int 
      (*<TT
CLASS="PARAMETER"
><I
>init</I
></TT
>) (WINDOW *, int));</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33345"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>ripoffline()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>ripoffline()</TT
> shall
return <TT
CLASS="LITERAL"
>-1</TT
> if the number of lines that
were ripped off exceeds five.</P
></DIV
><H1
><A
NAME="CURSES-SCANW-1"
></A
>scanw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33356"
></A
><H2
>Name</H2
>scanw&nbsp;--&nbsp;convert formatted input from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33361"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33362"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>scanw</TT
></CODE
>(const char *<TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>...</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33371"
></A
><H2
>Description</H2
><P
>The scanw family of functions shall behave as
described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33375"
></A
><H2
>Differences</H2
><P
>This function returns <CODE
CLASS="CONSTANT"
>ERR</CODE
> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>, which
indicates this function returns <CODE
CLASS="CONSTANT"
>OK</CODE
>
on success.</P
></DIV
><H1
><A
NAME="CURSES-VW-SCANW-1"
></A
>vw_scanw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33385"
></A
><H2
>Name</H2
>vw_scanw&nbsp;--&nbsp;convert formatted input from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33390"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33391"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>vw_scanw</TT
></CODE
>(WINDOW *<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, const char *<TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, va_list <TT
CLASS="PARAMETER"
><I
>vararglist</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33402"
></A
><H2
>Description</H2
><P
>The scanw family of functions shall behave as
described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33406"
></A
><H2
>Differences</H2
><P
>This function returns <CODE
CLASS="CONSTANT"
>ERR</CODE
> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>, which
indicates this function returns <CODE
CLASS="CONSTANT"
>OK</CODE
>
on success.</P
></DIV
><H1
><A
NAME="CURSES-VWSCANW-1"
></A
>vwscanw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33416"
></A
><H2
>Name</H2
>vwscanw&nbsp;--&nbsp;convert formatted input from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33421"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33422"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>vw_scanw</TT
></CODE
>(WINDOW *<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, const char *<TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, va_list <TT
CLASS="PARAMETER"
><I
>vararglist</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33433"
></A
><H2
>Description</H2
><P
>The scanw family of functions shall behave as
described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33437"
></A
><H2
>Differences</H2
><P
>This function returns <CODE
CLASS="CONSTANT"
>ERR</CODE
> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>, which
indicates this function returns <CODE
CLASS="CONSTANT"
>OK</CODE
>
on success.</P
></DIV
><H1
><A
NAME="CURSES-WINCHNSTR-1"
></A
>winchnstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33447"
></A
><H2
>Name</H2
>winchnstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33452"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33453"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>winchnstr</TT
></CODE
>(WINDOW *
<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>, int
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33464"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>winchnstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>winchnstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-WINCHSTR-1"
></A
>winchstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33474"
></A
><H2
>Name</H2
>winchstr&nbsp;--&nbsp;obtain a string of characters and their attributes from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33479"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33480"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>winchstr</TT
></CODE
>(WINDOW *
<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, chtype *
<TT
CLASS="PARAMETER"
><I
>chstr</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33489"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>winchstr()</TT
> shall behave
as specified in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except that <TT
CLASS="FUNCTION"
>winchstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-WINSTR-1"
></A
>winstr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33499"
></A
><H2
>Name</H2
>winstr&nbsp;--&nbsp;obtain a string of characters from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33504"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33505"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>winstr</TT
></CODE
>(WINDOW *
<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, char *
<TT
CLASS="PARAMETER"
><I
>str</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33514"
></A
><H2
>Description</H2
><P
>The interface <TT
CLASS="FUNCTION"
>winstr()</TT
> shall behave
as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
except that <TT
CLASS="FUNCTION"
>winstr()</TT
> shall
return the number of characters that were read.</P
></DIV
><H1
><A
NAME="CURSES-WSCANW-1"
></A
>wscanw</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN33524"
></A
><H2
>Name</H2
>wscanw&nbsp;--&nbsp;convert formatted input from a curses window</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN33529"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN33530"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;curses.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>wscanw</TT
></CODE
>(WINDOW *<TT
CLASS="PARAMETER"
><I
>win</I
></TT
>, const char *<TT
CLASS="PARAMETER"
><I
>fmt</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>...</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33541"
></A
><H2
>Description</H2
><P
>The scanw family of functions shall behave as
described in <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>,
except as noted below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN33545"
></A
><H2
>Differences</H2
><P
>This function returns <CODE
CLASS="CONSTANT"
>ERR</CODE
> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
>, which
indicates this function returns <CODE
CLASS="CONSTANT"
>OK</CODE
>
on success.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSESW"
>15.8. Interfaces for libncursesw</A
></H2
><P
><A
HREF="#LIB-LIBNCURSESW-DEF"
>Table 15-7</A
> defines the library name and shared object name
for the libncursesw library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBNCURSESW-DEF"
></A
><P
><B
>Table 15-7. libncursesw Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libncursesw</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libncursesw.so.5</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBNCURSESW.1"
></A
>[Libncursesw] <A
HREF="#STD.LIBNCURSESW"
>Libncursesw API</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBNCURSESW.2"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBNCURSESW.3"
></A
>[ncursesw] <A
HREF="#STD.NCURSESW"
>Libncursesw Placeholder</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBNCURSESW.4"
></A
>[X-CURSES] <A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN33575"
>15.8.1. Curses Wide</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN33578"
>15.8.1.1. Interfaces for Curses Wide</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Curses Wide specified in <A
HREF="#TBL-LIBNCURSESW-CURSE-INTS"
>Table 15-8</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSESW-CURSE-INTS"
></A
><P
><B
>Table 15-8. libncursesw - Curses Wide Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>add_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>add_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>add_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>addch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>addchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>addnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>addnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>addwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>assume_default_colors <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>attr_get <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attr_off <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>attr_on <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>attr_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>attroff <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attron <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>attrset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>baudrate <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>beep <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>bkgd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>bkgdset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>bkgrnd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>bkgrndset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>border <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>border_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>box <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>box_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>can_change_color <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>cbreak <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>chgat <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>clear <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>clearok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>clrtobot <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>clrtoeol <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>color_content <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>color_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>copywin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>curs_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>curses_version <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>def_prog_mode <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>def_shell_mode <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>define_key <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>del_curterm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>delay_output <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>delch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>deleteln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>delscreen <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>delwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>derwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>doupdate <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>dupwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>echo <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>echo_wchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>echochar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>endwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>erase <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>erasechar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>erasewchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>filter <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>flash <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>flushinp <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>get_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>get_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getbkgd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>getbkgrnd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>getcchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>getch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getmouse <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>getn_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>getnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>getstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>halfdelay <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>has_colors <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>has_ic <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>has_il <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>has_key <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>has_mouse <A
HREF="#REFSTD.LIBNCURSESW.2"
>[LSB]</A
></TD
><TD
>hline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>hline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>idcok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>idlok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>immedok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>in_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>in_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>in_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>inch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>inchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>inchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>init_color <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>init_pair <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>initscr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>innstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>innwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>ins_nwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>ins_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>ins_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>insch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>insdelln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>insertln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>insnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>insstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>instr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>intrflush <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>inwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>is_linetouched <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>is_wintouched <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>isendwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>key_name <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>keybound <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>keyname <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>keyok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>keypad <A
HREF="#REFSTD.LIBNCURSESW.2"
>[LSB]</A
></TD
><TD
>killchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>killwchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>leaveok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>longname <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mcprint <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>meta <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mouse_trafo <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mouseinterval <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mousemask <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>move <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvadd_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvadd_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvadd_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvaddch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvaddchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvaddchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvaddnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvaddnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvaddstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvaddwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvchgat <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvcur <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvdelch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvderwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvget_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvget_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvgetch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvgetn_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvgetnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvgetstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvhline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvhline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvin_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvin_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvin_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvinnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvins_nwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvins_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvins_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinsch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinsnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinsstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvinstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvinwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvprintw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvscanw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvvline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvvline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwadd_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwadd_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwadd_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwaddch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwaddchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwaddchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwaddnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwaddnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwaddstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwaddwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwchgat <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwdelch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwget_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwget_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwgetch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwgetn_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwgetnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwgetstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwhline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwhline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwin_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwin_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwin_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwinchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwins_nwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwins_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwins_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinsch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinsnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwinsstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwinwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwprintw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvwscanw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwvline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>mvwvline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>napms <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>newpad <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>newterm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>newwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>nl <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>nocbreak <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>nodelay <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>noecho <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>nonl <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>noqiflush <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>noraw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>notimeout <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>overlay <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>overwrite <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>pair_content <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>pecho_wchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>pechochar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>pnoutrefresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>prefresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>printw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>putp <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>putwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>qiflush <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>raw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>redrawwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>refresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>reset_prog_mode <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>reset_shell_mode <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>resetty <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>resizeterm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>restartterm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>ripoffline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>savetty <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>scanw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>scr_dump <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>scr_init <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>scr_restore <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>scr_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>scrl <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>scroll <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>scrollok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>set_curterm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>set_term <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>setcchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>setscrreg <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>setupterm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_attr <A
HREF="#REFSTD.LIBNCURSESW.4"
>[X-CURSES]</A
></TD
><TD
>slk_attr_off <A
HREF="#REFSTD.LIBNCURSESW.4"
>[X-CURSES]</A
></TD
><TD
>slk_attr_on <A
HREF="#REFSTD.LIBNCURSESW.4"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>slk_attr_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_attroff <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_attron <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_attrset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>slk_clear <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_color <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_init <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_label <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>slk_noutrefresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_refresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_restore <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>slk_touch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>slk_wset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>standend <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>standout <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>start_color <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>subpad <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>subwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>syncok <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>term_attrs <A
HREF="#REFSTD.LIBNCURSESW.4"
>[X-CURSES]</A
></TD
><TD
>termattrs <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>termname <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgetent <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>tgetflag <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgetnum <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgetstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgoto <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>tigetflag <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tigetnum <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tigetstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>timeout <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>touchline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>touchwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tparm <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tputs <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>typeahead <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>unctrl <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>unget_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>ungetch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>ungetmouse <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>untouchwin <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>use_default_colors <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>use_env <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>use_extended_names <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vid_attr <A
HREF="#REFSTD.LIBNCURSESW.4"
>[X-CURSES]</A
></TD
><TD
>vid_puts <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vidattr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>vidputs <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vw_printw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>vw_scanw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vwprintw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>vwscanw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wadd_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wadd_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wadd_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>waddch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>waddchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>waddchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>waddnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>waddnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>waddstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>waddwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wattr_get <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wattr_off <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wattr_on <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wattr_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wattroff <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wattron <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wattrset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wbkgd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wbkgdset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wbkgrnd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wbkgrndset <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wborder <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wborder_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wchgat <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wclear <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wclrtobot <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wclrtoeol <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wcolor_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wcursyncup <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wdelch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wdeleteln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wecho_wchar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wechochar <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>werase <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wget_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wget_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wgetbkgrnd <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wgetch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wgetn_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wgetnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wgetstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>whline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>whline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>win_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>win_wchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>win_wchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winchnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winchstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>winnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winnwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wins_nwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wins_wch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wins_wstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winsch <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winsdelln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winsertln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>winsnstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winsstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>winwstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wmouse_trafo <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wmove <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wnoutrefresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wprintw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wredrawln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wrefresh <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wresize <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wscanw <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wscrl <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wsetscrreg <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wstandend <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wstandout <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wsyncdown <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wsyncup <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wtimeout <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wtouchln <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>wunctrl <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wvline <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>wvline_set <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic deprecated functions
for Curses Wide specified in <A
HREF="#TBL-LIBNCURSESW-CURSE-DEPINTS"
>Table 15-9</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSESW-CURSE-DEPINTS"
></A
><P
><B
>Table 15-9. libncursesw - Curses Wide Deprecated Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>tgetent <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgetflag <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgetnum <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>tgetstr <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>tgoto <A
HREF="#REFSTD.LIBNCURSESW.1"
>[Libncursesw]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Curses Wide specified in <A
HREF="#TBL-LIBNCURSESW-CURSE-DATA"
>Table 15-10</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNCURSESW-CURSE-DATA"
></A
><P
><B
>Table 15-10. libncursesw - Curses Wide Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>COLORS <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
><TD
>COLOR_PAIRS <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
><TD
>COLS <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
><TD
>LINES <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
></TR
><TR
><TD
>acs_map <A
HREF="#REFSTD.LIBNCURSESW.2"
>[LSB]</A
></TD
><TD
>cur_term <A
HREF="#REFSTD.LIBNCURSESW.2"
>[LSB]</A
></TD
><TD
>curscr <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
><TD
>newscr <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
></TR
><TR
><TD
>stdscr <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
><TD
>ttytype <A
HREF="#REFSTD.LIBNCURSESW.3"
>[ncursesw]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSESW-DDEFS"
>15.9. Data Definitions for libncursesw</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libncursesw.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35339"
>15.9.1. ncursesw/curses.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CURSES	1
#define setsyx(y,x)	do { if (newscr) { \
				 if ((y) == -1 &#38;&#38; (x) == -1) \
					 leaveok(newscr, TRUE); \
				 else { \
					 leaveok(newscr, FALSE); \
					 wmove(newscr, (y), (x)); \
				} \
			 } \
		  } while(0)
#define getsyx(y,x)	do { if (newscr) { \
				 if (is_leaveok(newscr)) \
					 (y) = (x) = -1; \
				 else \
					 getyx(newscr,(y), (x)); \
			 } \
		 } while(0)
#define CURSES_H	1
#define NCURSES_VERSION_MAJOR	5
#define NCURSES_VERSION_MINOR	9
#define NCURSES_VERSION_PATCH	20110404
#define NCURSES_VERSION	"5.9"
#define NCURSES_MOUSE_VERSION	1
#define NCURSES_ENABLE_STDBOOL_H	1
#define NCURSES_INLINE	inline
#define NCURSES_TPARM_VARARGS	1
#ifndef TRUE
#define TRUE	1
#endif
#define NCURSES_BOOL	bool
#ifdef __cplusplus
#  define NCURSES_CAST(type,value)        static_cast&#60;type&#62;(value)
#else
#  define NCURSES_CAST(type,value)        (type)(value)
#endif
#define WA_ATTRIBUTES	A_ATTRIBUTES
#define WA_NORMAL	A_NORMAL
#define WA_STANDOUT	A_STANDOUT
#define WA_UNDERLINE	A_UNDERLINE
#define WA_REVERSE	A_REVERSE
#define WA_BLINK	A_BLINK
#define WA_DIM	A_DIM
#define WA_BOLD	A_BOLD
#define WA_ALTCHARSET	A_ALTCHARSET
#define WA_INVIS	A_INVIS
#define WA_PROTECT	A_PROTECT
#define WA_HORIZONTAL	A_HORIZONTAL
#define WA_LEFT	A_LEFT
#define WA_LOW	A_LOW
#define WA_RIGHT	A_RIGHT
#define WA_TOP	A_TOP
#define WA_VERTICAL	A_VERTICAL
#define COLOR_BLACK	0
#define COLOR_RED	1
#define COLOR_GREEN	2
#define COLOR_YELLOW	3
#define COLOR_BLUE	4
#define COLOR_MAGENTA	5
#define COLOR_CYAN	6
#define COLOR_WHITE	7
#define NCURSES_ACS(c)	(acs_map[NCURSES_CAST(unsigned char,c)])
#define ACS_ULCORNER	NCURSES_ACS('l')
#define ACS_LLCORNER	NCURSES_ACS('m')
#define ACS_URCORNER	NCURSES_ACS('k')
#define ACS_LRCORNER	NCURSES_ACS('j')
#define ACS_LTEE	NCURSES_ACS('t')
#define ACS_RTEE	NCURSES_ACS('u')
#define ACS_BTEE	NCURSES_ACS('v')
#define ACS_TTEE	NCURSES_ACS('w')
#define ACS_HLINE	NCURSES_ACS('q')
#define ACS_VLINE	NCURSES_ACS('x')
#define ACS_PLUS	NCURSES_ACS('n')
#define ACS_S1	NCURSES_ACS('o')
#define ACS_S9	NCURSES_ACS('s')
#define ACS_DIAMOND	NCURSES_ACS('`')
#define ACS_CKBOARD	NCURSES_ACS('a')
#define ACS_DEGREE	NCURSES_ACS('f')
#define ACS_PLMINUS	NCURSES_ACS('g')
#define ACS_BULLET	NCURSES_ACS('~')
#define ACS_LARROW	NCURSES_ACS(',')
#define ACS_RARROW	NCURSES_ACS('+')
#define ACS_DARROW	NCURSES_ACS('.')
#define ACS_UARROW	NCURSES_ACS('-')
#define ACS_BOARD	NCURSES_ACS('h')
#define ACS_LANTERN	NCURSES_ACS('i')
#define ACS_BLOCK	NCURSES_ACS('0')
#define ACS_S3	NCURSES_ACS('p')
#define ACS_S7	NCURSES_ACS('r')
#define ACS_LEQUAL	NCURSES_ACS('y')
#define ACS_GEQUAL	NCURSES_ACS('z')
#define ACS_PI	NCURSES_ACS('{')
#define ACS_NEQUAL	NCURSES_ACS('|')
#define ACS_STERLING	NCURSES_ACS('}')
#define ACS_BSSB	ACS_ULCORNER
#define ACS_SSBB	ACS_LLCORNER
#define ACS_BBSS	ACS_URCORNER
#define ACS_SBBS	ACS_LRCORNER
#define ACS_SBSS	ACS_RTEE
#define ACS_SSSB	ACS_LTEE
#define ACS_SSBS	ACS_BTEE
#define ACS_BSSS	ACS_TTEE
#define ACS_BSBS	ACS_HLINE
#define ACS_SBSB	ACS_VLINE
#define ACS_SSSS	ACS_PLUS
#define ERR	(-1)
#define OK	(0)
#define _SUBWIN	0x01
#define _ENDLINE	0x02
#define _FULLWIN	0x04
#define _SCROLLWIN	0x08
#define _ISPAD	0x10
#define _HASMOVED	0x20
#define _WRAPPED	0x40
#define _NOCHANGE	-1
#define _NEWINDEX	-1
#define CCHARW_MAX	5
#define NCURSES_EXT_COLORS	20110404
#define GCC_PRINTFLIKE(fmt,var)	__attribute__((format(printf,fmt,var)))
#define GCC_SCANFLIKE(fmt,var)	__attribute__((format(scanf,fmt,var)))
#define NCURSES_EXT_FUNCS	20110404
#define curses_version()	NCURSES_VERSION
#define NCURSES_SP_FUNCS	20110404
#define NCURSES_SP_OUTC	NCURSES_SP_NAME(NCURSES_OUTC)
#define NCURSES_SP_NAME(name)	name
#define NCURSES_ATTR_SHIFT	8
#define NCURSES_BITS(mask,shift)	((mask) &#60;&#60; ((shift) + NCURSES_ATTR_SHIFT))
#define A_NORMAL	(1UL - 1UL)
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL - 1UL),0)
#define A_CHARTEXT	(NCURSES_BITS(1UL,0) - 1UL)
#define A_COLOR	NCURSES_BITS(((1UL) &#60;&#60; 8) - 1UL,0)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define A_REVERSE	NCURSES_BITS(1UL,10)
#define A_BLINK	NCURSES_BITS(1UL,11)
#define A_DIM	NCURSES_BITS(1UL,12)
#define A_BOLD	NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS	NCURSES_BITS(1UL,15)
#define A_PROTECT	NCURSES_BITS(1UL,16)
#define A_HORIZONTAL	NCURSES_BITS(1UL,17)
#define A_LEFT	NCURSES_BITS(1UL,18)
#define A_LOW	NCURSES_BITS(1UL,19)
#define A_RIGHT	NCURSES_BITS(1UL,20)
#define A_TOP	NCURSES_BITS(1UL,21)
#define A_VERTICAL	NCURSES_BITS(1UL,22)
#define getyx(win,y,x)	(y = getcury(win), x = getcurx(win))
#define getbegyx(win,y,x)	(y = getbegy(win), x = getbegx(win))
#define getmaxyx(win,y,x)	(y = getmaxy(win), x = getmaxx(win))
#define getparyx(win,y,x)	(y = getpary(win), x = getparx(win))
#define wgetstr(w, s)	wgetnstr(w, s, -1)
#define getnstr(s, n)	wgetnstr(stdscr, s, n)
#define setterm(term)	setupterm(term, 1, (int *)0)
#define fixterm()	reset_prog_mode()
#define resetterm()	reset_shell_mode()
#define saveterm()	def_prog_mode()
#define crmode()	cbreak()
#define nocrmode()	nocbreak()
#define getattrs(win)	NCURSES_CAST(int, (win) ? (win)-&#62;_attrs : A_NORMAL)
#define getcurx(win)	((win) ? (win)-&#62;_curx : ERR)
#define getcury(win)	((win) ? (win)-&#62;_cury : ERR)
#define getbegx(win)	((win) ? (win)-&#62;_begx : ERR)
#define getbegy(win)	((win) ? (win)-&#62;_begy : ERR)
#define getmaxx(win)	((win) ? ((win)-&#62;_maxx + 1) : ERR)
#define getmaxy(win)	((win) ? ((win)-&#62;_maxy + 1) : ERR)
#define getparx(win)	((win) ? (win)-&#62;_parx : ERR)
#define getpary(win)	((win) ? (win)-&#62;_pary : ERR)
#define wstandout(win)	(wattrset(win,A_STANDOUT))
#define wstandend(win)	(wattrset(win,A_NORMAL))
#define wattron(win,at)	wattr_on(win, NCURSES_CAST(attr_t, at), NULL)
#define wattroff(win,at)	wattr_off(win, NCURSES_CAST(attr_t, at), NULL)
#define scroll(win)	wscrl(win,1)
#define touchwin(win)	wtouchln((win), 0, getmaxy(win), 1)
#define touchline(win, s, c)	wtouchln((win), s, c, 1)
#define untouchwin(win)	wtouchln((win), 0, getmaxy(win), 0)
#define box(win, v, h)	wborder(win, v, v, h, h, 0, 0, 0, 0)
#define border(ls, rs, ts, bs, tl, tr, bl, br)	wborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br)
#define hline(ch, n)	whline(stdscr, ch, n)
#define vline(ch, n)	wvline(stdscr, ch, n)
#define winstr(w, s)	winnstr(w, s, -1)
#define winchstr(w, s)	winchnstr(w, s, -1)
#define winsstr(w, s)	winsnstr(w, s, -1)
#define redrawwin(win)	wredrawln(win, 0, (win)-&#62;_maxy+1)
#define waddstr(win,str)	waddnstr(win,str,-1)
#define waddchstr(win,str)	waddchnstr(win,str,-1)
#define COLOR_PAIR(n)	NCURSES_BITS(n, 0)
#define PAIR_NUMBER(a)	(NCURSES_CAST(int,((NCURSES_CAST(unsigned long,a) &#38; A_COLOR) &#62;&#62; NCURSES_ATTR_SHIFT)))
#define addch(ch)	waddch(stdscr,ch)
#define addchnstr(str,n)	waddchnstr(stdscr,str,n)
#define addchstr(str)	waddchstr(stdscr,str)
#define addnstr(str,n)	waddnstr(stdscr,str,n)
#define addstr(str)	waddnstr(stdscr,str,-1)
#define attroff(at)	wattroff(stdscr,at)
#define attron(at)	wattron(stdscr,at)
#define attrset(at)	wattrset(stdscr,at)
#define attr_get(ap,cp,o)	wattr_get(stdscr,ap,cp,o)
#define attr_off(a,o)	wattr_off(stdscr,a,o)
#define attr_on(a,o)	wattr_on(stdscr,a,o)
#define attr_set(a,c,o)	wattr_set(stdscr,a,c,o)
#define bkgd(ch)	wbkgd(stdscr,ch)
#define bkgdset(ch)	wbkgdset(stdscr,ch)
#define chgat(n,a,c,o)	wchgat(stdscr,n,a,c,o)
#define clear()	wclear(stdscr)
#define clrtobot()	wclrtobot(stdscr)
#define clrtoeol()	wclrtoeol(stdscr)
#define color_set(c,o)	wcolor_set(stdscr,c,o)
#define delch()	wdelch(stdscr)
#define deleteln()	winsdelln(stdscr,-1)
#define echochar(c)	wechochar(stdscr,c)
#define erase()	werase(stdscr)
#define getch()	wgetch(stdscr)
#define getstr(str)	wgetstr(stdscr,str)
#define inch()	winch(stdscr)
#define inchnstr(s,n)	winchnstr(stdscr,s,n)
#define inchstr(s)	winchstr(stdscr,s)
#define innstr(s,n)	winnstr(stdscr,s,n)
#define insch(c)	winsch(stdscr,c)
#define insdelln(n)	winsdelln(stdscr,n)
#define insertln()	winsdelln(stdscr,1)
#define insnstr(s,n)	winsnstr(stdscr,s,n)
#define insstr(s)	winsstr(stdscr,s)
#define instr(s)	winstr(stdscr,s)
#define move(y,x)	wmove(stdscr,y,x)
#define refresh()	wrefresh(stdscr)
#define scrl(n)	wscrl(stdscr,n)
#define setscrreg(t,b)	wsetscrreg(stdscr,t,b)
#define standend()	wstandend(stdscr)
#define standout()	wstandout(stdscr)
#define timeout(delay)	wtimeout(stdscr,delay)
#define wdeleteln(win)	winsdelln(win,-1)
#define winsertln(win)	winsdelln(win,1)
#define mvwaddch(win,y,x,ch)	(wmove(win,y,x) == ERR ? ERR : waddch(win,ch))
#define mvwaddchnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,n))
#define mvwaddchstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,-1))
#define mvwaddnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,n))
#define mvwaddstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,-1))
#define mvwdelch(win,y,x)	(wmove(win,y,x) == ERR ? ERR : wdelch(win))
#define mvwchgat(win,y,x,n,a,c,o)	(wmove(win,y,x) == ERR ? ERR : wchgat(win,n,a,c,o))
#define mvwgetch(win,y,x)	(wmove(win,y,x) == ERR ? ERR : wgetch(win))
#define mvwgetnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : wgetnstr(win,str,n))
#define mvwgetstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : wgetstr(win,str))
#define mvwhline(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : whline(win,c,n))
#define mvwinch(win,y,x)	(wmove(win,y,x) == ERR ? NCURSES_CAST(chtype, ERR) : winch(win))
#define mvwinchnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winchnstr(win,s,n))
#define mvwinchstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : winchstr(win,s))
#define mvwinnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winnstr(win,s,n))
#define mvwinsch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : winsch(win,c))
#define mvwinsnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winsnstr(win,s,n))
#define mvwinsstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : winsstr(win,s))
#define mvwinstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : winstr(win,s))
#define mvwvline(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : wvline(win,c,n))
#define mvaddch(y,x,ch)	mvwaddch(stdscr,y,x,ch)
#define mvaddchnstr(y,x,str,n)	mvwaddchnstr(stdscr,y,x,str,n)
#define mvaddchstr(y,x,str)	mvwaddchstr(stdscr,y,x,str)
#define mvaddnstr(y,x,str,n)	mvwaddnstr(stdscr,y,x,str,n)
#define mvaddstr(y,x,str)	mvwaddstr(stdscr,y,x,str)
#define mvchgat(y,x,n,a,c,o)	mvwchgat(stdscr,y,x,n,a,c,o)
#define mvdelch(y,x)	mvwdelch(stdscr,y,x)
#define mvgetch(y,x)	mvwgetch(stdscr,y,x)
#define mvgetnstr(y,x,str,n)	mvwgetnstr(stdscr,y,x,str,n)
#define mvgetstr(y,x,str)	mvwgetstr(stdscr,y,x,str)
#define mvhline(y,x,c,n)	mvwhline(stdscr,y,x,c,n)
#define mvinch(y,x)	mvwinch(stdscr,y,x)
#define mvinchnstr(y,x,s,n)	mvwinchnstr(stdscr,y,x,s,n)
#define mvinchstr(y,x,s)	mvwinchstr(stdscr,y,x,s)
#define mvinnstr(y,x,s,n)	mvwinnstr(stdscr,y,x,s,n)
#define mvinsch(y,x,c)	mvwinsch(stdscr,y,x,c)
#define mvinsnstr(y,x,s,n)	mvwinsnstr(stdscr,y,x,s,n)
#define mvinsstr(y,x,s)	mvwinsstr(stdscr,y,x,s)
#define mvinstr(y,x,s)	mvwinstr(stdscr,y,x,s)
#define mvvline(y,x,c,n)	mvwvline(stdscr,y,x,c,n)
#define getbkgd(win)	((win)-&#62;_bkgd)
#define slk_attr_off(a,v)	((v) ? ERR : slk_attroff(a))
#define slk_attr_on(a,v)	((v) ? ERR : slk_attron(a))
#define wattr_set(win,a,p,opts)	((win)-&#62;_attrs = (((a) &#38; ~A_COLOR) | (attr_t)COLOR_PAIR(p)), OK)
#define vw_printw	vwprintw
#define vw_scanw	vwscanw
#define vsscanf(a,b,c)	_nc_vsscanf(a,b,c)
#define is_cleared(win)	((win) ? (win)-&#62;_clear : FALSE)
#define is_idcok(win)	((win) ? (win)-&#62;_idcok : FALSE)
#define is_idlok(win)	((win) ? (win)-&#62;_idlok : FALSE)
#define is_immedok(win)	((win) ? (win)-&#62;_immed : FALSE)
#define is_keypad(win)	((win) ? (win)-&#62;_use_keypad : FALSE)
#define is_leaveok(win)	((win) ? (win)-&#62;_leaveok : FALSE)
#define is_nodelay(win)	((win) ? ((win)-&#62;_delay == 0) : FALSE)
#define is_notimeout(win)	((win) ? (win)-&#62;_notimeout : FALSE)
#define is_pad(win)	((win) ? ((win)-&#62;_flags &#38; _ISPAD) != 0 : FALSE)
#define is_scrollok(win)	((win) ? (win)-&#62;_scroll : FALSE)
#define is_subwin(win)	((win) ? ((win)-&#62;_flags &#38; _SUBWIN) != 0 : FALSE)
#define is_syncok(win)	((win) ? (win)-&#62;_sync : FALSE)
#define wgetparent(win)	((win) ? (win)-&#62;_parent : 0)
#define wgetscrreg(win,t,b)	((win) ? (*(t) = (win)-&#62;_regtop, *(b) = (win)-&#62;_regbottom, OK) : ERR)
#define KEY_CODE_YES	0400
#define KEY_MIN	0401
#define KEY_BREAK	0401
#define KEY_SRESET	0530
#define KEY_RESET	0531
#define KEY_DOWN	0402
#define KEY_UP	0403
#define KEY_LEFT	0404
#define KEY_RIGHT	0405
#define KEY_HOME	0406
#define KEY_BACKSPACE	0407
#define KEY_F0	0410
#define KEY_F(n)	(KEY_F0+(n))
#define KEY_DL	0510
#define KEY_IL	0511
#define KEY_DC	0512
#define KEY_IC	0513
#define KEY_EIC	0514
#define KEY_CLEAR	0515
#define KEY_EOS	0516
#define KEY_EOL	0517
#define KEY_SF	0520
#define KEY_SR	0521
#define KEY_NPAGE	0522
#define KEY_PPAGE	0523
#define KEY_STAB	0524
#define KEY_CTAB	0525
#define KEY_CATAB	0526
#define KEY_ENTER	0527
#define KEY_PRINT	0532
#define KEY_LL	0533
#define KEY_A1	0534
#define KEY_A3	0535
#define KEY_B2	0536
#define KEY_C1	0537
#define KEY_C3	0540
#define KEY_BTAB	0541
#define KEY_BEG	0542
#define KEY_CANCEL	0543
#define KEY_CLOSE	0544
#define KEY_COMMAND	0545
#define KEY_COPY	0546
#define KEY_CREATE	0547
#define KEY_END	0550
#define KEY_EXIT	0551
#define KEY_FIND	0552
#define KEY_HELP	0553
#define KEY_MARK	0554
#define KEY_MESSAGE	0555
#define KEY_MOVE	0556
#define KEY_NEXT	0557
#define KEY_OPEN	0560
#define KEY_OPTIONS	0561
#define KEY_PREVIOUS	0562
#define KEY_REDO	0563
#define KEY_REFERENCE	0564
#define KEY_REFRESH	0565
#define KEY_REPLACE	0566
#define KEY_RESTART	0567
#define KEY_RESUME	0570
#define KEY_SAVE	0571
#define KEY_SBEG	0572
#define KEY_SCANCEL	0573
#define KEY_SCOMMAND	0574
#define KEY_SCOPY	0575
#define KEY_SCREATE	0576
#define KEY_SDC	0577
#define KEY_SDL	0600
#define KEY_SELECT	0601
#define KEY_SEND	0602
#define KEY_SEOL	0603
#define KEY_SEXIT	0604
#define KEY_SFIND	0605
#define KEY_SHELP	0606
#define KEY_SHOME	0607
#define KEY_SIC	0610
#define KEY_SLEFT	0611
#define KEY_SMESSAGE	0612
#define KEY_SMOVE	0613
#define KEY_SNEXT	0614
#define KEY_SOPTIONS	0615
#define KEY_SPREVIOUS	0616
#define KEY_SPRINT	0617
#define KEY_SREDO	0620
#define KEY_SREPLACE	0621
#define KEY_SRIGHT	0622
#define KEY_SRSUME	0623
#define KEY_SSAVE	0624
#define KEY_SSUSPEND	0625
#define KEY_SUNDO	0626
#define KEY_SUSPEND	0627
#define KEY_UNDO	0630
#define KEY_MOUSE	0631
#define KEY_RESIZE	0632
#define KEY_EVENT	0633
#define KEY_MAX	0777
#define _XOPEN_CURSES	1
#define NCURSES_WACS(c)	(&#38;_nc_wacs[(unsigned char)c])
#define WACS_BSSB	NCURSES_WACS('l')
#define WACS_SSBB	NCURSES_WACS('m')
#define WACS_BBSS	NCURSES_WACS('k')
#define WACS_SBBS	NCURSES_WACS('j')
#define WACS_SBSS	NCURSES_WACS('u')
#define WACS_SSSB	NCURSES_WACS('t')
#define WACS_SSBS	NCURSES_WACS('v')
#define WACS_BSSS	NCURSES_WACS('w')
#define WACS_BSBS	NCURSES_WACS('q')
#define WACS_SBSB	NCURSES_WACS('x')
#define WACS_SSSS	NCURSES_WACS('n')
#define WACS_ULCORNER	WACS_BSSB
#define WACS_LLCORNER	WACS_SSBB
#define WACS_URCORNER	WACS_BBSS
#define WACS_LRCORNER	WACS_SBBS
#define WACS_RTEE	WACS_SBSS
#define WACS_LTEE	WACS_SSSB
#define WACS_BTEE	WACS_SSBS
#define WACS_TTEE	WACS_BSSS
#define WACS_HLINE	WACS_BSBS
#define WACS_VLINE	WACS_SBSB
#define WACS_PLUS	WACS_SSSS
#define WACS_S1	NCURSES_WACS('o')
#define WACS_S9	NCURSES_WACS('s')
#define WACS_DIAMOND	NCURSES_WACS('`')
#define WACS_CKBOARD	NCURSES_WACS('a')
#define WACS_DEGREE	NCURSES_WACS('f')
#define WACS_PLMINUS	NCURSES_WACS('g')
#define WACS_BULLET	NCURSES_WACS('~')
#define WACS_LARROW	NCURSES_WACS(',')
#define WACS_RARROW	NCURSES_WACS('+')
#define WACS_DARROW	NCURSES_WACS('.')
#define WACS_UARROW	NCURSES_WACS('-')
#define WACS_BOARD	NCURSES_WACS('h')
#define WACS_LANTERN	NCURSES_WACS('i')
#define WACS_BLOCK	NCURSES_WACS('0')
#define WACS_S3	NCURSES_WACS('p')
#define WACS_S7	NCURSES_WACS('r')
#define WACS_LEQUAL	NCURSES_WACS('y')
#define WACS_GEQUAL	NCURSES_WACS('z')
#define WACS_PI	NCURSES_WACS('{')
#define WACS_NEQUAL	NCURSES_WACS('|')
#define WACS_STERLING	NCURSES_WACS('}')
#define WACS_BDDB	NCURSES_WACS('C')
#define WACS_DDBB	NCURSES_WACS('D')
#define WACS_BBDD	NCURSES_WACS('B')
#define WACS_DBBD	NCURSES_WACS('A')
#define WACS_DBDD	NCURSES_WACS('G')
#define WACS_DDDB	NCURSES_WACS('F')
#define WACS_DDBD	NCURSES_WACS('H')
#define WACS_BDDD	NCURSES_WACS('I')
#define WACS_BDBD	NCURSES_WACS('R')
#define WACS_DBDB	NCURSES_WACS('Y')
#define WACS_DDDD	NCURSES_WACS('E')
#define WACS_D_ULCORNER	WACS_BDDB
#define WACS_D_LLCORNER	WACS_DDBB
#define WACS_D_URCORNER	WACS_BBDD
#define WACS_D_LRCORNER	WACS_DBBD
#define WACS_D_RTEE	WACS_DBDD
#define WACS_D_LTEE	WACS_DDDB
#define WACS_D_BTEE	WACS_DDBD
#define WACS_D_TTEE	WACS_BDDD
#define WACS_D_HLINE	WACS_BDBD
#define WACS_D_VLINE	WACS_DBDB
#define WACS_D_PLUS	WACS_DDDD
#define WACS_BTTB	NCURSES_WACS('L')
#define WACS_TTBB	NCURSES_WACS('M')
#define WACS_BBTT	NCURSES_WACS('K')
#define WACS_TBBT	NCURSES_WACS('J')
#define WACS_TBTT	NCURSES_WACS('U')
#define WACS_TTTB	NCURSES_WACS('T')
#define WACS_TTBT	NCURSES_WACS('V')
#define WACS_BTTT	NCURSES_WACS('W')
#define WACS_BTBT	NCURSES_WACS('Q')
#define WACS_TBTB	NCURSES_WACS('X')
#define WACS_TTTT	NCURSES_WACS('N')
#define WACS_T_ULCORNER	WACS_BTTB
#define WACS_T_LLCORNER	WACS_TTBB
#define WACS_T_URCORNER	WACS_BBTT
#define WACS_T_LRCORNER	WACS_TBBT
#define WACS_T_RTEE	WACS_TBTT
#define WACS_T_LTEE	WACS_TTTB
#define WACS_T_BTEE	WACS_TTBT
#define WACS_T_TTEE	WACS_BTTT
#define WACS_T_HLINE	WACS_BTBT
#define WACS_T_VLINE	WACS_TBTB
#define WACS_T_PLUS	WACS_TTTT
#define add_wch(c)	wadd_wch(stdscr,c)
#define add_wchnstr(str,n)	wadd_wchnstr(stdscr,str,n)
#define add_wchstr(str)	wadd_wchstr(stdscr,str)
#define addnwstr(wstr,n)	waddnwstr(stdscr,wstr,n)
#define addwstr(wstr)	waddwstr(stdscr,wstr)
#define bkgrnd(c)	wbkgrnd(stdscr,c)
#define bkgrndset(c)	wbkgrndset(stdscr,c)
#define border_set(l,r,t,b,tl,tr,bl,br)	wborder_set(stdscr,l,r,t,b,tl,tr,bl,br)
#define box_set(w,v,h)	wborder_set(w,v,v,h,h,0,0,0,0)
#define echo_wchar(c)	wecho_wchar(stdscr,c)
#define get_wch(c)	wget_wch(stdscr,c)
#define get_wstr(t)	wget_wstr(stdscr,t)
#define getbkgrnd(wch)	wgetbkgrnd(stdscr,wch)
#define getn_wstr(t,n)	wgetn_wstr(stdscr,t,n)
#define hline_set(c,n)	whline_set(stdscr,c,n)
#define in_wch(c)	win_wch(stdscr,c)
#define in_wchnstr(c,n)	win_wchnstr(stdscr,c,n)
#define in_wchstr(c)	win_wchstr(stdscr,c)
#define innwstr(c,n)	winnwstr(stdscr,c,n)
#define ins_nwstr(t,n)	wins_nwstr(stdscr,t,n)
#define ins_wch(c)	wins_wch(stdscr,c)
#define ins_wstr(t)	wins_wstr(stdscr,t)
#define inwstr(c)	winwstr(stdscr,c)
#define vline_set(c,n)	wvline_set(stdscr,c,n)
#define wadd_wchstr(win,str)	wadd_wchnstr(win,str,-1)
#define waddwstr(win,wstr)	waddnwstr(win,wstr,-1)
#define wget_wstr(w,t)	wgetn_wstr(w,t,-1)
#define win_wchstr(w,c)	win_wchnstr(w,c,-1)
#define wins_wstr(w,t)	wins_nwstr(w,t,-1)
#define wgetbkgrnd(win,wch)	(*wch = win-&#62;_bkgrnd, OK)
#define mvadd_wch(y,x,c)	mvwadd_wch(stdscr,y,x,c)
#define mvadd_wchnstr(y,x,s,n)	mvwadd_wchnstr(stdscr,y,x,s,n)
#define mvadd_wchstr(y,x,s)	mvwadd_wchstr(stdscr,y,x,s)
#define mvaddnwstr(y,x,wstr,n)	mvwaddnwstr(stdscr,y,x,wstr,n)
#define mvaddwstr(y,x,wstr)	mvwaddwstr(stdscr,y,x,wstr)
#define mvget_wch(y,x,c)	mvwget_wch(stdscr,y,x,c)
#define mvget_wstr(y,x,t)	mvwget_wstr(stdscr,y,x,t)
#define mvgetn_wstr(y,x,t,n)	mvwgetn_wstr(stdscr,y,x,t,n)
#define mvhline_set(y,x,c,n)	mvwhline_set(stdscr,y,x,c,n)
#define mvin_wch(y,x,c)	mvwin_wch(stdscr,y,x,c)
#define mvin_wchnstr(y,x,c,n)	mvwin_wchnstr(stdscr,y,x,c,n)
#define mvin_wchstr(y,x,c)	mvwin_wchstr(stdscr,y,x,c)
#define mvinnwstr(y,x,c,n)	mvwinnwstr(stdscr,y,x,c,n)
#define mvins_nwstr(y,x,t,n)	mvwins_nwstr(stdscr,y,x,t,n)
#define mvins_wch(y,x,c)	mvwins_wch(stdscr,y,x,c)
#define mvins_wstr(y,x,t)	mvwins_wstr(stdscr,y,x,t)
#define mvinwstr(y,x,c)	mvwinwstr(stdscr,y,x,c)
#define mvvline_set(y,x,c,n)	mvwvline_set(stdscr,y,x,c,n)
#define mvwadd_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : wadd_wch(win,c))
#define mvwadd_wchnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : wadd_wchnstr(win,s,n))
#define mvwadd_wchstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : wadd_wchstr(win,s))
#define mvwaddnwstr(win,y,x,wstr,n)	(wmove(win,y,x) == ERR ? ERR : waddnwstr(win,wstr,n))
#define mvwaddwstr(win,y,x,wstr)	(wmove(win,y,x) == ERR ? ERR : waddwstr(win,wstr))
#define mvwget_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : wget_wch(win,c))
#define mvwget_wstr(win,y,x,t)	(wmove(win,y,x) == ERR ? ERR : wget_wstr(win,t))
#define mvwgetn_wstr(win,y,x,t,n)	(wmove(win,y,x) == ERR ? ERR : wgetn_wstr(win,t,n))
#define mvwhline_set(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : whline_set(win,c,n))
#define mvwin_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : win_wch(win,c))
#define mvwin_wchnstr(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : win_wchnstr(win,c,n))
#define mvwin_wchstr(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : win_wchstr(win,c))
#define mvwinnwstr(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : winnwstr(win,c,n))
#define mvwins_nwstr(win,y,x,t,n)	(wmove(win,y,x) == ERR ? ERR : wins_nwstr(win,t,n))
#define mvwins_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : wins_wch(win,c))
#define mvwins_wstr(win,y,x,t)	(wmove(win,y,x) == ERR ? ERR : wins_wstr(win,t))
#define mvwinwstr(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : winwstr(win,c))
#define mvwvline_set(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : wvline_set(win,c,n))
#define NCURSES_MOUSE_MASK(b,m)	((m) &#60;&#60; (((b) - 1) * 6))
#define NCURSES_BUTTON_RELEASED	001L
#define NCURSES_BUTTON_PRESSED	002L
#define NCURSES_BUTTON_CLICKED	004L
#define NCURSES_DOUBLE_CLICKED	010L
#define NCURSES_TRIPLE_CLICKED	020L
#define NCURSES_RESERVED_EVENT	040L
#define BUTTON1_RELEASED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)
#define BUTTON1_PRESSED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_PRESSED)
#define BUTTON1_CLICKED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_CLICKED)
#define BUTTON1_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(1, NCURSES_DOUBLE_CLICKED)
#define BUTTON1_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(1, NCURSES_TRIPLE_CLICKED)
#define BUTTON2_RELEASED	NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_RELEASED)
#define BUTTON2_PRESSED	NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_PRESSED)
#define BUTTON2_CLICKED	NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_CLICKED)
#define BUTTON2_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(2, NCURSES_DOUBLE_CLICKED)
#define BUTTON2_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(2, NCURSES_TRIPLE_CLICKED)
#define BUTTON3_RELEASED	NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_RELEASED)
#define BUTTON3_PRESSED	NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_PRESSED)
#define BUTTON3_CLICKED	NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_CLICKED)
#define BUTTON3_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(3, NCURSES_DOUBLE_CLICKED)
#define BUTTON3_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(3, NCURSES_TRIPLE_CLICKED)
#define BUTTON4_RELEASED	NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_RELEASED)
#define BUTTON4_PRESSED	NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_PRESSED)
#define BUTTON4_CLICKED	NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_CLICKED)
#define BUTTON4_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(4, NCURSES_DOUBLE_CLICKED)
#define BUTTON4_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(4, NCURSES_TRIPLE_CLICKED)
#define BUTTON5_RELEASED	NCURSES_MOUSE_MASK(5, NCURSES_BUTTON_RELEASED)
#define BUTTON5_PRESSED	NCURSES_MOUSE_MASK(5, NCURSES_BUTTON_PRESSED)
#define BUTTON5_CLICKED	NCURSES_MOUSE_MASK(5, NCURSES_BUTTON_CLICKED)
#define BUTTON5_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(5, NCURSES_DOUBLE_CLICKED)
#define BUTTON5_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(5, NCURSES_TRIPLE_CLICKED)
#define BUTTON_CTRL	NCURSES_MOUSE_MASK(6, 0001L)
#define BUTTON_SHIFT	NCURSES_MOUSE_MASK(6, 0002L)
#define BUTTON_ALT	NCURSES_MOUSE_MASK(6, 0004L)
#define REPORT_MOUSE_POSITION	NCURSES_MOUSE_MASK(6, 0010L)
#define BUTTON1_RESERVED_EVENT	NCURSES_MOUSE_MASK(1, NCURSES_RESERVED_EVENT)
#define BUTTON2_RESERVED_EVENT	NCURSES_MOUSE_MASK(2, NCURSES_RESERVED_EVENT)
#define BUTTON3_RESERVED_EVENT	NCURSES_MOUSE_MASK(3, NCURSES_RESERVED_EVENT)
#define BUTTON4_RESERVED_EVENT	NCURSES_MOUSE_MASK(4, NCURSES_RESERVED_EVENT)
#define ALL_MOUSE_EVENTS	(REPORT_MOUSE_POSITION - 1)
#define BUTTON_RELEASE(e,	x) ((e) &#38; NCURSES_MOUSE_MASK(x, 001))
#define BUTTON_PRESS(e,	x) ((e) &#38; NCURSES_MOUSE_MASK(x, 002))
#define BUTTON_CLICK(e,	x) ((e) &#38; NCURSES_MOUSE_MASK(x, 004))
#define BUTTON_DOUBLE_CLICK(e,	x) ((e) &#38; NCURSES_MOUSE_MASK(x, 010))
#define BUTTON_TRIPLE_CLICK(e,	x) ((e) &#38; NCURSES_MOUSE_MASK(x, 020))
#define BUTTON_RESERVED_EVENT(e,	x) ((e) &#38; NCURSES_MOUSE_MASK(x, 040))
#define mouse_trafo(y,x,to_screen)	wmouse_trafo(stdscr,y,x,to_screen)
#define _tracech_t	_tracecchar_t
#define _tracech_t2	_tracecchar_t2
#define TRACE_DISABLE	0x0000
#define TRACE_TIMES	0x0001
#define TRACE_TPUTS	0x0002
#define TRACE_UPDATE	0x0004
#define TRACE_MOVE	0x0008
#define TRACE_CHARPUT	0x0010
#define TRACE_ORDINARY	0x001F
#define TRACE_CALLS	0x0020
#define TRACE_VIRTPUT	0x0040
#define TRACE_IEVENT	0x0080
#define TRACE_BITS	0x0100
#define TRACE_ICALLS	0x0200
#define TRACE_CCALLS	0x0400
#define TRACE_DATABASE	0x0800
#define TRACE_ATTRS	0x1000
#define TRACE_SHIFT	13
#define TRACE_MAXIMUM	((1 &#60;&#60; TRACE_SHIFT) - 1)
#define OPTIMIZE_MVCUR	0x01
#define OPTIMIZE_HASHMAP	0x02
#define OPTIMIZE_SCROLL	0x04
#define OPTIMIZE_ALL	0xff

typedef unsigned long int chtype;
typedef chtype attr_t;

struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;
typedef unsigned long int mmask_t;
typedef unsigned char bool;

typedef unsigned char NCURSES_BOOL;
typedef int (*NCURSES_OUTC) (int);
typedef int (*NCURSES_WINDOW_CB) (WINDOW *, void *);
typedef int (*NCURSES_SCREEN_CB) (SCREEN *, void *);
struct _win_st {
    short _cury;		/* current cursor position */
    short _curx;
    short _maxy;		/* maximums of x and y, NOT window size */
    short _maxx;
    short _begy;		/* screen coords of upper-left-hand corner */
    short _begx;
    short _flags;		/* window state flags */
    attr_t _attrs;		/* current attribute for non-space character */
    chtype _bkgd;		/* current background char/attribute pair */
    bool _notimeout;		/* no time out on function-key entry? */
    bool _clear;		/* consider all data in the window invalid? */
    bool _leaveok;		/* OK to not reset cursor on exit? */
    bool _scroll;		/* OK to scroll this window? */
    bool _idlok;		/* OK to use insert/delete line? */
    bool _idcok;		/* OK to use insert/delete char? */
    bool _immed;		/* window in immed mode? (not yet used) */
    bool _sync;			/* window in sync mode? */
    bool _use_keypad;		/* process function keys into KEY_ symbols? */
    int _delay;			/* 0 = nodelay, &#60;0 = blocking, &#62;0 = delay */
    struct ldat *_line;		/* the actual line data */
    short _regtop;		/* top line of scrolling region */
    short _regbottom;		/* bottom line of scrolling region */
    int _parx;			/* x coordinate of this window in parent */
    int _pary;			/* y coordinate of this window in parent */
    WINDOW *_parent;		/* pointer to parent if a sub-window */
    struct pdat _pad;
    short _yoffset;		/* real begy is _begy + _yoffset */
    cchar_t _bkgrnd;		/* current background char/attribute pair */
};
extern int COLORS;
extern int COLOR_PAIRS;
extern int COLS;
extern int LINES;
extern chtype acs_map[];
extern int add_wch(cchar_t *);
extern int add_wchnstr(cchar_t *, int);
extern int add_wchstr(cchar_t *);
extern int addch(const chtype);
extern int addchnstr(const chtype *, int);
extern int addchstr(const chtype *);
extern int addnstr(const char *, int);
extern int addnwstr(wchar_t *, int);
extern int addstr(const char *);
extern int addwstr(wchar_t *);
extern int assume_default_colors(int, int);
extern int attr_get(attr_t *, short *, void *);
extern int attr_off(attr_t, void *);
extern int attr_on(attr_t, void *);
extern int attr_set(attr_t, short, void *);
extern int attroff(int);
extern int attron(int);
extern int attrset(int);
extern int baudrate(void);
extern int beep(void);
extern int bkgd(chtype);
extern void bkgdset(chtype);
extern int bkgrnd(cchar_t *);
extern void bkgrndset(cchar_t *);
extern int border(chtype, chtype, chtype, chtype, chtype, chtype, chtype,
		  chtype);
extern int border_set(cchar_t *, cchar_t *, cchar_t *, cchar_t *,
		      cchar_t *, cchar_t *, cchar_t *, cchar_t *);
extern int box(WINDOW *, chtype, chtype);
extern int box_set(WINDOW *, cchar_t *, cchar_t *);
extern unsigned char can_change_color(void);
extern int cbreak(void);
extern int chgat(int, attr_t, short, const void *);
extern int clear(void);
extern int clearok(WINDOW *, unsigned char);
extern int clrtobot(void);
extern int clrtoeol(void);
extern int color_content(short, short *, short *, short *);
extern int color_set(short, void *);
extern int copywin(const WINDOW *, WINDOW *, int, int, int, int, int, int,
		   int);
extern int curs_set(int);
extern WINDOW *curscr;
extern const char *curses_version(void);
extern int def_prog_mode(void);
extern int def_shell_mode(void);
extern int define_key(const char *, int);
extern int delay_output(int);
extern int delch(void);
extern int deleteln(void);
extern void delscreen(SCREEN *);
extern int delwin(WINDOW *);
extern WINDOW *derwin(WINDOW *, int, int, int, int);
extern int doupdate(void);
extern WINDOW *dupwin(WINDOW *);
extern int echo(void);
extern int echo_wchar(cchar_t *);
extern int echochar(const chtype);
extern int endwin(void);
extern int erase(void);
extern char erasechar(void);
extern int erasewchar(wchar_t *);
extern void filter(void);
extern int flash(void);
extern int flushinp(void);
extern int get_wch(wint_t *);
extern int get_wstr(wint_t *);
extern chtype getbkgd(WINDOW *);
extern int getbkgrnd(cchar_t *);
extern int getcchar(cchar_t *, wchar_t *, attr_t *, short *, void *);
extern int getch(void);
extern int getmouse(MEVENT *);
extern int getn_wstr(wint_t *, int);
extern int getnstr(char *, int);
extern int getstr(char *);
extern WINDOW *getwin(FILE *);
extern int halfdelay(int);
extern unsigned char has_colors(void);
extern unsigned char has_ic(void);
extern unsigned char has_il(void);
extern int has_key(void);
extern bool has_mouse(void);
extern int hline(chtype, int);
extern int hline_set(cchar_t *, int);
extern void idcok(WINDOW *, unsigned char);
extern int idlok(WINDOW *, unsigned char);
extern void immedok(WINDOW *, unsigned char);
extern int in_wch(cchar_t *);
extern int in_wchnstr(cchar_t *, int);
extern int in_wchstr(cchar_t *);
extern chtype inch(void);
extern int inchnstr(chtype *, int);
extern int inchstr(chtype *);
extern int init_color(short, short, short, short);
extern int init_pair(short, short, short);
extern WINDOW *initscr(void);
extern int innstr(char *, int);
extern int innwstr(wchar_t *, int);
extern int ins_nwstr(wchar_t *, int);
extern int ins_wch(cchar_t *);
extern int ins_wstr(wchar_t *);
extern int insch(chtype);
extern int insdelln(int);
extern int insertln(void);
extern int insnstr(const char *, int);
extern int insstr(const char *);
extern int instr(char *);
extern int intrflush(WINDOW *, unsigned char);
extern int inwstr(wchar_t *);
extern unsigned char is_linetouched(WINDOW *, int);
extern unsigned char is_wintouched(WINDOW *);
extern unsigned char isendwin(void);
extern char *key_name(wchar_t);
extern char *keybound(int, int);
extern char *keyname(int);
extern int keyok(int, unsigned char);
extern int keypad(WINDOW *, unsigned char);
extern char killchar(void);
extern int killwchar(wchar_t *);
extern int leaveok(WINDOW *, unsigned char);
extern char *longname(void);
extern int mcprint(void);
extern int meta(WINDOW *, unsigned char);
extern bool mouse_trafo(int *, int *, bool);
extern int mouseinterval(int);
extern mmask_t mousemask(mmask_t, mmask_t *);
extern int move(int, int);
extern int mvadd_wch(int, int, cchar_t *);
extern int mvadd_wchnstr(int, int, cchar_t *, int);
extern int mvadd_wchstr(int, int, cchar_t *);
extern int mvaddch(const chtype, const chtype, const chtype);
extern int mvaddchnstr(int, int, const chtype *, int);
extern int mvaddchstr(int, int, const chtype *);
extern int mvaddnstr(int, int, const char *, int);
extern int mvaddnwstr(int, int, wchar_t *, int);
extern int mvaddstr(int, int, const char *);
extern int mvaddwstr(int, int, wchar_t *);
extern int mvchgat(int, int, int, attr_t, short, const void *);
extern int mvcur(int, int, int, int);
extern int mvdelch(int, int);
extern int mvderwin(WINDOW *, int, int);
extern int mvget_wch(int, int, wint_t *);
extern int mvget_wstr(int, int, wint_t *);
extern int mvgetch(int, int);
extern int mvgetn_wstr(int, int, wint_t *, int);
extern int mvgetnstr(int, int, char *, int);
extern int mvgetstr(int, int, char *);
extern int mvhline(int, int, chtype, int);
extern int mvhline_set(int, int, cchar_t *, int);
extern int mvin_wch(int, int, cchar_t *);
extern int mvin_wchnstr(int, int, cchar_t *, int);
extern int mvin_wchstr(int, int, cchar_t *);
extern chtype mvinch(int, int);
extern int mvinchnstr(int, int, chtype *, int);
extern int mvinchstr(int, int, chtype *);
extern int mvinnstr(int, int, char *, int);
extern int mvinnwstr(int, int, wchar_t *, int);
extern int mvins_nwstr(int, int, wchar_t *, int);
extern int mvins_wch(int, int, cchar_t *);
extern int mvins_wstr(int, int, wchar_t *);
extern int mvinsch(int, int, chtype);
extern int mvinsnstr(int, int, const char *, int);
extern int mvinsstr(int, int, const char *);
extern int mvinstr(int, int, char *);
extern int mvinwstr(int, int, wchar_t *);
extern int mvprintw(int, int, const char *, ...);
extern int mvscanw(int, int, char *, ...);
extern int mvvline(int, int, chtype, int);
extern int mvvline_set(int, int, cchar_t *, int);
extern int mvwadd_wch(WINDOW *, int, int, cchar_t *);
extern int mvwadd_wchnstr(WINDOW *, int, int, cchar_t *, int);
extern int mvwadd_wchstr(WINDOW *, int, int, cchar_t *);
extern int mvwaddch(const chtype, const chtype, const chtype,
		    const chtype);
extern int mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr(WINDOW *, int, int, const chtype *);
extern int mvwaddnstr(WINDOW *, int, int, const char *, int);
extern int mvwaddnwstr(WINDOW *, int, int, wchar_t *, int);
extern int mvwaddstr(WINDOW *, int, int, const char *);
extern int mvwaddwstr(WINDOW *, int, int, wchar_t *);
extern int mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch(WINDOW *, int, int);
extern int mvwget_wch(WINDOW *, int, int, wint_t *);
extern int mvwget_wstr(WINDOW *, int, int, wint_t *);
extern int mvwgetch(WINDOW *, int, int);
extern int mvwgetn_wstr(WINDOW *, int, int, wint_t *, int);
extern int mvwgetnstr(WINDOW *, int, int, char *, int);
extern int mvwgetstr(WINDOW *, int, int, char *);
extern int mvwhline(WINDOW *, int, int, chtype, int);
extern int mvwhline_set(WINDOW *, int, int, cchar_t *, int);
extern int mvwin(WINDOW *, int, int);
extern int mvwin_wch(WINDOW *, int, int, cchar_t *);
extern int mvwin_wchnstr(WINDOW *, int, int, cchar_t *, int);
extern int mvwin_wchstr(WINDOW *, int, int, cchar_t *);
extern chtype mvwinch(WINDOW *, int, int);
extern int mvwinchnstr(WINDOW *, int, int, chtype *, int);
extern int mvwinchstr(WINDOW *, int, int, chtype *);
extern int mvwinnstr(WINDOW *, int, int, char *, int);
extern int mvwinnwstr(WINDOW *, int, int, wchar_t *, int);
extern int mvwins_nwstr(WINDOW *, int, int, wchar_t *, int);
extern int mvwins_wch(WINDOW *, int, int, cchar_t *);
extern int mvwins_wstr(WINDOW *, int, int, wchar_t *);
extern int mvwinsch(WINDOW *, int, int, chtype);
extern int mvwinsnstr(WINDOW *, int, int, const char *, int);
extern int mvwinsstr(WINDOW *, int, int, const char *);
extern int mvwinstr(WINDOW *, int, int, char *);
extern int mvwinwstr(WINDOW *, int, int, wchar_t *);
extern int mvwprintw(WINDOW *, int, int, const char *, ...);
extern int mvwscanw(WINDOW *, int, int, char *, ...);
extern int mvwvline(WINDOW *, int, int, chtype, int);
extern int mvwvline_set(WINDOW *, int, int, cchar_t *, int);
extern int napms(int);
extern WINDOW *newpad(int, int);
extern WINDOW *newscr;
extern SCREEN *newterm(char *, FILE *, FILE *);
extern WINDOW *newwin(int, int, int, int);
extern int nl(void);
extern int nocbreak(void);
extern int nodelay(WINDOW *, unsigned char);
extern int noecho(void);
extern int nonl(void);
extern void noqiflush(void);
extern int noraw(void);
extern int notimeout(WINDOW *, unsigned char);
extern int overlay(const WINDOW *, WINDOW *);
extern int overwrite(const WINDOW *, WINDOW *);
extern int pair_content(short, short *, short *);
extern int pecho_wchar(WINDOW *, cchar_t *);
extern int pechochar(const chtype, const chtype);
extern int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
extern int prefresh(WINDOW *, int, int, int, int, int, int);
extern int printw(const char *, ...);
extern int putwin(WINDOW *, FILE *);
extern void qiflush(void);
extern int raw(void);
extern int redrawwin(WINDOW *);
extern int refresh(void);
extern int reset_prog_mode(void);
extern int reset_shell_mode(void);
extern int resetty(void);
extern int resizeterm(int, int);
extern int ripoffline(int, int (*)(WINDOW *, int));
extern int savetty(void);
extern int scanw(char *, ...);
extern int scr_dump(const char *);
extern int scr_init(const char *);
extern int scr_restore(const char *);
extern int scr_set(const char *);
extern int scrl(int);
extern int scroll(WINDOW *);
extern int scrollok(WINDOW *, unsigned char);
extern SCREEN *set_term(SCREEN *);
extern int setcchar(cchar_t *, wchar_t *, attr_t, short, void *);
extern int setscrreg(int, int);
extern attr_t slk_attr(void);
extern int slk_attr_off(const attr_t, void *);
extern int slk_attr_on(attr_t, void *);
extern int slk_attr_set(const attr_t, short, void *);
extern int slk_attroff(const chtype);
extern int slk_attron(const chtype);
extern int slk_attrset(const chtype);
extern int slk_clear(void);
extern int slk_color(short);
extern int slk_init(int);
extern char *slk_label(int);
extern int slk_noutrefresh(void);
extern int slk_refresh(void);
extern int slk_restore(void);
extern int slk_set(int, const char *, int);
extern int slk_touch(void);
extern int slk_wset(int, const wchar_t *, int);
extern int standend(void);
extern int standout(void);
extern int start_color(void);
extern WINDOW *stdscr;
extern WINDOW *subpad(WINDOW *, int, int, int, int);
extern WINDOW *subwin(WINDOW *, int, int, int, int);
extern int syncok(WINDOW *, unsigned char);
extern attr_t term_attrs(void);
extern chtype termattrs(void);
extern char *termname(void);
extern void timeout(int);
extern int touchline(WINDOW *, int, int);
extern int touchwin(WINDOW *);
extern int typeahead(int);
extern char *unctrl(chtype);
extern int unget_wch(wchar_t);
extern int ungetch(int);
extern int ungetmouse(MEVENT *);
extern int untouchwin(WINDOW *);
extern int use_default_colors(void);
extern void use_env(unsigned char);
extern int use_extended_names(unsigned char);
extern int vid_attr(attr_t, short, void *);
extern int vid_puts(attr_t, short, void *, int);
extern int vidattr(chtype);
extern int vidputs(chtype, NCURSES_OUTC);
extern int vline(chtype, int);
extern int vline_set(cchar_t *, int);
extern int vw_printw(WINDOW *, const char *, va_list);
extern int vw_scanw(WINDOW *, char *, va_list);
extern int vwprintw(WINDOW *, const char *, va_list);
extern int vwscanw(WINDOW *, char *, va_list);
extern int wadd_wch(WINDOW *, cchar_t *);
extern int wadd_wchnstr(WINDOW *, cchar_t *, int);
extern int wadd_wchstr(WINDOW *, cchar_t *);
extern int waddch(WINDOW *, chtype);
extern int waddchnstr(WINDOW *, const chtype *, int);
extern int waddchstr(WINDOW *, const chtype *);
extern int waddnstr(WINDOW *, const char *, int);
extern int waddnwstr(WINDOW *, wchar_t *, int);
extern int waddstr(WINDOW *, const char *);
extern int waddwstr(WINDOW *, wchar_t *);
extern int wattr_get(WINDOW *, attr_t *, short *, void *);
extern int wattr_off(WINDOW *, attr_t, void *);
extern int wattr_on(WINDOW *, attr_t, void *);
extern int wattr_set(WINDOW *, attr_t, short, void *);
extern int wattroff(WINDOW *, int);
extern int wattron(WINDOW *, int);
extern int wattrset(WINDOW *, int);
extern int wbkgd(WINDOW *, chtype);
extern void wbkgdset(WINDOW *, chtype);
extern int wbkgrnd(WINDOW *, cchar_t *);
extern void wbkgrndset(WINDOW *, cchar_t *);
extern int wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype,
		   chtype, chtype, chtype);
extern int wborder_set(WINDOW *, cchar_t *, cchar_t *, cchar_t *,
		       cchar_t *, cchar_t *, cchar_t *, cchar_t *,
		       cchar_t *);
extern int wchgat(WINDOW *, int, attr_t, short, const void *);
extern int wclear(WINDOW *);
extern int wclrtobot(WINDOW *);
extern int wclrtoeol(WINDOW *);
extern int wcolor_set(WINDOW *, short, void *);
extern void wcursyncup(WINDOW *);
extern int wdelch(WINDOW *);
extern int wdeleteln(WINDOW *);
extern int wecho_wchar(WINDOW *, cchar_t *);
extern int wechochar(const chtype, const chtype);
extern int werase(WINDOW *);
extern int wget_wch(WINDOW *, wint_t *);
extern int wget_wstr(WINDOW *, wint_t *);
extern int wgetbkgrnd(WINDOW *, cchar_t *);
extern int wgetch(WINDOW *);
extern int wgetn_wstr(WINDOW *, wint_t *, int);
extern int wgetnstr(WINDOW *, char *, int);
extern int wgetstr(WINDOW *, char *);
extern int whline(WINDOW *, chtype, int);
extern int whline_set(WINDOW *, cchar_t *, int);
extern int win_wch(WINDOW *, cchar_t *);
extern int win_wchnstr(WINDOW *, cchar_t *, int);
extern int win_wchstr(WINDOW *, cchar_t *);
extern chtype winch(WINDOW *);
extern int winchnstr(WINDOW *, chtype *, int);
extern int winchstr(WINDOW *, chtype *);
extern int winnstr(WINDOW *, char *, int);
extern int winnwstr(WINDOW *, wchar_t *, int);
extern int wins_nwstr(WINDOW *, wchar_t *, int);
extern int wins_wch(WINDOW *, cchar_t *);
extern int wins_wstr(WINDOW *, wchar_t *);
extern int winsch(WINDOW *, chtype);
extern int winsdelln(WINDOW *, int);
extern int winsertln(WINDOW *);
extern int winsnstr(WINDOW *, const char *, int);
extern int winsstr(WINDOW *, const char *);
extern int winstr(WINDOW *, char *);
extern int winwstr(WINDOW *, wchar_t *);
extern unsigned char wmouse_trafo(const WINDOW *, int *, int *, bool);
extern int wmove(WINDOW *, int, int);
extern int wnoutrefresh(WINDOW *);
extern int wprintw(WINDOW *, const char *, ...);
extern int wredrawln(WINDOW *, int, int);
extern int wrefresh(WINDOW *);
extern int wresize(WINDOW *, int, int);
extern int wscanw(WINDOW *, char *, ...);
extern int wscrl(WINDOW *, int);
extern int wsetscrreg(WINDOW *, int, int);
extern int wstandend(WINDOW *);
extern int wstandout(WINDOW *);
extern void wsyncdown(WINDOW *);
extern void wsyncup(WINDOW *);
extern void wtimeout(WINDOW *, int);
extern int wtouchln(WINDOW *, int, int, int);
extern wchar_t *wunctrl(cchar_t *);
extern int wvline(WINDOW *, chtype, int);
extern int wvline_set(WINDOW *, cchar_t *, int);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35343"
>15.9.2. ncursesw/ncurses_dll.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NCURSES_API
#define NCURSES_IMPEXP
#define NCURSES_STATIC
#define NCURSES_WRAPPED_VAR(type,name)	extern type NCURSES_PUBLIC_VAR(name)(void)
#define NCURSES_PUBLIC_VAR(name)	_nc_ ##name</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35347"
>15.9.3. ncursesw/term.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NCURSES_TERM_H_incl	1
#define NCURSES_VERSION	"5.9"
#define NCURSES_SBOOL	char
#define NCURSES_XNAMES	1
#define TERMIOS	1
#define TTY	struct termios
#define TCSANOW	TCSETA
#define TCSADRAIN	TCSETAW
#define TCSAFLUSH	TCSETAF
#define tcsetattr(fd, cmd, arg)	ioctl(fd, cmd, arg)
#define tcgetattr(fd, arg)	ioctl(fd, TCGETA, arg)
#define cfgetospeed(t)	((t)-&#62;c_cflag &#38; CBAUD)
#define TCOFLUSH	1
#define TCIOFLUSH	2
#define tcflush(fd, arg)	ioctl(fd, TCFLSH, arg)
#define GET_TTY(fd, buf)	tcgetattr(fd, buf)
#define SET_TTY(fd, buf)	tcsetattr(fd, TCSADRAIN, buf)
#define NAMESIZE	256
#define CUR	cur_term-&#62;type.
#define auto_left_margin	CUR Booleans[0]
#define auto_right_margin	CUR Booleans[1]
#define no_esc_ctlc	CUR Booleans[2]
#define ceol_standout_glitch	CUR Booleans[3]
#define eat_newline_glitch	CUR Booleans[4]
#define erase_overstrike	CUR Booleans[5]
#define generic_type	CUR Booleans[6]
#define hard_copy	CUR Booleans[7]
#define has_meta_key	CUR Booleans[8]
#define has_status_line	CUR Booleans[9]
#define insert_null_glitch	CUR Booleans[10]
#define memory_above	CUR Booleans[11]
#define memory_below	CUR Booleans[12]
#define move_insert_mode	CUR Booleans[13]
#define move_standout_mode	CUR Booleans[14]
#define over_strike	CUR Booleans[15]
#define status_line_esc_ok	CUR Booleans[16]
#define dest_tabs_magic_smso	CUR Booleans[17]
#define tilde_glitch	CUR Booleans[18]
#define transparent_underline	CUR Booleans[19]
#define xon_xoff	CUR Booleans[20]
#define needs_xon_xoff	CUR Booleans[21]
#define prtr_silent	CUR Booleans[22]
#define hard_cursor	CUR Booleans[23]
#define non_rev_rmcup	CUR Booleans[24]
#define no_pad_char	CUR Booleans[25]
#define non_dest_scroll_region	CUR Booleans[26]
#define can_change	CUR Booleans[27]
#define back_color_erase	CUR Booleans[28]
#define hue_lightness_saturation	CUR Booleans[29]
#define col_addr_glitch	CUR Booleans[30]
#define cr_cancels_micro_mode	CUR Booleans[31]
#define has_print_wheel	CUR Booleans[32]
#define row_addr_glitch	CUR Booleans[33]
#define semi_auto_right_margin	CUR Booleans[34]
#define cpi_changes_res	CUR Booleans[35]
#define lpi_changes_res	CUR Booleans[36]
#define columns	CUR Numbers[0]
#define init_tabs	CUR Numbers[1]
#define lines	CUR Numbers[2]
#define lines_of_memory	CUR Numbers[3]
#define magic_cookie_glitch	CUR Numbers[4]
#define padding_baud_rate	CUR Numbers[5]
#define virtual_terminal	CUR Numbers[6]
#define width_status_line	CUR Numbers[7]
#define num_labels	CUR Numbers[8]
#define label_height	CUR Numbers[9]
#define label_width	CUR Numbers[10]
#define max_attributes	CUR Numbers[11]
#define maximum_windows	CUR Numbers[12]
#define max_colors	CUR Numbers[13]
#define max_pairs	CUR Numbers[14]
#define no_color_video	CUR Numbers[15]
#define buffer_capacity	CUR Numbers[16]
#define dot_vert_spacing	CUR Numbers[17]
#define dot_horz_spacing	CUR Numbers[18]
#define max_micro_address	CUR Numbers[19]
#define max_micro_jump	CUR Numbers[20]
#define micro_col_size	CUR Numbers[21]
#define micro_line_size	CUR Numbers[22]
#define number_of_pins	CUR Numbers[23]
#define output_res_char	CUR Numbers[24]
#define output_res_line	CUR Numbers[25]
#define output_res_horz_inch	CUR Numbers[26]
#define output_res_vert_inch	CUR Numbers[27]
#define print_rate	CUR Numbers[28]
#define wide_char_size	CUR Numbers[29]
#define buttons	CUR Numbers[30]
#define bit_image_entwining	CUR Numbers[31]
#define bit_image_type	CUR Numbers[32]
#define back_tab	CUR Strings[0]
#define bell	CUR Strings[1]
#define carriage_return	CUR Strings[2]
#define change_scroll_region	CUR Strings[3]
#define clear_all_tabs	CUR Strings[4]
#define clear_screen	CUR Strings[5]
#define clr_eol	CUR Strings[6]
#define clr_eos	CUR Strings[7]
#define column_address	CUR Strings[8]
#define command_character	CUR Strings[9]
#define cursor_address	CUR Strings[10]
#define cursor_down	CUR Strings[11]
#define cursor_home	CUR Strings[12]
#define cursor_invisible	CUR Strings[13]
#define cursor_left	CUR Strings[14]
#define cursor_mem_address	CUR Strings[15]
#define cursor_normal	CUR Strings[16]
#define cursor_right	CUR Strings[17]
#define cursor_to_ll	CUR Strings[18]
#define cursor_up	CUR Strings[19]
#define cursor_visible	CUR Strings[20]
#define delete_character	CUR Strings[21]
#define delete_line	CUR Strings[22]
#define dis_status_line	CUR Strings[23]
#define down_half_line	CUR Strings[24]
#define enter_alt_charset_mode	CUR Strings[25]
#define enter_blink_mode	CUR Strings[26]
#define enter_bold_mode	CUR Strings[27]
#define enter_ca_mode	CUR Strings[28]
#define enter_delete_mode	CUR Strings[29]
#define enter_dim_mode	CUR Strings[30]
#define enter_insert_mode	CUR Strings[31]
#define enter_secure_mode	CUR Strings[32]
#define enter_protected_mode	CUR Strings[33]
#define enter_reverse_mode	CUR Strings[34]
#define enter_standout_mode	CUR Strings[35]
#define enter_underline_mode	CUR Strings[36]
#define erase_chars	CUR Strings[37]
#define exit_alt_charset_mode	CUR Strings[38]
#define exit_attribute_mode	CUR Strings[39]
#define exit_ca_mode	CUR Strings[40]
#define exit_delete_mode	CUR Strings[41]
#define exit_insert_mode	CUR Strings[42]
#define exit_standout_mode	CUR Strings[43]
#define exit_underline_mode	CUR Strings[44]
#define flash_screen	CUR Strings[45]
#define form_feed	CUR Strings[46]
#define from_status_line	CUR Strings[47]
#define init_1string	CUR Strings[48]
#define init_2string	CUR Strings[49]
#define init_3string	CUR Strings[50]
#define init_file	CUR Strings[51]
#define insert_character	CUR Strings[52]
#define insert_line	CUR Strings[53]
#define insert_padding	CUR Strings[54]
#define key_backspace	CUR Strings[55]
#define key_catab	CUR Strings[56]
#define key_clear	CUR Strings[57]
#define key_ctab	CUR Strings[58]
#define key_dc	CUR Strings[59]
#define key_dl	CUR Strings[60]
#define key_down	CUR Strings[61]
#define key_eic	CUR Strings[62]
#define key_eol	CUR Strings[63]
#define key_eos	CUR Strings[64]
#define key_f0	CUR Strings[65]
#define key_f1	CUR Strings[66]
#define key_f10	CUR Strings[67]
#define key_f2	CUR Strings[68]
#define key_f3	CUR Strings[69]
#define key_f4	CUR Strings[70]
#define key_f5	CUR Strings[71]
#define key_f6	CUR Strings[72]
#define key_f7	CUR Strings[73]
#define key_f8	CUR Strings[74]
#define key_f9	CUR Strings[75]
#define key_home	CUR Strings[76]
#define key_ic	CUR Strings[77]
#define key_il	CUR Strings[78]
#define key_left	CUR Strings[79]
#define key_ll	CUR Strings[80]
#define key_npage	CUR Strings[81]
#define key_ppage	CUR Strings[82]
#define key_right	CUR Strings[83]
#define key_sf	CUR Strings[84]
#define key_sr	CUR Strings[85]
#define key_stab	CUR Strings[86]
#define key_up	CUR Strings[87]
#define keypad_local	CUR Strings[88]
#define keypad_xmit	CUR Strings[89]
#define lab_f0	CUR Strings[90]
#define lab_f1	CUR Strings[91]
#define lab_f10	CUR Strings[92]
#define lab_f2	CUR Strings[93]
#define lab_f3	CUR Strings[94]
#define lab_f4	CUR Strings[95]
#define lab_f5	CUR Strings[96]
#define lab_f6	CUR Strings[97]
#define lab_f7	CUR Strings[98]
#define lab_f8	CUR Strings[99]
#define lab_f9	CUR Strings[100]
#define meta_off	CUR Strings[101]
#define meta_on	CUR Strings[102]
#define newline	CUR Strings[103]
#define pad_char	CUR Strings[104]
#define parm_dch	CUR Strings[105]
#define parm_delete_line	CUR Strings[106]
#define parm_down_cursor	CUR Strings[107]
#define parm_ich	CUR Strings[108]
#define parm_index	CUR Strings[109]
#define parm_insert_line	CUR Strings[110]
#define parm_left_cursor	CUR Strings[111]
#define parm_right_cursor	CUR Strings[112]
#define parm_rindex	CUR Strings[113]
#define parm_up_cursor	CUR Strings[114]
#define pkey_key	CUR Strings[115]
#define pkey_local	CUR Strings[116]
#define pkey_xmit	CUR Strings[117]
#define print_screen	CUR Strings[118]
#define prtr_off	CUR Strings[119]
#define prtr_on	CUR Strings[120]
#define repeat_char	CUR Strings[121]
#define reset_1string	CUR Strings[122]
#define reset_2string	CUR Strings[123]
#define reset_3string	CUR Strings[124]
#define reset_file	CUR Strings[125]
#define restore_cursor	CUR Strings[126]
#define row_address	CUR Strings[127]
#define save_cursor	CUR Strings[128]
#define scroll_forward	CUR Strings[129]
#define scroll_reverse	CUR Strings[130]
#define set_attributes	CUR Strings[131]
#define set_tab	CUR Strings[132]
#define set_window	CUR Strings[133]
#define tab	CUR Strings[134]
#define to_status_line	CUR Strings[135]
#define underline_char	CUR Strings[136]
#define up_half_line	CUR Strings[137]
#define init_prog	CUR Strings[138]
#define key_a1	CUR Strings[139]
#define key_a3	CUR Strings[140]
#define key_b2	CUR Strings[141]
#define key_c1	CUR Strings[142]
#define key_c3	CUR Strings[143]
#define prtr_non	CUR Strings[144]
#define char_padding	CUR Strings[145]
#define acs_chars	CUR Strings[146]
#define plab_norm	CUR Strings[147]
#define key_btab	CUR Strings[148]
#define enter_xon_mode	CUR Strings[149]
#define exit_xon_mode	CUR Strings[150]
#define enter_am_mode	CUR Strings[151]
#define exit_am_mode	CUR Strings[152]
#define xon_character	CUR Strings[153]
#define xoff_character	CUR Strings[154]
#define ena_acs	CUR Strings[155]
#define label_on	CUR Strings[156]
#define label_off	CUR Strings[157]
#define key_beg	CUR Strings[158]
#define key_cancel	CUR Strings[159]
#define key_close	CUR Strings[160]
#define key_command	CUR Strings[161]
#define key_copy	CUR Strings[162]
#define key_create	CUR Strings[163]
#define key_end	CUR Strings[164]
#define key_enter	CUR Strings[165]
#define key_exit	CUR Strings[166]
#define key_find	CUR Strings[167]
#define key_help	CUR Strings[168]
#define key_mark	CUR Strings[169]
#define key_message	CUR Strings[170]
#define key_move	CUR Strings[171]
#define key_next	CUR Strings[172]
#define key_open	CUR Strings[173]
#define key_options	CUR Strings[174]
#define key_previous	CUR Strings[175]
#define key_print	CUR Strings[176]
#define key_redo	CUR Strings[177]
#define key_reference	CUR Strings[178]
#define key_refresh	CUR Strings[179]
#define key_replace	CUR Strings[180]
#define key_restart	CUR Strings[181]
#define key_resume	CUR Strings[182]
#define key_save	CUR Strings[183]
#define key_suspend	CUR Strings[184]
#define key_undo	CUR Strings[185]
#define key_sbeg	CUR Strings[186]
#define key_scancel	CUR Strings[187]
#define key_scommand	CUR Strings[188]
#define key_scopy	CUR Strings[189]
#define key_screate	CUR Strings[190]
#define key_sdc	CUR Strings[191]
#define key_sdl	CUR Strings[192]
#define key_select	CUR Strings[193]
#define key_send	CUR Strings[194]
#define key_seol	CUR Strings[195]
#define key_sexit	CUR Strings[196]
#define key_sfind	CUR Strings[197]
#define key_shelp	CUR Strings[198]
#define key_shome	CUR Strings[199]
#define key_sic	CUR Strings[200]
#define key_sleft	CUR Strings[201]
#define key_smessage	CUR Strings[202]
#define key_smove	CUR Strings[203]
#define key_snext	CUR Strings[204]
#define key_soptions	CUR Strings[205]
#define key_sprevious	CUR Strings[206]
#define key_sprint	CUR Strings[207]
#define key_sredo	CUR Strings[208]
#define key_sreplace	CUR Strings[209]
#define key_sright	CUR Strings[210]
#define key_srsume	CUR Strings[211]
#define key_ssave	CUR Strings[212]
#define key_ssuspend	CUR Strings[213]
#define key_sundo	CUR Strings[214]
#define req_for_input	CUR Strings[215]
#define key_f11	CUR Strings[216]
#define key_f12	CUR Strings[217]
#define key_f13	CUR Strings[218]
#define key_f14	CUR Strings[219]
#define key_f15	CUR Strings[220]
#define key_f16	CUR Strings[221]
#define key_f17	CUR Strings[222]
#define key_f18	CUR Strings[223]
#define key_f19	CUR Strings[224]
#define key_f20	CUR Strings[225]
#define key_f21	CUR Strings[226]
#define key_f22	CUR Strings[227]
#define key_f23	CUR Strings[228]
#define key_f24	CUR Strings[229]
#define key_f25	CUR Strings[230]
#define key_f26	CUR Strings[231]
#define key_f27	CUR Strings[232]
#define key_f28	CUR Strings[233]
#define key_f29	CUR Strings[234]
#define key_f30	CUR Strings[235]
#define key_f31	CUR Strings[236]
#define key_f32	CUR Strings[237]
#define key_f33	CUR Strings[238]
#define key_f34	CUR Strings[239]
#define key_f35	CUR Strings[240]
#define key_f36	CUR Strings[241]
#define key_f37	CUR Strings[242]
#define key_f38	CUR Strings[243]
#define key_f39	CUR Strings[244]
#define key_f40	CUR Strings[245]
#define key_f41	CUR Strings[246]
#define key_f42	CUR Strings[247]
#define key_f43	CUR Strings[248]
#define key_f44	CUR Strings[249]
#define key_f45	CUR Strings[250]
#define key_f46	CUR Strings[251]
#define key_f47	CUR Strings[252]
#define key_f48	CUR Strings[253]
#define key_f49	CUR Strings[254]
#define key_f50	CUR Strings[255]
#define key_f51	CUR Strings[256]
#define key_f52	CUR Strings[257]
#define key_f53	CUR Strings[258]
#define key_f54	CUR Strings[259]
#define key_f55	CUR Strings[260]
#define key_f56	CUR Strings[261]
#define key_f57	CUR Strings[262]
#define key_f58	CUR Strings[263]
#define key_f59	CUR Strings[264]
#define key_f60	CUR Strings[265]
#define key_f61	CUR Strings[266]
#define key_f62	CUR Strings[267]
#define key_f63	CUR Strings[268]
#define clr_bol	CUR Strings[269]
#define clear_margins	CUR Strings[270]
#define set_left_margin	CUR Strings[271]
#define set_right_margin	CUR Strings[272]
#define label_format	CUR Strings[273]
#define set_clock	CUR Strings[274]
#define display_clock	CUR Strings[275]
#define remove_clock	CUR Strings[276]
#define create_window	CUR Strings[277]
#define goto_window	CUR Strings[278]
#define hangup	CUR Strings[279]
#define dial_phone	CUR Strings[280]
#define quick_dial	CUR Strings[281]
#define tone	CUR Strings[282]
#define pulse	CUR Strings[283]
#define flash_hook	CUR Strings[284]
#define fixed_pause	CUR Strings[285]
#define wait_tone	CUR Strings[286]
#define user0	CUR Strings[287]
#define user1	CUR Strings[288]
#define user2	CUR Strings[289]
#define user3	CUR Strings[290]
#define user4	CUR Strings[291]
#define user5	CUR Strings[292]
#define user6	CUR Strings[293]
#define user7	CUR Strings[294]
#define user8	CUR Strings[295]
#define user9	CUR Strings[296]
#define orig_pair	CUR Strings[297]
#define orig_colors	CUR Strings[298]
#define initialize_color	CUR Strings[299]
#define initialize_pair	CUR Strings[300]
#define set_color_pair	CUR Strings[301]
#define set_foreground	CUR Strings[302]
#define set_background	CUR Strings[303]
#define change_char_pitch	CUR Strings[304]
#define change_line_pitch	CUR Strings[305]
#define change_res_horz	CUR Strings[306]
#define change_res_vert	CUR Strings[307]
#define define_char	CUR Strings[308]
#define enter_doublewide_mode	CUR Strings[309]
#define enter_draft_quality	CUR Strings[310]
#define enter_italics_mode	CUR Strings[311]
#define enter_leftward_mode	CUR Strings[312]
#define enter_micro_mode	CUR Strings[313]
#define enter_near_letter_quality	CUR Strings[314]
#define enter_normal_quality	CUR Strings[315]
#define enter_shadow_mode	CUR Strings[316]
#define enter_subscript_mode	CUR Strings[317]
#define enter_superscript_mode	CUR Strings[318]
#define enter_upward_mode	CUR Strings[319]
#define exit_doublewide_mode	CUR Strings[320]
#define exit_italics_mode	CUR Strings[321]
#define exit_leftward_mode	CUR Strings[322]
#define exit_micro_mode	CUR Strings[323]
#define exit_shadow_mode	CUR Strings[324]
#define exit_subscript_mode	CUR Strings[325]
#define exit_superscript_mode	CUR Strings[326]
#define exit_upward_mode	CUR Strings[327]
#define micro_column_address	CUR Strings[328]
#define micro_down	CUR Strings[329]
#define micro_left	CUR Strings[330]
#define micro_right	CUR Strings[331]
#define micro_row_address	CUR Strings[332]
#define micro_up	CUR Strings[333]
#define order_of_pins	CUR Strings[334]
#define parm_down_micro	CUR Strings[335]
#define parm_left_micro	CUR Strings[336]
#define parm_right_micro	CUR Strings[337]
#define parm_up_micro	CUR Strings[338]
#define select_char_set	CUR Strings[339]
#define set_bottom_margin	CUR Strings[340]
#define set_bottom_margin_parm	CUR Strings[341]
#define set_left_margin_parm	CUR Strings[342]
#define set_right_margin_parm	CUR Strings[343]
#define set_top_margin	CUR Strings[344]
#define set_top_margin_parm	CUR Strings[345]
#define start_bit_image	CUR Strings[346]
#define start_char_set_def	CUR Strings[347]
#define stop_bit_image	CUR Strings[348]
#define stop_char_set_def	CUR Strings[349]
#define subscript_characters	CUR Strings[350]
#define superscript_characters	CUR Strings[351]
#define these_cause_cr	CUR Strings[352]
#define zero_motion	CUR Strings[353]
#define char_set_names	CUR Strings[354]
#define key_mouse	CUR Strings[355]
#define mouse_info	CUR Strings[356]
#define req_mouse_pos	CUR Strings[357]
#define get_mouse	CUR Strings[358]
#define set_a_foreground	CUR Strings[359]
#define set_a_background	CUR Strings[360]
#define pkey_plab	CUR Strings[361]
#define device_type	CUR Strings[362]
#define code_set_init	CUR Strings[363]
#define set0_des_seq	CUR Strings[364]
#define set1_des_seq	CUR Strings[365]
#define set2_des_seq	CUR Strings[366]
#define set3_des_seq	CUR Strings[367]
#define set_lr_margin	CUR Strings[368]
#define set_tb_margin	CUR Strings[369]
#define bit_image_repeat	CUR Strings[370]
#define bit_image_newline	CUR Strings[371]
#define bit_image_carriage_return	CUR Strings[372]
#define color_names	CUR Strings[373]
#define define_bit_image_region	CUR Strings[374]
#define end_bit_image_region	CUR Strings[375]
#define set_color_band	CUR Strings[376]
#define set_page_length	CUR Strings[377]
#define display_pc_char	CUR Strings[378]
#define enter_pc_charset_mode	CUR Strings[379]
#define exit_pc_charset_mode	CUR Strings[380]
#define enter_scancode_mode	CUR Strings[381]
#define exit_scancode_mode	CUR Strings[382]
#define pc_term_options	CUR Strings[383]
#define scancode_escape	CUR Strings[384]
#define alt_scancode_esc	CUR Strings[385]
#define enter_horizontal_hl_mode	CUR Strings[386]
#define enter_left_hl_mode	CUR Strings[387]
#define enter_low_hl_mode	CUR Strings[388]
#define enter_right_hl_mode	CUR Strings[389]
#define enter_top_hl_mode	CUR Strings[390]
#define enter_vertical_hl_mode	CUR Strings[391]
#define set_a_attributes	CUR Strings[392]
#define set_pglen_inch	CUR Strings[393]
#define BOOLWRITE	37
#define NUMWRITE	33
#define STRWRITE	394
#define beehive_glitch	no_esc_ctlc
#define teleray_glitch	dest_tabs_magic_smso
#define micro_char_size	micro_col_size
#define termcap_init2	CUR Strings[394]
#define termcap_reset	CUR Strings[395]
#define magic_cookie_glitch_ul	CUR Numbers[33]
#define backspaces_with_bs	CUR Booleans[37]
#define crt_no_scrolling	CUR Booleans[38]
#define no_correctly_working_cr	CUR Booleans[39]
#define carriage_return_delay	CUR Numbers[34]
#define new_line_delay	CUR Numbers[35]
#define linefeed_if_not_lf	CUR Strings[396]
#define backspace_if_not_bs	CUR Strings[397]
#define gnu_has_meta_key	CUR Booleans[40]
#define linefeed_is_newline	CUR Booleans[41]
#define backspace_delay	CUR Numbers[36]
#define horizontal_tab_delay	CUR Numbers[37]
#define number_of_function_keys	CUR Numbers[38]
#define other_non_function_keys	CUR Strings[398]
#define arrow_key_map	CUR Strings[399]
#define has_hardware_tabs	CUR Booleans[42]
#define return_does_clr_eol	CUR Booleans[43]
#define acs_ulcorner	CUR Strings[400]
#define acs_llcorner	CUR Strings[401]
#define acs_urcorner	CUR Strings[402]
#define acs_lrcorner	CUR Strings[403]
#define acs_ltee	CUR Strings[404]
#define acs_rtee	CUR Strings[405]
#define acs_btee	CUR Strings[406]
#define acs_ttee	CUR Strings[407]
#define acs_hline	CUR Strings[408]
#define acs_vline	CUR Strings[409]
#define acs_plus	CUR Strings[410]
#define memory_lock	CUR Strings[411]
#define memory_unlock	CUR Strings[412]
#define box_chars_1	CUR Strings[413]
#define BOOLCOUNT	44
#define NUMCOUNT	39
#define STRCOUNT	414
#define acs_chars_index	146
#define cur_term	NCURSES_PUBLIC_VAR(cur_term())
#define boolnames	NCURSES_PUBLIC_VAR(boolnames())
#define boolcodes	NCURSES_PUBLIC_VAR(boolcodes())
#define boolfnames	NCURSES_PUBLIC_VAR(boolfnames())
#define numnames	NCURSES_PUBLIC_VAR(numnames())
#define numcodes	NCURSES_PUBLIC_VAR(numcodes())
#define numfnames	NCURSES_PUBLIC_VAR(numfnames())
#define strnames	NCURSES_PUBLIC_VAR(strnames())
#define strcodes	NCURSES_PUBLIC_VAR(strcodes())
#define strfnames	NCURSES_PUBLIC_VAR(strfnames())

typedef struct termtype {
    char *term_names;
    char *str_table;
    char *Booleans;
    short *Numbers;
    char **Strings;
    char *ext_str_table;
    char **ext_Names;
    unsigned short num_Booleans;
    unsigned short num_Numbers;
    unsigned short num_Strings;
    unsigned short ext_Booleans;
    unsigned short ext_Numbers;
    unsigned short ext_Strings;
} TERMTYPE;
typedef struct term {
    TERMTYPE type;
    short Filedes;
    struct termios Ottyb;
    struct termios Nttyb;
    int _baudrate;
    char *_termname;
} TERMINAL;
extern TERMINAL *cur_term;
extern int del_curterm(TERMINAL *);
extern int putp(const char *);
extern int restartterm(char *, int, int *);
extern TERMINAL *set_curterm(TERMINAL *);
extern int setupterm(char *, int, int *);
extern int tgetent(char *, const char *);
extern int tgetflag(char *);
extern int tgetnum(char *);
extern char *tgetstr(char *, char **);
extern char *tgoto(const char *, int, int);
extern int tigetflag(char *);
extern int tigetnum(char *);
extern char *tigetstr(char *);
extern char *tparm(char *, ...);
extern int tputs(const char *, int, int (*)(int));
extern char ttytype[];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35351"
>15.9.4. ncursesw/unctrl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NCURSES_UNCTRL_H_incl	1
#define NCURSES_VERSION	"5.9"</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNCURSESWMAN"
>15.10. Interface Definitions for libncursesw</A
></H2
><P
>The interfaces defined on the following pages are included in libncursesw and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBNCURSESW"
>Section 15.8</A
> shall behave as described
in the referenced base document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBUTIL"
>15.11. Interfaces for libutil</A
></H2
><P
><A
HREF="#LIB-LIBUTIL-DEF"
>Table 15-11</A
> defines the library name and shared object name
for the libutil library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBUTIL-DEF"
></A
><P
><B
>Table 15-11. libutil Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libutil</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libutil.so.1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBUTIL.1"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35378"
>15.11.1. Utility Functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN35381"
>15.11.1.1. Interfaces for Utility Functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Utility Functions specified in <A
HREF="#TBL-LIBUTIL-UTILI-INTS"
>Table 15-12</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBUTIL-UTILI-INTS"
></A
><P
><B
>Table 15-12. libutil - Utility Functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>forkpty <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>login <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>login_tty <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>logout <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
></TR
><TR
><TD
>logwtmp <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>openpty <A
HREF="#REFSTD.LIBUTIL.1"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBUTIL-DDEFS"
>15.12. Data Definitions for libutil</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libutil.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35423"
>15.12.1. pty.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int forkpty(int *__amaster, char *__name,
		   const struct termios *__termp,
		   const struct winsize *__winp);
extern int openpty(int *__amaster, int *__aslave, char *__name,
		   const struct termios *__termp,
		   const struct winsize *__winp);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBUTILMAN"
>15.13. Interface Definitions for libutil</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#UTILLIB-FORKPTY-3"
>forkpty</A
>&nbsp;--&nbsp;Create a new process attached to an available pseudo-terminal</DT
><DT
><A
HREF="#UTILLIB-LOGIN-3"
>login</A
>&nbsp;--&nbsp;login utility function</DT
><DT
><A
HREF="#UTILLIB-LOGIN-TTY-3"
>login_tty</A
>&nbsp;--&nbsp;Prepare a terminal for login</DT
><DT
><A
HREF="#UTILLIB-LOGOUT-3"
>logout</A
>&nbsp;--&nbsp;logout utility function</DT
><DT
><A
HREF="#UTILLIB-LOGWTMP-3"
>logwtmp</A
>&nbsp;--&nbsp;append an entry to the wtmp file</DT
><DT
><A
HREF="#UTILLIB-OPENPTY-3"
>openpty</A
>&nbsp;--&nbsp;find and open an available pseudo-terminal</DT
></DL
></DIV
><P
>The interfaces defined on the following pages are included in libutil and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBUTIL"
>Section 15.11</A
> shall behave as described
in the referenced base document.</P
><H1
><A
NAME="UTILLIB-FORKPTY-3"
></A
>forkpty</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN35436"
></A
><H2
>Name</H2
>forkpty&nbsp;--&nbsp;Create a new process attached to an available pseudo-terminal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN35441"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN35444"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pty.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>forkpty</TT
></CODE
>(int *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>amaster</I
></TT
></I
></TT
>, char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, const struct termios *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>termp</I
></TT
></I
></TT
>, const struct winsize *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>winp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35461"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>forkpty()</TT
>
function shall find and open a pseudo-terminal device pair in the
same manner as the <TT
CLASS="FUNCTION"
>openpty()</TT
> function. 
If a pseudo-terminal is available,
<TT
CLASS="FUNCTION"
>forkpty()</TT
>
shall create a new process in the same manner as the <TT
CLASS="FUNCTION"
>fork()</TT
>
function, and prepares the new process for login in the same manner as 
<TT
CLASS="FUNCTION"
>login_tty()</TT
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>termp</I
></TT
> is not null, 
it shall refer to a <CODE
CLASS="VARNAME"
>termios</CODE
> structure that shall be used
to initialize the characteristics of the slave device. 
If <TT
CLASS="PARAMETER"
><I
>winp</I
></TT
> is not null, it
shall refer to a <CODE
CLASS="VARNAME"
>winsize</CODE
> structure used to 
initialize the window size of the
slave device.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35476"
></A
><H2
>Return Value</H2
><P
>On success, the parent process shall return the process id of the child, and the
child shall return 0. On error, no new process shall be created, -1 shall be
returned, and <CODE
CLASS="VARNAME"
>errno</CODE
> shall be set appropriately.
On success, the parent process shall receive the file descriptor of the master
side of the pseudo-terminal in the location referenced by 
<TT
CLASS="PARAMETER"
><I
>amaster</I
></TT
>, and, if <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is
not NULL, the filename of the slave device in 
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
>. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35483"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN35486"
></A
><SPAN
STYLE="white-space: nowrap"
>EAGAIN</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unable to create a new process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN35490"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There are no available pseudo-terminals.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN35494"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOMEM</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Insufficient memory was available.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="UTILLIB-LOGIN-3"
></A
>login</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN35502"
></A
><H2
>Name</H2
>login&nbsp;--&nbsp;login utility function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN35507"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN35510"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
      <TT
CLASS="FUNCTION"
>login</TT
>
    </CODE
>(struct utmp *
      <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>ut</I
></TT
></I
></TT
>
    );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35518"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>login()</TT
> function shall update the user 
accounting databases.
The <TT
CLASS="PARAMETER"
><I
>ut</I
></TT
> parameter shall reference a 
<TT
CLASS="STRUCTNAME"
>utmp</TT
> structure 
for all fields except the following:
<P
></P
><OL
TYPE="1"
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>ut_type</CODE
> field shall be set to <CODE
CLASS="CONSTANT"
>USER_PROCESS</CODE
>.</P
></LI
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>ut_pid</CODE
> field shall be set to the process identifier
for the current process.</P
></LI
><LI
><P
>The <CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field shall be set to the name of the 
controlling terminal device.
The name shall be found by examining the device associated with the
standard input, output and error streams in sequence, until one associated with
a terminal device is found.
If none of these streams refers to a terminal device, the 
<CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field shall be set to <CODE
CLASS="CONSTANT"
>"???"</CODE
>.
If the terminal device is in the <TT
CLASS="FILENAME"
>/dev</TT
> directory
hierarchy, the <CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field shall not contain the leading
<CODE
CLASS="CONSTANT"
>"/dev/"</CODE
>, otherwise it shall be set to the final component
of the pathname of the device. 
If the user
accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field, it shall
truncate the name, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_LINESIZE</CODE
>
(including a terminating null character).</P
></LI
></OL
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35544"
></A
><H2
>Return Value</H2
><P
>None</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35547"
></A
><H2
>Errors</H2
><P
>None</P
></DIV
><H1
><A
NAME="UTILLIB-LOGIN-TTY-3"
></A
>login_tty</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN35554"
></A
><H2
>Name</H2
>login_tty&nbsp;--&nbsp;Prepare a terminal for login</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN35559"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN35562"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
    <TT
CLASS="FUNCTION"
>login_tty</TT
>
  </CODE
>(int <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>fdr</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35570"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>login_tty()</TT
> function
shall prepare the terminal device referenced by the file
descriptor <TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
>. 
This function shall create a new session, make the terminal 
the controlling terminal for the current process, and set the standard 
input, output, and error streams of the current process to the terminal.
If <TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
> is not the standard input, output or error stream,
then <TT
CLASS="FUNCTION"
>login_tty()</TT
> shall close <TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35580"
></A
><H2
>Return Value</H2
><P
>On success, <TT
CLASS="FUNCTION"
>login_tty()</TT
> shall return zero;
otherwise -1 is returned, and errno shall be set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35584"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN35589"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOTTY</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="PARAMETER"
><I
>fdr</I
></TT
> does not refer to a terminal device.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="UTILLIB-LOGOUT-3"
></A
>logout</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN35598"
></A
><H2
>Name</H2
>logout&nbsp;--&nbsp;logout utility function</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN35603"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN35606"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
      <TT
CLASS="FUNCTION"
>logout</TT
>
    </CODE
>(const char *
      <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>line</I
></TT
></I
></TT
>
    );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35614"
></A
><H2
>Description</H2
><P
>Given the device <TT
CLASS="PARAMETER"
><I
>line</I
></TT
>,
the <TT
CLASS="FUNCTION"
>logout()</TT
> function shall search
the user accounting database which is read by <TT
CLASS="FUNCTION"
>getutent()</TT
>
for an entry with the corresponding line,
and with the type of <CODE
CLASS="CONSTANT"
>USER_PROCESS</CODE
>.
If a corresponding entry is located, it shall be updated as follows:
<P
></P
><OL
TYPE="1"
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_name</CODE
> field shall be set to zeroes
(<CODE
CLASS="CONSTANT"
>UT_NAMESIZE</CODE
> NUL bytes).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_host</CODE
> field shall be set to zeroes
(<CODE
CLASS="CONSTANT"
>UT_HOSTSIZE</CODE
> NUL bytes).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_tv</CODE
> shall be set to the current 
time of day.</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_type</CODE
> field shall be set to
<CODE
CLASS="CONSTANT"
>DEAD_PROCESS</CODE
>.</P
></LI
></OL
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35639"
></A
><H2
>Return Value</H2
><P
>On success, the <TT
CLASS="FUNCTION"
>logout()</TT
> function shall return non-zero.
Zero is returned if there was no entry to remove, or if the utmp file
could not be opened or updated.</P
></DIV
><H1
><A
NAME="UTILLIB-LOGWTMP-3"
></A
>logwtmp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN35647"
></A
><H2
>Name</H2
>logwtmp&nbsp;--&nbsp;append an entry to the wtmp file</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN35652"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN35655"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;utmp.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void
    <TT
CLASS="FUNCTION"
>logwtmp</TT
>
  </CODE
>(const char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>line</I
></TT
></I
></TT
>
  , const char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>
  , const char *
    <TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
></I
></TT
>
  );</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35669"
></A
><H2
>Description</H2
><P
>If the process has permission to update the user accounting databases,
the <TT
CLASS="FUNCTION"
>logwtmp()</TT
> function
shall append a record to the user accounting database 
that records all logins and logouts. The record to be appended
shall be constructed as follows:
<P
></P
><OL
TYPE="1"
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_line</CODE
> field shall be initialized
from <TT
CLASS="PARAMETER"
><I
>line</I
></TT
>.
If the user accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_line</CODE
> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_LINESIZE</CODE
>
(including a terminating null character).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_name</CODE
> field shall be initialized
from <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
If the user accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_name</CODE
> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_NAMESIZE</CODE
>
(including a terminating null character).</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_host</CODE
> field shall be initialized
from <TT
CLASS="PARAMETER"
><I
>host</I
></TT
>.
If the user accounting database imposes a limit on the size of the 
<CODE
CLASS="STRUCTFIELD"
>ut_host</CODE
> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CODE
CLASS="CONSTANT"
>UT_HOSTSIZE</CODE
>
(including a terminating null character).</P
></LI
><LI
><P
>If the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> parameter does not refer
to an empty string (i.e. <CODE
CLASS="CONSTANT"
>""</CODE
>), 
the <CODE
CLASS="VARNAME"
>ut_type</CODE
> field shall be set to 
<CODE
CLASS="CONSTANT"
>USER_PROCESS</CODE
>; otherwise the
<CODE
CLASS="VARNAME"
>ut_type</CODE
> field shall be set to 
<CODE
CLASS="CONSTANT"
>DEAD_PROCESS</CODE
>.</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_id</CODE
> field shall be set to the 
process identifier for the current process.</P
></LI
><LI
><P
>The <CODE
CLASS="VARNAME"
>ut_tv</CODE
> field shall be set to the
current time of day.</P
></LI
></OL
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If a process does not have write access to the 
the user accounting database, the
<TT
CLASS="FUNCTION"
>logwtmp()</TT
> function will not update it. 
Since the function does not return
any value, an application has no way of knowing whether it succeeded or failed.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35711"
></A
><H2
>Return Value</H2
><P
>None.</P
></DIV
><H1
><A
NAME="UTILLIB-OPENPTY-3"
></A
>openpty</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN35718"
></A
><H2
>Name</H2
>openpty&nbsp;--&nbsp;find and open an available pseudo-terminal</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN35723"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN35726"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;pty.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
    <TT
CLASS="FUNCTION"
>openpty</TT
></CODE
>(int *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>amaster</I
></TT
></I
></TT
>, int *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>aslave</I
></TT
></I
></TT
>, char *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></I
></TT
>, const struct termios *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>termp</I
></TT
></I
></TT
>, const struct winsize *<TT
CLASS="PARAMETER"
><I
><TT
CLASS="REPLACEABLE"
><I
>winp</I
></TT
></I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35746"
></A
><H2
>Description</H2
><P
>The <TT
CLASS="FUNCTION"
>openpty()</TT
>
function shall find an available pseudo-terminal
and return file descriptors for the master and slave devices in
the locations referenced by 
<TT
CLASS="PARAMETER"
><I
>amaster</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>aslave</I
></TT
>
respectively. 
If <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> is not NULL,
the filename of the slave shall be placed in the user supplied buffer 
referenced by <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>termp</I
></TT
> is not NULL, it shall
point to a <CODE
CLASS="VARNAME"
>termios</CODE
> structure used to initialize
the terminal parameters of the slave pseudo-terminal device.
If <TT
CLASS="PARAMETER"
><I
>winp</I
></TT
> is not NULL, it shall
point to a <CODE
CLASS="VARNAME"
>winsize</CODE
> structure used to initialize
the window size parameters of the slave pseudo-terminal device.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35760"
></A
><H2
>Return Value</H2
><P
>On success, zero is returned. On error, -1 is returned, and errno is set appropriately.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN35763"
></A
><H2
>Errors</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN35766"
></A
><SPAN
STYLE="white-space: nowrap"
>ENOENT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There are no available pseudo-terminals.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="CXXTOCBASELIB"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>V. C++ Libraries</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>16. <A
HREF="#CXXBASELIB"
>Libraries</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#LIBSTDCXX"
>Interfaces for libstdcxx</A
></DT
><DD
><DL
><DT
>16.1.1. <A
HREF="#AEN35799"
>C++ Runtime Support</A
></DT
><DT
>16.1.2. <A
HREF="#AEN36146"
>C++ type descriptors for built-in types</A
></DT
><DT
>16.1.3. <A
HREF="#AEN36668"
>C++ _Rb_tree</A
></DT
><DT
>16.1.4. <A
HREF="#AEN36724"
>Class type_info</A
></DT
><DT
>16.1.5. <A
HREF="#AEN36857"
>Class __cxxabiv1::__enum_type_info</A
></DT
><DT
>16.1.6. <A
HREF="#AEN36970"
>Class __cxxabiv1::__array_type_info</A
></DT
><DT
>16.1.7. <A
HREF="#AEN37083"
>Class __cxxabiv1::__class_type_info</A
></DT
><DT
>16.1.8. <A
HREF="#AEN37216"
>Class __cxxabiv1::__pbase_type_info</A
></DT
><DT
>16.1.9. <A
HREF="#AEN37344"
>Class __cxxabiv1::__pointer_type_info</A
></DT
><DT
>16.1.10. <A
HREF="#AEN37472"
>Class __cxxabiv1::__function_type_info</A
></DT
><DT
>16.1.11. <A
HREF="#AEN37590"
>Class __cxxabiv1::__si_class_type_info</A
></DT
><DT
>16.1.12. <A
HREF="#AEN37713"
>Class __cxxabiv1::__vmi_class_type_info</A
></DT
><DT
>16.1.13. <A
HREF="#AEN37836"
>Class __cxxabiv1::__fundamental_type_info</A
></DT
><DT
>16.1.14. <A
HREF="#AEN37949"
>Class __cxxabiv1::__pointer_to_member_type_info</A
></DT
><DT
>16.1.15. <A
HREF="#AEN38072"
>Class __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.16. <A
HREF="#AEN38094"
>Class __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.17. <A
HREF="#AEN38116"
>Class __gnu_cxx::__pool_alloc_base</A
></DT
><DT
>16.1.18. <A
HREF="#AEN38132"
>Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.19. <A
HREF="#AEN38251"
>Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.20. <A
HREF="#AEN38370"
>Class exception</A
></DT
><DT
>16.1.21. <A
HREF="#AEN38473"
>Class bad_typeid</A
></DT
><DT
>16.1.22. <A
HREF="#AEN38571"
>Class logic_error</A
></DT
><DT
>16.1.23. <A
HREF="#AEN38684"
>Class range_error</A
></DT
><DT
>16.1.24. <A
HREF="#AEN38787"
>Class domain_error</A
></DT
><DT
>16.1.25. <A
HREF="#AEN38890"
>Class length_error</A
></DT
><DT
>16.1.26. <A
HREF="#AEN38993"
>Class out_of_range</A
></DT
><DT
>16.1.27. <A
HREF="#AEN39096"
>Class bad_exception</A
></DT
><DT
>16.1.28. <A
HREF="#AEN39194"
>Class runtime_error</A
></DT
><DT
>16.1.29. <A
HREF="#AEN39307"
>Class overflow_error</A
></DT
><DT
>16.1.30. <A
HREF="#AEN39410"
>Class underflow_error</A
></DT
><DT
>16.1.31. <A
HREF="#AEN39513"
>Class invalid_argument</A
></DT
><DT
>16.1.32. <A
HREF="#AEN39616"
>Class bad_cast</A
></DT
><DT
>16.1.33. <A
HREF="#AEN39714"
>Class bad_alloc</A
></DT
><DT
>16.1.34. <A
HREF="#AEN39812"
>struct __numeric_limits_base</A
></DT
><DT
>16.1.35. <A
HREF="#AEN39934"
>struct numeric_limits&#60;long double&#62;</A
></DT
><DT
>16.1.36. <A
HREF="#AEN40056"
>struct numeric_limits&#60;long long&#62;</A
></DT
><DT
>16.1.37. <A
HREF="#AEN40178"
>struct numeric_limits&#60;unsigned long long&#62;</A
></DT
><DT
>16.1.38. <A
HREF="#AEN40300"
>struct numeric_limits&#60;float&#62;</A
></DT
><DT
>16.1.39. <A
HREF="#AEN40422"
>struct numeric_limits&#60;double&#62;</A
></DT
><DT
>16.1.40. <A
HREF="#AEN40544"
>struct numeric_limits&#60;short&#62;</A
></DT
><DT
>16.1.41. <A
HREF="#AEN40666"
>struct numeric_limits&#60;unsigned short&#62;</A
></DT
><DT
>16.1.42. <A
HREF="#AEN40788"
>struct numeric_limits&#60;int&#62;</A
></DT
><DT
>16.1.43. <A
HREF="#AEN40910"
>struct numeric_limits&#60;unsigned int&#62;</A
></DT
><DT
>16.1.44. <A
HREF="#AEN41032"
>struct numeric_limits&#60;long&#62;</A
></DT
><DT
>16.1.45. <A
HREF="#AEN41154"
>struct numeric_limits&#60;unsigned long&#62;</A
></DT
><DT
>16.1.46. <A
HREF="#AEN41276"
>struct numeric_limits&#60;wchar_t&#62;</A
></DT
><DT
>16.1.47. <A
HREF="#AEN41398"
>struct numeric_limits&#60;unsigned char&#62;</A
></DT
><DT
>16.1.48. <A
HREF="#AEN41520"
>struct numeric_limits&#60;signed char&#62;</A
></DT
><DT
>16.1.49. <A
HREF="#AEN41642"
>struct numeric_limits&#60;char&#62;</A
></DT
><DT
>16.1.50. <A
HREF="#AEN41764"
>struct numeric_limits&#60;bool&#62;</A
></DT
><DT
>16.1.51. <A
HREF="#AEN41886"
>Class ctype_base</A
></DT
><DT
>16.1.52. <A
HREF="#AEN41982"
>Class __ctype_abstract_base&#60;char&#62;</A
></DT
><DT
>16.1.53. <A
HREF="#AEN42099"
>Class __ctype_abstract_base&#60;wchar_t&#62;</A
></DT
><DT
>16.1.54. <A
HREF="#AEN42216"
>Class ctype&#60;char&#62;</A
></DT
><DT
>16.1.55. <A
HREF="#AEN42393"
>Class ctype&#60;wchar_t&#62;</A
></DT
><DT
>16.1.56. <A
HREF="#AEN42621"
>Class ctype_byname&#60;char&#62;</A
></DT
><DT
>16.1.57. <A
HREF="#AEN42754"
>Class ctype_byname&#60;wchar_t&#62;</A
></DT
><DT
>16.1.58. <A
HREF="#AEN42907"
>Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16.1.59. <A
HREF="#AEN43349"
>Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.60. <A
HREF="#AEN43821"
>Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16.1.61. <A
HREF="#AEN43926"
>Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.62. <A
HREF="#AEN44031"
>Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16.1.63. <A
HREF="#AEN44136"
>Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.64. <A
HREF="#AEN44241"
>Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16.1.65. <A
HREF="#AEN44346"
>Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.66. <A
HREF="#AEN44451"
>Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></DT
><DT
>16.1.67. <A
HREF="#AEN44656"
>Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.68. <A
HREF="#AEN44861"
>Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.69. <A
HREF="#AEN44956"
>Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.70. <A
HREF="#AEN45046"
>Class basic_istream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.71. <A
HREF="#AEN45386"
>Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.72. <A
HREF="#AEN45701"
>Class istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.73. <A
HREF="#AEN45717"
>Class istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.74. <A
HREF="#AEN45733"
>Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.75. <A
HREF="#AEN46048"
>Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.76. <A
HREF="#AEN46343"
>Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.77. <A
HREF="#AEN46458"
>Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.78. <A
HREF="#AEN46573"
>Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.79. <A
HREF="#AEN46688"
>Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.80. <A
HREF="#AEN46818"
>Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.81. <A
HREF="#AEN46933"
>Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.82. <A
HREF="#AEN47048"
>Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.83. <A
HREF="#AEN47363"
>Class basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.84. <A
HREF="#AEN47657"
>Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.85. <A
HREF="#AEN47887"
>Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.86. <A
HREF="#AEN48137"
>Class ios_base</A
></DT
><DT
>16.1.87. <A
HREF="#AEN48480"
>Class basic_ios&#60;char, char_traits&#60;char&#62; &#62;</A
></DT
><DT
>16.1.88. <A
HREF="#AEN48692"
>Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></DT
><DT
>16.1.89. <A
HREF="#AEN48929"
>Class ios_base::failure</A
></DT
><DT
>16.1.90. <A
HREF="#AEN49017"
>Class __timepunct&#60;char&#62;</A
></DT
><DT
>16.1.91. <A
HREF="#AEN49180"
>Class __timepunct&#60;wchar_t&#62;</A
></DT
><DT
>16.1.92. <A
HREF="#AEN49333"
>Class messages_base</A
></DT
><DT
>16.1.93. <A
HREF="#AEN49374"
>Class messages&#60;char&#62;</A
></DT
><DT
>16.1.94. <A
HREF="#AEN49521"
>Class messages&#60;wchar_t&#62;</A
></DT
><DT
>16.1.95. <A
HREF="#AEN49668"
>Class messages_byname&#60;char&#62;</A
></DT
><DT
>16.1.96. <A
HREF="#AEN49776"
>Class messages_byname&#60;wchar_t&#62;</A
></DT
><DT
>16.1.97. <A
HREF="#AEN49884"
>Class numpunct&#60;char&#62;</A
></DT
><DT
>16.1.98. <A
HREF="#AEN50067"
>Class numpunct&#60;wchar_t&#62;</A
></DT
><DT
>16.1.99. <A
HREF="#AEN50250"
>Class numpunct_byname&#60;char&#62;</A
></DT
><DT
>16.1.100. <A
HREF="#AEN50368"
>Class numpunct_byname&#60;wchar_t&#62;</A
></DT
><DT
>16.1.101. <A
HREF="#AEN50486"
>Class __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16.1.102. <A
HREF="#AEN50578"
>Class __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16.1.103. <A
HREF="#AEN50670"
>Class codecvt_base</A
></DT
><DT
>16.1.104. <A
HREF="#AEN50711"
>Class codecvt&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16.1.105. <A
HREF="#AEN50872"
>Class codecvt&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16.1.106. <A
HREF="#AEN51033"
>Class codecvt_byname&#60;char, char, __mbstate_t&#62;</A
></DT
><DT
>16.1.107. <A
HREF="#AEN51159"
>Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</A
></DT
><DT
>16.1.108. <A
HREF="#AEN51285"
>Class collate&#60;char&#62;</A
></DT
><DT
>16.1.109. <A
HREF="#AEN51438"
>Class collate&#60;wchar_t&#62;</A
></DT
><DT
>16.1.110. <A
HREF="#AEN51591"
>Class collate_byname&#60;char&#62;</A
></DT
><DT
>16.1.111. <A
HREF="#AEN51699"
>Class collate_byname&#60;wchar_t&#62;</A
></DT
><DT
>16.1.112. <A
HREF="#AEN51807"
>Class time_base</A
></DT
><DT
>16.1.113. <A
HREF="#AEN51848"
>Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.114. <A
HREF="#AEN51971"
>Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.115. <A
HREF="#AEN52094"
>Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.116. <A
HREF="#AEN52192"
>Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.117. <A
HREF="#AEN52290"
>Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.118. <A
HREF="#AEN52472"
>Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.119. <A
HREF="#AEN52654"
>Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.120. <A
HREF="#AEN52792"
>Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.121. <A
HREF="#AEN52930"
>Class moneypunct&#60;char, false&#62;</A
></DT
><DT
>16.1.122. <A
HREF="#AEN53162"
>Class moneypunct&#60;char, true&#62;</A
></DT
><DT
>16.1.123. <A
HREF="#AEN53394"
>Class moneypunct&#60;wchar_t, false&#62;</A
></DT
><DT
>16.1.124. <A
HREF="#AEN53626"
>Class moneypunct&#60;wchar_t, true&#62;</A
></DT
><DT
>16.1.125. <A
HREF="#AEN53858"
>Class moneypunct_byname&#60;char, false&#62;</A
></DT
><DT
>16.1.126. <A
HREF="#AEN54001"
>Class moneypunct_byname&#60;char, true&#62;</A
></DT
><DT
>16.1.127. <A
HREF="#AEN54144"
>Class moneypunct_byname&#60;wchar_t, false&#62;</A
></DT
><DT
>16.1.128. <A
HREF="#AEN54287"
>Class moneypunct_byname&#60;wchar_t, true&#62;</A
></DT
><DT
>16.1.129. <A
HREF="#AEN54430"
>Class money_base</A
></DT
><DT
>16.1.130. <A
HREF="#AEN54491"
>Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.131. <A
HREF="#AEN54634"
>Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.132. <A
HREF="#AEN54777"
>Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.133. <A
HREF="#AEN54920"
>Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.134. <A
HREF="#AEN55063"
>Class locale</A
></DT
><DT
>16.1.135. <A
HREF="#AEN55245"
>Class locale::facet</A
></DT
><DT
>16.1.136. <A
HREF="#AEN55378"
>facet functions</A
></DT
><DT
>16.1.137. <A
HREF="#AEN55659"
>Class __num_base</A
></DT
><DT
>16.1.138. <A
HREF="#AEN55694"
>Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.139. <A
HREF="#AEN56002"
>Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.140. <A
HREF="#AEN56310"
>Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></DT
><DT
>16.1.141. <A
HREF="#AEN56568"
>Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></DT
><DT
>16.1.142. <A
HREF="#AEN56826"
>Class __basic_file&#60;char&#62;</A
></DT
><DT
>16.1.143. <A
HREF="#AEN56905"
>Class _List_node_base</A
></DT
><DT
>16.1.144. <A
HREF="#AEN56941"
>Class allocator&#60;char&#62;</A
></DT
><DT
>16.1.145. <A
HREF="#AEN56985"
>Class allocator&#60;wchar_t&#62;</A
></DT
><DT
>16.1.146. <A
HREF="#AEN57029"
>Class __gnu_cxx::__pool&#60;true&#62;</A
></DT
><DT
>16.1.147. <A
HREF="#AEN57065"
>Class __gnu_cxx::__pool&#60;false&#62;</A
></DT
><DT
>16.1.148. <A
HREF="#AEN57086"
>Class __gnu_cxx::free_list</A
></DT
><DT
>16.1.149. <A
HREF="#AEN57102"
>Class char_traits&#60;char&#62;</A
></DT
><DT
>16.1.150. <A
HREF="#AEN57118"
>Class char_traits&#60;wchar_t&#62;</A
></DT
></DL
></DD
><DT
>16.2. <A
HREF="#LIBSTDCXXMAN"
>Interface Definitions for libstdcxx</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CXXBASELIB"
></A
>Chapter 16. Libraries</H1
><P
>An LSB-conforming implementation shall support some C++ libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBSTDCXX"
>16.1. Interfaces for libstdcxx</A
></H2
><P
><A
HREF="#LIB-LIBSTDCXX-DEF"
>Table 16-1</A
> defines the library name and shared object name
for the libstdcxx library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBSTDCXX-DEF"
></A
><P
><B
>Table 16-1. libstdcxx Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libstdcxx</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libstdc++.so.6</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Unless stated otherwise, all symbols are in the <CODE
CLASS="VARNAME"
>std::</CODE
> namespace.</P
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBSTDCXX.1"
></A
>[CXXABI-1.86] <A
HREF="#STD.CXXABI"
>Itanium&#8482; C++ ABI</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBSTDCXX.2"
></A
>[ISOCXX] <A
HREF="#STD.ISOCXX"
>ISO/IEC 14882: 2003 C++ Language</A
></TD
></TR
><TR
><TD
><A
NAME="REFSTD.LIBSTDCXX.3"
></A
>[LSB] <A
HREF="#STD.LSB"
>This Specification</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN35799"
>16.1.1. C++ Runtime Support</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN35802"
>16.1.1.1. Interfaces for C++ Runtime Support</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for C++ Runtime Support specified in <A
HREF="#TBL-LIBSTDCXX-C-R-INTS"
>Table 16-2</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-C-R-INTS"
></A
><P
><B
>Table 16-2. libstdcxx - C++ Runtime Support Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::__atomic_add(int volatile*, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__exchange_and_add(int volatile*, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__verbose_terminate_handler()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>unexpected()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>set_terminate(void (*)())(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>set_unexpected(void (*)())(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>set_new_handler(void (*)())(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_bad_cast()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_bad_alloc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_bad_typeid()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>uncaught_exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_ios_failure(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_logic_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_range_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_domain_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_length_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_out_of_range(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_bad_exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_runtime_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_overflow_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_underflow_error(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__throw_invalid_argument(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>terminate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>operator delete[](void*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>operator delete[](void*, nothrow_t const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>operator delete(void*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>operator delete(void*, nothrow_t const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__cxa_allocate_exception(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_bad_cast(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_bad_typeid(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_begin_catch(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_call_unexpected(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_current_exception_type(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_demangle(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_end_catch(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_free_exception(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_get_exception_ptr(CXXABI_1.3.1) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_get_globals(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_get_globals_fast(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_guard_abort(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_guard_acquire(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_guard_release(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_pure_virtual(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_rethrow(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_throw(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_cctor(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_cleanup(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_ctor(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_delete(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_delete2(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_delete3(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_dtor(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_new(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_new2(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxa_vec_new3(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__dynamic_cast(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__gxx_personality_v0(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for C++ Runtime Support specified in <A
HREF="#TBL-LIBSTDCXX-C-R-DATA"
>Table 16-3</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-C-R-DATA"
></A
><P
><B
>Table 16-3. libstdcxx - C++ Runtime Support Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>cin(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>cerr(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>clog(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>cout(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>wcin(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>wcerr(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>wclog(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>wcout(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>nothrow(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN36146"
>16.1.2. C++ type descriptors for built-in types</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36149"
>16.1.2.1. Interfaces for C++ type descriptors for built-in types</A
></H4
><P
>No external methods are defined for libstdcxx - C++ type descriptors for built-in types
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for C++ type descriptors for built-in types specified in <A
HREF="#TBL-LIBSTDCXX-C-T-DATA"
>Table 16-4</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-C-T-DATA"
></A
><P
><B
>Table 16-4. libstdcxx - C++ type descriptors for built-in types Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for signed char const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for bool const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for char const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for double const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long double const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for float const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned char const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for int const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned int const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for short const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned short const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for void const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for wchar_t const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned long long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for signed char*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for bool*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for char*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for double*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long double*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for float*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned char*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for int*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned int*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for short*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned short*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for void*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for wchar_t*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned long long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for signed char(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for bool(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for char(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for double(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long double(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for float(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned char(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for int(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned int(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for short(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned short(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for void(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for wchar_t(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for long long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for unsigned long long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for signed char const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bool const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for char const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for double const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long double const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for float const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned char const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for int const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned int const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for short const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned short const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for void const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for wchar_t const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned long long const*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for signed char*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bool*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for char*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for double*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long double*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for float*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned char*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for int*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned int*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for short*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned short*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for void*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for wchar_t*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned long long*(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for signed char(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bool(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for char(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for double(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long double(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for float(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned char(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for int(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned int(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for short(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned short(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for void(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for wchar_t(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for long long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for unsigned long long(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN36668"
>16.1.3. C++ _Rb_tree</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36671"
>16.1.3.1. Interfaces for C++ _Rb_tree</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for C++ _Rb_tree specified in <A
HREF="#TBL-LIBSTDCXX-C-INTS"
>Table 16-5</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-C-INTS"
></A
><P
><B
>Table 16-5. libstdcxx - C++ _Rb_tree Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Rb_tree_decrement(_Rb_tree_node_base const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_decrement(_Rb_tree_node_base*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_increment(_Rb_tree_node_base const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_increment(_Rb_tree_node_base*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_black_count(_Rb_tree_node_base const*, _Rb_tree_node_base const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_rotate_left(_Rb_tree_node_base*, _Rb_tree_node_base*&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_rotate_right(_Rb_tree_node_base*, _Rb_tree_node_base*&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_rebalance_for_erase(_Rb_tree_node_base*, _Rb_tree_node_base&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Rb_tree_insert_and_rebalance(bool, _Rb_tree_node_base*, _Rb_tree_node_base*, _Rb_tree_node_base&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN36724"
>16.1.4. Class type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36727"
>16.1.4.1. Class data for type_info</A
></H4
><P
></P
><P
>The virtual table for the std::type_info class
is described by <A
HREF="#CLS-24325-0"
>Table 16-6</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24325-0"
></A
><P
><B
>Table 16-6. Primary vtable for type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>type_info::~type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>type_info::~type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::type_info  class
is described by <A
HREF="#RTTI-24030"
>Table 16-7</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24030"
></A
><P
><B
>Table 16-7. typeinfo for type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36793"
>16.1.4.2. Interfaces for Class type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASS-INTS"
>Table 16-8</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASS-INTS"
></A
><P
><B
>Table 16-8. libstdcxx - Class type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>type_info::__do_catch(type_info const*, void**, unsigned int) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>type_info::__is_pointer_p() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>type_info::__is_function_p() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>type_info::~type_info()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>type_info::~type_info()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>type_info::~type_info()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASS-DATA"
>Table 16-9</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASS-DATA"
></A
><P
><B
>Table 16-9. libstdcxx - Class type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for type_info(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for type_info(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for type_info(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN36857"
>16.1.5. Class __cxxabiv1::__enum_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36860"
>16.1.5.1. Class data for __cxxabiv1::__enum_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__enum_type_info class
is described by <A
HREF="#CLS-24328-0"
>Table 16-10</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24328-0"
></A
><P
><B
>Table 16-10. Primary vtable for __cxxabiv1::__enum_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__enum_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__enum_type_info::~__enum_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__enum_type_info::~__enum_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__enum_type_info  class
is described by <A
HREF="#RTTI-24099"
>Table 16-11</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24099"
></A
><P
><B
>Table 16-11. typeinfo for __cxxabiv1::__enum_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__enum_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36926"
>16.1.5.2. Interfaces for Class __cxxabiv1::__enum_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__enum_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLAST-INTS"
>Table 16-12</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAST-INTS"
></A
><P
><B
>Table 16-12. libstdcxx - Class __cxxabiv1::__enum_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__enum_type_info::~__enum_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__enum_type_info::~__enum_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__enum_type_info::~__enum_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__enum_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLAST-DATA"
>Table 16-13</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAST-DATA"
></A
><P
><B
>Table 16-13. libstdcxx - Class __cxxabiv1::__enum_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__enum_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__enum_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__enum_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN36970"
>16.1.6. Class __cxxabiv1::__array_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN36973"
>16.1.6.1. Class data for __cxxabiv1::__array_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__array_type_info class
is described by <A
HREF="#CLS-24330-0"
>Table 16-14</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24330-0"
></A
><P
><B
>Table 16-14. Primary vtable for __cxxabiv1::__array_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__array_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__array_type_info::~__array_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__array_type_info::~__array_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__array_type_info  class
is described by <A
HREF="#RTTI-24101"
>Table 16-15</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24101"
></A
><P
><B
>Table 16-15. typeinfo for __cxxabiv1::__array_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__array_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37039"
>16.1.6.2. Interfaces for Class __cxxabiv1::__array_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__array_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASU-INTS"
>Table 16-16</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASU-INTS"
></A
><P
><B
>Table 16-16. libstdcxx - Class __cxxabiv1::__array_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__array_type_info::~__array_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__array_type_info::~__array_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__array_type_info::~__array_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__array_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASU-DATA"
>Table 16-17</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASU-DATA"
></A
><P
><B
>Table 16-17. libstdcxx - Class __cxxabiv1::__array_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__array_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__array_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__array_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37083"
>16.1.7. Class __cxxabiv1::__class_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37086"
>16.1.7.1. Class data for __cxxabiv1::__class_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__class_type_info class
is described by <A
HREF="#CLS-23981-0"
>Table 16-18</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-23981-0"
></A
><P
><B
>Table 16-18. Primary vtable for __cxxabiv1::__class_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__class_type_info::~__class_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__class_type_info::~__class_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__upcast_result&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__class_type_info  class
is described by <A
HREF="#RTTI-24031"
>Table 16-19</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24031"
></A
><P
><B
>Table 16-19. typeinfo for __cxxabiv1::__class_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__class_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37157"
>16.1.7.2. Interfaces for Class __cxxabiv1::__class_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__class_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASV-INTS"
>Table 16-20</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASV-INTS"
></A
><P
><B
>Table 16-20. libstdcxx - Class __cxxabiv1::__class_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__class_type_info::~__class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__class_type_info::~__class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__class_type_info::~__class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__class_type_info::__do_catch(type_info const*, void**, unsigned int) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__upcast_result&#38;) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__class_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASV-DATA"
>Table 16-21</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASV-DATA"
></A
><P
><B
>Table 16-21. libstdcxx - Class __cxxabiv1::__class_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37216"
>16.1.8. Class __cxxabiv1::__pbase_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37219"
>16.1.8.1. Class data for __cxxabiv1::__pbase_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__pbase_type_info class
is described by <A
HREF="#CLS-24327-0"
>Table 16-22</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24327-0"
></A
><P
><B
>Table 16-22. Primary vtable for __cxxabiv1::__pbase_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__pbase_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__pbase_type_info::~__pbase_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__pbase_type_info::~__pbase_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxxabiv1::__pbase_type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxxabiv1::__pbase_type_info::__pointer_catch(__cxxabiv1::__pbase_type_info const*, void**, unsigned int) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__pbase_type_info  class
is described by <A
HREF="#RTTI-24032"
>Table 16-23</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24032"
></A
><P
><B
>Table 16-23. typeinfo for __cxxabiv1::__pbase_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__pbase_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37290"
>16.1.8.2. Interfaces for Class __cxxabiv1::__pbase_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__pbase_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASW-INTS"
>Table 16-24</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASW-INTS"
></A
><P
><B
>Table 16-24. libstdcxx - Class __cxxabiv1::__pbase_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__pbase_type_info::~__pbase_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pbase_type_info::~__pbase_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pbase_type_info::~__pbase_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pbase_type_info::__do_catch(type_info const*, void**, unsigned int) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pbase_type_info::__pointer_catch(__cxxabiv1::__pbase_type_info const*, void**, unsigned int) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__pbase_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASW-DATA"
>Table 16-25</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASW-DATA"
></A
><P
><B
>Table 16-25. libstdcxx - Class __cxxabiv1::__pbase_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__pbase_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__pbase_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__pbase_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37344"
>16.1.9. Class __cxxabiv1::__pointer_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37347"
>16.1.9.1. Class data for __cxxabiv1::__pointer_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__pointer_type_info class
is described by <A
HREF="#CLS-23983-0"
>Table 16-26</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-23983-0"
></A
><P
><B
>Table 16-26. Primary vtable for __cxxabiv1::__pointer_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__pointer_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__pointer_type_info::~__pointer_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__pointer_type_info::~__pointer_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>__cxxabiv1::__pointer_type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxxabiv1::__pbase_type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxxabiv1::__pointer_type_info::__pointer_catch(__cxxabiv1::__pbase_type_info const*, void**, unsigned int) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__pointer_type_info  class
is described by <A
HREF="#RTTI-24098"
>Table 16-27</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24098"
></A
><P
><B
>Table 16-27. typeinfo for __cxxabiv1::__pointer_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__pointer_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37418"
>16.1.9.2. Interfaces for Class __cxxabiv1::__pointer_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__pointer_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASX-INTS"
>Table 16-28</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASX-INTS"
></A
><P
><B
>Table 16-28. libstdcxx - Class __cxxabiv1::__pointer_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__pointer_type_info::~__pointer_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_type_info::~__pointer_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_type_info::~__pointer_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_type_info::__is_pointer_p() const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_type_info::__pointer_catch(__cxxabiv1::__pbase_type_info const*, void**, unsigned int) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__pointer_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASX-DATA"
>Table 16-29</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASX-DATA"
></A
><P
><B
>Table 16-29. libstdcxx - Class __cxxabiv1::__pointer_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__pointer_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__pointer_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__pointer_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37472"
>16.1.10. Class __cxxabiv1::__function_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37475"
>16.1.10.1. Class data for __cxxabiv1::__function_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__function_type_info class
is described by <A
HREF="#CLS-24329-0"
>Table 16-30</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24329-0"
></A
><P
><B
>Table 16-30. Primary vtable for __cxxabiv1::__function_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__function_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__function_type_info::~__function_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__function_type_info::~__function_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>__cxxabiv1::__function_type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__function_type_info  class
is described by <A
HREF="#RTTI-24100"
>Table 16-31</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24100"
></A
><P
><B
>Table 16-31. typeinfo for __cxxabiv1::__function_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__function_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37541"
>16.1.10.2. Interfaces for Class __cxxabiv1::__function_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__function_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASY-INTS"
>Table 16-32</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASY-INTS"
></A
><P
><B
>Table 16-32. libstdcxx - Class __cxxabiv1::__function_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__function_type_info::~__function_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__function_type_info::~__function_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__function_type_info::~__function_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__function_type_info::__is_function_p() const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__function_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASY-DATA"
>Table 16-33</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASY-DATA"
></A
><P
><B
>Table 16-33. libstdcxx - Class __cxxabiv1::__function_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__function_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__function_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__function_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37590"
>16.1.11. Class __cxxabiv1::__si_class_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37593"
>16.1.11.1. Class data for __cxxabiv1::__si_class_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__si_class_type_info class
is described by <A
HREF="#CLS-23979-0"
>Table 16-34</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-23979-0"
></A
><P
><B
>Table 16-34. Primary vtable for __cxxabiv1::__si_class_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__si_class_type_info::~__si_class_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__si_class_type_info::~__si_class_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxxabiv1::__si_class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__upcast_result&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__si_class_type_info  class
is described by <A
HREF="#RTTI-24094"
>Table 16-35</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24094"
></A
><P
><B
>Table 16-35. typeinfo for __cxxabiv1::__si_class_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__si_class_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37664"
>16.1.11.2. Interfaces for Class __cxxabiv1::__si_class_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__si_class_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASZ-INTS"
>Table 16-36</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASZ-INTS"
></A
><P
><B
>Table 16-36. libstdcxx - Class __cxxabiv1::__si_class_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__si_class_type_info::~__si_class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__si_class_type_info::~__si_class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__si_class_type_info::~__si_class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__si_class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__upcast_result&#38;) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__si_class_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLASZ-DATA"
>Table 16-37</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLASZ-DATA"
></A
><P
><B
>Table 16-37. libstdcxx - Class __cxxabiv1::__si_class_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__si_class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__si_class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__si_class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37713"
>16.1.12. Class __cxxabiv1::__vmi_class_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37716"
>16.1.12.1. Class data for __cxxabiv1::__vmi_class_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__vmi_class_type_info class
is described by <A
HREF="#CLS-23980-0"
>Table 16-38</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-23980-0"
></A
><P
><B
>Table 16-38. Primary vtable for __cxxabiv1::__vmi_class_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__vmi_class_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxxabiv1::__class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxxabiv1::__vmi_class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__upcast_result&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__vmi_class_type_info  class
is described by <A
HREF="#RTTI-24093"
>Table 16-39</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24093"
></A
><P
><B
>Table 16-39. typeinfo for __cxxabiv1::__vmi_class_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__vmi_class_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37787"
>16.1.12.2. Interfaces for Class __cxxabiv1::__vmi_class_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__vmi_class_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLATA-INTS"
>Table 16-40</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATA-INTS"
></A
><P
><B
>Table 16-40. libstdcxx - Class __cxxabiv1::__vmi_class_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__vmi_class_type_info::~__vmi_class_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__vmi_class_type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__upcast_result&#38;) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__vmi_class_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLATA-DATA"
>Table 16-41</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATA-DATA"
></A
><P
><B
>Table 16-41. libstdcxx - Class __cxxabiv1::__vmi_class_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__vmi_class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__vmi_class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__vmi_class_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37836"
>16.1.13. Class __cxxabiv1::__fundamental_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37839"
>16.1.13.1. Class data for __cxxabiv1::__fundamental_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__fundamental_type_info class
is described by <A
HREF="#CLS-23982-0"
>Table 16-42</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-23982-0"
></A
><P
><B
>Table 16-42. Primary vtable for __cxxabiv1::__fundamental_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__fundamental_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__fundamental_type_info::~__fundamental_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__fundamental_type_info::~__fundamental_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__fundamental_type_info  class
is described by <A
HREF="#RTTI-24102"
>Table 16-43</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24102"
></A
><P
><B
>Table 16-43. typeinfo for __cxxabiv1::__fundamental_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__fundamental_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37905"
>16.1.13.2. Interfaces for Class __cxxabiv1::__fundamental_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__fundamental_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLATB-INTS"
>Table 16-44</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATB-INTS"
></A
><P
><B
>Table 16-44. libstdcxx - Class __cxxabiv1::__fundamental_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__fundamental_type_info::~__fundamental_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__fundamental_type_info::~__fundamental_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__fundamental_type_info::~__fundamental_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__fundamental_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLATB-DATA"
>Table 16-45</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATB-DATA"
></A
><P
><B
>Table 16-45. libstdcxx - Class __cxxabiv1::__fundamental_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__fundamental_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__fundamental_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__fundamental_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN37949"
>16.1.14. Class __cxxabiv1::__pointer_to_member_type_info</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN37952"
>16.1.14.1. Class data for __cxxabiv1::__pointer_to_member_type_info</A
></H4
><P
></P
><P
>The virtual table for the __cxxabiv1::__pointer_to_member_type_info class
is described by <A
HREF="#CLS-24326-0"
>Table 16-46</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24326-0"
></A
><P
><B
>Table 16-46. Primary vtable for __cxxabiv1::__pointer_to_member_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __cxxabiv1::__pointer_to_member_type_info</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__cxxabiv1::__pointer_to_member_type_info::~__pointer_to_member_type_info()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__cxxabiv1::__pointer_to_member_type_info::~__pointer_to_member_type_info()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>type_info::__is_pointer_p() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>type_info::__is_function_p() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxxabiv1::__pbase_type_info::__do_catch(type_info const*, void**, unsigned int) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>type_info::__do_upcast(__cxxabiv1::__class_type_info const*, void**) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxxabiv1::__pointer_to_member_type_info::__pointer_catch(__cxxabiv1::__pbase_type_info const*, void**, unsigned int) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the __cxxabiv1::__pointer_to_member_type_info  class
is described by <A
HREF="#RTTI-24097"
>Table 16-47</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24097"
></A
><P
><B
>Table 16-47. typeinfo for __cxxabiv1::__pointer_to_member_type_info</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __cxxabiv1::__pointer_to_member_type_info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38023"
>16.1.14.2. Interfaces for Class __cxxabiv1::__pointer_to_member_type_info</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __cxxabiv1::__pointer_to_member_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLATC-INTS"
>Table 16-48</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATC-INTS"
></A
><P
><B
>Table 16-48. libstdcxx - Class __cxxabiv1::__pointer_to_member_type_info Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__cxxabiv1::__pointer_to_member_type_info::~__pointer_to_member_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_to_member_type_info::~__pointer_to_member_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_to_member_type_info::~__pointer_to_member_type_info()(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__cxxabiv1::__pointer_to_member_type_info::__pointer_catch(__cxxabiv1::__pbase_type_info const*, void**, unsigned int) const(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __cxxabiv1::__pointer_to_member_type_info specified in <A
HREF="#TBL-LIBSTDCXX-CLATC-DATA"
>Table 16-49</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATC-DATA"
></A
><P
><B
>Table 16-49. libstdcxx - Class __cxxabiv1::__pointer_to_member_type_info Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __cxxabiv1::__pointer_to_member_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __cxxabiv1::__pointer_to_member_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __cxxabiv1::__pointer_to_member_type_info(CXXABI_1.3) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38072"
>16.1.15. Class __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38075"
>16.1.15.1. Interfaces for Class __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>No external methods are defined for libstdcxx - Class __gnu_cxx::stdio_filebuf&#60;char, std::char_traits&#60;char&#62; &#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __gnu_cxx::stdio_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATD-DATA"
>Table 16-50</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATD-DATA"
></A
><P
><B
>Table 16-50. libstdcxx - Class __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __gnu_cxx::stdio_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38094"
>16.1.16. Class __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38097"
>16.1.16.1. Interfaces for Class __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>No external methods are defined for libstdcxx - Class __gnu_cxx::stdio_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __gnu_cxx::stdio_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATE-DATA"
>Table 16-51</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATE-DATA"
></A
><P
><B
>Table 16-51. libstdcxx - Class __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __gnu_cxx::stdio_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38116"
>16.1.17. Class __gnu_cxx::__pool_alloc_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38119"
>16.1.17.1. Interfaces for Class __gnu_cxx::__pool_alloc_base</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __gnu_cxx::__pool_alloc_base specified in <A
HREF="#TBL-LIBSTDCXX-CLATF-INTS"
>Table 16-52</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATF-INTS"
></A
><P
><B
>Table 16-52. libstdcxx - Class __gnu_cxx::__pool_alloc_base Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::__pool_alloc_base::_M_get_mutex()(GLIBCXX_3.4.2) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38132"
>16.1.18. Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38135"
>16.1.18.1. Class data for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the __gnu_cxx::stdio_sync_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; class
is described by <A
HREF="#CLS-29351-0"
>Table 16-53</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-29351-0"
></A
><P
><B
>Table 16-53. Primary vtable for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~stdio_sync_filebuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~stdio_sync_filebuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::pbackfail(int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::overflow(int)</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38217"
>16.1.18.2. Interfaces for Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __gnu_cxx::stdio_sync_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATG-INTS"
>Table 16-54</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATG-INTS"
></A
><P
><B
>Table 16-54. libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;::file()(GLIBCXX_3.4.2) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __gnu_cxx::stdio_sync_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATG-DATA"
>Table 16-55</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATG-DATA"
></A
><P
><B
>Table 16-55. libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __gnu_cxx::stdio_sync_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38251"
>16.1.19. Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38254"
>16.1.19.1. Class data for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described by <A
HREF="#CLS-29211-0"
>Table 16-56</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-29211-0"
></A
><P
><B
>Table 16-56. Primary vtable for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~stdio_sync_filebuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~stdio_sync_filebuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::overflow(unsigned int)</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38336"
>16.1.19.2. Interfaces for Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATH-INTS"
>Table 16-57</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATH-INTS"
></A
><P
><B
>Table 16-57. libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::file()(GLIBCXX_3.4.2) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATH-DATA"
>Table 16-58</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATH-DATA"
></A
><P
><B
>Table 16-58. libstdcxx - Class __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __gnu_cxx::stdio_sync_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38370"
>16.1.20. Class exception</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38373"
>16.1.20.1. Class data for exception</A
></H4
><P
></P
><P
>The virtual table for the std::exception class
is described by <A
HREF="#CLS-24321-0"
>Table 16-59</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24321-0"
></A
><P
><B
>Table 16-59. Primary vtable for exception</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for exception</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>exception::~exception()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>exception::~exception()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>exception::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::exception  class
is described by <A
HREF="#RTTI-24002"
>Table 16-60</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24002"
></A
><P
><B
>Table 16-60. typeinfo for exception</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for exception</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38424"
>16.1.20.2. Interfaces for Class exception</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::exception specified in <A
HREF="#TBL-LIBSTDCXX-CLATI-INTS"
>Table 16-61</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATI-INTS"
></A
><P
><B
>Table 16-61. libstdcxx - Class exception Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>exception::what() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>exception::~exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>exception::~exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>exception::~exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::exception specified in <A
HREF="#TBL-LIBSTDCXX-CLATI-DATA"
>Table 16-62</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATI-DATA"
></A
><P
><B
>Table 16-62. libstdcxx - Class exception Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for exception(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for exception(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for exception(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38473"
>16.1.21. Class bad_typeid</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38476"
>16.1.21.1. Class data for bad_typeid</A
></H4
><P
></P
><P
>The virtual table for the std::bad_typeid class
is described by <A
HREF="#CLS-24323-0"
>Table 16-63</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24323-0"
></A
><P
><B
>Table 16-63. Primary vtable for bad_typeid</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for bad_typeid</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>bad_typeid::~bad_typeid()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>bad_typeid::~bad_typeid()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>exception::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::bad_typeid  class
is described by <A
HREF="#RTTI-24095"
>Table 16-64</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24095"
></A
><P
><B
>Table 16-64. typeinfo for bad_typeid</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for bad_typeid</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38527"
>16.1.21.2. Interfaces for Class bad_typeid</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::bad_typeid specified in <A
HREF="#TBL-LIBSTDCXX-CLATJ-INTS"
>Table 16-65</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATJ-INTS"
></A
><P
><B
>Table 16-65. libstdcxx - Class bad_typeid Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>bad_typeid::~bad_typeid()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_typeid::~bad_typeid()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_typeid::~bad_typeid()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::bad_typeid specified in <A
HREF="#TBL-LIBSTDCXX-CLATJ-DATA"
>Table 16-66</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATJ-DATA"
></A
><P
><B
>Table 16-66. libstdcxx - Class bad_typeid Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for bad_typeid(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bad_typeid(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for bad_typeid(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38571"
>16.1.22. Class logic_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38574"
>16.1.22.1. Class data for logic_error</A
></H4
><P
></P
><P
>The virtual table for the std::logic_error class
is described by <A
HREF="#CLS-24313-0"
>Table 16-67</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24313-0"
></A
><P
><B
>Table 16-67. Primary vtable for logic_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for logic_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>logic_error::~logic_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>logic_error::~logic_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>logic_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::logic_error  class
is described by <A
HREF="#RTTI-23998"
>Table 16-68</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-23998"
></A
><P
><B
>Table 16-68. typeinfo for logic_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for logic_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38625"
>16.1.22.2. Interfaces for Class logic_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::logic_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATK-INTS"
>Table 16-69</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATK-INTS"
></A
><P
><B
>Table 16-69. libstdcxx - Class logic_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>logic_error::what() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>logic_error::logic_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>logic_error::logic_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>logic_error::~logic_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>logic_error::~logic_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>logic_error::~logic_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::logic_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATK-DATA"
>Table 16-70</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATK-DATA"
></A
><P
><B
>Table 16-70. libstdcxx - Class logic_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for logic_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for logic_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for logic_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38684"
>16.1.23. Class range_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38687"
>16.1.23.1. Class data for range_error</A
></H4
><P
></P
><P
>The virtual table for the std::range_error class
is described by <A
HREF="#CLS-24243-0"
>Table 16-71</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24243-0"
></A
><P
><B
>Table 16-71. Primary vtable for range_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for range_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>range_error::~range_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>range_error::~range_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>runtime_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::range_error  class
is described by <A
HREF="#RTTI-24054"
>Table 16-72</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24054"
></A
><P
><B
>Table 16-72. typeinfo for range_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for range_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38738"
>16.1.23.2. Interfaces for Class range_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::range_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATL-INTS"
>Table 16-73</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATL-INTS"
></A
><P
><B
>Table 16-73. libstdcxx - Class range_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>range_error::range_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>range_error::range_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>range_error::~range_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>range_error::~range_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::range_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATL-DATA"
>Table 16-74</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATL-DATA"
></A
><P
><B
>Table 16-74. libstdcxx - Class range_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for range_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for range_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for range_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38787"
>16.1.24. Class domain_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38790"
>16.1.24.1. Class data for domain_error</A
></H4
><P
></P
><P
>The virtual table for the std::domain_error class
is described by <A
HREF="#CLS-24247-0"
>Table 16-75</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24247-0"
></A
><P
><B
>Table 16-75. Primary vtable for domain_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for domain_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>domain_error::~domain_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>domain_error::~domain_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>logic_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::domain_error  class
is described by <A
HREF="#RTTI-24058"
>Table 16-76</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24058"
></A
><P
><B
>Table 16-76. typeinfo for domain_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for domain_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38841"
>16.1.24.2. Interfaces for Class domain_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::domain_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATM-INTS"
>Table 16-77</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATM-INTS"
></A
><P
><B
>Table 16-77. libstdcxx - Class domain_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>domain_error::domain_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>domain_error::domain_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>domain_error::~domain_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>domain_error::~domain_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::domain_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATM-DATA"
>Table 16-78</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATM-DATA"
></A
><P
><B
>Table 16-78. libstdcxx - Class domain_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for domain_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for domain_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for domain_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38890"
>16.1.25. Class length_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38893"
>16.1.25.1. Class data for length_error</A
></H4
><P
></P
><P
>The virtual table for the std::length_error class
is described by <A
HREF="#CLS-24245-0"
>Table 16-79</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24245-0"
></A
><P
><B
>Table 16-79. Primary vtable for length_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for length_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>length_error::~length_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>length_error::~length_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>logic_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::length_error  class
is described by <A
HREF="#RTTI-24056"
>Table 16-80</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24056"
></A
><P
><B
>Table 16-80. typeinfo for length_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for length_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38944"
>16.1.25.2. Interfaces for Class length_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::length_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATN-INTS"
>Table 16-81</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATN-INTS"
></A
><P
><B
>Table 16-81. libstdcxx - Class length_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>length_error::length_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>length_error::length_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>length_error::~length_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>length_error::~length_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::length_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATN-DATA"
>Table 16-82</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATN-DATA"
></A
><P
><B
>Table 16-82. libstdcxx - Class length_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for length_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for length_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for length_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN38993"
>16.1.26. Class out_of_range</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN38996"
>16.1.26.1. Class data for out_of_range</A
></H4
><P
></P
><P
>The virtual table for the std::out_of_range class
is described by <A
HREF="#CLS-24244-0"
>Table 16-83</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24244-0"
></A
><P
><B
>Table 16-83. Primary vtable for out_of_range</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for out_of_range</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>out_of_range::~out_of_range()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>out_of_range::~out_of_range()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>logic_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::out_of_range  class
is described by <A
HREF="#RTTI-24055"
>Table 16-84</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24055"
></A
><P
><B
>Table 16-84. typeinfo for out_of_range</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for out_of_range</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39047"
>16.1.26.2. Interfaces for Class out_of_range</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::out_of_range specified in <A
HREF="#TBL-LIBSTDCXX-CLATO-INTS"
>Table 16-85</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATO-INTS"
></A
><P
><B
>Table 16-85. libstdcxx - Class out_of_range Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>out_of_range::out_of_range(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>out_of_range::out_of_range(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>out_of_range::~out_of_range()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>out_of_range::~out_of_range()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::out_of_range specified in <A
HREF="#TBL-LIBSTDCXX-CLATO-DATA"
>Table 16-86</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATO-DATA"
></A
><P
><B
>Table 16-86. libstdcxx - Class out_of_range Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for out_of_range(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for out_of_range(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for out_of_range(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39096"
>16.1.27. Class bad_exception</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39099"
>16.1.27.1. Class data for bad_exception</A
></H4
><P
></P
><P
>The virtual table for the std::bad_exception class
is described by <A
HREF="#CLS-24320-0"
>Table 16-87</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24320-0"
></A
><P
><B
>Table 16-87. Primary vtable for bad_exception</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for bad_exception</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>bad_exception::~bad_exception()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>bad_exception::~bad_exception()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>exception::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::bad_exception  class
is described by <A
HREF="#RTTI-24091"
>Table 16-88</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24091"
></A
><P
><B
>Table 16-88. typeinfo for bad_exception</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for bad_exception</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39150"
>16.1.27.2. Interfaces for Class bad_exception</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::bad_exception specified in <A
HREF="#TBL-LIBSTDCXX-CLATP-INTS"
>Table 16-89</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATP-INTS"
></A
><P
><B
>Table 16-89. libstdcxx - Class bad_exception Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>bad_exception::~bad_exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_exception::~bad_exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_exception::~bad_exception()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::bad_exception specified in <A
HREF="#TBL-LIBSTDCXX-CLATP-DATA"
>Table 16-90</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATP-DATA"
></A
><P
><B
>Table 16-90. libstdcxx - Class bad_exception Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for bad_exception(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bad_exception(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for bad_exception(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39194"
>16.1.28. Class runtime_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39197"
>16.1.28.1. Class data for runtime_error</A
></H4
><P
></P
><P
>The virtual table for the std::runtime_error class
is described by <A
HREF="#CLS-24312-0"
>Table 16-91</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24312-0"
></A
><P
><B
>Table 16-91. Primary vtable for runtime_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for runtime_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>runtime_error::~runtime_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>runtime_error::~runtime_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>runtime_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::runtime_error  class
is described by <A
HREF="#RTTI-23999"
>Table 16-92</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-23999"
></A
><P
><B
>Table 16-92. typeinfo for runtime_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for runtime_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39248"
>16.1.28.2. Interfaces for Class runtime_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::runtime_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATQ-INTS"
>Table 16-93</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATQ-INTS"
></A
><P
><B
>Table 16-93. libstdcxx - Class runtime_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>runtime_error::what() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>runtime_error::runtime_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>runtime_error::runtime_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>runtime_error::~runtime_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>runtime_error::~runtime_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>runtime_error::~runtime_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::runtime_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATQ-DATA"
>Table 16-94</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATQ-DATA"
></A
><P
><B
>Table 16-94. libstdcxx - Class runtime_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for runtime_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for runtime_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for runtime_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39307"
>16.1.29. Class overflow_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39310"
>16.1.29.1. Class data for overflow_error</A
></H4
><P
></P
><P
>The virtual table for the std::overflow_error class
is described by <A
HREF="#CLS-24242-0"
>Table 16-95</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24242-0"
></A
><P
><B
>Table 16-95. Primary vtable for overflow_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for overflow_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>overflow_error::~overflow_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>overflow_error::~overflow_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>runtime_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::overflow_error  class
is described by <A
HREF="#RTTI-24053"
>Table 16-96</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24053"
></A
><P
><B
>Table 16-96. typeinfo for overflow_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for overflow_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39361"
>16.1.29.2. Interfaces for Class overflow_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::overflow_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATR-INTS"
>Table 16-97</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATR-INTS"
></A
><P
><B
>Table 16-97. libstdcxx - Class overflow_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>overflow_error::overflow_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>overflow_error::overflow_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>overflow_error::~overflow_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>overflow_error::~overflow_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::overflow_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATR-DATA"
>Table 16-98</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATR-DATA"
></A
><P
><B
>Table 16-98. libstdcxx - Class overflow_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for overflow_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for overflow_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for overflow_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39410"
>16.1.30. Class underflow_error</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39413"
>16.1.30.1. Class data for underflow_error</A
></H4
><P
></P
><P
>The virtual table for the std::underflow_error class
is described by <A
HREF="#CLS-24241-0"
>Table 16-99</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24241-0"
></A
><P
><B
>Table 16-99. Primary vtable for underflow_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for underflow_error</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>underflow_error::~underflow_error()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>underflow_error::~underflow_error()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>runtime_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::underflow_error  class
is described by <A
HREF="#RTTI-24052"
>Table 16-100</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24052"
></A
><P
><B
>Table 16-100. typeinfo for underflow_error</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for underflow_error</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39464"
>16.1.30.2. Interfaces for Class underflow_error</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::underflow_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATS-INTS"
>Table 16-101</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATS-INTS"
></A
><P
><B
>Table 16-101. libstdcxx - Class underflow_error Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>underflow_error::underflow_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>underflow_error::underflow_error(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>underflow_error::~underflow_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>underflow_error::~underflow_error()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::underflow_error specified in <A
HREF="#TBL-LIBSTDCXX-CLATS-DATA"
>Table 16-102</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATS-DATA"
></A
><P
><B
>Table 16-102. libstdcxx - Class underflow_error Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for underflow_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for underflow_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for underflow_error(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39513"
>16.1.31. Class invalid_argument</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39516"
>16.1.31.1. Class data for invalid_argument</A
></H4
><P
></P
><P
>The virtual table for the std::invalid_argument class
is described by <A
HREF="#CLS-24246-0"
>Table 16-103</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24246-0"
></A
><P
><B
>Table 16-103. Primary vtable for invalid_argument</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for invalid_argument</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>invalid_argument::~invalid_argument()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>invalid_argument::~invalid_argument()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>logic_error::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::invalid_argument  class
is described by <A
HREF="#RTTI-24057"
>Table 16-104</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24057"
></A
><P
><B
>Table 16-104. typeinfo for invalid_argument</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for invalid_argument</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39567"
>16.1.31.2. Interfaces for Class invalid_argument</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::invalid_argument specified in <A
HREF="#TBL-LIBSTDCXX-CLATT-INTS"
>Table 16-105</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATT-INTS"
></A
><P
><B
>Table 16-105. libstdcxx - Class invalid_argument Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>invalid_argument::invalid_argument(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>invalid_argument::invalid_argument(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>invalid_argument::~invalid_argument()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>invalid_argument::~invalid_argument()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::invalid_argument specified in <A
HREF="#TBL-LIBSTDCXX-CLATT-DATA"
>Table 16-106</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATT-DATA"
></A
><P
><B
>Table 16-106. libstdcxx - Class invalid_argument Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for invalid_argument(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for invalid_argument(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for invalid_argument(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39616"
>16.1.32. Class bad_cast</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39619"
>16.1.32.1. Class data for bad_cast</A
></H4
><P
></P
><P
>The virtual table for the std::bad_cast class
is described by <A
HREF="#CLS-24324-0"
>Table 16-107</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24324-0"
></A
><P
><B
>Table 16-107. Primary vtable for bad_cast</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for bad_cast</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>bad_cast::~bad_cast()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>bad_cast::~bad_cast()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>exception::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::bad_cast  class
is described by <A
HREF="#RTTI-24096"
>Table 16-108</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24096"
></A
><P
><B
>Table 16-108. typeinfo for bad_cast</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for bad_cast</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39670"
>16.1.32.2. Interfaces for Class bad_cast</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::bad_cast specified in <A
HREF="#TBL-LIBSTDCXX-CLATU-INTS"
>Table 16-109</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATU-INTS"
></A
><P
><B
>Table 16-109. libstdcxx - Class bad_cast Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>bad_cast::~bad_cast()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_cast::~bad_cast()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_cast::~bad_cast()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::bad_cast specified in <A
HREF="#TBL-LIBSTDCXX-CLATU-DATA"
>Table 16-110</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATU-DATA"
></A
><P
><B
>Table 16-110. libstdcxx - Class bad_cast Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for bad_cast(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bad_cast(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for bad_cast(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39714"
>16.1.33. Class bad_alloc</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39717"
>16.1.33.1. Class data for bad_alloc</A
></H4
><P
></P
><P
>The virtual table for the std::bad_alloc class
is described by <A
HREF="#CLS-24322-0"
>Table 16-111</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24322-0"
></A
><P
><B
>Table 16-111. Primary vtable for bad_alloc</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for bad_alloc</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>bad_alloc::~bad_alloc()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>bad_alloc::~bad_alloc()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>exception::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::bad_alloc  class
is described by <A
HREF="#RTTI-24092"
>Table 16-112</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24092"
></A
><P
><B
>Table 16-112. typeinfo for bad_alloc</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for bad_alloc</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39768"
>16.1.33.2. Interfaces for Class bad_alloc</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::bad_alloc specified in <A
HREF="#TBL-LIBSTDCXX-CLATV-INTS"
>Table 16-113</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATV-INTS"
></A
><P
><B
>Table 16-113. libstdcxx - Class bad_alloc Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>bad_alloc::~bad_alloc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_alloc::~bad_alloc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bad_alloc::~bad_alloc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::bad_alloc specified in <A
HREF="#TBL-LIBSTDCXX-CLATV-DATA"
>Table 16-114</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATV-DATA"
></A
><P
><B
>Table 16-114. libstdcxx - Class bad_alloc Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for bad_alloc(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for bad_alloc(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for bad_alloc(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39812"
>16.1.34. struct __numeric_limits_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39815"
>16.1.34.1. Interfaces for struct __numeric_limits_base</A
></H4
><P
>No external methods are defined for libstdcxx - struct __numeric_limits_base
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct __numeric_limits_base specified in <A
HREF="#TBL-LIBSTDCXX-STRUC-DATA"
>Table 16-115</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUC-DATA"
></A
><P
><B
>Table 16-115. libstdcxx - struct __numeric_limits_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__numeric_limits_base::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__numeric_limits_base::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN39934"
>16.1.35. struct numeric_limits&#60;long double&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN39937"
>16.1.35.1. Interfaces for struct numeric_limits&#60;long double&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;long double&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;long double&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUD-DATA"
>Table 16-116</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUD-DATA"
></A
><P
><B
>Table 16-116. libstdcxx - struct numeric_limits&#60;long double&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;long double&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long double&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40056"
>16.1.36. struct numeric_limits&#60;long long&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40059"
>16.1.36.1. Interfaces for struct numeric_limits&#60;long long&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;long long&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;long long&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUE-DATA"
>Table 16-117</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUE-DATA"
></A
><P
><B
>Table 16-117. libstdcxx - struct numeric_limits&#60;long long&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;long long&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long long&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40178"
>16.1.37. struct numeric_limits&#60;unsigned long long&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40181"
>16.1.37.1. Interfaces for struct numeric_limits&#60;unsigned long long&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;unsigned long long&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;unsigned long long&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUF-DATA"
>Table 16-118</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUF-DATA"
></A
><P
><B
>Table 16-118. libstdcxx - struct numeric_limits&#60;unsigned long long&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long long&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40300"
>16.1.38. struct numeric_limits&#60;float&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40303"
>16.1.38.1. Interfaces for struct numeric_limits&#60;float&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;float&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;float&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUG-DATA"
>Table 16-119</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUG-DATA"
></A
><P
><B
>Table 16-119. libstdcxx - struct numeric_limits&#60;float&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;float&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;float&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40422"
>16.1.39. struct numeric_limits&#60;double&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40425"
>16.1.39.1. Interfaces for struct numeric_limits&#60;double&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;double&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;double&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUH-DATA"
>Table 16-120</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUH-DATA"
></A
><P
><B
>Table 16-120. libstdcxx - struct numeric_limits&#60;double&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;double&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;double&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40544"
>16.1.40. struct numeric_limits&#60;short&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40547"
>16.1.40.1. Interfaces for struct numeric_limits&#60;short&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;short&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;short&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUI-DATA"
>Table 16-121</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUI-DATA"
></A
><P
><B
>Table 16-121. libstdcxx - struct numeric_limits&#60;short&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;short&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;short&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40666"
>16.1.41. struct numeric_limits&#60;unsigned short&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40669"
>16.1.41.1. Interfaces for struct numeric_limits&#60;unsigned short&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;unsigned short&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;unsigned short&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUJ-DATA"
>Table 16-122</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUJ-DATA"
></A
><P
><B
>Table 16-122. libstdcxx - struct numeric_limits&#60;unsigned short&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned short&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40788"
>16.1.42. struct numeric_limits&#60;int&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40791"
>16.1.42.1. Interfaces for struct numeric_limits&#60;int&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;int&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;int&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUK-DATA"
>Table 16-123</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUK-DATA"
></A
><P
><B
>Table 16-123. libstdcxx - struct numeric_limits&#60;int&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;int&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;int&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN40910"
>16.1.43. struct numeric_limits&#60;unsigned int&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN40913"
>16.1.43.1. Interfaces for struct numeric_limits&#60;unsigned int&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;unsigned int&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;unsigned int&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUL-DATA"
>Table 16-124</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUL-DATA"
></A
><P
><B
>Table 16-124. libstdcxx - struct numeric_limits&#60;unsigned int&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned int&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41032"
>16.1.44. struct numeric_limits&#60;long&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41035"
>16.1.44.1. Interfaces for struct numeric_limits&#60;long&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;long&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;long&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUM-DATA"
>Table 16-125</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUM-DATA"
></A
><P
><B
>Table 16-125. libstdcxx - struct numeric_limits&#60;long&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;long&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;long&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41154"
>16.1.45. struct numeric_limits&#60;unsigned long&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41157"
>16.1.45.1. Interfaces for struct numeric_limits&#60;unsigned long&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;unsigned long&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;unsigned long&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUN-DATA"
>Table 16-126</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUN-DATA"
></A
><P
><B
>Table 16-126. libstdcxx - struct numeric_limits&#60;unsigned long&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned long&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41276"
>16.1.46. struct numeric_limits&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41279"
>16.1.46.1. Interfaces for struct numeric_limits&#60;wchar_t&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;wchar_t&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUO-DATA"
>Table 16-127</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUO-DATA"
></A
><P
><B
>Table 16-127. libstdcxx - struct numeric_limits&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;wchar_t&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41398"
>16.1.47. struct numeric_limits&#60;unsigned char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41401"
>16.1.47.1. Interfaces for struct numeric_limits&#60;unsigned char&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;unsigned char&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;unsigned char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUP-DATA"
>Table 16-128</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUP-DATA"
></A
><P
><B
>Table 16-128. libstdcxx - struct numeric_limits&#60;unsigned char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;unsigned char&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41520"
>16.1.48. struct numeric_limits&#60;signed char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41523"
>16.1.48.1. Interfaces for struct numeric_limits&#60;signed char&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;signed char&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;signed char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUQ-DATA"
>Table 16-129</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUQ-DATA"
></A
><P
><B
>Table 16-129. libstdcxx - struct numeric_limits&#60;signed char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;signed char&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;signed char&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41642"
>16.1.49. struct numeric_limits&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41645"
>16.1.49.1. Interfaces for struct numeric_limits&#60;char&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;char&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUR-DATA"
>Table 16-130</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUR-DATA"
></A
><P
><B
>Table 16-130. libstdcxx - struct numeric_limits&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;char&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;char&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41764"
>16.1.50. struct numeric_limits&#60;bool&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41767"
>16.1.50.1. Interfaces for struct numeric_limits&#60;bool&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - struct numeric_limits&#60;bool&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for struct numeric_limits&#60;bool&#62; specified in <A
HREF="#TBL-LIBSTDCXX-STRUS-DATA"
>Table 16-131</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-STRUS-DATA"
></A
><P
><B
>Table 16-131. libstdcxx - struct numeric_limits&#60;bool&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numeric_limits&#60;bool&#62;::has_denorm(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_bounded(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_integer(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::round_style(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::has_infinity(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::max_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::min_exponent(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::has_quiet_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_specialized(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::max_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::min_exponent10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::has_denorm_loss(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::tinyness_before(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::has_signaling_NaN(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::radix(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::traps(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::digits(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::digits10(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_exact(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_iec559(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_modulo(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numeric_limits&#60;bool&#62;::is_signed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41886"
>16.1.51. Class ctype_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41889"
>16.1.51.1. Class data for ctype_base</A
></H4
><P
></P
><P
>The Run Time Type Information for the std::ctype_base  class
is described by <A
HREF="#RTTI-24006"
>Table 16-132</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24006"
></A
><P
><B
>Table 16-132. typeinfo for ctype_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for ctype_base</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41908"
>16.1.51.2. Interfaces for Class ctype_base</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::ctype_base
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ctype_base specified in <A
HREF="#TBL-LIBSTDCXX-CLATW-DATA"
>Table 16-133</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATW-DATA"
></A
><P
><B
>Table 16-133. libstdcxx - Class ctype_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype_base::alnum(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::alpha(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::cntrl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::digit(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::graph(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::lower(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::print(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::punct(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::space(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::upper(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_base::xdigit(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for ctype_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ctype_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41982"
>16.1.52. Class __ctype_abstract_base&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN41985"
>16.1.52.1. Class data for __ctype_abstract_base&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::__ctype_abstract_base&#60;char&#62; class
is described by <A
HREF="#CLS-24301-0"
>Table 16-134</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24301-0"
></A
><P
><B
>Table 16-134. Primary vtable for __ctype_abstract_base&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __ctype_abstract_base&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>NULL or __ctype_abstract_base&#60;char&#62;::~__ctype_abstract_base()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>NULL or __ctype_abstract_base&#60;char&#62;::~__ctype_abstract_base()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42075"
>16.1.52.2. Interfaces for Class __ctype_abstract_base&#60;char&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::__ctype_abstract_base&#60;char&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__ctype_abstract_base&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATX-DATA"
>Table 16-135</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATX-DATA"
></A
><P
><B
>Table 16-135. libstdcxx - Class __ctype_abstract_base&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __ctype_abstract_base&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __ctype_abstract_base&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __ctype_abstract_base&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN42099"
>16.1.53. Class __ctype_abstract_base&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42102"
>16.1.53.1. Class data for __ctype_abstract_base&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::__ctype_abstract_base&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24300-0"
>Table 16-136</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24300-0"
></A
><P
><B
>Table 16-136. Primary vtable for __ctype_abstract_base&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __ctype_abstract_base&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>NULL or __ctype_abstract_base&#60;wchar_t&#62;::~__ctype_abstract_base()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>NULL or __ctype_abstract_base&#60;wchar_t&#62;::~__ctype_abstract_base()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42192"
>16.1.53.2. Interfaces for Class __ctype_abstract_base&#60;wchar_t&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::__ctype_abstract_base&#60;wchar_t&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__ctype_abstract_base&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATY-DATA"
>Table 16-137</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATY-DATA"
></A
><P
><B
>Table 16-137. libstdcxx - Class __ctype_abstract_base&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __ctype_abstract_base&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __ctype_abstract_base&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __ctype_abstract_base&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN42216"
>16.1.54. Class ctype&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42219"
>16.1.54.1. Class data for ctype&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::ctype&#60;char&#62; class
is described by <A
HREF="#CLS-24230-0"
>Table 16-138</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24230-0"
></A
><P
><B
>Table 16-138. Primary vtable for ctype&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for ctype&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>ctype&#60;char&#62;::~ctype()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>ctype&#60;char&#62;::~ctype()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>ctype&#60;char&#62;::do_toupper(char) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>ctype&#60;char&#62;::do_toupper(char*, char const*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>ctype&#60;char&#62;::do_tolower(char) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>ctype&#60;char&#62;::do_tolower(char*, char const*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>ctype&#60;char&#62;::do_widen(char) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>ctype&#60;char&#62;::do_widen(char const*, char const*, char*) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>ctype&#60;char&#62;::do_narrow(char, char) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>ctype&#60;char&#62;::do_narrow(char const*, char const*, char, char*) const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42289"
>16.1.54.2. Interfaces for Class ctype&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::ctype&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATZ-INTS"
>Table 16-139</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATZ-INTS"
></A
><P
><B
>Table 16-139. libstdcxx - Class ctype&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype&#60;char&#62;::do_tolower(char*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_tolower(char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_toupper(char*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_toupper(char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_widen(char const*, char const*, char*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_widen(char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_narrow(char const*, char const*, char, char*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::do_narrow(char, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::classic_table()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::~ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::~ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::~ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;ctype&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ctype&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLATZ-DATA"
>Table 16-140</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLATZ-DATA"
></A
><P
><B
>Table 16-140. libstdcxx - Class ctype&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype&#60;char&#62;::table_size(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for ctype&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ctype&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for ctype&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN42393"
>16.1.55. Class ctype&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42396"
>16.1.55.1. Class data for ctype&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::ctype&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24229-0"
>Table 16-141</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24229-0"
></A
><P
><B
>Table 16-141. Primary vtable for ctype&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for ctype&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>ctype&#60;wchar_t&#62;::~ctype()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>ctype&#60;wchar_t&#62;::~ctype()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_is(unsigned short, wchar_t) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_is(wchar_t const*, wchar_t const*, unsigned short*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_scan_is(unsigned short, wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_scan_not(unsigned short, wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_toupper(wchar_t) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_toupper(wchar_t*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_tolower(wchar_t) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_tolower(wchar_t*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_widen(char) const</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_widen(char const*, char const*, wchar_t*) const</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_narrow(wchar_t, char) const</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_narrow(wchar_t const*, wchar_t const*, char, char*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::ctype&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24008"
>Table 16-142</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24008"
></A
><P
><B
>Table 16-142. typeinfo for ctype&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for ctype&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42502"
>16.1.55.2. Interfaces for Class ctype&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::ctype&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUA-INTS"
>Table 16-143</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUA-INTS"
></A
><P
><B
>Table 16-143. libstdcxx - Class ctype&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype&#60;wchar_t&#62;::do_scan_is(unsigned short, wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_tolower(wchar_t*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_tolower(wchar_t) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_toupper(wchar_t*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_toupper(wchar_t) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_scan_not(unsigned short, wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::_M_convert_to_wmask(unsigned short) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_is(wchar_t const*, wchar_t const*, unsigned short*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_is(unsigned short, wchar_t) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_widen(char const*, char const*, wchar_t*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_widen(char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_narrow(wchar_t const*, wchar_t const*, char, char*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::do_narrow(wchar_t, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::_M_initialize_ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::~ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::~ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62;::~ctype()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ctype&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUA-DATA"
>Table 16-144</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUA-DATA"
></A
><P
><B
>Table 16-144. libstdcxx - Class ctype&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for ctype&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ctype&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for ctype&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN42621"
>16.1.56. Class ctype_byname&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42624"
>16.1.56.1. Class data for ctype_byname&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::ctype_byname&#60;char&#62; class
is described by <A
HREF="#CLS-24299-0"
>Table 16-145</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24299-0"
></A
><P
><B
>Table 16-145. Primary vtable for ctype_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for ctype_byname&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>ctype_byname&#60;char&#62;::~ctype_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>ctype_byname&#60;char&#62;::~ctype_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>ctype&#60;char&#62;::do_toupper(char) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>ctype&#60;char&#62;::do_toupper(char*, char const*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>ctype&#60;char&#62;::do_tolower(char) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>ctype&#60;char&#62;::do_tolower(char*, char const*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>ctype&#60;char&#62;::do_widen(char) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>ctype&#60;char&#62;::do_widen(char const*, char const*, char*) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>ctype&#60;char&#62;::do_narrow(char, char) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>ctype&#60;char&#62;::do_narrow(char const*, char const*, char, char*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::ctype_byname&#60;char&#62;  class
is described by <A
HREF="#RTTI-24087"
>Table 16-146</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24087"
></A
><P
><B
>Table 16-146. typeinfo for ctype_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for ctype_byname&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42710"
>16.1.56.2. Interfaces for Class ctype_byname&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::ctype_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUB-INTS"
>Table 16-147</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUB-INTS"
></A
><P
><B
>Table 16-147. libstdcxx - Class ctype_byname&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype_byname&#60;char&#62;::~ctype_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_byname&#60;char&#62;::~ctype_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_byname&#60;char&#62;::~ctype_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ctype_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUB-DATA"
>Table 16-148</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUB-DATA"
></A
><P
><B
>Table 16-148. libstdcxx - Class ctype_byname&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for ctype_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ctype_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for ctype_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN42754"
>16.1.57. Class ctype_byname&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42757"
>16.1.57.1. Class data for ctype_byname&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::ctype_byname&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24298-0"
>Table 16-149</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24298-0"
></A
><P
><B
>Table 16-149. Primary vtable for ctype_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for ctype_byname&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>ctype_byname&#60;wchar_t&#62;::~ctype_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>ctype_byname&#60;wchar_t&#62;::~ctype_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_is(unsigned short, wchar_t) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_is(wchar_t const*, wchar_t const*, unsigned short*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_scan_is(unsigned short, wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_scan_not(unsigned short, wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_toupper(wchar_t) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_toupper(wchar_t*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_tolower(wchar_t) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_tolower(wchar_t*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_widen(char) const</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_widen(char const*, char const*, wchar_t*) const</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_narrow(wchar_t, char) const</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>ctype&#60;wchar_t&#62;::do_narrow(wchar_t const*, wchar_t const*, char, char*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::ctype_byname&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24086"
>Table 16-150</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24086"
></A
><P
><B
>Table 16-150. typeinfo for ctype_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for ctype_byname&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42863"
>16.1.57.2. Interfaces for Class ctype_byname&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::ctype_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUC-INTS"
>Table 16-151</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUC-INTS"
></A
><P
><B
>Table 16-151. libstdcxx - Class ctype_byname&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ctype_byname&#60;wchar_t&#62;::~ctype_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_byname&#60;wchar_t&#62;::~ctype_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype_byname&#60;wchar_t&#62;::~ctype_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ctype_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUC-DATA"
>Table 16-152</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUC-DATA"
></A
><P
><B
>Table 16-152. libstdcxx - Class ctype_byname&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for ctype_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ctype_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for ctype_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN42907"
>16.1.58. Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN42910"
>16.1.58.1. Interfaces for Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_string&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUD-INTS"
>Table 16-153</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUD-INTS"
></A
><P
><B
>Table 16-153. libstdcxx - Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_disjunct(char const*) const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::get_allocator() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::end() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_is_leaked() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_is_shared() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::data() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rend() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::size() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::begin() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::c_str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::empty() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_rep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::length() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rbegin() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_data() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_iend() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::compare(char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::compare(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::capacity() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::max_size() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_ibegin() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Alloc_hider::_Alloc_hider(char*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Alloc_hider::_Alloc_hider(char*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_leak_hard()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_S_empty_rep()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_S_copy_chars(char*, __gnu_cxx::__normal_iterator&#60;char const*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char const*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_S_copy_chars(char*, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_S_copy_chars(char*, char const*, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_S_copy_chars(char*, char*, char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::end()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_destroy(allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_dispose(allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_refcopy()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_refdata()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_S_empty_rep()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_set_leaked()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_set_sharable()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_M_grab(allocator&#60;char&#62; const&#38;, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rend()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::swap(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::begin()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::clear()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::erase(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::erase(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::append(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::append(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::assign(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::assign(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::insert(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rbegin()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_data(char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_leak()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char const*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char const*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, char const*, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, char*, char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::push_back(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string(char const*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string(allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string&#60;__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62; &#62;(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string&#60;char const*&#62;(char const*, char const*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string&#60;char*&#62;(char*, char*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string(char const*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string(allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string&#60;__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62; &#62;(__gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;char*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; &#62;, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string&#60;char const*&#62;(char const*, char const*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_string&#60;char*&#62;(char*, char*, allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::operator=(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::operator=(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::operator=(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::operator+=(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::operator+=(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::operator+=(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_string&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUD-DATA"
>Table 16-154</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUD-DATA"
></A
><P
><B
>Table 16-154. libstdcxx - Class basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_S_max_size(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_S_terminal(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_Rep::_S_empty_rep_storage(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::npos(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN43349"
>16.1.59. Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN43352"
>16.1.59.1. Interfaces for Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_string&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUE-INTS"
>Table 16-155</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUE-INTS"
></A
><P
><B
>Table 16-155. libstdcxx - Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_disjunct(wchar_t const*) const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::get_allocator() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::end() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_is_leaked() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_is_shared() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::data() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rend() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::size() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::begin() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::c_str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::empty() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_rep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::length() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rbegin() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_data() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_iend() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::compare(wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::compare(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::capacity() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::max_size() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_ibegin() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Alloc_hider::_Alloc_hider(wchar_t*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Alloc_hider::_Alloc_hider(wchar_t*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_leak_hard()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_S_empty_rep()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_S_copy_chars(wchar_t*, __gnu_cxx::__normal_iterator&#60;wchar_t const*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t const*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_S_copy_chars(wchar_t*, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_S_copy_chars(wchar_t*, wchar_t const*, wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_S_copy_chars(wchar_t*, wchar_t*, wchar_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::end()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_destroy(allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_dispose(allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_refcopy()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_refdata()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_S_empty_rep()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_set_leaked()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_set_sharable()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_M_grab(allocator&#60;wchar_t&#62; const&#38;, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rend()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::swap(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::begin()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::clear()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::erase(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::erase(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::append(wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::append(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::assign(wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::assign(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::insert(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rbegin()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_data(wchar_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_leak()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t const*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t const*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, wchar_t const*, wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, wchar_t*, wchar_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::replace(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::push_back(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string(wchar_t const*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string(allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string&#60;__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62; &#62;(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string&#60;wchar_t const*&#62;(wchar_t const*, wchar_t const*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string&#60;wchar_t*&#62;(wchar_t*, wchar_t*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string(wchar_t const*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string(allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string&#60;__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62; &#62;(__gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, __gnu_cxx::__normal_iterator&#60;wchar_t*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; &#62;, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string&#60;wchar_t const*&#62;(wchar_t const*, wchar_t const*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_string&#60;wchar_t*&#62;(wchar_t*, wchar_t*, allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_string()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::operator=(wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::operator=(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::operator=(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::operator+=(wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::operator+=(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::operator+=(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; operator+&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(char const*, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; operator+&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; operator+&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(char, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; operator+&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(wchar_t const*, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; operator+&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; operator+&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(wchar_t, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_string&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUE-DATA"
>Table 16-156</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUE-DATA"
></A
><P
><B
>Table 16-156. libstdcxx - Class basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_S_max_size(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_S_terminal(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_Rep::_S_empty_rep_storage(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::npos(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN43821"
>16.1.60. Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN43824"
>16.1.60.1. Class data for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_stringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_stringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24742"
>Table 16-157</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24742"
></A
><P
><B
>Table 16-157. VTT for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt18basic_stringstreamIcSt11char_traitsIcESaIcEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>10</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN43842"
>16.1.60.2. Interfaces for Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_stringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUF-INTS"
>Table 16-158</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUF-INTS"
></A
><P
><B
>Table 16-158. libstdcxx - Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringstream(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringstream(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_stringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUF-DATA"
>Table 16-159</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUF-DATA"
></A
><P
><B
>Table 16-159. libstdcxx - Class basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_stringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN43926"
>16.1.61. Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN43929"
>16.1.61.1. Class data for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_stringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_stringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24743"
>Table 16-160</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24743"
></A
><P
><B
>Table 16-160. VTT for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt18basic_stringstreamIwSt11char_traitsIwESaIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>10</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN43947"
>16.1.61.2. Interfaces for Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_stringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUG-INTS"
>Table 16-161</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUG-INTS"
></A
><P
><B
>Table 16-161. libstdcxx - Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringstream(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringstream(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_stringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUG-DATA"
>Table 16-162</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUG-DATA"
></A
><P
><B
>Table 16-162. libstdcxx - Class basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_stringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44031"
>16.1.62. Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44034"
>16.1.62.1. Class data for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_istringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_istringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24394"
>Table 16-163</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24394"
></A
><P
><B
>Table 16-163. VTT for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt19basic_istringstreamIcSt11char_traitsIcESaIcEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44052"
>16.1.62.2. Interfaces for Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_istringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUH-INTS"
>Table 16-164</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUH-INTS"
></A
><P
><B
>Table 16-164. libstdcxx - Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_istringstream(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_istringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_istringstream(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_istringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_istringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_istringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_istringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_istringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUH-DATA"
>Table 16-165</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUH-DATA"
></A
><P
><B
>Table 16-165. libstdcxx - Class basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_istringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44136"
>16.1.63. Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44139"
>16.1.63.1. Class data for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_istringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_istringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24395"
>Table 16-166</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24395"
></A
><P
><B
>Table 16-166. VTT for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt19basic_istringstreamIwSt11char_traitsIwESaIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44157"
>16.1.63.2. Interfaces for Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_istringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUI-INTS"
>Table 16-167</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUI-INTS"
></A
><P
><B
>Table 16-167. libstdcxx - Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_istringstream(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_istringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_istringstream(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_istringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_istringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_istringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_istringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_istringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUI-DATA"
>Table 16-168</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUI-DATA"
></A
><P
><B
>Table 16-168. libstdcxx - Class basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_istringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44241"
>16.1.64. Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44244"
>16.1.64.1. Class data for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ostringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ostringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24396"
>Table 16-169</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24396"
></A
><P
><B
>Table 16-169. VTT for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44262"
>16.1.64.2. Interfaces for Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ostringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUJ-INTS"
>Table 16-170</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUJ-INTS"
></A
><P
><B
>Table 16-170. libstdcxx - Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_ostringstream(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_ostringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_ostringstream(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_ostringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_ostringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_ostringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_ostringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ostringstream&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUJ-DATA"
>Table 16-171</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUJ-DATA"
></A
><P
><B
>Table 16-171. libstdcxx - Class basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ostringstream&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44346"
>16.1.65. Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44349"
>16.1.65.1. Class data for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ostringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ostringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24397"
>Table 16-172</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24397"
></A
><P
><B
>Table 16-172. VTT for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt19basic_ostringstreamIwSt11char_traitsIwESaIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44367"
>16.1.65.2. Interfaces for Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ostringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUK-INTS"
>Table 16-173</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUK-INTS"
></A
><P
><B
>Table 16-173. libstdcxx - Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_ostringstream(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_ostringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_ostringstream(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_ostringstream(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_ostringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_ostringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_ostringstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ostringstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUK-DATA"
>Table 16-174</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUK-DATA"
></A
><P
><B
>Table 16-174. libstdcxx - Class basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ostringstream&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44451"
>16.1.66. Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44454"
>16.1.66.1. Class data for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_stringbuf&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; class
is described by <A
HREF="#CLS-24311-0"
>Table 16-175</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24311-0"
></A
><P
><B
>Table 16-175. Primary vtable for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringbuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringbuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::pbackfail(int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::overflow(int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_stringbuf&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62;  class
is described by <A
HREF="#RTTI-24089"
>Table 16-176</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24089"
></A
><P
><B
>Table 16-176. typeinfo for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44552"
>16.1.66.2. Interfaces for Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_stringbuf&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUL-INTS"
>Table 16-177</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUL-INTS"
></A
><P
><B
>Table 16-177. libstdcxx - Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_update_egptr()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::_M_stringbuf_init(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::str(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::overflow(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::pbackfail(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::showmanyc()(GLIBCXX_3.4.6) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::underflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringbuf(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringbuf(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringbuf(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::basic_stringbuf(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringbuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;::~basic_stringbuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_stringbuf&#60;char, std::char_traits&#60;char&#62;, std::allocator&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUL-DATA"
>Table 16-178</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUL-DATA"
></A
><P
><B
>Table 16-178. libstdcxx - Class basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_stringbuf&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44656"
>16.1.67. Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44659"
>16.1.67.1. Class data for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_stringbuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; class
is described by <A
HREF="#CLS-24307-0"
>Table 16-179</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24307-0"
></A
><P
><B
>Table 16-179. Primary vtable for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringbuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringbuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::overflow(unsigned int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_stringbuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#RTTI-24088"
>Table 16-180</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24088"
></A
><P
><B
>Table 16-180. typeinfo for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44757"
>16.1.67.2. Interfaces for Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_stringbuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUM-INTS"
>Table 16-181</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUM-INTS"
></A
><P
><B
>Table 16-181. libstdcxx - Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_update_egptr()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::_M_stringbuf_init(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::str(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::overflow(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::showmanyc()(GLIBCXX_3.4.6) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::underflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringbuf(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringbuf(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringbuf(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::basic_stringbuf(_Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringbuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;::~basic_stringbuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_stringbuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62;, std::allocator&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUM-DATA"
>Table 16-182</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUM-DATA"
></A
><P
><B
>Table 16-182. libstdcxx - Class basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_stringbuf&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44861"
>16.1.68. Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44864"
>16.1.68.1. Class data for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_iostream&#60;char, std::char_traits&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_iostream&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24660"
>Table 16-183</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24660"
></A
><P
><B
>Table 16-183. VTT for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSd</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>7</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44882"
>16.1.68.2. Interfaces for Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_iostream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUN-INTS"
>Table 16-184</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUN-INTS"
></A
><P
><B
>Table 16-184. libstdcxx - Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::basic_iostream(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::basic_iostream(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::~basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::~basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;char, char_traits&#60;char&#62; &#62;::~basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, signed char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_iostream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUN-DATA"
>Table 16-185</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUN-DATA"
></A
><P
><B
>Table 16-185. libstdcxx - Class basic_iostream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_iostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44956"
>16.1.69. Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44959"
>16.1.69.1. Class data for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_iostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_iostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24661"
>Table 16-186</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24661"
></A
><P
><B
>Table 16-186. VTT for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt14basic_iostreamIwSt11char_traitsIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>7</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN44977"
>16.1.69.2. Interfaces for Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_iostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUO-INTS"
>Table 16-187</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUO-INTS"
></A
><P
><B
>Table 16-187. libstdcxx - Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_iostream(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_iostream(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_iostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_iostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUO-DATA"
>Table 16-188</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUO-DATA"
></A
><P
><B
>Table 16-188. libstdcxx - Class basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_iostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN45046"
>16.1.70. Class basic_istream&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45049"
>16.1.70.1. Class data for basic_istream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_istream&#60;char, std::char_traits&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_istream&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24999"
>Table 16-189</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24999"
></A
><P
><B
>Table 16-189. VTT for basic_istream&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSi</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45067"
>16.1.70.2. Interfaces for Class basic_istream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_istream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUP-INTS"
>Table 16-190</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUP-INTS"
></A
><P
><B
>Table 16-190. libstdcxx - Class basic_istream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::gcount() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::sentry::operator bool() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::get(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::get(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;&#38;, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::get(char&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::peek()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::seekg(fpos&#60;__mbstate_t&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::tellg()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::unget()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::ignore()(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::sentry::sentry(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::sentry::sentry(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::putback(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::basic_istream(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::basic_istream(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::~basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::~basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::~basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; (*)(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(ios_base&#38; (*)(ios_base&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(basic_ios&#60;char, char_traits&#60;char&#62; &#62;&#38; (*)(basic_ios&#60;char, char_traits&#60;char&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(void*&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(bool&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(double&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(long double&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(float&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(int&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(unsigned int&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(unsigned long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(short&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(unsigned short&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(long long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;::operator&#62;&#62;(unsigned long long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; ws&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; getline&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; getline&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, unsigned char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, signed char&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, unsigned char&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, char&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setprecision)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Resetiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setw)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setbase)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setfill&#60;char&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;double, char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, complex&#60;double&#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;long double, char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, complex&#60;long double&#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#62;&#62;&#60;float, char, char_traits&#60;char&#62; &#62;(basic_istream&#60;char, char_traits&#60;char&#62; &#62;&#38;, complex&#60;float&#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_istream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUP-DATA"
>Table 16-191</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUP-DATA"
></A
><P
><B
>Table 16-191. libstdcxx - Class basic_istream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_istream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_istream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_istream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_istream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN45386"
>16.1.71. Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45389"
>16.1.71.1. Class data for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_istream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_istream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-25001"
>Table 16-192</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-25001"
></A
><P
><B
>Table 16-192. VTT for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt13basic_istreamIwSt11char_traitsIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45407"
>16.1.71.2. Interfaces for Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_istream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUQ-INTS"
>Table 16-193</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUQ-INTS"
></A
><P
><B
>Table 16-193. libstdcxx - Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::gcount() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::operator bool() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::get(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::get(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::get(wchar_t&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::peek()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekg(fpos&#60;__mbstate_t&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::tellg()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::unget()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::ignore()(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::sentry(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::sentry(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::putback(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_istream(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_istream(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; (*)(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(ios_base&#38; (*)(ios_base&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; (*)(basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(void*&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(bool&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(double&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(long double&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(float&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(int&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(unsigned int&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(unsigned long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(short&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(unsigned short&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(long long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#62;&#62;(unsigned long long&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; ws&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; getline&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; getline&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;, wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;double, wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, complex&#60;double&#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;long double, wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, complex&#60;long double&#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;float, wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, complex&#60;float&#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, wchar_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, wchar_t&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setprecision)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Resetiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setw)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setbase)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setfill&#60;wchar_t&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#62;&#62;&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_istream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUQ-DATA"
>Table 16-194</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUQ-DATA"
></A
><P
><B
>Table 16-194. libstdcxx - Class basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN45701"
>16.1.72. Class istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45704"
>16.1.72.1. Interfaces for Class istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUR-INTS"
>Table 16-195</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUR-INTS"
></A
><P
><B
>Table 16-195. libstdcxx - Class istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator++()(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN45717"
>16.1.73. Class istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45720"
>16.1.73.1. Interfaces for Class istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUS-INTS"
>Table 16-196</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUS-INTS"
></A
><P
><B
>Table 16-196. libstdcxx - Class istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;::operator++()(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN45733"
>16.1.74. Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45736"
>16.1.74.1. Class data for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ostream&#60;char, std::char_traits&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ostream&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-25000"
>Table 16-197</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-25000"
></A
><P
><B
>Table 16-197. VTT for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSo</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN45754"
>16.1.74.2. Interfaces for Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ostream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUT-INTS"
>Table 16-198</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUT-INTS"
></A
><P
><B
>Table 16-198. libstdcxx - Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::sentry::operator bool() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::put(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::flush()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::seekp(fpos&#60;__mbstate_t&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::tellp()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::sentry::sentry(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::sentry::sentry(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::sentry::~sentry()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::sentry::~sentry()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::basic_ostream(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::basic_ostream(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; (*)(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(ios_base&#38; (*)(ios_base&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(basic_ios&#60;char, char_traits&#60;char&#62; &#62;&#38; (*)(basic_ios&#60;char, char_traits&#60;char&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(void const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(double)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(long double)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(float)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(unsigned long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(short)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(unsigned short)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(long long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;::operator&#60;&#60;(unsigned long long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; endl&#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; ends&#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; flush&#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, signed char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, unsigned char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, signed char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, unsigned char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setprecision)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Resetiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setw)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setbase)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, _Setfill&#60;char&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;double, char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, complex&#60;double&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;long double, char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, complex&#60;long double&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38; operator&#60;&#60; &#60;float, char, char_traits&#60;char&#62; &#62;(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;&#38;, complex&#60;float&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ostream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUT-DATA"
>Table 16-199</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUT-DATA"
></A
><P
><B
>Table 16-199. libstdcxx - Class basic_ostream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ostream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46048"
>16.1.75. Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46051"
>16.1.75.1. Class data for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-25002"
>Table 16-200</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-25002"
></A
><P
><B
>Table 16-200. VTT for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt13basic_ostreamIwSt11char_traitsIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46069"
>16.1.75.2. Interfaces for Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUU-INTS"
>Table 16-201</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUU-INTS"
></A
><P
><B
>Table 16-201. libstdcxx - Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::operator bool() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::put(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::flush()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekp(fpos&#60;__mbstate_t&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::tellp()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::sentry(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::sentry(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::~sentry()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sentry::~sentry()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ostream(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ostream(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; (*)(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(ios_base&#38; (*)(ios_base&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; (*)(basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;))(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(void const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(double)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(long double)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(float)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(unsigned long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(short)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(unsigned short)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(long long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator&#60;&#60;(unsigned long long)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; endl&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; ends&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; flush&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;double, wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, complex&#60;double&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;long double, wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, complex&#60;long double&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;float, wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, complex&#60;float&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, wchar_t const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setprecision)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Resetiosflags)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setw)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setbase)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, _Setfill&#60;wchar_t&#62;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38; operator&#60;&#60; &#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ostream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUU-DATA"
>Table 16-202</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUU-DATA"
></A
><P
><B
>Table 16-202. libstdcxx - Class basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46343"
>16.1.76. Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46346"
>16.1.76.1. Class data for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_fstream&#60;char, std::char_traits&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_fstream&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24740"
>Table 16-203</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24740"
></A
><P
><B
>Table 16-203. VTT for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt13basic_fstreamIcSt11char_traitsIcEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>10</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46364"
>16.1.76.2. Interfaces for Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_fstream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUV-INTS"
>Table 16-204</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUV-INTS"
></A
><P
><B
>Table 16-204. libstdcxx - Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::is_open() const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::is_open()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::basic_fstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::basic_fstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_fstream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUV-DATA"
>Table 16-205</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUV-DATA"
></A
><P
><B
>Table 16-205. libstdcxx - Class basic_fstream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_fstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46458"
>16.1.77. Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46461"
>16.1.77.1. Class data for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_fstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_fstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24741"
>Table 16-206</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24741"
></A
><P
><B
>Table 16-206. VTT for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt13basic_fstreamIwSt11char_traitsIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>10</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46479"
>16.1.77.2. Interfaces for Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_fstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUW-INTS"
>Table 16-207</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUW-INTS"
></A
><P
><B
>Table 16-207. libstdcxx - Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open() const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_fstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_fstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_fstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_fstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUW-DATA"
>Table 16-208</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUW-DATA"
></A
><P
><B
>Table 16-208. libstdcxx - Class basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_fstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46573"
>16.1.78. Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46576"
>16.1.78.1. Class data for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ifstream&#60;char, std::char_traits&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ifstream&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24390"
>Table 16-209</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24390"
></A
><P
><B
>Table 16-209. VTT for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt14basic_ifstreamIcSt11char_traitsIcEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46594"
>16.1.78.2. Interfaces for Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ifstream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUX-INTS"
>Table 16-210</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUX-INTS"
></A
><P
><B
>Table 16-210. libstdcxx - Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::is_open() const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::is_open()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ifstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ifstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ifstream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUX-DATA"
>Table 16-211</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUX-DATA"
></A
><P
><B
>Table 16-211. libstdcxx - Class basic_ifstream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ifstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46688"
>16.1.79. Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46691"
>16.1.79.1. Class data for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ifstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ifstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24391"
>Table 16-212</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24391"
></A
><P
><B
>Table 16-212. VTT for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt14basic_ifstreamIwSt11char_traitsIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46709"
>16.1.79.2. Interfaces for Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ifstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUY-INTS"
>Table 16-213</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUY-INTS"
></A
><P
><B
>Table 16-213. libstdcxx - Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open() const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ifstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ifstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ifstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ifstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUY-DATA"
>Table 16-214</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUY-DATA"
></A
><P
><B
>Table 16-214. libstdcxx - Class basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ifstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46818"
>16.1.80. Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46821"
>16.1.80.1. Class data for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ofstream&#60;char, std::char_traits&#60;char&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ofstream&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#VTT-24392"
>Table 16-215</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24392"
></A
><P
><B
>Table 16-215. VTT for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt14basic_ofstreamIcSt11char_traitsIcEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46839"
>16.1.80.2. Interfaces for Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ofstream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUZ-INTS"
>Table 16-216</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUZ-INTS"
></A
><P
><B
>Table 16-216. libstdcxx - Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::is_open() const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::is_open()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ofstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ofstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;::~basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ofstream&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAUZ-DATA"
>Table 16-217</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAUZ-DATA"
></A
><P
><B
>Table 16-217. libstdcxx - Class basic_ofstream&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ofstream&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN46933"
>16.1.81. Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46936"
>16.1.81.1. Class data for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ofstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described in the relevant architecture specific part of this specification.</P
><P
>The VTT for the std::basic_ofstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#VTT-24393"
>Table 16-218</A
></P
><DIV
CLASS="TABLE"
><A
NAME="VTT-24393"
></A
><P
><B
>Table 16-218. VTT for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>VTT Name</TD
><TD
>_ZTTSt14basic_ofstreamIwSt11char_traitsIwEE</TD
></TR
><TR
><TD
>Number of Entries</TD
><TD
>4</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN46954"
>16.1.81.2. Interfaces for Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ofstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVA-INTS"
>Table 16-219</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVA-INTS"
></A
><P
><B
>Table 16-219. libstdcxx - Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open() const(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ofstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ofstream(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ofstream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ofstream&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVA-DATA"
>Table 16-220</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVA-DATA"
></A
><P
><B
>Table 16-220. libstdcxx - Class basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>VTT for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ofstream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN47048"
>16.1.82. Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47051"
>16.1.82.1. Class data for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_streambuf&#60;char, std::char_traits&#60;char&#62; &#62; class
is described by <A
HREF="#CLS-24315-0"
>Table 16-221</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24315-0"
></A
><P
><B
>Table 16-221. Primary vtable for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_streambuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_streambuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pbackfail(int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::overflow(int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_streambuf&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#RTTI-23990"
>Table 16-222</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-23990"
></A
><P
><B
>Table 16-222. typeinfo for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47149"
>16.1.82.2. Interfaces for Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_streambuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVB-INTS"
>Table 16-223</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVB-INTS"
></A
><P
><B
>Table 16-223. libstdcxx - Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::gptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::eback() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::egptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::epptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pbase() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::getloc() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pubseekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::setg(char*, char*, char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::setp(char*, char*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::gbump(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pbump(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sgetc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sputc(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::uflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sbumpc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::snextc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pubsync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sungetc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::in_avail()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::overflow(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pubimbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::pbackfail(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::showmanyc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::sputbackc(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::underflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::basic_streambuf(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::basic_streambuf(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::operator=(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_streambuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVB-DATA"
>Table 16-224</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVB-DATA"
></A
><P
><B
>Table 16-224. libstdcxx - Class basic_streambuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN47363"
>16.1.83. Class basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47366"
>16.1.83.1. Class data for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_streambuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described by <A
HREF="#CLS-24314-0"
>Table 16-225</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24314-0"
></A
><P
><B
>Table 16-225. Primary vtable for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_streambuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_streambuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::overflow(unsigned int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_streambuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#RTTI-23991"
>Table 16-226</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-23991"
></A
><P
><B
>Table 16-226. typeinfo for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47464"
>16.1.83.2. Interfaces for Class basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_streambuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVC-INTS"
>Table 16-227</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVC-INTS"
></A
><P
><B
>Table 16-227. libstdcxx - Class basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::gptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::eback() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::egptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::epptr() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbase() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::getloc() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pubseekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::setg(wchar_t*, wchar_t*, wchar_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::setp(wchar_t*, wchar_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::gbump(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbump(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sgetc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sputc(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::uflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sbumpc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::snextc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pubsync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sungetc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::in_avail()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::overflow(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pubimbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::showmanyc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sputbackc(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::underflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_streambuf(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_streambuf(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_streambuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator=(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN47657"
>16.1.84. Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47660"
>16.1.84.1. Class data for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; class
is described by <A
HREF="#CLS-24240-0"
>Table 16-228</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24240-0"
></A
><P
><B
>Table 16-228. Primary vtable for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_filebuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_filebuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::pbackfail(int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::overflow(int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_filebuf&#60;char, std::char_traits&#60;char&#62; &#62;  class
is described by <A
HREF="#RTTI-23988"
>Table 16-229</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-23988"
></A
><P
><B
>Table 16-229. typeinfo for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47758"
>16.1.84.2. Interfaces for Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVD-INTS"
>Table 16-230</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVD-INTS"
></A
><P
><B
>Table 16-230. libstdcxx - Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::is_open() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::_M_create_pback()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::_M_destroy_pback()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::_M_terminate_output()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::_M_destroy_internal_buffer()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::_M_allocate_internal_buffer()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::overflow(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::pbackfail(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::showmanyc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::underflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;::~basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_filebuf&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVD-DATA"
>Table 16-231</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVD-DATA"
></A
><P
><B
>Table 16-231. libstdcxx - Class basic_filebuf&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_filebuf&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN47887"
>16.1.85. Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47890"
>16.1.85.1. Class data for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described by <A
HREF="#CLS-24239-0"
>Table 16-232</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24239-0"
></A
><P
><B
>Table 16-232. Primary vtable for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_filebuf()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_filebuf()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::showmanyc()</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::underflow()</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::uflow()</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[13]:</TD
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::overflow(unsigned int)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#RTTI-23989"
>Table 16-233</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-23989"
></A
><P
><B
>Table 16-233. typeinfo for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN47988"
>16.1.85.2. Interfaces for Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVE-INTS"
>Table 16-234</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVE-INTS"
></A
><P
><B
>Table 16-234. libstdcxx - Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::is_open() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::_M_create_pback()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::_M_destroy_pback()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::_M_terminate_output()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::_M_destroy_internal_buffer()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::_M_allocate_internal_buffer()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::open(char const*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::seekpos(fpos&#60;__mbstate_t&#62;, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::overflow(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::pbackfail(unsigned int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::showmanyc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::underflow()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_filebuf()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_istream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_istream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ostream()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_filebuf&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVE-DATA"
>Table 16-235</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVE-DATA"
></A
><P
><B
>Table 16-235. libstdcxx - Class basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_filebuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN48137"
>16.1.86. Class ios_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48140"
>16.1.86.1. Class data for ios_base</A
></H4
><P
></P
><P
>The virtual table for the std::ios_base class
is described by <A
HREF="#CLS-29891-0"
>Table 16-236</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-29891-0"
></A
><P
><B
>Table 16-236. Primary vtable for ios_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for ios_base</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>ios_base::~ios_base()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>ios_base::~ios_base()</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::ios_base  class
is described by <A
HREF="#RTTI-24001"
>Table 16-237</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24001"
></A
><P
><B
>Table 16-237. typeinfo for ios_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for ios_base</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48186"
>16.1.86.2. Interfaces for Class ios_base</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::ios_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAVF-INTS"
>Table 16-238</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVF-INTS"
></A
><P
><B
>Table 16-238. libstdcxx - Class ios_base Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ios_base::_M_grow_words(int, bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::sync_with_stdio(bool)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::_M_call_callbacks(ios_base::event)(GLIBCXX_3.4.6) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::register_callback(void (*)(ios_base::event, ios_base&#38;, int), int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::_M_dispose_callbacks()(GLIBCXX_3.4.6) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::Init::Init()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::Init::Init()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::Init::~Init()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::Init::~Init()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::xalloc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::_M_init()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::failure::failure(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::failure::failure(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::failure::~failure()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::failure::~failure()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::failure::~failure()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::ios_base()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::ios_base()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::~ios_base()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::~ios_base()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::~ios_base()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ios_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAVF-DATA"
>Table 16-239</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVF-DATA"
></A
><P
><B
>Table 16-239. libstdcxx - Class ios_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ios_base::floatfield(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::scientific(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::adjustfield(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::in(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::app(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::ate(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::beg(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::cur(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::dec(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::end(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::hex(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::oct(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::out(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::left(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::fixed(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::right(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::trunc(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::badbit(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::binary(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::eofbit(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::skipws(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::failbit(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::goodbit(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::showpos(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::unitbuf(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::internal(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::showbase(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::basefield(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::boolalpha(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::showpoint(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ios_base::uppercase(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for ios_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ios_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for ios_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN48480"
>16.1.87. Class basic_ios&#60;char, char_traits&#60;char&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48483"
>16.1.87.1. Class data for basic_ios&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ios&#60;char, std::char_traits&#60;char&#62; &#62; class
is described by <A
HREF="#CLS-24251-0"
>Table 16-240</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24251-0"
></A
><P
><B
>Table 16-240. Primary vtable for basic_ios&#60;char, char_traits&#60;char&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_ios&#60;char, char_traits&#60;char&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::~basic_ios()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::~basic_ios()</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48513"
>16.1.87.2. Interfaces for Class basic_ios&#60;char, char_traits&#60;char&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ios&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVG-INTS"
>Table 16-241</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVG-INTS"
></A
><P
><B
>Table 16-241. libstdcxx - Class basic_ios&#60;char, char_traits&#60;char&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::exceptions() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::bad() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::eof() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::tie() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::fail() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::fill() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::good() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::widen(char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::narrow(char, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::rdstate() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::operator void*() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::operator!() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::exceptions(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::_M_setstate(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::tie(basic_ostream&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::fill(char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::init(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::clear(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::rdbuf(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::copyfmt(basic_ios&#60;char, char_traits&#60;char&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::setstate(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::basic_ios(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::basic_ios(basic_streambuf&#60;char, char_traits&#60;char&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::~basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::~basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;char, char_traits&#60;char&#62; &#62;::~basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ios&#60;char, std::char_traits&#60;char&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVG-DATA"
>Table 16-242</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVG-DATA"
></A
><P
><B
>Table 16-242. libstdcxx - Class basic_ios&#60;char, char_traits&#60;char&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ios&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ios&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ios&#60;char, char_traits&#60;char&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN48692"
>16.1.88. Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48695"
>16.1.88.1. Class data for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::basic_ios&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; class
is described by <A
HREF="#CLS-24250-0"
>Table 16-243</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24250-0"
></A
><P
><B
>Table 16-243. Primary vtable for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ios()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ios()</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::basic_ios&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62;  class
is described by <A
HREF="#RTTI-24004"
>Table 16-244</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24004"
></A
><P
><B
>Table 16-244. typeinfo for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</TD
></TR
><TR
><TD
>flags:</TD
><TD
>8</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for ios_base</TD
><TD
>1026</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48750"
>16.1.88.2. Interfaces for Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::basic_ios&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVH-INTS"
>Table 16-245</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVH-INTS"
></A
><P
><B
>Table 16-245. libstdcxx - Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::exceptions() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::bad() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::eof() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::tie() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::fail() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::fill() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::good() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::rdbuf() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::widen(char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::narrow(wchar_t, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::rdstate() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator void*() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::operator!() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::exceptions(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::_M_setstate(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::tie(basic_ostream&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::fill(wchar_t)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::init(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::clear(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::imbue(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::rdbuf(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::copyfmt(basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::setstate(_Ios_Iostate)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ios(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ios(basic_streambuf&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;::~basic_ios()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::basic_ios&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVH-DATA"
>Table 16-246</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVH-DATA"
></A
><P
><B
>Table 16-246. libstdcxx - Class basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for basic_ios&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN48929"
>16.1.89. Class ios_base::failure</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48932"
>16.1.89.1. Class data for ios_base::failure</A
></H4
><P
></P
><P
>The virtual table for the std::ios_base::failure class
is described by <A
HREF="#CLS-24252-0"
>Table 16-247</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24252-0"
></A
><P
><B
>Table 16-247. Primary vtable for ios_base::failure</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for ios_base::failure</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>ios_base::failure::~failure()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>ios_base::failure::~failure()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>ios_base::failure::what() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::ios_base::failure  class
is described by <A
HREF="#RTTI-24059"
>Table 16-248</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24059"
></A
><P
><B
>Table 16-248. typeinfo for ios_base::failure</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for ios_base::failure</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN48983"
>16.1.89.2. Interfaces for Class ios_base::failure</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::ios_base::failure specified in <A
HREF="#TBL-LIBSTDCXX-CLAVI-INTS"
>Table 16-249</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVI-INTS"
></A
><P
><B
>Table 16-249. libstdcxx - Class ios_base::failure Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ios_base::failure::what() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::ios_base::failure specified in <A
HREF="#TBL-LIBSTDCXX-CLAVI-DATA"
>Table 16-250</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVI-DATA"
></A
><P
><B
>Table 16-250. libstdcxx - Class ios_base::failure Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for ios_base::failure(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for ios_base::failure(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for ios_base::failure(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49017"
>16.1.90. Class __timepunct&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49020"
>16.1.90.1. Class data for __timepunct&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::__timepunct&#60;char&#62; class
is described by <A
HREF="#CLS-24291-0"
>Table 16-251</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24291-0"
></A
><P
><B
>Table 16-251. Primary vtable for __timepunct&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __timepunct&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__timepunct&#60;char&#62;::~__timepunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__timepunct&#60;char&#62;::~__timepunct()</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::__timepunct&#60;char&#62;  class
is described by <A
HREF="#RTTI-24085"
>Table 16-252</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24085"
></A
><P
><B
>Table 16-252. typeinfo for __timepunct&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __timepunct&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49066"
>16.1.90.2. Interfaces for Class __timepunct&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::__timepunct&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVJ-INTS"
>Table 16-253</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVJ-INTS"
></A
><P
><B
>Table 16-253. libstdcxx - Class __timepunct&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__timepunct&#60;char&#62;::_M_am_pm_format(char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_date_formats(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_time_formats(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_days_abbreviated(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_date_time_formats(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_months_abbreviated(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_days(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_am_pm(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_months(char const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_am_pm_format(wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::_M_initialize_timepunct(__locale_struct*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::~__timepunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::~__timepunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::~__timepunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;__timepunct&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__timepunct&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVJ-DATA"
>Table 16-254</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVJ-DATA"
></A
><P
><B
>Table 16-254. libstdcxx - Class __timepunct&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for __timepunct&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for __timepunct&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __timepunct&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __timepunct&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49180"
>16.1.91. Class __timepunct&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49183"
>16.1.91.1. Class data for __timepunct&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::__timepunct&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24290-0"
>Table 16-255</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24290-0"
></A
><P
><B
>Table 16-255. Primary vtable for __timepunct&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __timepunct&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>__timepunct&#60;wchar_t&#62;::~__timepunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>__timepunct&#60;wchar_t&#62;::~__timepunct()</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::__timepunct&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24084"
>Table 16-256</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24084"
></A
><P
><B
>Table 16-256. typeinfo for __timepunct&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for __timepunct&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49229"
>16.1.91.2. Interfaces for Class __timepunct&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::__timepunct&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVK-INTS"
>Table 16-257</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVK-INTS"
></A
><P
><B
>Table 16-257. libstdcxx - Class __timepunct&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_date_formats(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_time_formats(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_days_abbreviated(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_date_time_formats(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_months_abbreviated(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_days(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_am_pm(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_months(wchar_t const**) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::_M_initialize_timepunct(__locale_struct*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::~__timepunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::~__timepunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::~__timepunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;__timepunct&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__timepunct&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVK-DATA"
>Table 16-258</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVK-DATA"
></A
><P
><B
>Table 16-258. libstdcxx - Class __timepunct&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for __timepunct&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for __timepunct&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __timepunct&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __timepunct&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49333"
>16.1.92. Class messages_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49336"
>16.1.92.1. Class data for messages_base</A
></H4
><P
></P
><P
>The Run Time Type Information for the std::messages_base  class
is described by <A
HREF="#RTTI-24011"
>Table 16-259</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24011"
></A
><P
><B
>Table 16-259. typeinfo for messages_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for messages_base</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49355"
>16.1.92.2. Interfaces for Class messages_base</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::messages_base
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::messages_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAVL-DATA"
>Table 16-260</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVL-DATA"
></A
><P
><B
>Table 16-260. libstdcxx - Class messages_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for messages_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for messages_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49374"
>16.1.93. Class messages&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49377"
>16.1.93.1. Class data for messages&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::messages&#60;char&#62; class
is described by <A
HREF="#CLS-24285-0"
>Table 16-261</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24285-0"
></A
><P
><B
>Table 16-261. Primary vtable for messages&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for messages&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>messages&#60;char&#62;::~messages()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>messages&#60;char&#62;::~messages()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>messages&#60;char&#62;::do_open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>messages&#60;char&#62;::do_get(int, int, int, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>messages&#60;char&#62;::do_close(int) const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49422"
>16.1.93.2. Interfaces for Class messages&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::messages&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVM-INTS"
>Table 16-262</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVM-INTS"
></A
><P
><B
>Table 16-262. libstdcxx - Class messages&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>messages&#60;char&#62;::_M_convert_to_char(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::_M_convert_from_char(char*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::get(int, int, int, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::close(int) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::do_get(int, int, int, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::do_open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::do_close(int) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::~messages()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::~messages()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::~messages()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::messages&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVM-DATA"
>Table 16-263</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVM-DATA"
></A
><P
><B
>Table 16-263. libstdcxx - Class messages&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for messages&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for messages&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for messages&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for messages&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49521"
>16.1.94. Class messages&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49524"
>16.1.94.1. Class data for messages&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::messages&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24284-0"
>Table 16-264</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24284-0"
></A
><P
><B
>Table 16-264. Primary vtable for messages&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for messages&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>messages&#60;wchar_t&#62;::~messages()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>messages&#60;wchar_t&#62;::~messages()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>messages&#60;wchar_t&#62;::do_open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>messages&#60;wchar_t&#62;::do_get(int, int, int, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>messages&#60;wchar_t&#62;::do_close(int) const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49569"
>16.1.94.2. Interfaces for Class messages&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::messages&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVN-INTS"
>Table 16-265</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVN-INTS"
></A
><P
><B
>Table 16-265. libstdcxx - Class messages&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>messages&#60;wchar_t&#62;::_M_convert_to_char(basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::_M_convert_from_char(char*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::get(int, int, int, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::close(int) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::do_get(int, int, int, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::do_open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::do_close(int) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::~messages()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::~messages()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::~messages()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::messages&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVN-DATA"
>Table 16-266</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVN-DATA"
></A
><P
><B
>Table 16-266. libstdcxx - Class messages&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for messages&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for messages&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for messages&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for messages&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49668"
>16.1.95. Class messages_byname&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49671"
>16.1.95.1. Class data for messages_byname&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::messages_byname&#60;char&#62; class
is described by <A
HREF="#CLS-24272-0"
>Table 16-267</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24272-0"
></A
><P
><B
>Table 16-267. Primary vtable for messages_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for messages_byname&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>messages_byname&#60;char&#62;::~messages_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>messages_byname&#60;char&#62;::~messages_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>messages&#60;char&#62;::do_open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>messages&#60;char&#62;::do_get(int, int, int, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>messages&#60;char&#62;::do_close(int) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::messages_byname&#60;char&#62;  class
is described by <A
HREF="#RTTI-24074"
>Table 16-268</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24074"
></A
><P
><B
>Table 16-268. typeinfo for messages_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for messages_byname&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49732"
>16.1.95.2. Interfaces for Class messages_byname&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::messages_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVO-INTS"
>Table 16-269</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVO-INTS"
></A
><P
><B
>Table 16-269. libstdcxx - Class messages_byname&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>messages_byname&#60;char&#62;::~messages_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages_byname&#60;char&#62;::~messages_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages_byname&#60;char&#62;::~messages_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::messages_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVO-DATA"
>Table 16-270</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVO-DATA"
></A
><P
><B
>Table 16-270. libstdcxx - Class messages_byname&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for messages_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for messages_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for messages_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49776"
>16.1.96. Class messages_byname&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49779"
>16.1.96.1. Class data for messages_byname&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::messages_byname&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24258-0"
>Table 16-271</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24258-0"
></A
><P
><B
>Table 16-271. Primary vtable for messages_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for messages_byname&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>messages_byname&#60;wchar_t&#62;::~messages_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>messages_byname&#60;wchar_t&#62;::~messages_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>messages&#60;wchar_t&#62;::do_open(basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;, locale const&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>messages&#60;wchar_t&#62;::do_get(int, int, int, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>messages&#60;wchar_t&#62;::do_close(int) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::messages_byname&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24062"
>Table 16-272</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24062"
></A
><P
><B
>Table 16-272. typeinfo for messages_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for messages_byname&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49840"
>16.1.96.2. Interfaces for Class messages_byname&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::messages_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVP-INTS"
>Table 16-273</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVP-INTS"
></A
><P
><B
>Table 16-273. libstdcxx - Class messages_byname&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>messages_byname&#60;wchar_t&#62;::~messages_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages_byname&#60;wchar_t&#62;::~messages_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages_byname&#60;wchar_t&#62;::~messages_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::messages_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVP-DATA"
>Table 16-274</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVP-DATA"
></A
><P
><B
>Table 16-274. libstdcxx - Class messages_byname&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for messages_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for messages_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for messages_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN49884"
>16.1.97. Class numpunct&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49887"
>16.1.97.1. Class data for numpunct&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::numpunct&#60;char&#62; class
is described by <A
HREF="#CLS-24295-0"
>Table 16-275</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24295-0"
></A
><P
><B
>Table 16-275. Primary vtable for numpunct&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for numpunct&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>numpunct&#60;char&#62;::~numpunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>numpunct&#60;char&#62;::~numpunct()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>numpunct&#60;char&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>numpunct&#60;char&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>numpunct&#60;char&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>numpunct&#60;char&#62;::do_truename() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>numpunct&#60;char&#62;::do_falsename() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::numpunct&#60;char&#62;  class
is described by <A
HREF="#RTTI-24014"
>Table 16-276</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24014"
></A
><P
><B
>Table 16-276. typeinfo for numpunct&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for numpunct&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN49958"
>16.1.97.2. Interfaces for Class numpunct&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::numpunct&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVQ-INTS"
>Table 16-277</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVQ-INTS"
></A
><P
><B
>Table 16-277. libstdcxx - Class numpunct&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numpunct&#60;char&#62;::do_grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::do_truename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::do_falsename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::do_decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::do_thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::truename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::falsename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::_M_initialize_numpunct(__locale_struct*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::~numpunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::~numpunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::~numpunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::numpunct&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVQ-DATA"
>Table 16-278</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVQ-DATA"
></A
><P
><B
>Table 16-278. libstdcxx - Class numpunct&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for numpunct&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for numpunct&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for numpunct&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for numpunct&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50067"
>16.1.98. Class numpunct&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50070"
>16.1.98.1. Class data for numpunct&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::numpunct&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24294-0"
>Table 16-279</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24294-0"
></A
><P
><B
>Table 16-279. Primary vtable for numpunct&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for numpunct&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>numpunct&#60;wchar_t&#62;::~numpunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>numpunct&#60;wchar_t&#62;::~numpunct()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_truename() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_falsename() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::numpunct&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24024"
>Table 16-280</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24024"
></A
><P
><B
>Table 16-280. typeinfo for numpunct&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for numpunct&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50141"
>16.1.98.2. Interfaces for Class numpunct&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::numpunct&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVR-INTS"
>Table 16-281</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVR-INTS"
></A
><P
><B
>Table 16-281. libstdcxx - Class numpunct&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numpunct&#60;wchar_t&#62;::do_grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::do_truename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::do_falsename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::do_decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::do_thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::truename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::falsename() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::_M_initialize_numpunct(__locale_struct*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::~numpunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::~numpunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::~numpunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::numpunct&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVR-DATA"
>Table 16-282</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVR-DATA"
></A
><P
><B
>Table 16-282. libstdcxx - Class numpunct&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for numpunct&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for numpunct&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for numpunct&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for numpunct&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50250"
>16.1.99. Class numpunct_byname&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50253"
>16.1.99.1. Class data for numpunct_byname&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::numpunct_byname&#60;char&#62; class
is described by <A
HREF="#CLS-24279-0"
>Table 16-283</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24279-0"
></A
><P
><B
>Table 16-283. Primary vtable for numpunct_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for numpunct_byname&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>numpunct_byname&#60;char&#62;::~numpunct_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>numpunct_byname&#60;char&#62;::~numpunct_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>numpunct&#60;char&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>numpunct&#60;char&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>numpunct&#60;char&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>numpunct&#60;char&#62;::do_truename() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>numpunct&#60;char&#62;::do_falsename() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::numpunct_byname&#60;char&#62;  class
is described by <A
HREF="#RTTI-24079"
>Table 16-284</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24079"
></A
><P
><B
>Table 16-284. typeinfo for numpunct_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for numpunct_byname&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50324"
>16.1.99.2. Interfaces for Class numpunct_byname&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::numpunct_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVS-INTS"
>Table 16-285</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVS-INTS"
></A
><P
><B
>Table 16-285. libstdcxx - Class numpunct_byname&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numpunct_byname&#60;char&#62;::~numpunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct_byname&#60;char&#62;::~numpunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct_byname&#60;char&#62;::~numpunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::numpunct_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVS-DATA"
>Table 16-286</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVS-DATA"
></A
><P
><B
>Table 16-286. libstdcxx - Class numpunct_byname&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for numpunct_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for numpunct_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for numpunct_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50368"
>16.1.100. Class numpunct_byname&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50371"
>16.1.100.1. Class data for numpunct_byname&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::numpunct_byname&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24265-0"
>Table 16-287</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24265-0"
></A
><P
><B
>Table 16-287. Primary vtable for numpunct_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for numpunct_byname&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>numpunct_byname&#60;wchar_t&#62;::~numpunct_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>numpunct_byname&#60;wchar_t&#62;::~numpunct_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_truename() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>numpunct&#60;wchar_t&#62;::do_falsename() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::numpunct_byname&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24067"
>Table 16-288</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24067"
></A
><P
><B
>Table 16-288. typeinfo for numpunct_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for numpunct_byname&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50442"
>16.1.100.2. Interfaces for Class numpunct_byname&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::numpunct_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVT-INTS"
>Table 16-289</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVT-INTS"
></A
><P
><B
>Table 16-289. libstdcxx - Class numpunct_byname&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>numpunct_byname&#60;wchar_t&#62;::~numpunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct_byname&#60;wchar_t&#62;::~numpunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct_byname&#60;wchar_t&#62;::~numpunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::numpunct_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVT-DATA"
>Table 16-290</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVT-DATA"
></A
><P
><B
>Table 16-290. libstdcxx - Class numpunct_byname&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for numpunct_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for numpunct_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for numpunct_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50486"
>16.1.101. Class __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50489"
>16.1.101.1. Class data for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::__codecvt_abstract_base&#60;char, char, __mbstate_t&#62; class
is described by <A
HREF="#CLS-24297-0"
>Table 16-291</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24297-0"
></A
><P
><B
>Table 16-291. Primary vtable for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>NULL or __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;::~__codecvt_abstract_base()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>NULL or __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;::~__codecvt_abstract_base()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50554"
>16.1.101.2. Interfaces for Class __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::__codecvt_abstract_base&#60;char, char, __mbstate_t&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__codecvt_abstract_base&#60;char, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVU-DATA"
>Table 16-292</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVU-DATA"
></A
><P
><B
>Table 16-292. libstdcxx - Class __codecvt_abstract_base&#60;char, char, __mbstate_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __codecvt_abstract_base&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50578"
>16.1.102. Class __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50581"
>16.1.102.1. Class data for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::__codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62; class
is described by <A
HREF="#CLS-24296-0"
>Table 16-293</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24296-0"
></A
><P
><B
>Table 16-293. Primary vtable for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>NULL or __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;::~__codecvt_abstract_base()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>NULL or __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;::~__codecvt_abstract_base()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>__cxa_pure_virtual</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50646"
>16.1.102.2. Interfaces for Class __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::__codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVV-DATA"
>Table 16-294</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVV-DATA"
></A
><P
><B
>Table 16-294. libstdcxx - Class __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for __codecvt_abstract_base&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50670"
>16.1.103. Class codecvt_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50673"
>16.1.103.1. Class data for codecvt_base</A
></H4
><P
></P
><P
>The Run Time Type Information for the std::codecvt_base  class
is described by <A
HREF="#RTTI-24009"
>Table 16-295</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24009"
></A
><P
><B
>Table 16-295. typeinfo for codecvt_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for codecvt_base</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50692"
>16.1.103.2. Interfaces for Class codecvt_base</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::codecvt_base
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::codecvt_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAVW-DATA"
>Table 16-296</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVW-DATA"
></A
><P
><B
>Table 16-296. libstdcxx - Class codecvt_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for codecvt_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for codecvt_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50711"
>16.1.104. Class codecvt&#60;char, char, __mbstate_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50714"
>16.1.104.1. Class data for codecvt&#60;char, char, __mbstate_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::codecvt&#60;char, char, __mbstate_t&#62; class
is described by <A
HREF="#CLS-24228-0"
>Table 16-297</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24228-0"
></A
><P
><B
>Table 16-297. Primary vtable for codecvt&#60;char, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for codecvt&#60;char, char, __mbstate_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::~codecvt()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::~codecvt()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_out(__mbstate_t&#38;, char const*, char const*, char const*&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_unshift(__mbstate_t&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_in(__mbstate_t&#38;, char const*, char const*, char const*&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_encoding() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_always_noconv() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_max_length() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::codecvt&#60;char, char, __mbstate_t&#62;  class
is described by <A
HREF="#RTTI-24020"
>Table 16-298</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24020"
></A
><P
><B
>Table 16-298. typeinfo for codecvt&#60;char, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for codecvt&#60;char, char, __mbstate_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50793"
>16.1.104.2. Interfaces for Class codecvt&#60;char, char, __mbstate_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::codecvt&#60;char, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVX-INTS"
>Table 16-299</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVX-INTS"
></A
><P
><B
>Table 16-299. libstdcxx - Class codecvt&#60;char, char, __mbstate_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_unshift(__mbstate_t&#38;, char*, char*, char*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_encoding() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_max_length() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_always_noconv() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_in(__mbstate_t&#38;, char const*, char const*, char const*&#38;, char*, char*, char*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_out(__mbstate_t&#38;, char const*, char const*, char const*&#38;, char*, char*, char*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::~codecvt()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::~codecvt()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::~codecvt()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::codecvt&#60;char, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVX-DATA"
>Table 16-300</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVX-DATA"
></A
><P
><B
>Table 16-300. libstdcxx - Class codecvt&#60;char, char, __mbstate_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for codecvt&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for codecvt&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for codecvt&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN50872"
>16.1.105. Class codecvt&#60;wchar_t, char, __mbstate_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50875"
>16.1.105.1. Class data for codecvt&#60;wchar_t, char, __mbstate_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::codecvt&#60;wchar_t, char, __mbstate_t&#62; class
is described by <A
HREF="#CLS-24227-0"
>Table 16-301</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24227-0"
></A
><P
><B
>Table 16-301. Primary vtable for codecvt&#60;wchar_t, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for codecvt&#60;wchar_t, char, __mbstate_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::~codecvt()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::~codecvt()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_out(__mbstate_t&#38;, wchar_t const*, wchar_t const*, wchar_t const*&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_unshift(__mbstate_t&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_in(__mbstate_t&#38;, char const*, char const*, char const*&#38;, wchar_t*, wchar_t*, wchar_t*&#38;) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_encoding() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_always_noconv() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_max_length() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::codecvt&#60;wchar_t, char, __mbstate_t&#62;  class
is described by <A
HREF="#RTTI-24028"
>Table 16-302</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24028"
></A
><P
><B
>Table 16-302. typeinfo for codecvt&#60;wchar_t, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for codecvt&#60;wchar_t, char, __mbstate_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN50954"
>16.1.105.2. Interfaces for Class codecvt&#60;wchar_t, char, __mbstate_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::codecvt&#60;wchar_t, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVY-INTS"
>Table 16-303</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVY-INTS"
></A
><P
><B
>Table 16-303. libstdcxx - Class codecvt&#60;wchar_t, char, __mbstate_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_unshift(__mbstate_t&#38;, char*, char*, char*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_encoding() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_max_length() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_always_noconv() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_in(__mbstate_t&#38;, char const*, char const*, char const*&#38;, wchar_t*, wchar_t*, wchar_t*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_out(__mbstate_t&#38;, wchar_t const*, wchar_t const*, wchar_t const*&#38;, char*, char*, char*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::~codecvt()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::~codecvt()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::~codecvt()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::codecvt&#60;wchar_t, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVY-DATA"
>Table 16-304</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVY-DATA"
></A
><P
><B
>Table 16-304. libstdcxx - Class codecvt&#60;wchar_t, char, __mbstate_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for codecvt&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for codecvt&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for codecvt&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51033"
>16.1.106. Class codecvt_byname&#60;char, char, __mbstate_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51036"
>16.1.106.1. Class data for codecvt_byname&#60;char, char, __mbstate_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::codecvt_byname&#60;char, char, __mbstate_t&#62; class
is described by <A
HREF="#CLS-24271-0"
>Table 16-305</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24271-0"
></A
><P
><B
>Table 16-305. Primary vtable for codecvt_byname&#60;char, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for codecvt_byname&#60;char, char, __mbstate_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>codecvt_byname&#60;char, char, __mbstate_t&#62;::~codecvt_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>codecvt_byname&#60;char, char, __mbstate_t&#62;::~codecvt_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_out(__mbstate_t&#38;, char const*, char const*, char const*&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_unshift(__mbstate_t&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_in(__mbstate_t&#38;, char const*, char const*, char const*&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_encoding() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_always_noconv() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>codecvt&#60;char, char, __mbstate_t&#62;::do_max_length() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::codecvt_byname&#60;char, char, __mbstate_t&#62;  class
is described by <A
HREF="#RTTI-24073"
>Table 16-306</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24073"
></A
><P
><B
>Table 16-306. typeinfo for codecvt_byname&#60;char, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for codecvt_byname&#60;char, char, __mbstate_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51115"
>16.1.106.2. Interfaces for Class codecvt_byname&#60;char, char, __mbstate_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::codecvt_byname&#60;char, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVZ-INTS"
>Table 16-307</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVZ-INTS"
></A
><P
><B
>Table 16-307. libstdcxx - Class codecvt_byname&#60;char, char, __mbstate_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>codecvt_byname&#60;char, char, __mbstate_t&#62;::~codecvt_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt_byname&#60;char, char, __mbstate_t&#62;::~codecvt_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt_byname&#60;char, char, __mbstate_t&#62;::~codecvt_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::codecvt_byname&#60;char, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAVZ-DATA"
>Table 16-308</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAVZ-DATA"
></A
><P
><B
>Table 16-308. libstdcxx - Class codecvt_byname&#60;char, char, __mbstate_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for codecvt_byname&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for codecvt_byname&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for codecvt_byname&#60;char, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51159"
>16.1.107. Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51162"
>16.1.107.1. Class data for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; class
is described by <A
HREF="#CLS-24257-0"
>Table 16-309</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24257-0"
></A
><P
><B
>Table 16-309. Primary vtable for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;::~codecvt_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;::~codecvt_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_out(__mbstate_t&#38;, wchar_t const*, wchar_t const*, wchar_t const*&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_unshift(__mbstate_t&#38;, char*, char*, char*&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_in(__mbstate_t&#38;, char const*, char const*, char const*&#38;, wchar_t*, wchar_t*, wchar_t*&#38;) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_encoding() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_always_noconv() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>See architecture specific part.</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62;::do_max_length() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;  class
is described by <A
HREF="#RTTI-24061"
>Table 16-310</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24061"
></A
><P
><B
>Table 16-310. typeinfo for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51241"
>16.1.107.2. Interfaces for Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWA-INTS"
>Table 16-311</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWA-INTS"
></A
><P
><B
>Table 16-311. libstdcxx - Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;::~codecvt_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;::~codecvt_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;::~codecvt_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWA-DATA"
>Table 16-312</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWA-DATA"
></A
><P
><B
>Table 16-312. libstdcxx - Class codecvt_byname&#60;wchar_t, char, __mbstate_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for codecvt_byname&#60;wchar_t, char, __mbstate_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51285"
>16.1.108. Class collate&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51288"
>16.1.108.1. Class data for collate&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::collate&#60;char&#62; class
is described by <A
HREF="#CLS-24293-0"
>Table 16-313</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24293-0"
></A
><P
><B
>Table 16-313. Primary vtable for collate&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for collate&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>collate&#60;char&#62;::~collate()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>collate&#60;char&#62;::~collate()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>collate&#60;char&#62;::do_compare(char const*, char const*, char const*, char const*) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>collate&#60;char&#62;::do_transform(char const*, char const*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>collate&#60;char&#62;::do_hash(char const*, char const*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::collate&#60;char&#62;  class
is described by <A
HREF="#RTTI-24021"
>Table 16-314</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24021"
></A
><P
><B
>Table 16-314. typeinfo for collate&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for collate&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51349"
>16.1.108.2. Interfaces for Class collate&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::collate&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWB-INTS"
>Table 16-315</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWB-INTS"
></A
><P
><B
>Table 16-315. libstdcxx - Class collate&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>collate&#60;char&#62;::_M_compare(char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::do_compare(char const*, char const*, char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::do_transform(char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::hash(char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::compare(char const*, char const*, char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::do_hash(char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::transform(char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::~collate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::~collate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::~collate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::collate&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWB-DATA"
>Table 16-316</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWB-DATA"
></A
><P
><B
>Table 16-316. libstdcxx - Class collate&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for collate&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for collate&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for collate&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for collate&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51438"
>16.1.109. Class collate&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51441"
>16.1.109.1. Class data for collate&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::collate&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24292-0"
>Table 16-317</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24292-0"
></A
><P
><B
>Table 16-317. Primary vtable for collate&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for collate&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>collate&#60;wchar_t&#62;::~collate()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>collate&#60;wchar_t&#62;::~collate()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>collate&#60;wchar_t&#62;::do_compare(wchar_t const*, wchar_t const*, wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>collate&#60;wchar_t&#62;::do_transform(wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>collate&#60;wchar_t&#62;::do_hash(wchar_t const*, wchar_t const*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::collate&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24029"
>Table 16-318</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24029"
></A
><P
><B
>Table 16-318. typeinfo for collate&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for collate&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51502"
>16.1.109.2. Interfaces for Class collate&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::collate&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWC-INTS"
>Table 16-319</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWC-INTS"
></A
><P
><B
>Table 16-319. libstdcxx - Class collate&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>collate&#60;wchar_t&#62;::_M_compare(wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::do_compare(wchar_t const*, wchar_t const*, wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::do_transform(wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::hash(wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::compare(wchar_t const*, wchar_t const*, wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::do_hash(wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::transform(wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::~collate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::~collate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::~collate()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::collate&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWC-DATA"
>Table 16-320</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWC-DATA"
></A
><P
><B
>Table 16-320. libstdcxx - Class collate&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for collate&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for collate&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for collate&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for collate&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51591"
>16.1.110. Class collate_byname&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51594"
>16.1.110.1. Class data for collate_byname&#60;char&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::collate_byname&#60;char&#62; class
is described by <A
HREF="#CLS-24270-0"
>Table 16-321</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24270-0"
></A
><P
><B
>Table 16-321. Primary vtable for collate_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for collate_byname&#60;char&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>collate_byname&#60;char&#62;::~collate_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>collate_byname&#60;char&#62;::~collate_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>collate&#60;char&#62;::do_compare(char const*, char const*, char const*, char const*) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>collate&#60;char&#62;::do_transform(char const*, char const*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>collate&#60;char&#62;::do_hash(char const*, char const*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::collate_byname&#60;char&#62;  class
is described by <A
HREF="#RTTI-24072"
>Table 16-322</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24072"
></A
><P
><B
>Table 16-322. typeinfo for collate_byname&#60;char&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for collate_byname&#60;char&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51655"
>16.1.110.2. Interfaces for Class collate_byname&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::collate_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWD-INTS"
>Table 16-323</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWD-INTS"
></A
><P
><B
>Table 16-323. libstdcxx - Class collate_byname&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>collate_byname&#60;char&#62;::~collate_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate_byname&#60;char&#62;::~collate_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate_byname&#60;char&#62;::~collate_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::collate_byname&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWD-DATA"
>Table 16-324</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWD-DATA"
></A
><P
><B
>Table 16-324. libstdcxx - Class collate_byname&#60;char&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for collate_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for collate_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for collate_byname&#60;char&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51699"
>16.1.111. Class collate_byname&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51702"
>16.1.111.1. Class data for collate_byname&#60;wchar_t&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::collate_byname&#60;wchar_t&#62; class
is described by <A
HREF="#CLS-24256-0"
>Table 16-325</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24256-0"
></A
><P
><B
>Table 16-325. Primary vtable for collate_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for collate_byname&#60;wchar_t&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>collate_byname&#60;wchar_t&#62;::~collate_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>collate_byname&#60;wchar_t&#62;::~collate_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>collate&#60;wchar_t&#62;::do_compare(wchar_t const*, wchar_t const*, wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>collate&#60;wchar_t&#62;::do_transform(wchar_t const*, wchar_t const*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>collate&#60;wchar_t&#62;::do_hash(wchar_t const*, wchar_t const*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::collate_byname&#60;wchar_t&#62;  class
is described by <A
HREF="#RTTI-24060"
>Table 16-326</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24060"
></A
><P
><B
>Table 16-326. typeinfo for collate_byname&#60;wchar_t&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for collate_byname&#60;wchar_t&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51763"
>16.1.111.2. Interfaces for Class collate_byname&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::collate_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWE-INTS"
>Table 16-327</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWE-INTS"
></A
><P
><B
>Table 16-327. libstdcxx - Class collate_byname&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>collate_byname&#60;wchar_t&#62;::~collate_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate_byname&#60;wchar_t&#62;::~collate_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate_byname&#60;wchar_t&#62;::~collate_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::collate_byname&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWE-DATA"
>Table 16-328</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWE-DATA"
></A
><P
><B
>Table 16-328. libstdcxx - Class collate_byname&#60;wchar_t&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for collate_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for collate_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for collate_byname&#60;wchar_t&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51807"
>16.1.112. Class time_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51810"
>16.1.112.1. Class data for time_base</A
></H4
><P
></P
><P
>The Run Time Type Information for the std::time_base  class
is described by <A
HREF="#RTTI-24016"
>Table 16-329</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24016"
></A
><P
><B
>Table 16-329. typeinfo for time_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_base</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51829"
>16.1.112.2. Interfaces for Class time_base</A
></H4
><P
>No external methods are defined for libstdcxx - Class std::time_base
in this part of the specification. See also the relevant architecture specific part of this specification.</P
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAWF-DATA"
>Table 16-330</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWF-DATA"
></A
><P
><B
>Table 16-330. libstdcxx - Class time_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for time_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51848"
>16.1.113. Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51851"
>16.1.113.1. Class data for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_get_byname&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24273-0"
>Table 16-331</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24273-0"
></A
><P
><B
>Table 16-331. Primary vtable for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_date_order() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_time(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_date(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_weekday(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_monthname(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_year(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::time_get_byname&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24075"
>Table 16-332</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24075"
></A
><P
><B
>Table 16-332. typeinfo for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51927"
>16.1.113.2. Interfaces for Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_get_byname&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWG-INTS"
>Table 16-333</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWG-INTS"
></A
><P
><B
>Table 16-333. libstdcxx - Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_get_byname&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWG-DATA"
>Table 16-334</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWG-DATA"
></A
><P
><B
>Table 16-334. libstdcxx - Class time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_get_byname&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51971"
>16.1.114. Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN51974"
>16.1.114.1. Class data for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_get_byname&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24259-0"
>Table 16-335</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24259-0"
></A
><P
><B
>Table 16-335. Primary vtable for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_date_order() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_time(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_date(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_weekday(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_monthname(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_year(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::time_get_byname&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24063"
>Table 16-336</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24063"
></A
><P
><B
>Table 16-336. typeinfo for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52050"
>16.1.114.2. Interfaces for Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_get_byname&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWH-INTS"
>Table 16-337</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWH-INTS"
></A
><P
><B
>Table 16-337. libstdcxx - Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_get_byname&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWH-DATA"
>Table 16-338</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWH-DATA"
></A
><P
><B
>Table 16-338. libstdcxx - Class time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_get_byname&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52094"
>16.1.115. Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52097"
>16.1.115.1. Class data for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_put_byname&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24275-0"
>Table 16-339</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24275-0"
></A
><P
><B
>Table 16-339. Primary vtable for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, tm const*, char, char) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::time_put_byname&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24076"
>Table 16-340</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24076"
></A
><P
><B
>Table 16-340. typeinfo for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52148"
>16.1.115.2. Interfaces for Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_put_byname&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWI-INTS"
>Table 16-341</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWI-INTS"
></A
><P
><B
>Table 16-341. libstdcxx - Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_put_byname&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWI-DATA"
>Table 16-342</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWI-DATA"
></A
><P
><B
>Table 16-342. libstdcxx - Class time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_put_byname&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52192"
>16.1.116. Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52195"
>16.1.116.1. Class data for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_put_byname&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24261-0"
>Table 16-343</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24261-0"
></A
><P
><B
>Table 16-343. Primary vtable for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, tm const*, char, char) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::time_put_byname&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24064"
>Table 16-344</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24064"
></A
><P
><B
>Table 16-344. typeinfo for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52246"
>16.1.116.2. Interfaces for Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_put_byname&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWJ-INTS"
>Table 16-345</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWJ-INTS"
></A
><P
><B
>Table 16-345. libstdcxx - Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_put_byname&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWJ-DATA"
>Table 16-346</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWJ-DATA"
></A
><P
><B
>Table 16-346. libstdcxx - Class time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>typeinfo for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_put_byname&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52290"
>16.1.117. Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52293"
>16.1.117.1. Class data for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24274-0"
>Table 16-347</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24274-0"
></A
><P
><B
>Table 16-347. Primary vtable for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_date_order() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_time(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_date(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_weekday(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_monthname(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_year(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52353"
>16.1.117.2. Interfaces for Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWK-INTS"
>Table 16-348</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWK-INTS"
></A
><P
><B
>Table 16-348. libstdcxx - Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::date_order() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_date(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_time(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_year(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get_weekday(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_date_order() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get_monthname(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_weekday(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get_monthname(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_via_format(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get_date(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get_time(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get_year(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWK-DATA"
>Table 16-349</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWK-DATA"
></A
><P
><B
>Table 16-349. libstdcxx - Class time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52472"
>16.1.118. Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52475"
>16.1.118.1. Class data for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24260-0"
>Table 16-350</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24260-0"
></A
><P
><B
>Table 16-350. Primary vtable for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_date_order() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_time(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_date(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_weekday(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_monthname(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_year(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52535"
>16.1.118.2. Interfaces for Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWL-INTS"
>Table 16-351</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWL-INTS"
></A
><P
><B
>Table 16-351. libstdcxx - Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::date_order() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_date(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_time(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_year(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get_weekday(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_date_order() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get_monthname(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_weekday(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get_monthname(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_via_format(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get_date(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get_time(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get_year(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, tm*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWL-DATA"
>Table 16-352</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWL-DATA"
></A
><P
><B
>Table 16-352. libstdcxx - Class time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52654"
>16.1.119. Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52657"
>16.1.119.1. Class data for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24276-0"
>Table 16-353</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24276-0"
></A
><P
><B
>Table 16-353. Primary vtable for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, tm const*, char, char) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::time_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24017"
>Table 16-354</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24017"
></A
><P
><B
>Table 16-354. typeinfo for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>flags:</TD
><TD
>8</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for locale::facet</TD
><TD
>2</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for time_base</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52723"
>16.1.119.2. Interfaces for Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWM-INTS"
>Table 16-355</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWM-INTS"
></A
><P
><B
>Table 16-355. libstdcxx - Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, tm const*, char const*, char const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, tm const*, char, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, tm const*, char, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~time_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWM-DATA"
>Table 16-356</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWM-DATA"
></A
><P
><B
>Table 16-356. libstdcxx - Class time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52792"
>16.1.120. Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52795"
>16.1.120.1. Class data for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::time_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24262-0"
>Table 16-357</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24262-0"
></A
><P
><B
>Table 16-357. Primary vtable for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, tm const*, char, char) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::time_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24025"
>Table 16-358</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24025"
></A
><P
><B
>Table 16-358. typeinfo for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>flags:</TD
><TD
>8</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for locale::facet</TD
><TD
>2</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for time_base</TD
><TD
>2</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52861"
>16.1.120.2. Interfaces for Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::time_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWN-INTS"
>Table 16-359</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWN-INTS"
></A
><P
><B
>Table 16-359. libstdcxx - Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, tm const*, wchar_t const*, wchar_t const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, tm const*, char, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, tm const*, char, char) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~time_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::time_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWN-DATA"
>Table 16-360</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWN-DATA"
></A
><P
><B
>Table 16-360. libstdcxx - Class time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52930"
>16.1.121. Class moneypunct&#60;char, false&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN52933"
>16.1.121.1. Class data for moneypunct&#60;char, false&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct&#60;char, false&#62; class
is described by <A
HREF="#CLS-24288-0"
>Table 16-361</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24288-0"
></A
><P
><B
>Table 16-361. Primary vtable for moneypunct&#60;char, false&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct&#60;char, false&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct&#60;char, false&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct&#60;char, false&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53008"
>16.1.121.2. Interfaces for Class moneypunct&#60;char, false&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct&#60;char, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWO-INTS"
>Table 16-362</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWO-INTS"
></A
><P
><B
>Table 16-362. libstdcxx - Class moneypunct&#60;char, false&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct&#60;char, false&#62;::neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::do_thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::_M_initialize_moneypunct(__locale_struct*, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct&#60;char, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWO-DATA"
>Table 16-363</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWO-DATA"
></A
><P
><B
>Table 16-363. libstdcxx - Class moneypunct&#60;char, false&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for moneypunct&#60;char, false&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct&#60;char, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct&#60;char, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct&#60;char, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN53162"
>16.1.122. Class moneypunct&#60;char, true&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53165"
>16.1.122.1. Class data for moneypunct&#60;char, true&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct&#60;char, true&#62; class
is described by <A
HREF="#CLS-24289-0"
>Table 16-364</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24289-0"
></A
><P
><B
>Table 16-364. Primary vtable for moneypunct&#60;char, true&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct&#60;char, true&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct&#60;char, true&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct&#60;char, true&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53240"
>16.1.122.2. Interfaces for Class moneypunct&#60;char, true&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct&#60;char, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWP-INTS"
>Table 16-365</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWP-INTS"
></A
><P
><B
>Table 16-365. libstdcxx - Class moneypunct&#60;char, true&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct&#60;char, true&#62;::neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::do_thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::_M_initialize_moneypunct(__locale_struct*, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct&#60;char, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWP-DATA"
>Table 16-366</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWP-DATA"
></A
><P
><B
>Table 16-366. libstdcxx - Class moneypunct&#60;char, true&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for moneypunct&#60;char, true&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct&#60;char, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct&#60;char, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct&#60;char, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN53394"
>16.1.123. Class moneypunct&#60;wchar_t, false&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53397"
>16.1.123.1. Class data for moneypunct&#60;wchar_t, false&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct&#60;wchar_t, false&#62; class
is described by <A
HREF="#CLS-24286-0"
>Table 16-367</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24286-0"
></A
><P
><B
>Table 16-367. Primary vtable for moneypunct&#60;wchar_t, false&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct&#60;wchar_t, false&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53472"
>16.1.123.2. Interfaces for Class moneypunct&#60;wchar_t, false&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct&#60;wchar_t, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWQ-INTS"
>Table 16-368</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWQ-INTS"
></A
><P
><B
>Table 16-368. libstdcxx - Class moneypunct&#60;wchar_t, false&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::do_thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::_M_initialize_moneypunct(__locale_struct*, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct&#60;wchar_t, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWQ-DATA"
>Table 16-369</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWQ-DATA"
></A
><P
><B
>Table 16-369. libstdcxx - Class moneypunct&#60;wchar_t, false&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for moneypunct&#60;wchar_t, false&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct&#60;wchar_t, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct&#60;wchar_t, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct&#60;wchar_t, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN53626"
>16.1.124. Class moneypunct&#60;wchar_t, true&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53629"
>16.1.124.1. Class data for moneypunct&#60;wchar_t, true&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct&#60;wchar_t, true&#62; class
is described by <A
HREF="#CLS-24287-0"
>Table 16-370</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24287-0"
></A
><P
><B
>Table 16-370. Primary vtable for moneypunct&#60;wchar_t, true&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct&#60;wchar_t, true&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::~moneypunct()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53704"
>16.1.124.2. Interfaces for Class moneypunct&#60;wchar_t, true&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct&#60;wchar_t, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWR-INTS"
>Table 16-371</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWR-INTS"
></A
><P
><B
>Table 16-371. libstdcxx - Class moneypunct&#60;wchar_t, true&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_neg_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_pos_format() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_curr_symbol() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_frac_digits() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_decimal_point() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_negative_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_positive_sign() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::do_thousands_sep() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::grouping() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::_M_initialize_moneypunct(__locale_struct*, char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::~moneypunct()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct&#60;wchar_t, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWR-DATA"
>Table 16-372</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWR-DATA"
></A
><P
><B
>Table 16-372. libstdcxx - Class moneypunct&#60;wchar_t, true&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for moneypunct&#60;wchar_t, true&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct&#60;wchar_t, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct&#60;wchar_t, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct&#60;wchar_t, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN53858"
>16.1.125. Class moneypunct_byname&#60;char, false&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53861"
>16.1.125.1. Class data for moneypunct_byname&#60;char, false&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct_byname&#60;char, false&#62; class
is described by <A
HREF="#CLS-24283-0"
>Table 16-373</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24283-0"
></A
><P
><B
>Table 16-373. Primary vtable for moneypunct_byname&#60;char, false&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct_byname&#60;char, false&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct_byname&#60;char, false&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct_byname&#60;char, false&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;char, false&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::moneypunct_byname&#60;char, false&#62;  class
is described by <A
HREF="#RTTI-24083"
>Table 16-374</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24083"
></A
><P
><B
>Table 16-374. typeinfo for moneypunct_byname&#60;char, false&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for moneypunct_byname&#60;char, false&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN53952"
>16.1.125.2. Interfaces for Class moneypunct_byname&#60;char, false&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct_byname&#60;char, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWS-INTS"
>Table 16-375</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWS-INTS"
></A
><P
><B
>Table 16-375. libstdcxx - Class moneypunct_byname&#60;char, false&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;char, false&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;char, false&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;char, false&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct_byname&#60;char, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWS-DATA"
>Table 16-376</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWS-DATA"
></A
><P
><B
>Table 16-376. libstdcxx - Class moneypunct_byname&#60;char, false&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;char, false&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct_byname&#60;char, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct_byname&#60;char, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct_byname&#60;char, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54001"
>16.1.126. Class moneypunct_byname&#60;char, true&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54004"
>16.1.126.1. Class data for moneypunct_byname&#60;char, true&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct_byname&#60;char, true&#62; class
is described by <A
HREF="#CLS-24282-0"
>Table 16-377</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24282-0"
></A
><P
><B
>Table 16-377. Primary vtable for moneypunct_byname&#60;char, true&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct_byname&#60;char, true&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct_byname&#60;char, true&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct_byname&#60;char, true&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;char, true&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::moneypunct_byname&#60;char, true&#62;  class
is described by <A
HREF="#RTTI-24082"
>Table 16-378</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24082"
></A
><P
><B
>Table 16-378. typeinfo for moneypunct_byname&#60;char, true&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for moneypunct_byname&#60;char, true&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54095"
>16.1.126.2. Interfaces for Class moneypunct_byname&#60;char, true&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct_byname&#60;char, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWT-INTS"
>Table 16-379</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWT-INTS"
></A
><P
><B
>Table 16-379. libstdcxx - Class moneypunct_byname&#60;char, true&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;char, true&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;char, true&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;char, true&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct_byname&#60;char, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWT-DATA"
>Table 16-380</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWT-DATA"
></A
><P
><B
>Table 16-380. libstdcxx - Class moneypunct_byname&#60;char, true&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;char, true&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct_byname&#60;char, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct_byname&#60;char, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct_byname&#60;char, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54144"
>16.1.127. Class moneypunct_byname&#60;wchar_t, false&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54147"
>16.1.127.1. Class data for moneypunct_byname&#60;wchar_t, false&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct_byname&#60;wchar_t, false&#62; class
is described by <A
HREF="#CLS-24269-0"
>Table 16-381</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24269-0"
></A
><P
><B
>Table 16-381. Primary vtable for moneypunct_byname&#60;wchar_t, false&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct_byname&#60;wchar_t, false&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct_byname&#60;wchar_t, false&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct_byname&#60;wchar_t, false&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;wchar_t, false&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::moneypunct_byname&#60;wchar_t, false&#62;  class
is described by <A
HREF="#RTTI-24071"
>Table 16-382</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24071"
></A
><P
><B
>Table 16-382. typeinfo for moneypunct_byname&#60;wchar_t, false&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for moneypunct_byname&#60;wchar_t, false&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54238"
>16.1.127.2. Interfaces for Class moneypunct_byname&#60;wchar_t, false&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct_byname&#60;wchar_t, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWU-INTS"
>Table 16-383</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWU-INTS"
></A
><P
><B
>Table 16-383. libstdcxx - Class moneypunct_byname&#60;wchar_t, false&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;wchar_t, false&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;wchar_t, false&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;wchar_t, false&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct_byname&#60;wchar_t, false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWU-DATA"
>Table 16-384</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWU-DATA"
></A
><P
><B
>Table 16-384. libstdcxx - Class moneypunct_byname&#60;wchar_t, false&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;wchar_t, false&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct_byname&#60;wchar_t, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct_byname&#60;wchar_t, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct_byname&#60;wchar_t, false&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54287"
>16.1.128. Class moneypunct_byname&#60;wchar_t, true&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54290"
>16.1.128.1. Class data for moneypunct_byname&#60;wchar_t, true&#62;</A
></H4
><P
></P
><P
>The virtual table for the std::moneypunct_byname&#60;wchar_t, true&#62; class
is described by <A
HREF="#CLS-24268-0"
>Table 16-385</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24268-0"
></A
><P
><B
>Table 16-385. Primary vtable for moneypunct_byname&#60;wchar_t, true&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for moneypunct_byname&#60;wchar_t, true&#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>moneypunct_byname&#60;wchar_t, true&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>moneypunct_byname&#60;wchar_t, true&#62;::~moneypunct_byname()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_decimal_point() const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_thousands_sep() const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_grouping() const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_curr_symbol() const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_positive_sign() const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_negative_sign() const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_frac_digits() const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_pos_format() const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>moneypunct&#60;wchar_t, true&#62;::do_neg_format() const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::moneypunct_byname&#60;wchar_t, true&#62;  class
is described by <A
HREF="#RTTI-24070"
>Table 16-386</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24070"
></A
><P
><B
>Table 16-386. typeinfo for moneypunct_byname&#60;wchar_t, true&#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for moneypunct_byname&#60;wchar_t, true&#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54381"
>16.1.128.2. Interfaces for Class moneypunct_byname&#60;wchar_t, true&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::moneypunct_byname&#60;wchar_t, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWV-INTS"
>Table 16-387</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWV-INTS"
></A
><P
><B
>Table 16-387. libstdcxx - Class moneypunct_byname&#60;wchar_t, true&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;wchar_t, true&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;wchar_t, true&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct_byname&#60;wchar_t, true&#62;::~moneypunct_byname()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::moneypunct_byname&#60;wchar_t, true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWV-DATA"
>Table 16-388</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWV-DATA"
></A
><P
><B
>Table 16-388. libstdcxx - Class moneypunct_byname&#60;wchar_t, true&#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>moneypunct_byname&#60;wchar_t, true&#62;::intl(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for moneypunct_byname&#60;wchar_t, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for moneypunct_byname&#60;wchar_t, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for moneypunct_byname&#60;wchar_t, true&#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54430"
>16.1.129. Class money_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54433"
>16.1.129.1. Class data for money_base</A
></H4
><P
></P
><P
>The Run Time Type Information for the std::money_base  class
is described by <A
HREF="#RTTI-24010"
>Table 16-389</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24010"
></A
><P
><B
>Table 16-389. typeinfo for money_base</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for money_base</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54452"
>16.1.129.2. Interfaces for Class money_base</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::money_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAWW-INTS"
>Table 16-390</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWW-INTS"
></A
><P
><B
>Table 16-390. libstdcxx - Class money_base Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>money_base::_S_construct_pattern(char, char, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::money_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAWW-DATA"
>Table 16-391</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWW-DATA"
></A
><P
><B
>Table 16-391. libstdcxx - Class money_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>money_base::_S_default_pattern(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_base::_S_atoms(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for money_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for money_base(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54491"
>16.1.130. Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54494"
>16.1.130.1. Class data for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::money_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24281-0"
>Table 16-392</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24281-0"
></A
><P
><B
>Table 16-392. Primary vtable for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_get()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_get()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::money_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24081"
>Table 16-393</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24081"
></A
><P
><B
>Table 16-393. typeinfo for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54550"
>16.1.130.2. Interfaces for Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::money_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWX-INTS"
>Table 16-394</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWX-INTS"
></A
><P
><B
>Table 16-394. libstdcxx - Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract&#60;false&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract&#60;true&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::money_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWX-DATA"
>Table 16-395</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWX-DATA"
></A
><P
><B
>Table 16-395. libstdcxx - Class money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54634"
>16.1.131. Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54637"
>16.1.131.1. Class data for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::money_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24267-0"
>Table 16-396</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24267-0"
></A
><P
><B
>Table 16-396. Primary vtable for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_get()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_get()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::money_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24069"
>Table 16-397</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24069"
></A
><P
><B
>Table 16-397. typeinfo for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54693"
>16.1.131.2. Interfaces for Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::money_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWY-INTS"
>Table 16-398</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWY-INTS"
></A
><P
><B
>Table 16-398. libstdcxx - Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract&#60;false&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract&#60;true&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::money_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWY-DATA"
>Table 16-399</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWY-DATA"
></A
><P
><B
>Table 16-399. libstdcxx - Class money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54777"
>16.1.132. Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54780"
>16.1.132.1. Class data for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::money_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24280-0"
>Table 16-400</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24280-0"
></A
><P
><B
>Table 16-400. Primary vtable for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_put()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_put()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, char, long double) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, char, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::money_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24080"
>Table 16-401</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24080"
></A
><P
><B
>Table 16-401. typeinfo for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54836"
>16.1.132.2. Interfaces for Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::money_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWZ-INTS"
>Table 16-402</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWZ-INTS"
></A
><P
><B
>Table 16-402. libstdcxx - Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, char, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, char, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, char, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, bool, ios_base&#38;, char, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert&#60;false&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert&#60;true&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~money_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::money_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAWZ-DATA"
>Table 16-403</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAWZ-DATA"
></A
><P
><B
>Table 16-403. libstdcxx - Class money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN54920"
>16.1.133. Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54923"
>16.1.133.1. Class data for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::money_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24266-0"
>Table 16-404</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24266-0"
></A
><P
><B
>Table 16-404. Primary vtable for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_put()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_put()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, wchar_t, long double) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, wchar_t, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::money_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24068"
>Table 16-405</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24068"
></A
><P
><B
>Table 16-405. typeinfo for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN54979"
>16.1.133.2. Interfaces for Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::money_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXA-INTS"
>Table 16-406</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXA-INTS"
></A
><P
><B
>Table 16-406. libstdcxx - Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, wchar_t, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, wchar_t, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, wchar_t, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, bool, ios_base&#38;, wchar_t, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert&#60;false&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert&#60;true&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, basic_string&#60;wchar_t, char_traits&#60;wchar_t&#62;, allocator&#60;wchar_t&#62; &#62; const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~money_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::money_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXA-DATA"
>Table 16-407</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXA-DATA"
></A
><P
><B
>Table 16-407. libstdcxx - Class money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN55063"
>16.1.134. Class locale</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55066"
>16.1.134.1. Interfaces for Class locale</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::locale specified in <A
HREF="#TBL-LIBSTDCXX-CLAXB-INTS"
>Table 16-408</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXB-INTS"
></A
><P
><B
>Table 16-408. libstdcxx - Class locale Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>locale::id::_M_id() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::name() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::operator==(locale const&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::_M_coalesce(locale const&#38;, locale const&#38;, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::_S_normalize_category(int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::_Impl::_M_install_facet(locale::id const*, locale::facet const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>locale::_Impl::_M_replace_facet(locale::_Impl const*, locale::id const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>locale::_Impl::~_Impl()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>locale::_Impl::~_Impl()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>locale::global(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::classic()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale::_Impl*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale const&#38;, locale const&#38;, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(char const*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale::_Impl*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale const&#38;, char const*, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale const&#38;, locale const&#38;, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::~locale()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::~locale()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::operator=(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::locale specified in <A
HREF="#TBL-LIBSTDCXX-CLAXB-DATA"
>Table 16-409</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXB-DATA"
></A
><P
><B
>Table 16-409. libstdcxx - Class locale Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>locale::all(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::none(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::time(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::ctype(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::collate(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::numeric(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::messages(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::monetary(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN55245"
>16.1.135. Class locale::facet</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55248"
>16.1.135.1. Class data for locale::facet</A
></H4
><P
></P
><P
>The virtual table for the std::locale::facet class
is described by <A
HREF="#CLS-24255-0"
>Table 16-410</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24255-0"
></A
><P
><B
>Table 16-410. Primary vtable for locale::facet</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for locale::facet</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>locale::facet::~facet()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>locale::facet::~facet()</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::locale::facet  class
is described by <A
HREF="#RTTI-24005"
>Table 16-411</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24005"
></A
><P
><B
>Table 16-411. typeinfo for locale::facet</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for locale::facet</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55294"
>16.1.135.2. Interfaces for Class locale::facet</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::locale::facet specified in <A
HREF="#TBL-LIBSTDCXX-CLAXC-INTS"
>Table 16-412</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXC-INTS"
></A
><P
><B
>Table 16-412. libstdcxx - Class locale::facet Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>locale::facet::_S_get_c_name()(GLIBCXX_3.4.6) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::_S_get_c_locale()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::_S_clone_c_locale(__locale_struct*&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::_S_create_c_locale(__locale_struct*&#38;, char const*, __locale_struct*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::_S_destroy_c_locale(__locale_struct*&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::~facet()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::~facet()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::facet::~facet()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>locale::locale(locale const&#38;, char const*, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::locale::facet specified in <A
HREF="#TBL-LIBSTDCXX-CLAXC-DATA"
>Table 16-413</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXC-DATA"
></A
><P
><B
>Table 16-413. libstdcxx - Class locale::facet Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__timepunct_cache&#60;char&#62;::_S_timezones(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct_cache&#60;wchar_t&#62;::_S_timezones(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for locale::facet(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for locale::facet(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for locale::facet(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN55378"
>16.1.136. facet functions</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55381"
>16.1.136.1. Interfaces for facet functions</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for facet functions specified in <A
HREF="#TBL-LIBSTDCXX-FACET-INTS"
>Table 16-414</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-FACET-INTS"
></A
><P
><B
>Table 16-414. libstdcxx - facet functions Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>void __convert_to_v&#60;double&#62;(char const*, double&#38;, _Ios_Iostate&#38;, __locale_struct* const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>void __convert_to_v&#60;long double&#62;(char const*, long double&#38;, _Ios_Iostate&#38;, __locale_struct* const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>void __convert_to_v&#60;float&#62;(char const*, float&#38;, _Ios_Iostate&#38;, __locale_struct* const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;moneypunct&#60;char, false&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;moneypunct&#60;wchar_t, false&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;ctype&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;codecvt&#60;char, char, __mbstate_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;codecvt&#60;wchar_t, char, __mbstate_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;collate&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;collate&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;messages&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;messages&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;numpunct&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;numpunct&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>bool has_facet&#60;money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, false&#62; const&#38; use_facet&#60;moneypunct&#60;char, false&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;char, true&#62; const&#38; use_facet&#60;moneypunct&#60;char, true&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, false&#62; const&#38; use_facet&#60;moneypunct&#60;wchar_t, false&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>moneypunct&#60;wchar_t, true&#62; const&#38; use_facet&#60;moneypunct&#60;wchar_t, true&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;char&#62; const&#38; use_facet&#60;__timepunct&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__timepunct&#60;wchar_t&#62; const&#38; use_facet&#60;__timepunct&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;char&#62; const&#38; use_facet&#60;ctype&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ctype&#60;wchar_t&#62; const&#38; use_facet&#60;ctype&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;char, char, __mbstate_t&#62; const&#38; use_facet&#60;codecvt&#60;char, char, __mbstate_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>codecvt&#60;wchar_t, char, __mbstate_t&#62; const&#38; use_facet&#60;codecvt&#60;wchar_t, char, __mbstate_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;char&#62; const&#38; use_facet&#60;collate&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>collate&#60;wchar_t&#62; const&#38; use_facet&#60;collate&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; const&#38; use_facet&#60;num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; const&#38; use_facet&#60;num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; const&#38; use_facet&#60;num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; const&#38; use_facet&#60;num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;char&#62; const&#38; use_facet&#60;messages&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>messages&#60;wchar_t&#62; const&#38; use_facet&#60;messages&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;char&#62; const&#38; use_facet&#60;numpunct&#60;char&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>numpunct&#60;wchar_t&#62; const&#38; use_facet&#60;numpunct&#60;wchar_t&#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; const&#38; use_facet&#60;time_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; const&#38; use_facet&#60;time_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; const&#38; use_facet&#60;time_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; const&#38; use_facet&#60;time_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; const&#38; use_facet&#60;money_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; const&#38; use_facet&#60;money_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; const&#38; use_facet&#60;money_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; const&#38; use_facet&#60;money_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; &#62;(locale const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN55659"
>16.1.137. Class __num_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55662"
>16.1.137.1. Class data for __num_base</A
></H4
><P
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55665"
>16.1.137.2. Interfaces for Class __num_base</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::__num_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAXD-INTS"
>Table 16-415</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXD-INTS"
></A
><P
><B
>Table 16-415. libstdcxx - Class __num_base Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__num_base::_S_format_float(ios_base const&#38;, char*, char)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::__num_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAXD-DATA"
>Table 16-416</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXD-DATA"
></A
><P
><B
>Table 16-416. libstdcxx - Class __num_base Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__num_base::_S_atoms_in(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__num_base::_S_atoms_out(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN55694"
>16.1.138. Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55697"
>16.1.138.1. Class data for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::num_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24278-0"
>Table 16-417</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24278-0"
></A
><P
><B
>Table 16-417. Primary vtable for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_get()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_get()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, bool&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, float&#38;) const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, double&#38;) const</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, void*&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::num_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24078"
>Table 16-418</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24078"
></A
><P
><B
>Table 16-418. typeinfo for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for locale::facet</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN55803"
>16.1.138.2. Interfaces for Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::num_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXE-INTS"
>Table 16-419</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXE-INTS"
></A
><P
><B
>Table 16-419. libstdcxx - Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_int&#60;unsigned int&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_int&#60;long&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_int&#60;unsigned long&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_int&#60;unsigned short&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_int&#60;long long&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_int&#60;unsigned long long&#62;(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_extract_float(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, void*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, bool&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, float&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, void*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, bool&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, float&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::num_get&#60;char, std::istreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXE-DATA"
>Table 16-420</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXE-DATA"
></A
><P
><B
>Table 16-420. libstdcxx - Class num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for num_get&#60;char, istreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56002"
>16.1.139. Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56005"
>16.1.139.1. Class data for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::num_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24264-0"
>Table 16-421</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24264-0"
></A
><P
><B
>Table 16-421. Primary vtable for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_get()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_get()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, bool&#38;) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, float&#38;) const</TD
></TR
><TR
><TD
>vfunc[10]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, double&#38;) const</TD
></TR
><TR
><TD
>vfunc[11]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const</TD
></TR
><TR
><TD
>vfunc[12]:</TD
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, void*&#38;) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::num_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24066"
>Table 16-422</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24066"
></A
><P
><B
>Table 16-422. typeinfo for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for locale::facet</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56111"
>16.1.139.2. Interfaces for Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::num_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXF-INTS"
>Table 16-423</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXF-INTS"
></A
><P
><B
>Table 16-423. libstdcxx - Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_int&#60;unsigned int&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_int&#60;long&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_int&#60;unsigned long&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_int&#60;unsigned short&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_int&#60;long long&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_int&#60;unsigned long long&#62;(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_extract_float(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, basic_string&#60;char, char_traits&#60;char&#62;, allocator&#60;char&#62; &#62;&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, void*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, bool&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, float&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, void*&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, bool&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long double&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, float&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned int&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned short&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_get(istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, _Ios_Iostate&#38;, unsigned long long&#38;) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_get()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::num_get&#60;wchar_t, std::istreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXF-DATA"
>Table 16-424</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXF-DATA"
></A
><P
><B
>Table 16-424. libstdcxx - Class num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for num_get&#60;wchar_t, istreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56310"
>16.1.140. Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56313"
>16.1.140.1. Class data for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::num_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24277-0"
>Table 16-425</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24277-0"
></A
><P
><B
>Table 16-425. Primary vtable for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_put()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_put()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, bool) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long long) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long long) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, double) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long double) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, void const*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::num_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24077"
>Table 16-426</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24077"
></A
><P
><B
>Table 16-426. typeinfo for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for locale::facet</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56404"
>16.1.140.2. Interfaces for Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::num_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXG-INTS"
>Table 16-427</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXG-INTS"
></A
><P
><B
>Table 16-427. libstdcxx - Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert_int&#60;long&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert_int&#60;unsigned long&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert_int&#60;long long&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert_int&#60;unsigned long long&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert_float&#60;double&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, char, double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::_M_insert_float&#60;long double&#62;(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, char, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, void const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, bool) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, void const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, bool) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62;, ios_base&#38;, char, unsigned long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::~num_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::num_put&#60;char, std::ostreambuf_iterator&#60;char, std::char_traits&#60;char&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXG-DATA"
>Table 16-428</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXG-DATA"
></A
><P
><B
>Table 16-428. libstdcxx - Class num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for num_put&#60;char, ostreambuf_iterator&#60;char, char_traits&#60;char&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56568"
>16.1.141. Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56571"
>16.1.141.1. Class data for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
></P
><P
>The virtual table for the std::num_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; class
is described by <A
HREF="#CLS-24263-0"
>Table 16-429</A
></P
><DIV
CLASS="TABLE"
><A
NAME="CLS-24263-0"
></A
><P
><B
>Table 16-429. Primary vtable for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>Virtual Base Offset</TD
><TD
>0</TD
></TR
><TR
><TD
>RTTI</TD
><TD
>typeinfo for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>vfunc[0]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_put()</TD
></TR
><TR
><TD
>vfunc[1]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_put()</TD
></TR
><TR
><TD
>vfunc[2]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, bool) const</TD
></TR
><TR
><TD
>vfunc[3]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long) const</TD
></TR
><TR
><TD
>vfunc[4]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long) const</TD
></TR
><TR
><TD
>vfunc[5]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long long) const</TD
></TR
><TR
><TD
>vfunc[6]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long long) const</TD
></TR
><TR
><TD
>vfunc[7]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, double) const</TD
></TR
><TR
><TD
>vfunc[8]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long double) const</TD
></TR
><TR
><TD
>vfunc[9]:</TD
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, void const*) const</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The Run Time Type Information for the std::num_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62;  class
is described by <A
HREF="#RTTI-24065"
>Table 16-430</A
></P
><DIV
CLASS="TABLE"
><A
NAME="RTTI-24065"
></A
><P
><B
>Table 16-430. typeinfo for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Base Vtable</TD
><TD
>vtable for __cxxabiv1::__si_class_type_info</TD
></TR
><TR
><TD
>Name</TD
><TD
>typeinfo name for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</TD
></TR
><TR
><TD
>basetype:</TD
><TD
>typeinfo for locale::facet</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56662"
>16.1.141.2. Interfaces for Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::num_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXH-INTS"
>Table 16-431</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXH-INTS"
></A
><P
><B
>Table 16-431. libstdcxx - Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert_int&#60;long&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert_int&#60;unsigned long&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert_int&#60;long long&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert_int&#60;unsigned long long&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert_float&#60;double&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, char, double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::_M_insert_float&#60;long double&#62;(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, char, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, void const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, bool) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, void const*) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, bool) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long double) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::do_put(ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62;, ios_base&#38;, wchar_t, unsigned long long) const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::~num_put()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>An LSB conforming implementation shall provide the generic data interfaces
for Class std::num_put&#60;wchar_t, std::ostreambuf_iterator&#60;wchar_t, std::char_traits&#60;wchar_t&#62; &#62; &#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXH-DATA"
>Table 16-432</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXH-DATA"
></A
><P
><B
>Table 16-432. libstdcxx - Class num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62; Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>guard variable for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;::id(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>typeinfo for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>typeinfo name for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
><TR
><TD
>vtable for num_put&#60;wchar_t, ostreambuf_iterator&#60;wchar_t, char_traits&#60;wchar_t&#62; &#62; &#62;(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.1"
>[CXXABI-1.86]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56826"
>16.1.142. Class __basic_file&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56829"
>16.1.142.1. Class data for __basic_file&#60;char&#62;</A
></H4
><P
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56832"
>16.1.142.2. Interfaces for Class __basic_file&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::__basic_file&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXI-INTS"
>Table 16-433</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXI-INTS"
></A
><P
><B
>Table 16-433. libstdcxx - Class __basic_file&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__basic_file&#60;char&#62;::is_open() const(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::fd()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::file()(GLIBCXX_3.4.1) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::open(char const*, _Ios_Openmode, int)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::sync()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::close()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::sys_open(_IO_FILE*, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::sys_open(int, _Ios_Openmode)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::showmanyc()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::__basic_file(pthread_mutex_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::__basic_file(pthread_mutex_t*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::~__basic_file()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>__basic_file&#60;char&#62;::~__basic_file()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56905"
>16.1.143. Class _List_node_base</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56908"
>16.1.143.1. Interfaces for Class _List_node_base</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::_List_node_base specified in <A
HREF="#TBL-LIBSTDCXX-CLAXJ-INTS"
>Table 16-434</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXJ-INTS"
></A
><P
><B
>Table 16-434. libstdcxx - Class _List_node_base Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_List_node_base::hook(_List_node_base*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_List_node_base::swap(_List_node_base&#38;, _List_node_base&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_List_node_base::unhook()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_List_node_base::reverse()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>_List_node_base::transfer(_List_node_base*, _List_node_base*)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56941"
>16.1.144. Class allocator&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56944"
>16.1.144.1. Class data for allocator&#60;char&#62;</A
></H4
><P
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56947"
>16.1.144.2. Interfaces for Class allocator&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::allocator&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXK-INTS"
>Table 16-435</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXK-INTS"
></A
><P
><B
>Table 16-435. libstdcxx - Class allocator&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>allocator&#60;char&#62;::allocator(allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;char&#62;::allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;char&#62;::allocator(allocator&#60;char&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;char&#62;::allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;char&#62;::~allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;char&#62;::~allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56985"
>16.1.145. Class allocator&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56988"
>16.1.145.1. Class data for allocator&#60;wchar_t&#62;</A
></H4
><P
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN56991"
>16.1.145.2. Interfaces for Class allocator&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::allocator&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXL-INTS"
>Table 16-436</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXL-INTS"
></A
><P
><B
>Table 16-436. libstdcxx - Class allocator&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>allocator&#60;wchar_t&#62;::allocator(allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;wchar_t&#62;::allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;wchar_t&#62;::allocator(allocator&#60;wchar_t&#62; const&#38;)(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;wchar_t&#62;::allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;wchar_t&#62;::~allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
><TR
><TD
>allocator&#60;wchar_t&#62;::~allocator()(GLIBCXX_3.4) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN57029"
>16.1.146. Class __gnu_cxx::__pool&#60;true&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN57032"
>16.1.146.1. Interfaces for Class __gnu_cxx::__pool&#60;true&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __gnu_cxx::__pool&#60;true&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXM-INTS"
>Table 16-437</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXM-INTS"
></A
><P
><B
>Table 16-437. libstdcxx - Class __gnu_cxx::__pool&#60;true&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::__pool&#60;true&#62;::_M_destroy()(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__pool&#60;true&#62;::_M_initialize(void (*)(void*))(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__pool&#60;true&#62;::_M_initialize()(GLIBCXX_3.4.6) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__pool&#60;true&#62;::_M_get_thread_id()(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__pool&#60;true&#62;::_M_destroy_thread_key(void*)(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN57065"
>16.1.147. Class __gnu_cxx::__pool&#60;false&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN57068"
>16.1.147.1. Interfaces for Class __gnu_cxx::__pool&#60;false&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __gnu_cxx::__pool&#60;false&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXN-INTS"
>Table 16-438</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXN-INTS"
></A
><P
><B
>Table 16-438. libstdcxx - Class __gnu_cxx::__pool&#60;false&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::__pool&#60;false&#62;::_M_destroy()(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
><TR
><TD
>__gnu_cxx::__pool&#60;false&#62;::_M_initialize()(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN57086"
>16.1.148. Class __gnu_cxx::free_list</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN57089"
>16.1.148.1. Interfaces for Class __gnu_cxx::free_list</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class __gnu_cxx::free_list specified in <A
HREF="#TBL-LIBSTDCXX-CLAXO-INTS"
>Table 16-439</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXO-INTS"
></A
><P
><B
>Table 16-439. libstdcxx - Class __gnu_cxx::free_list Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__gnu_cxx::free_list::_M_clear()(GLIBCXX_3.4.4) <A
HREF="#REFSTD.LIBSTDCXX.3"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN57102"
>16.1.149. Class char_traits&#60;char&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN57105"
>16.1.149.1. Interfaces for Class char_traits&#60;char&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::char_traits&#60;char&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXP-INTS"
>Table 16-440</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXP-INTS"
></A
><P
><B
>Table 16-440. libstdcxx - Class char_traits&#60;char&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>char_traits&#60;char&#62;::eq(char const&#38;, char const&#38;)(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN57118"
>16.1.150. Class char_traits&#60;wchar_t&#62;</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN57121"
>16.1.150.1. Interfaces for Class char_traits&#60;wchar_t&#62;</A
></H4
><P
>An LSB conforming implementation shall provide the generic methods
for Class std::char_traits&#60;wchar_t&#62; specified in <A
HREF="#TBL-LIBSTDCXX-CLAXQ-INTS"
>Table 16-441</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSTDCXX-CLAXQ-INTS"
></A
><P
><B
>Table 16-441. libstdcxx - Class char_traits&#60;wchar_t&#62; Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>char_traits&#60;wchar_t&#62;::eq(wchar_t const&#38;, wchar_t const&#38;)(GLIBCXX_3.4.5) <A
HREF="#REFSTD.LIBSTDCXX.2"
>[ISOCXX]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBSTDCXXMAN"
>16.2. Interface Definitions for libstdcxx</A
></H2
><P
>The interfaces defined on the following pages are included in libstdcxx and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.</P
><P
>Other interfaces listed in <A
HREF="#LIBSTDCXX"
>Section 16.1</A
> shall behave as described
in the referenced base document.</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCCOMMAND"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VI. Commands and Utilities</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>17. <A
HREF="#COMMAND"
>Commands and Utilities</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#CMDUTIL"
>Commands and Utilities</A
></DT
><DT
>17.2. <A
HREF="#CMDBEHAV"
>Command Behavior</A
></DT
><DD
><DL
><DT
><A
HREF="#AR"
>ar</A
>&nbsp;--&nbsp;create and maintain library archives (DEPRECATED)</DT
><DT
><A
HREF="#AT"
>at</A
>&nbsp;--&nbsp;examine or delete jobs for later execution</DT
><DT
><A
HREF="#AWK"
>awk</A
>&nbsp;--&nbsp;pattern scanning and processing language</DT
><DT
><A
HREF="#BATCH"
>batch</A
>&nbsp;--&nbsp;schedule commands to be executed in a batch queue</DT
><DT
><A
HREF="#BC"
>bc</A
>&nbsp;--&nbsp;an arbitrary precision calculator language</DT
><DT
><A
HREF="#CHFN"
>chfn</A
>&nbsp;--&nbsp;change user name and information</DT
><DT
><A
HREF="#CHSH"
>chsh</A
>&nbsp;--&nbsp;change login shell</DT
><DT
><A
HREF="#COL"
>col</A
>&nbsp;--&nbsp;filter reverse line feeds from input</DT
><DT
><A
HREF="#CPIO"
>cpio</A
>&nbsp;--&nbsp;copy file archives in and out</DT
><DT
><A
HREF="#CRONTAB"
>crontab</A
>&nbsp;--&nbsp;maintain crontab files for individual users</DT
><DT
><A
HREF="#DF"
>df</A
>&nbsp;--&nbsp;report file system disk space usage</DT
><DT
><A
HREF="#DMESG"
>dmesg</A
>&nbsp;--&nbsp;print or control the system message buffer</DT
><DT
><A
HREF="#DU"
>du</A
>&nbsp;--&nbsp;estimate file space usage</DT
><DT
><A
HREF="#ECHO"
>echo</A
>&nbsp;--&nbsp;write arguments to standard output</DT
><DT
><A
HREF="#EGREP"
>egrep</A
>&nbsp;--&nbsp;search a file with an Extended Regular Expression pattern</DT
><DT
><A
HREF="#FGREP"
>fgrep</A
>&nbsp;--&nbsp;search a file with a fixed pattern</DT
><DT
><A
HREF="#FILE"
>file</A
>&nbsp;--&nbsp;determine file type</DT
><DT
><A
HREF="#FUSER"
>fuser</A
>&nbsp;--&nbsp;identify processes using files or sockets</DT
><DT
><A
HREF="#GETTEXT"
>gettext</A
>&nbsp;--&nbsp;retrieve text string from message catalog</DT
><DT
><A
HREF="#GREP"
>grep</A
>&nbsp;--&nbsp;print lines matching a pattern</DT
><DT
><A
HREF="#GROUPADD"
>groupadd</A
>&nbsp;--&nbsp;create a new group</DT
><DT
><A
HREF="#GROUPDEL"
>groupdel</A
>&nbsp;--&nbsp;delete a group</DT
><DT
><A
HREF="#GROUPMOD"
>groupmod</A
>&nbsp;--&nbsp;modify a group</DT
><DT
><A
HREF="#GROUPS"
>groups</A
>&nbsp;--&nbsp;display a group</DT
><DT
><A
HREF="#GUNZIP"
>gunzip</A
>&nbsp;--&nbsp;uncompress files</DT
><DT
><A
HREF="#GZIP"
>gzip</A
>&nbsp;--&nbsp;compress or expand files</DT
><DT
><A
HREF="#HOSTNAME"
>hostname</A
>&nbsp;--&nbsp;show or set the system's host name</DT
><DT
><A
HREF="#INSTALL"
>install</A
>&nbsp;--&nbsp;copy files and set attributes</DT
><DT
><A
HREF="#INSTALLINITD"
>install_initd</A
>&nbsp;--&nbsp;activate an init script</DT
><DT
><A
HREF="#IPCRM"
>ipcrm</A
>&nbsp;--&nbsp;remove IPC Resources</DT
><DT
><A
HREF="#IPCS"
>ipcs</A
>&nbsp;--&nbsp;provide information on ipc facilities</DT
><DT
><A
HREF="#KILLALL"
>killall</A
>&nbsp;--&nbsp;kill processes by name</DT
><DT
><A
HREF="#LPR"
>lpr</A
>&nbsp;--&nbsp;off line print</DT
><DT
><A
HREF="#LS"
>ls</A
>&nbsp;--&nbsp;list directory contents</DT
><DT
><A
HREF="#LSBRELEASE"
>lsb_release</A
>&nbsp;--&nbsp;print distribution specific information</DT
><DT
><A
HREF="#M4"
>m4</A
>&nbsp;--&nbsp;macro processor</DT
><DT
><A
HREF="#MD5SUM"
>md5sum</A
>&nbsp;--&nbsp;generate or check MD5 message digests</DT
><DT
><A
HREF="#MKNOD"
>mknod</A
>&nbsp;--&nbsp;make special files</DT
><DT
><A
HREF="#MKTEMP"
>mktemp</A
>&nbsp;--&nbsp;make temporary file name (unique)</DT
><DT
><A
HREF="#MORE"
>more</A
>&nbsp;--&nbsp;display files on a page-by-page basis</DT
><DT
><A
HREF="#MOUNT"
>mount</A
>&nbsp;--&nbsp;mount a file system </DT
><DT
><A
HREF="#MSGFMT"
>msgfmt</A
>&nbsp;--&nbsp;create a message object from a message file </DT
><DT
><A
HREF="#NEWGRP"
>newgrp</A
>&nbsp;--&nbsp;change group ID</DT
><DT
><A
HREF="#OD"
>od</A
>&nbsp;--&nbsp;dump files in octal and other formats </DT
><DT
><A
HREF="#PASSWD"
>passwd</A
>&nbsp;--&nbsp;change user password</DT
><DT
><A
HREF="#PATCH"
>patch</A
>&nbsp;--&nbsp;apply a diff file to an original</DT
><DT
><A
HREF="#PIDOF"
>pidof</A
>&nbsp;--&nbsp;find the process ID of a running program</DT
><DT
><A
HREF="#REMOVEINITD"
>remove_initd</A
>&nbsp;--&nbsp;clean up init script system modifications introduced by install_initd</DT
><DT
><A
HREF="#RENICE"
>renice</A
>&nbsp;--&nbsp;alter priority of running processes</DT
><DT
><A
HREF="#SED"
>sed</A
>&nbsp;--&nbsp;stream editor</DT
><DT
><A
HREF="#BASELIB-SENDMAIL-1"
>sendmail</A
>&nbsp;--&nbsp;an electronic mail transport agent</DT
><DT
><A
HREF="#SEQ"
>seq</A
>&nbsp;--&nbsp;generate a sequence of numbers</DT
><DT
><A
HREF="#SH"
>sh</A
>&nbsp;--&nbsp;shell, the standard command language interpreter</DT
><DT
><A
HREF="#SHUTDOWN"
>shutdown</A
>&nbsp;--&nbsp;shut the system down</DT
><DT
><A
HREF="#SU"
>su</A
>&nbsp;--&nbsp;change user ID</DT
><DT
><A
HREF="#SYNC"
>sync</A
>&nbsp;--&nbsp;flush file system buffers</DT
><DT
><A
HREF="#TAR"
>tar</A
>&nbsp;--&nbsp;file archiver</DT
><DT
><A
HREF="#UMOUNT"
>umount</A
>&nbsp;--&nbsp;unmount file systems</DT
><DT
><A
HREF="#USERADD"
>useradd</A
>&nbsp;--&nbsp;create a new user or update default new user information</DT
><DT
><A
HREF="#USERDEL"
>userdel</A
>&nbsp;--&nbsp;delete a user account and related files</DT
><DT
><A
HREF="#USERMOD"
>usermod</A
>&nbsp;--&nbsp;modify a user account</DT
><DT
><A
HREF="#XARGS"
>xargs</A
>&nbsp;--&nbsp;build and execute command lines from standard input</DT
><DT
><A
HREF="#ZCAT"
>zcat</A
>&nbsp;--&nbsp;uncompress files to standard output</DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="COMMAND"
></A
>Chapter 17. Commands and Utilities</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="CMDUTIL"
>17.1. Commands and Utilities</A
></H2
><P
>An LSB conforming implementation shall provide the
commands and utilities as described in <A
HREF="#TBL-CMDS"
>Table 17-1</A
>, with at least the behavior
described as mandatory in the referenced underlying
specification, with the following exceptions:
<P
></P
><OL
TYPE="1"
><LI
><P
>If any operand (except one which follows <CODE
CLASS="OPTION"
>--</CODE
>) starts with a
hyphen, the behavior is unspecified.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale (Informative): </B
>Applications should place options before operands, or use
<CODE
CLASS="OPTION"
>--</CODE
>, as needed.  This text is needed because,
by default, GNU option parsing
differs from POSIX, unless the environment variable 
<CODE
CLASS="ENVAR"
>POSIXLY_CORRECT</CODE
>
is set.  For example, <B
CLASS="COMMAND"
>ls . -a</B
> in GNU
<B
CLASS="COMMAND"
>ls</B
> means to list the current directory, showing all
files (that is, <CODE
CLASS="OPTION"
>"."</CODE
> is an operand and <CODE
CLASS="OPTION"
>-a</CODE
> is an
option).  In POSIX, <CODE
CLASS="OPTION"
>"."</CODE
> and <CODE
CLASS="OPTION"
>-a</CODE
> are both operands,
and the command means to list the current directory, and also the file
named <TT
CLASS="FILENAME"
>-a</TT
>.  Suggesting that applications rely on the
setting of the <CODE
CLASS="ENVAR"
>POSIXLY_CORRECT</CODE
> environment variable,
or try to set it, seems worse than just asking the applications to invoke
commands in ways which work with either the POSIX or GNU behaviors.</P
></BLOCKQUOTE
></DIV
></P
></LI
></OL
></P
><DIV
CLASS="TABLE"
><A
NAME="TBL-CMDS"
></A
><P
><B
>Table 17-1. Commands And Utilities</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>[
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>du
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>install
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>mv
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>strings
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>ar
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>echo
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>install_initd
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>newgrp
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>strip
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>at
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>ed
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>ipcrm
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>nice
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>stty
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>awk
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>egrep
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>ipcs
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>nl
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>su
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>basename
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>env
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>join
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>nohup
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>sync
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>batch
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>expand
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>kill
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>od
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>tail
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>bc
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>expr
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>killall
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>passwd
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>tar
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>cat
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>false
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>ln
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>paste
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>tee
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>chfn
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>fgrep
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>locale
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>patch
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>test
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>chgrp
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>file
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>localedef
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>pathchk
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>tic
<A
HREF="#AEN57485"
> [3]</A
></TD
></TR
><TR
><TD
>chmod
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>find
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>logger
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>pax
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>time
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>chown
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>fold
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>logname
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>pidof
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>touch
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>chsh
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>fuser
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>lp
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>pr
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>tput
<A
HREF="#AEN57485"
> [3]</A
></TD
></TR
><TR
><TD
>cksum
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>gencat
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>lpr
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>printf
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>tr
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>cmp
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>getconf
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>ls
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>ps
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>true
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>col
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>gettext
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>lsb_release
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>pwd
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>tsort
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>comm
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>grep
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>m4
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>remove_initd
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>tty
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>cp
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>groupadd
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>mailx
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>renice
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>umount
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>cpio
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>groupdel
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>make
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>rm
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>uname
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>crontab
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>groupmod
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>man
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>rmdir
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>unexpand
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>csplit
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>groups
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>md5sum
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>sed
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>uniq
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>cut
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>gunzip
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>mkdir
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>sendmail
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>useradd
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>date
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>gzip
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>mkfifo
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>seq
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>userdel
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>dd
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>head
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>mknod
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>sh
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>usermod
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>df
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>hostname
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>mktemp
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>shutdown
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>wc
<A
HREF="#AEN57477"
> [1]</A
></TD
></TR
><TR
><TD
>diff
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>iconv
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>more
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>sleep
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>xargs
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>dirname
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>id
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>mount
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>sort
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>zcat
<A
HREF="#AEN57481"
> [2]</A
></TD
></TR
><TR
><TD
>dmesg
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>infocmp
<A
HREF="#AEN57485"
> [3]</A
></TD
><TD
>msgfmt
<A
HREF="#AEN57481"
> [2]</A
></TD
><TD
>split
<A
HREF="#AEN57477"
> [1]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
><I
CLASS="EMPHASIS"
>Referenced Specification(s)</I
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[1]. </B
></B
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></P
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[2]. </B
></B
><A
HREF="#STD.LSB"
>This Specification</A
></P
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[3]. </B
></B
><A
HREF="#STD.LIBNCURSESW"
>Libncursesw API</A
></P
></DIV
><P
>An LSB conforming implementation shall provide the
shell built in utilities as described in <A
HREF="#TBL-BUILTINS"
>Table 17-2</A
>, with at least the behavior
described as mandatory in the referenced underlying
specification, with the following exceptions:
<P
></P
><OL
TYPE="1"
><LI
><P
>The built in commands and utilities shall be provided by the
<B
CLASS="COMMAND"
>sh</B
> utility itself, and need not 
be implemented in a manner so that they can be accessed via the 
exec family of functions as defined in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
and should not be invoked directly by those standard utilities 
that execute other utilities (
<B
CLASS="COMMAND"
>env</B
>, <B
CLASS="COMMAND"
>find</B
>, <B
CLASS="COMMAND"
>nice</B
>, <B
CLASS="COMMAND"
>nohup</B
>, <B
CLASS="COMMAND"
>time</B
>, <B
CLASS="COMMAND"
>xargs</B
>).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale (Informative): </B
>Since the built in utilities must affect the environment of the calling
process, they have no effect when executed as a file.</P
></BLOCKQUOTE
></DIV
></P
></LI
></OL
></P
><DIV
CLASS="TABLE"
><A
NAME="TBL-BUILTINS"
></A
><P
><B
>Table 17-2. Built In Utilities</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>alias
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>command
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>getopts
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>read
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>umask
<A
HREF="#AEN57551"
> [1]</A
></TD
></TR
><TR
><TD
>bg
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>fc
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>hash
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>type
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>unalias
<A
HREF="#AEN57551"
> [1]</A
></TD
></TR
><TR
><TD
>cd
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>fg
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>jobs
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>ulimit
<A
HREF="#AEN57551"
> [1]</A
></TD
><TD
>wait
<A
HREF="#AEN57551"
> [1]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><P
><I
CLASS="EMPHASIS"
>Referenced Specification(s)</I
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><B
>[1]. </B
></B
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CMDBEHAV"
>17.2. Command Behavior</A
></H2
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AR"
>ar</A
>&nbsp;--&nbsp;create and maintain library archives (DEPRECATED)</DT
><DT
><A
HREF="#AT"
>at</A
>&nbsp;--&nbsp;examine or delete jobs for later execution</DT
><DT
><A
HREF="#AWK"
>awk</A
>&nbsp;--&nbsp;pattern scanning and processing language</DT
><DT
><A
HREF="#BATCH"
>batch</A
>&nbsp;--&nbsp;schedule commands to be executed in a batch queue</DT
><DT
><A
HREF="#BC"
>bc</A
>&nbsp;--&nbsp;an arbitrary precision calculator language</DT
><DT
><A
HREF="#CHFN"
>chfn</A
>&nbsp;--&nbsp;change user name and information</DT
><DT
><A
HREF="#CHSH"
>chsh</A
>&nbsp;--&nbsp;change login shell</DT
><DT
><A
HREF="#COL"
>col</A
>&nbsp;--&nbsp;filter reverse line feeds from input</DT
><DT
><A
HREF="#CPIO"
>cpio</A
>&nbsp;--&nbsp;copy file archives in and out</DT
><DT
><A
HREF="#CRONTAB"
>crontab</A
>&nbsp;--&nbsp;maintain crontab files for individual users</DT
><DT
><A
HREF="#DF"
>df</A
>&nbsp;--&nbsp;report file system disk space usage</DT
><DT
><A
HREF="#DMESG"
>dmesg</A
>&nbsp;--&nbsp;print or control the system message buffer</DT
><DT
><A
HREF="#DU"
>du</A
>&nbsp;--&nbsp;estimate file space usage</DT
><DT
><A
HREF="#ECHO"
>echo</A
>&nbsp;--&nbsp;write arguments to standard output</DT
><DT
><A
HREF="#EGREP"
>egrep</A
>&nbsp;--&nbsp;search a file with an Extended Regular Expression pattern</DT
><DT
><A
HREF="#FGREP"
>fgrep</A
>&nbsp;--&nbsp;search a file with a fixed pattern</DT
><DT
><A
HREF="#FILE"
>file</A
>&nbsp;--&nbsp;determine file type</DT
><DT
><A
HREF="#FUSER"
>fuser</A
>&nbsp;--&nbsp;identify processes using files or sockets</DT
><DT
><A
HREF="#GETTEXT"
>gettext</A
>&nbsp;--&nbsp;retrieve text string from message catalog</DT
><DT
><A
HREF="#GREP"
>grep</A
>&nbsp;--&nbsp;print lines matching a pattern</DT
><DT
><A
HREF="#GROUPADD"
>groupadd</A
>&nbsp;--&nbsp;create a new group</DT
><DT
><A
HREF="#GROUPDEL"
>groupdel</A
>&nbsp;--&nbsp;delete a group</DT
><DT
><A
HREF="#GROUPMOD"
>groupmod</A
>&nbsp;--&nbsp;modify a group</DT
><DT
><A
HREF="#GROUPS"
>groups</A
>&nbsp;--&nbsp;display a group</DT
><DT
><A
HREF="#GUNZIP"
>gunzip</A
>&nbsp;--&nbsp;uncompress files</DT
><DT
><A
HREF="#GZIP"
>gzip</A
>&nbsp;--&nbsp;compress or expand files</DT
><DT
><A
HREF="#HOSTNAME"
>hostname</A
>&nbsp;--&nbsp;show or set the system's host name</DT
><DT
><A
HREF="#INSTALL"
>install</A
>&nbsp;--&nbsp;copy files and set attributes</DT
><DT
><A
HREF="#INSTALLINITD"
>install_initd</A
>&nbsp;--&nbsp;activate an init script</DT
><DT
><A
HREF="#IPCRM"
>ipcrm</A
>&nbsp;--&nbsp;remove IPC Resources</DT
><DT
><A
HREF="#IPCS"
>ipcs</A
>&nbsp;--&nbsp;provide information on ipc facilities</DT
><DT
><A
HREF="#KILLALL"
>killall</A
>&nbsp;--&nbsp;kill processes by name</DT
><DT
><A
HREF="#LPR"
>lpr</A
>&nbsp;--&nbsp;off line print</DT
><DT
><A
HREF="#LS"
>ls</A
>&nbsp;--&nbsp;list directory contents</DT
><DT
><A
HREF="#LSBRELEASE"
>lsb_release</A
>&nbsp;--&nbsp;print distribution specific information</DT
><DT
><A
HREF="#M4"
>m4</A
>&nbsp;--&nbsp;macro processor</DT
><DT
><A
HREF="#MD5SUM"
>md5sum</A
>&nbsp;--&nbsp;generate or check MD5 message digests</DT
><DT
><A
HREF="#MKNOD"
>mknod</A
>&nbsp;--&nbsp;make special files</DT
><DT
><A
HREF="#MKTEMP"
>mktemp</A
>&nbsp;--&nbsp;make temporary file name (unique)</DT
><DT
><A
HREF="#MORE"
>more</A
>&nbsp;--&nbsp;display files on a page-by-page basis</DT
><DT
><A
HREF="#MOUNT"
>mount</A
>&nbsp;--&nbsp;mount a file system </DT
><DT
><A
HREF="#MSGFMT"
>msgfmt</A
>&nbsp;--&nbsp;create a message object from a message file </DT
><DT
><A
HREF="#NEWGRP"
>newgrp</A
>&nbsp;--&nbsp;change group ID</DT
><DT
><A
HREF="#OD"
>od</A
>&nbsp;--&nbsp;dump files in octal and other formats </DT
><DT
><A
HREF="#PASSWD"
>passwd</A
>&nbsp;--&nbsp;change user password</DT
><DT
><A
HREF="#PATCH"
>patch</A
>&nbsp;--&nbsp;apply a diff file to an original</DT
><DT
><A
HREF="#PIDOF"
>pidof</A
>&nbsp;--&nbsp;find the process ID of a running program</DT
><DT
><A
HREF="#REMOVEINITD"
>remove_initd</A
>&nbsp;--&nbsp;clean up init script system modifications introduced by install_initd</DT
><DT
><A
HREF="#RENICE"
>renice</A
>&nbsp;--&nbsp;alter priority of running processes</DT
><DT
><A
HREF="#SED"
>sed</A
>&nbsp;--&nbsp;stream editor</DT
><DT
><A
HREF="#BASELIB-SENDMAIL-1"
>sendmail</A
>&nbsp;--&nbsp;an electronic mail transport agent</DT
><DT
><A
HREF="#SEQ"
>seq</A
>&nbsp;--&nbsp;generate a sequence of numbers</DT
><DT
><A
HREF="#SH"
>sh</A
>&nbsp;--&nbsp;shell, the standard command language interpreter</DT
><DT
><A
HREF="#SHUTDOWN"
>shutdown</A
>&nbsp;--&nbsp;shut the system down</DT
><DT
><A
HREF="#SU"
>su</A
>&nbsp;--&nbsp;change user ID</DT
><DT
><A
HREF="#SYNC"
>sync</A
>&nbsp;--&nbsp;flush file system buffers</DT
><DT
><A
HREF="#TAR"
>tar</A
>&nbsp;--&nbsp;file archiver</DT
><DT
><A
HREF="#UMOUNT"
>umount</A
>&nbsp;--&nbsp;unmount file systems</DT
><DT
><A
HREF="#USERADD"
>useradd</A
>&nbsp;--&nbsp;create a new user or update default new user information</DT
><DT
><A
HREF="#USERDEL"
>userdel</A
>&nbsp;--&nbsp;delete a user account and related files</DT
><DT
><A
HREF="#USERMOD"
>usermod</A
>&nbsp;--&nbsp;modify a user account</DT
><DT
><A
HREF="#XARGS"
>xargs</A
>&nbsp;--&nbsp;build and execute command lines from standard input</DT
><DT
><A
HREF="#ZCAT"
>zcat</A
>&nbsp;--&nbsp;uncompress files to standard output</DT
></DL
></DIV
><P
>This section contains descriptions for commands and utilities whose
specified behavior in the LSB contradicts or extends the standards
referenced. It also contains commands and utilities only required by
the LSB and not specified by other standards.</P
><H1
><A
NAME="AR"
></A
>ar</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57561"
></A
><H2
>Name</H2
>ar&nbsp;--&nbsp;create and maintain library archives (DEPRECATED)</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57564"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>ar</B
> is deprecated from the LSB and is expected to
disappear from a future version of the LSB.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The LSB generally does not include software development utilities nor
does it specify .o and .a file formats.</P
></BLOCKQUOTE
></DIV
></P
><P
><B
CLASS="COMMAND"
>ar</B
> is as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57574"
></A
><H2
>Differences</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57577"
></A
><SPAN
STYLE="white-space: nowrap"
>-T</SPAN
>, <SPAN
STYLE="white-space: nowrap"
>-C</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be accepted.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57582"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57586"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior; using -r is suggested.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="AT"
></A
>at</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57593"
></A
><H2
>Name</H2
>at&nbsp;--&nbsp;examine or delete jobs for later execution</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57596"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>at</B
> is as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57601"
></A
><H2
>Differences</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN57603"
></A
><H3
>Options</H3
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57606"
></A
><SPAN
STYLE="white-space: nowrap"
>-d</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is functionally equivalent to the -r option specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57611"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be supported, but the '-d' option is equivalent.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57615"
></A
><SPAN
STYLE="white-space: nowrap"
>-t time</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>need not be supported.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN57619"
></A
><H3
>Optional Control Files</H3
><P
>The implementation shall support the XSI optional behavior 
for access control; however the files 
<TT
CLASS="FILENAME"
>at.allow</TT
> and 
<TT
CLASS="FILENAME"
>at.deny</TT
> may reside in 
<TT
CLASS="FILENAME"
>/etc</TT
> rather than 
<TT
CLASS="FILENAME"
>/usr/lib/cron</TT
>.</P
></DIV
></DIV
><H1
><A
NAME="AWK"
></A
>awk</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57629"
></A
><H2
>Name</H2
>awk&nbsp;--&nbsp;pattern scanning and processing language</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57632"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>awk</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57637"
></A
><H2
>Differences</H2
><P
>Certain aspects of internationalized regular expressions are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
>.</P
></DIV
><H1
><A
NAME="BATCH"
></A
>batch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57644"
></A
><H2
>Name</H2
>batch&nbsp;--&nbsp;schedule commands to be executed in a batch queue</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57647"
></A
><H2
>Description</H2
><P
>The specification for <B
CLASS="COMMAND"
>batch</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN57652"
></A
><H3
>Optional Control Files</H3
><P
>The implementation shall support the XSI optional behavior 
for access control; however the files 
<TT
CLASS="FILENAME"
>at.allow</TT
> and 
<TT
CLASS="FILENAME"
>at.deny</TT
> may reside in 
<TT
CLASS="FILENAME"
>/etc</TT
> rather than 
<TT
CLASS="FILENAME"
>/usr/lib/cron</TT
>.</P
></DIV
></DIV
><H1
><A
NAME="BC"
></A
>bc</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57662"
></A
><H2
>Name</H2
>bc&nbsp;--&nbsp;an arbitrary precision calculator language</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57665"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>bc</B
> is as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> but with
extensions as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57670"
></A
><H2
>Extensions</H2
><P
>The bc language may be extended in an implementation defined manner. If an
implementation supports extensions, it shall also support the additional
options:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57674"
></A
><SPAN
STYLE="white-space: nowrap"
>-s|--standard</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>processes exactly the POSIX <B
CLASS="COMMAND"
>bc</B
> language.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57679"
></A
><SPAN
STYLE="white-space: nowrap"
>-w|--warn</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>gives warnings for extensions to POSIX bc.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
><H1
><A
NAME="CHFN"
></A
>chfn</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57686"
></A
><H2
>Name</H2
>chfn&nbsp;--&nbsp;change user name and information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN57689"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>chfn</B
> [-f <TT
CLASS="REPLACEABLE"
><I
>full_name</I
></TT
>] [-h <TT
CLASS="REPLACEABLE"
><I
>home_phone</I
></TT
>] [user]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57697"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>chfn</B
> shall update the user database.
An unprivileged user may only change the fields for their own account, 
a user with appropriate privileges may change the fields for any account.</P
><P
>The fields <TT
CLASS="PARAMETER"
><I
>full_name</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>home_phone</I
></TT
> may contain any
character except:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>any control character</TD
></TR
><TR
><TD
>comma</TD
></TR
><TR
><TD
>colon</TD
></TR
><TR
><TD
>equal sign</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>If none of the options are selected, <B
CLASS="COMMAND"
>chfn</B
> operates 
in an interactive fashion. The prompts and expected input in interactive 
mode are unspecified and should not be relied upon.</P
><P
>As it is possible for the system to be configured to restrict which
fields a non-privileged user is permitted to change, applications
should be written to gracefully handle these situations.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57712"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57715"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-f <TT
CLASS="REPLACEABLE"
><I
>full_name</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's full name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57721"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-h <TT
CLASS="REPLACEABLE"
><I
>home_phone</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's home phone number.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57727"
></A
><H2
>Future Directions</H2
><P
>The following two options are expected to be added in a future
version of the LSB:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57731"
></A
><SPAN
STYLE="white-space: nowrap"
>-o office</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's office room number.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57735"
></A
><SPAN
STYLE="white-space: nowrap"
>-p office_phone</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the user's office phone number.</P
></TD
></TR
></TBODY
></TABLE
><P
>Note that some implementations contain a "-o other" option which
specifies an additional field called "other".  Traditionally, this
field is not subject to the constraints about legitimate characters in
fields.  Also, one traditionally shall have appropriate privileges to
change the other field.  At this point there is no consensus about
whether it is desirable to specify the other field; applications may
wish to avoid using it.</P
><P
>The "-w work_phone" field found in some implementations should be
replaced by the "-p office_phone" field.  The "-r room_number" field
found in some implementations is the equivalent of the "-o office"
option mentioned above; which one of these two options to specify will
depend on implementation experience and the decision regarding the
other field.</P
></DIV
><H1
><A
NAME="CHSH"
></A
>chsh</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57744"
></A
><H2
>Name</H2
>chsh&nbsp;--&nbsp;change login shell</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN57747"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>chsh</B
> [-s <TT
CLASS="REPLACEABLE"
><I
>login_shell</I
></TT
>] [<TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
>]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57754"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>chsh</B
> changes the user login shell.  This determines 
the name of the
user's initial login command.  An unprivileged user may only change the login
shell for their own account, a user with appropriate privilege may change the login shell
for any account specified by <TT
CLASS="PARAMETER"
><I
>user</I
></TT
>.</P
><P
>Unless the user has appropriate privilege, the initial login command name 
shall be one of those listed in 
<TT
CLASS="FILENAME"
>/etc/shells</TT
>.
The <TT
CLASS="PARAMETER"
><I
>login_shell</I
></TT
> shall be the absolute path
(i.e. it must start with '<TT
CLASS="FILENAME"
>/</TT
>') to an executable file.
Accounts which are restricted (in an implementation-defined manner)
may not change their login shell.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
>
option is not selected, <B
CLASS="COMMAND"
>chsh</B
> operates in 
an interactive mode. The prompts and expected input in this mode are
unspecified.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57766"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57769"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-s <TT
CLASS="REPLACEABLE"
><I
>login_shell</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the login shell. </P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="COL"
></A
>col</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57778"
></A
><H2
>Name</H2
>col&nbsp;--&nbsp;filter reverse line feeds from input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57781"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>col</B
> is as specified in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
> but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57786"
></A
><H2
>Differences</H2
><P
>The 
<TT
CLASS="PARAMETER"
><I
>-p</I
></TT
> option has unspecified behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Although <B
CLASS="COMMAND"
>col</B
> is shown as legacy in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, it is
not (yet) deprecated in the LSB.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="CPIO"
></A
>cpio</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57797"
></A
><H2
>Name</H2
>cpio&nbsp;--&nbsp;copy file archives in and out</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57800"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>cpio</B
> is as specified in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57805"
></A
><H2
>Differences</H2
><P
>Some elements of the Pattern Matching Notation are optional;
see <A
HREF="#LOCALIZATION-GLOB"
>Pattern Matching Notation</A
>.</P
></DIV
><H1
><A
NAME="CRONTAB"
></A
>crontab</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57812"
></A
><H2
>Name</H2
>crontab&nbsp;--&nbsp;maintain crontab files for individual users</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN57815"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>crontab</B
> [-u user]  file <BR><B
CLASS="COMMAND"
>crontab</B
> [-u user] {-l | -r | -e}</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57827"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>crontab</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57832"
></A
><H2
>Optional Control Files</H2
><P
>The implementation shall support the XSI optional behavior 
for access control; however the files 
<TT
CLASS="FILENAME"
>cron.allow</TT
> and 
<TT
CLASS="FILENAME"
>cron.deny</TT
> may reside in 
<TT
CLASS="FILENAME"
>/etc</TT
> rather than 
<TT
CLASS="FILENAME"
>/usr/lib/cron</TT
>.</P
></DIV
><H1
><A
NAME="DF"
></A
>df</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57842"
></A
><H2
>Name</H2
>df&nbsp;--&nbsp;report file system disk space usage</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57845"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>df</B
> command shall behave as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57850"
></A
><H2
>Differences</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN57852"
></A
><H3
>Options</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
> option is not specified, 
disk space is shown in unspecified
units.  If the <TT
CLASS="PARAMETER"
><I
>-P</I
></TT
> option is specified,
the size of the unit shall be printed on the header line in the format 
<TT
CLASS="LITERAL"
>"%4s-blocks"</TT
>.
Applications should specify <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
>.</P
><P
>The XSI option <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
> has unspecified behavior.
Applications should not specify <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The most common implementation of <B
CLASS="COMMAND"
>df</B
> uses
the <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
> option for a different purpose
(restricting output to a particular file system type), and
use of <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
> is therefore non-portable.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN57868"
></A
><H3
>Operand May Identify Special File</H3
><P
>If  an argument is the absolute file name of a special file
containing a mounted file system, <B
CLASS="COMMAND"
>df</B
>
shall show  the  space
available on that file system rather than on the file system
containing the special file (which  is  typically  the  root
file system).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> the XSI optional behavior permits
an operand to name a special file, but appears to require the
operation be performed on the file system containing the special file.
A defect report has been submitted for this case.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="DMESG"
></A
>dmesg</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57878"
></A
><H2
>Name</H2
>dmesg&nbsp;--&nbsp;print or control the system message buffer</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN57881"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>dmesg</B
> [-c | -n <TT
CLASS="REPLACEABLE"
><I
>level</I
></TT
> | -s <TT
CLASS="REPLACEABLE"
><I
>bufsize</I
></TT
>]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57890"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>dmesg</B
> examines or controls the system message buffer.
Only a user with appropriate privileges may modify the system message
buffer parameters or contents.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57894"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57897"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-c</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the user has appropriate privilege,
clears the system message buffer contents after printing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57902"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-n level</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the user has appropriate privilege,
sets the level at which logging of messages is done to the console.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN57907"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-s bufsize</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>uses a buffer of <TT
CLASS="PARAMETER"
><I
>bufsize</I
></TT
> to query the system message buffer.  This is 
<CODE
CLASS="CONSTANT"
>16392</CODE
> by default.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="DU"
></A
>du</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57917"
></A
><H2
>Name</H2
>du&nbsp;--&nbsp;estimate file space usage</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57920"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>du</B
> is as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57925"
></A
><H2
>Differences</H2
><P
>If the <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
> option is not specified, disk space is shown in unspecified
units.  Applications should specify <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
>.</P
></DIV
><H1
><A
NAME="ECHO"
></A
>echo</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57933"
></A
><H2
>Name</H2
>echo&nbsp;--&nbsp;write arguments to standard output</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN57936"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>echo</B
> [string...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57940"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>echo</B
> command is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but
with the following differences.</P
><P
>Implementations may support implementation-defined options
to <B
CLASS="COMMAND"
>echo</B
>.
The behavior of
<B
CLASS="COMMAND"
>echo</B
> if any arguments contain backslashes is
also implementation defined.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57948"
></A
><H2
>Application Usage</H2
><P
>Conforming applications should not
run <B
CLASS="COMMAND"
>echo</B
> with a first argument starting with a hyphen,
or with any arguments containing backslashes; they should use
<B
CLASS="COMMAND"
>printf</B
> in those cases.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The behavior specified here is similar to that specified by 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> without the XSI option.  However, the LSB
strongly recommends conforming applications not use any options 
(even if the implementation provides them) while
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> specifies behavior if the first
operand is the string <TT
CLASS="PARAMETER"
><I
>-n</I
></TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="EGREP"
></A
>egrep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57961"
></A
><H2
>Name</H2
>egrep&nbsp;--&nbsp;search a file with an Extended Regular Expression pattern</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57964"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>egrep</B
> is equivalent to <B
CLASS="COMMAND"
>grep -E</B
>. For further details,
see the specification for <B
CLASS="COMMAND"
>grep</B
>.</P
></DIV
><H1
><A
NAME="FGREP"
></A
>fgrep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57973"
></A
><H2
>Name</H2
>fgrep&nbsp;--&nbsp;search a file with a fixed pattern</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57976"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>fgrep</B
> is equivalent to grep -F. For further details,
see the specification for <B
CLASS="COMMAND"
>grep</B
>.</P
></DIV
><H1
><A
NAME="FILE"
></A
>file</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN57984"
></A
><H2
>Name</H2
>file&nbsp;--&nbsp;determine file type</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57987"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>file</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN57992"
></A
><H2
>Differences</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>-M</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>-h</I
></TT
>, 
<TT
CLASS="PARAMETER"
><I
>-d</I
></TT
>, and 
<TT
CLASS="PARAMETER"
><I
>-i</I
></TT
> options need not be supported.</P
></DIV
><H1
><A
NAME="FUSER"
></A
>fuser</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58002"
></A
><H2
>Name</H2
>fuser&nbsp;--&nbsp;identify processes using files or sockets</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58005"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>fuser</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58010"
></A
><H2
>Differences</H2
><P
>The <B
CLASS="COMMAND"
>fuser</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN58015"
></A
><H3
>Option Differences</H3
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58018"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58022"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><H1
><A
NAME="GETTEXT"
></A
>gettext</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58029"
></A
><H2
>Name</H2
>gettext&nbsp;--&nbsp;retrieve text string from message catalog</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58032"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>gettext</B
> [options] [textdomain]  msgid <BR><B
CLASS="COMMAND"
>gettext</B
>  -s   [options]  msgid... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58043"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>gettext</B
> utility retrieves a translated 
text string corresponding to
string <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> from a message 
object generated with <B
CLASS="COMMAND"
>msgfmt</B
> utility.</P
><P
>The message object name is derived from the optional argument 
<TT
CLASS="PARAMETER"
><I
>textdomain</I
></TT
> if
present, otherwise from the <CODE
CLASS="CONSTANT"
>TEXTDOMAIN</CODE
> 
environment variable. If no domain is
specified, or if a corresponding string cannot be found, 
<B
CLASS="COMMAND"
>gettext</B
> prints
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>.</P
><P
>Ordinarily <B
CLASS="COMMAND"
>gettext</B
>
looks for its message object in 
<TT
CLASS="FILENAME"
><TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>lang</I
></TT
>/LC_MESSAGES</TT
>
where <TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
>
is the implementation-defined default directory and 
<TT
CLASS="REPLACEABLE"
><I
>lang</I
></TT
> is
the locale name. If present, the <CODE
CLASS="CONSTANT"
>TEXTDOMAINDIR</CODE
>
environment variable replaces
the <TT
CLASS="REPLACEABLE"
><I
>dirname</I
></TT
>.</P
><P
>This utility interprets C escape sequences such as <TT
CLASS="LITERAL"
>\t</TT
>
for tab. Use <TT
CLASS="LITERAL"
>\\</TT
> to
print a backslash. To produce a message on a line of its own, either put a
<TT
CLASS="LITERAL"
>\n</TT
> at the end of 
<TT
CLASS="PARAMETER"
><I
>msgid,</I
></TT
> or use this command in
conjunction with the <B
CLASS="COMMAND"
>printf</B
>
utility.</P
><P
>When used with the <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
>
option the <B
CLASS="COMMAND"
>gettext</B
>
utility behaves like the <B
CLASS="COMMAND"
>echo</B
> utility, 
except that the message corresponding to 
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> in the selected catalog
provides the arguments.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58074"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58077"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-d domainname</I
></TT
></SPAN
>, <SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>--domain=domainname</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>PARAMETER translated messages from domainname.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58084"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-e</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Enable expansion of some escape sequences.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58089"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-n</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Suppress trailing newline.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58094"
></A
><H2
>Operands</H2
><P
>The following operands are supported:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58098"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>textdomain</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A domain name used to retrieve the messages.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58103"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A key to retrieve the localized message.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58108"
></A
><H2
>Environment Variables</H2
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58112"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LANGUAGE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies one or more locale names. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58117"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>LANG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies locale name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58122"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>LC_MESSAGES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies messaging locale, and if present overrides <CODE
CLASS="CONSTANT"
>LANG</CODE
> for messages.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58128"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>TEXTDOMAIN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies the text domain name, which is identical to the message object
filename without <TT
CLASS="FILENAME"
>.mo</TT
> suffix.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58134"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>TEXTDOMAINDIR</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies the pathname to the message catalog, and if present replaces the
implementation-defined default directory.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58139"
></A
><H2
>Exit Status</H2
><P
>The following exit values are returned:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58143"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Successful completion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58148"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>&#62;0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="GREP"
></A
>grep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58156"
></A
><H2
>Name</H2
>grep&nbsp;--&nbsp;print lines matching a pattern</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58159"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>grep</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58164"
></A
><H2
>LSB Differences</H2
><P
>Certain aspects of regular expression matching are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
>.</P
></DIV
><H1
><A
NAME="GROUPADD"
></A
>groupadd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58171"
></A
><H2
>Name</H2
>groupadd&nbsp;--&nbsp;create a new group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58174"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groupadd</B
> [-g gid  [-o]]  group </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58180"
></A
><H2
>Description</H2
><P
>If the caller has appropriate privilege, the 
<B
CLASS="COMMAND"
>groupadd</B
> command shall create a new
group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
>.  
The group name shall be unique in the group database. If no
<TT
CLASS="PARAMETER"
><I
>gid</I
></TT
> is specified, 
<B
CLASS="COMMAND"
>groupadd</B
> shall create the new group with a unique group ID.
If the group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> already exists,
or if a group with <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
> ID exists and 
<TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is not set,
<B
CLASS="COMMAND"
>groupadd</B
> shall issue a diagnostic message and exit
with a non-zero exit status.</P
><P
>The <B
CLASS="COMMAND"
>groupadd</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58194"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58197"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-g <TT
CLASS="REPLACEABLE"
><I
>gid</I
></TT
> [-o]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The new group shall have group ID <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
>.
If the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is not used, no other
group shall have this group ID.
The value of <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
> shall be non-negative.  </P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="GROUPDEL"
></A
>groupdel</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58209"
></A
><H2
>Name</H2
>groupdel&nbsp;--&nbsp;delete a group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58212"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groupdel</B
>  group </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58216"
></A
><H2
>Description</H2
><P
>If the caller has sufficient privilege,
the <B
CLASS="COMMAND"
>groupdel</B
> command shall modify the system group database,
deleting the
group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
>.
If the group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> does not exist
or is a primary group for existing user,
<B
CLASS="COMMAND"
>groupdel</B
> shall issue a diagnostic message and exit
with a non-zero exit status.</P
><P
>The <B
CLASS="COMMAND"
>groupdel</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><H1
><A
NAME="GROUPMOD"
></A
>groupmod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58229"
></A
><H2
>Name</H2
>groupmod&nbsp;--&nbsp;modify a group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58232"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groupmod</B
> [-g <TT
CLASS="REPLACEABLE"
><I
>gid</I
></TT
> [-o]] [-n <TT
CLASS="REPLACEABLE"
><I
>group_name</I
></TT
>]  group </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58241"
></A
><H2
>Description</H2
><P
>If the caller has appropriate privilege, the 
<B
CLASS="COMMAND"
>groupmod</B
> command shall modify the entry in the system
group database corresponding to a group named 
<TT
CLASS="PARAMETER"
><I
>group</I
></TT
>.</P
><P
>The <B
CLASS="COMMAND"
>groupmod</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58249"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58252"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-g <TT
CLASS="REPLACEABLE"
><I
>gid</I
></TT
> [-o]</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Modify the group's group ID, setting it to <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
>.
If the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is not used, no other
group shall have this group ID.
The value of <TT
CLASS="PARAMETER"
><I
>gid</I
></TT
>shall be non-negative.  
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Only the group ID in the database is altered; any files with group
ownership set to the original group ID are unchanged by this modification.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58263"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>-n <TT
CLASS="REPLACEABLE"
><I
>group_name</I
></TT
></I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>changes the name of the group from <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> to 
<TT
CLASS="PARAMETER"
><I
>group_name</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="GROUPS"
></A
>groups</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58274"
></A
><H2
>Name</H2
>groups&nbsp;--&nbsp;display a group</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58277"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>groups</B
> [user]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58281"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>groups</B
> command shall behave as <B
CLASS="COMMAND"
>id -Gn
<TT
CLASS="REPLACEABLE"
><I
>[user]</I
></TT
></B
>, as specified in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
The optional <TT
CLASS="PARAMETER"
><I
>user</I
></TT
> parameter
will display the groups for the named user.</P
></DIV
><H1
><A
NAME="GUNZIP"
></A
>gunzip</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58294"
></A
><H2
>Name</H2
>gunzip&nbsp;--&nbsp;uncompress files</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58297"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>gunzip</B
> is equivalent to 
<B
CLASS="COMMAND"
>gzip -d</B
>. See the specification for
<B
CLASS="COMMAND"
>gzip</B
> for further details.</P
><P
><A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> requires that if 
<B
CLASS="COMMAND"
>gunzip</B
> exists, it must be a symbolic or hard link
to <TT
CLASS="FILENAME"
>/bin/gzip</TT
>.  This specification additionally
allows <B
CLASS="COMMAND"
>gunzip</B
> to be a wrapper script which
calls <B
CLASS="COMMAND"
>gzip -d</B
>.</P
></DIV
><H1
><A
NAME="GZIP"
></A
>gzip</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58312"
></A
><H2
>Name</H2
>gzip&nbsp;--&nbsp;compress or expand files</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58315"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>gzip</B
> [-cdfhlLnNrtvV19] [-S suffix] [name...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58321"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>gzip</B
> command shall attempt to reduce the size of 
the named files.
Whenever possible, each file is replaced by one with the
extension <TT
CLASS="FILENAME"
>.gz</TT
>,
while keeping the same ownership, modes, access and
modification times. If no files are specified, or if a file name is
<TT
CLASS="FILENAME"
>-</TT
>, 
the standard input is compressed to the standard output. 
<B
CLASS="COMMAND"
>gzip</B
>
shall only attempt to compress regular files.  In particular, it will
ignore symbolic links.</P
><P
>When compressing, gzip uses the deflate algorithm specified in 
<A
HREF="#STD.RFC1951"
>RFC 1951: DEFLATE Compressed Data Format Specification</A
>
and stores the result in a file using the gzip file format specified
in <A
HREF="#STD.RFC1952"
>RFC 1952: GZIP File Format Specification</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58331"
></A
><H2
>Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-c, --stdout, --to-stdout</DT
><DD
><P
>writes output on standard output, leaving the original files unchanged.  If
there are several input files, the output consists of a sequence of
independently compressed members. To obtain better compression,
concatenate all input files before compressing them.</P
></DD
><DT
>-d, --decompress, --uncompress</DT
><DD
><P
>the name operands are compressed files, and <B
CLASS="COMMAND"
>gzip</B
>
shall decompress them.</P
></DD
><DT
>-f, --force</DT
><DD
><P
>forces compression or decompression even if the file has multiple links
or the corresponding file already exists, or if the compressed data is
read from or written to a terminal. If the input data is not in a
format recognized by <B
CLASS="COMMAND"
>gzip</B
>, and if the option 
<TT
CLASS="PARAMETER"
><I
>--stdout</I
></TT
>
is also given, copy the input data without change to the standard ouput: 
let <B
CLASS="COMMAND"
>gzip</B
> behave as <B
CLASS="COMMAND"
>cat</B
>. If <TT
CLASS="PARAMETER"
><I
>-f</I
></TT
> is 
not given, and when not running in the background, <B
CLASS="COMMAND"
>gzip</B
> 
prompts to verify whether an existing file should be overwritten.</P
></DD
><DT
>-l, --list</DT
><DD
><P
>lists the compressed size, uncompressed size, ratio and uncompressed 
name for each compressed file. For files that are not in <B
CLASS="COMMAND"
>gzip</B
>
format, the uncompressed size shall be given as 
<CODE
CLASS="CONSTANT"
>-1</CODE
>.
If the <TT
CLASS="PARAMETER"
><I
>--verbose</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-v</I
></TT
> option
is also specified, the
crc and timestamp for the uncompressed file shall also be displayed.</P
><P
>For decompression, <B
CLASS="COMMAND"
>gzip</B
> shall support at least
the following compression methods:
<P
></P
><UL
><LI
><P
>deflate (<A
HREF="#STD.RFC1951"
>RFC 1951: DEFLATE Compressed Data Format Specification</A
>)</P
></LI
><LI
><P
>compress (<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>)</P
></LI
></UL
>
The crc shall be given as 
<CODE
CLASS="CONSTANT"
>ffffffff</CODE
> for a file
not in <B
CLASS="COMMAND"
>gzip</B
> format.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>--name</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-N</I
></TT
> option
is also specified, the uncompressed name, date and time are those stored
within the compressed file, if present.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>--quiet</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-q</I
></TT
> option
is also specified, the 
title and totals lines are not displayed.</P
></DD
><DT
>-L, --license</DT
><DD
><P
>displays the <B
CLASS="COMMAND"
>gzip</B
> license and quit.</P
></DD
><DT
>-n, --no-name</DT
><DD
><P
>does not save the original file name and time stamp by default when 
compressing. (The original name is always saved if the name had to be
truncated.)  When decompressing, do not restore the original file name
if present (remove only the gzip suffix from the compressed file name)
and do not restore the original time stamp if present (copy it from
the compressed file). This option is the default when decompressing.</P
></DD
><DT
>-N, --name</DT
><DD
><P
>always saves the original file name and time stamp when compressing;
this is the default.  When decompressing, restore the original file
name and time stamp if present. This option is useful on systems which
have a limit on file name length or when the time stamp has been lost
after a file transfer.</P
></DD
><DT
>-q, --quiet</DT
><DD
><P
>suppresses all warnings.</P
></DD
><DT
>-r, --recursive</DT
><DD
><P
>travels the directory structure recursively. If any of the file names
specified on the command line are directories, <B
CLASS="COMMAND"
>gzip</B
> 
will descend into the directory and compress all the files it finds there 
(or decompress them in the case of <B
CLASS="COMMAND"
>gunzip</B
>).</P
></DD
><DT
>-S .suf, --sufix .suf</DT
><DD
><P
>uses suffix <TT
CLASS="FILENAME"
>.suf</TT
> instead of <TT
CLASS="FILENAME"
>.gz</TT
>.</P
></DD
><DT
>-t, --test</DT
><DD
><P
>checks the compressed file integrity.</P
></DD
><DT
>-v, --verbose</DT
><DD
><P
>displays the name and percentage reduction for each file
compressed or decompressed.</P
></DD
><DT
>-#, --fast, --best</DT
><DD
><P
>regulates the speed of compression using the specified digit #, where
<TT
CLASS="PARAMETER"
><I
>-1</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--fast</I
></TT
> indicates the fastest compression method (less
compression) and <TT
CLASS="PARAMETER"
><I
>-9</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--best</I
></TT
> indicates the slowest compression method
(best compression).  The default compression level is <TT
CLASS="PARAMETER"
><I
>-6</I
></TT
>
(that is,
biased towards high compression at expense of speed).</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58424"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58428"
></A
><SPAN
STYLE="white-space: nowrap"
>-V, --version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays the version number and compilation options, then quits.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="HOSTNAME"
></A
>hostname</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58435"
></A
><H2
>Name</H2
>hostname&nbsp;--&nbsp;show or set the system's host name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58438"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>hostname</B
> [name]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58442"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>hostname</B
> is used to either display or, with appropriate
privileges, set the current host
name of the system.  The host name is used by many applications
to identify the machine. </P
><P
>When called without any arguments, the program displays the name of
the system as returned by the <TT
CLASS="FUNCTION"
>gethostname()</TT
> function.</P
><P
>When called with a <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> argument, and the user has appropriate
privilege, the command
sets the host name.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is not specified if the hostname displayed will be a fully qualified
domain name. Applications requiring a particular format of hostname
should check the output and take appropriate action.</P
></BLOCKQUOTE
></DIV
></DIV
><H1
><A
NAME="INSTALL"
></A
>install</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58455"
></A
><H2
>Name</H2
>install&nbsp;--&nbsp;copy files and set attributes</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58458"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>install</B
> [option...]  SOURCE   DEST <BR><B
CLASS="COMMAND"
>install</B
> [option...]  SOURCE...   DEST <BR><B
CLASS="COMMAND"
>install</B
> [-d | --directory] [option...]  DIRECTORY... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58476"
></A
><H2
>Description</H2
><P
>In the first two formats, copy <TT
CLASS="PARAMETER"
><I
>SOURCE</I
></TT
>
to <TT
CLASS="PARAMETER"
><I
>DEST</I
></TT
> or multiple <TT
CLASS="PARAMETER"
><I
>SOURCE(s)</I
></TT
> to
the existing <TT
CLASS="PARAMETER"
><I
>DEST</I
></TT
> directory, optionally setting permission modes and
file ownership.  In the third format, each
<TT
CLASS="PARAMETER"
><I
>DIRECTORY</I
></TT
> and any missing parent
directories shall be created.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58484"
></A
><H2
>Standard Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>--backup[=METHOD]</DT
><DD
><P
>makes a backup of each existing destination file.
<TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> may be one of the following:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58493"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>none</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>off</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>never make backups.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58499"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>numbered</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>t</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>make numbered backups. A numbered backup has the form
<TT
CLASS="LITERAL"
>"%s.~%d~", target_name, version_number</TT
>. Each backup
shall increment the version number by 1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58506"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>existing</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>nil</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>behave as numbered if numbered backups exist, or simple otherwise.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58512"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>simple</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>never</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>append a suffix to the name. The default suffix is '<TT
CLASS="LITERAL"
>~</TT
>',
but can be overriden by setting <CODE
CLASS="ENVAR"
>SIMPLE_BACKUP_SUFFIX</CODE
> in
the environment, or via the <TT
CLASS="PARAMETER"
><I
>-S</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>--suffix</I
></TT
>
option.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>If no <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> is specified, the environment variable
<CODE
CLASS="ENVAR"
>VERSION_CONTROL</CODE
> shall be examined for one of the above.
Unambiguous abbreviations of <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> shall be accepted.
If no <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> is specified, or if <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
>
is empty, the backup method shall default to <CODE
CLASS="CONSTANT"
>existing</CODE
>.</P
><P
>If <TT
CLASS="PARAMETER"
><I
>METHOD</I
></TT
> is invalid or ambiguous, <B
CLASS="COMMAND"
>install</B
>
shall fail and issue a diagnostic message.</P
></DD
><DT
>-b</DT
><DD
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>--backup=existing</I
></TT
>.</P
></DD
><DT
>-d, --directory</DT
><DD
><P
>treats all arguments as directory names; creates all components of the
specified directories.</P
></DD
><DT
>-D</DT
><DD
><P
>creates all leading components of DEST except the last, then copies
SOURCE to DEST; useful in the 1st format.</P
></DD
><DT
>-g GROUP, --group=GROUP</DT
><DD
><P
>if the user has appropriate privilege, sets group ownership, instead of process' current group.
<TT
CLASS="PARAMETER"
><I
>GROUP</I
></TT
> is either a name in the
user group database, or a positive integer, which shall be used as a group-id.</P
></DD
><DT
>-m MODE, --mode=MODE</DT
><DD
><P
>sets permission mode (specified as in <B
CLASS="COMMAND"
>chmod</B
>), instead of the default 
<TT
CLASS="LITERAL"
>rwxr-xr-x</TT
>.</P
></DD
><DT
>-o OWNER, --owner=OWNER</DT
><DD
><P
>if the user has appropriate privilege, sets ownership.
<TT
CLASS="PARAMETER"
><I
>OWNER</I
></TT
> is either a name in the
user login database, or a positive integer, which shall be used as a user-id.</P
></DD
><DT
>-p, --preserve-timestamps</DT
><DD
><P
>copies the access and modification times of 
<TT
CLASS="PARAMETER"
><I
>SOURCE</I
></TT
> files to corresponding
destination files.</P
></DD
><DT
>-s, --strip</DT
><DD
><P
>strips symbol tables, only for 1st and 2nd formats.</P
></DD
><DT
>-S SUFFIX, --suffix=SUFFIX</DT
><DD
><P
>equivalent to <TT
CLASS="PARAMETER"
><I
>--backup=existing</I
></TT
>, except if
a simple suffix is required, use <TT
CLASS="PARAMETER"
><I
>SUFFIX</I
></TT
>.</P
></DD
><DT
>--verbose</DT
><DD
><P
>prints the name of each directory as it is created.</P
></DD
><DT
>-v, --verbose</DT
><DD
><P
>print the name of each file before copying it to <CODE
CLASS="VARNAME"
>stdout</CODE
>.</P
></DD
></DL
></DIV
></DIV
><H1
><A
NAME="INSTALLINITD"
></A
>install_initd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58588"
></A
><H2
>Name</H2
>install_initd&nbsp;--&nbsp;activate an init script</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58591"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/lib/lsb/install_initd</B
>  initd_file </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58595"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>install_initd</B
> shall activate a system initialization file that has
been copied to an implementation defined location such that
this file shall be run at the appropriate point during system initialization.
The <B
CLASS="COMMAND"
>install_initd</B
> command is typically called in the postinstall
script of a package, after the script has been copied to
<TT
CLASS="FILENAME"
>/etc/init.d</TT
>.
See also <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
>.</P
></DIV
><H1
><A
NAME="IPCRM"
></A
>ipcrm</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58605"
></A
><H2
>Name</H2
>ipcrm&nbsp;--&nbsp;remove IPC Resources</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58608"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>ipcrm</B
> [-q <TT
CLASS="REPLACEABLE"
><I
>msgid</I
></TT
> | -Q <TT
CLASS="REPLACEABLE"
><I
>msgkey</I
></TT
> | -s <TT
CLASS="REPLACEABLE"
><I
>semid</I
></TT
> | -S <TT
CLASS="REPLACEABLE"
><I
>semkey</I
></TT
> | -m <TT
CLASS="REPLACEABLE"
><I
>shmid</I
></TT
> | -M <TT
CLASS="REPLACEABLE"
><I
>shmkey</I
></TT
>]...<BR><B
CLASS="COMMAND"
>ipcrm</B
> [shm | msg | msg]  id... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58631"
></A
><H2
>Description</H2
><P
>If any of the 
<TT
CLASS="PARAMETER"
><I
>-q</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-Q</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-S</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>or -M</I
></TT
>
arguments are given, the <B
CLASS="COMMAND"
>ipcrm</B
> shall
behave as described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
>Otherwise,
<B
CLASS="COMMAND"
>ipcrm</B
> shall remove the resource of
the specified type identified by <TT
CLASS="PARAMETER"
><I
>id</I
></TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58652"
></A
><H2
>Future Directions</H2
><P
>A future revision of this specification may deprecate the second synopsis form.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>In  its  first  Linux  implementation, <B
CLASS="COMMAND"
>ipcrm</B
> used the second syntax
shown in the SYNOPSIS.  Functionality present in other implementations
of  <B
CLASS="COMMAND"
>ipcrm</B
>  has  since  been  added, namely the ability to delete
resources by key (not just identifier), and to respect  the  same  command
line  syntax.  The previous syntax is
still supported for backwards compatibility only.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="IPCS"
></A
>ipcs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58663"
></A
><H2
>Name</H2
>ipcs&nbsp;--&nbsp;provide information on ipc facilities</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58666"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>ipcs</B
> [-smq] [-tcp]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58671"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>ipcs</B
> provides information on the ipc facilities 
for which the calling process has read access. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Although this command
has many similarities with the optional <B
CLASS="COMMAND"
>ipcs</B
> 
utility described in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, it has substantial differences and is
therefore described separately. The options specified here have similar
meaning to those in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>; other options specified
there have unspecified behavior on an LSB conforming implementation. See
<A
HREF="#IPCS.APP.USAGE"
>Application Usage</A
> below. The output format is not specified.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58681"
></A
><H2
>Resource display options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58684"
></A
><SPAN
STYLE="white-space: nowrap"
>-m</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>shared memory segments.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58688"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>message queues.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58692"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>semaphore arrays.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58696"
></A
><H2
>Output format options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58699"
></A
><SPAN
STYLE="white-space: nowrap"
>-t</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58703"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>pid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58707"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creator.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="IPCS.APP.USAGE"
></A
><H2
>Application Usage</H2
><P
>In some implementations of ipcs the <TT
CLASS="PARAMETER"
><I
>-a</I
></TT
>
option will print all
information available.  In other implementations the 
<TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option will
print all resource types.  Therefore, applications shall not use the 
<TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option.</P
><P
>Some implementations of <B
CLASS="COMMAND"
>ipcs</B
>
provide more output formats than are
specified here.  These options are not consistent between differing
implementations of <B
CLASS="COMMAND"
>ipcs</B
>.
Therefore, only the 
<TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-p</I
></TT
> option
formatting flags may be used.  At least one of the 
<TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-c</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-p</I
></TT
> options
and at least one of 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>-q</I
></TT
> and 
<TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> options
shall be specified. If no options are specified, the output is unspecified.</P
></DIV
><H1
><A
NAME="KILLALL"
></A
>killall</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58732"
></A
><H2
>Name</H2
>killall&nbsp;--&nbsp;kill processes by name</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58735"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>killall</B
> [-egiqvw] [-signal]  name... <BR><B
CLASS="COMMAND"
>killall</B
>  -l <BR><B
CLASS="COMMAND"
>killall</B
>  -V </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58747"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>killall</B
> sends a signal to all processes running any of 
the specified commands.  If no signal name is specified, <CODE
CLASS="CONSTANT"
>SIGTERM</CODE
> is sent.</P
><P
>Signals can be specified either by name (e.g. <CODE
CLASS="CONSTANT"
>-HUP</CODE
>) or by number
(e.g. <CODE
CLASS="CONSTANT"
>-1</CODE
>). Signal <CODE
CLASS="CONSTANT"
>0</CODE
>
(check if a process exists) can only be specified
by number.</P
><P
>If the command name contains a slash (/), processes executing that
particular file will be selected for killing, independent of their
name.</P
><P
><B
CLASS="COMMAND"
>killall</B
> returns a non-zero return code if no process 
has been killed for any of the listed commands.  If at least one process 
has been killed for each command, <B
CLASS="COMMAND"
>killall</B
> returns zero.</P
><P
>A <B
CLASS="COMMAND"
>killall</B
> process never kills itself (but may kill 
other <B
CLASS="COMMAND"
>killall</B
> processes).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58763"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58766"
></A
><SPAN
STYLE="white-space: nowrap"
>-e</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>requires an exact match for very long names. If a command name is
longer than 15 characters, the full name may be unavailable (i.e. it
is swapped out).  In this case, <B
CLASS="COMMAND"
>killall</B
> will kill 
everything that matches within the first 15 characters. With -e, such 
entries are skipped.  <B
CLASS="COMMAND"
>killall</B
> prints a message for 
each skipped entry if -v is specified in addition to -e.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58772"
></A
><SPAN
STYLE="white-space: nowrap"
>-g</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>kills the process group to which the process belongs.  The kill signal
is only sent once per group, even if multiple processes belonging to
the same process group were found.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58776"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>asks interactively for confirmation before killing.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58780"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>lists all known signal names.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58784"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>does not complain if no processes were killed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58788"
></A
><SPAN
STYLE="white-space: nowrap"
>-v</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reports if the signal was successfully sent.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58792"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58796"
></A
><SPAN
STYLE="white-space: nowrap"
>-V</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays version information.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LPR"
></A
>lpr</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58803"
></A
><H2
>Name</H2
>lpr&nbsp;--&nbsp;off line print</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58806"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>lpr</B
> [-l] [-p] [-Pprinter] [-h] [-s] [-#copies] [-J name] [-T title] [name ......]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58818"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>lpr</B
> uses a spooling daemon to print the named files when 
facilities become available.  If no names appear, the standard input is
assumed.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58822"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58825"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>identifies binary data that is not to be filtered but sent as raw input 
to printer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58829"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>formats with "pr" before sending to printer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58833"
></A
><SPAN
STYLE="white-space: nowrap"
>-Pprinter</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sends output to the printer named printer instead of the default
printer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58837"
></A
><SPAN
STYLE="white-space: nowrap"
>-h</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>suppresses header page.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58841"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>uses symbolic links.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58845"
></A
><SPAN
STYLE="white-space: nowrap"
>-#copies</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies copies as the number of copies to print.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58849"
></A
><SPAN
STYLE="white-space: nowrap"
>-J name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies name as the job name for the header page.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58853"
></A
><SPAN
STYLE="white-space: nowrap"
>-T title</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies title as the title used for "pr".</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LS"
></A
>ls</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58860"
></A
><H2
>Name</H2
>ls&nbsp;--&nbsp;list directory contents</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58863"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>ls</B
> shall behave as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
extensions listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58868"
></A
><H2
>Extensions</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58871"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file is a character special or block special file, 
the size of the file shall be replaced with 
two unsigned numbers in the format <TT
CLASS="LITERAL"
>"%u,  %u"</TT
>,
representing the major and minor device numbers associated with the
special file. 
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The LSB does not specify the meaning of the major and minor
devices numbers.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58878"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>in addition to <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> XSI optional behavior of printing a
slash for a directory,
<B
CLASS="COMMAND"
>ls -p</B
> may display other characters for other file types.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="LSBRELEASE"
></A
>lsb_release</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58887"
></A
><H2
>Name</H2
>lsb_release&nbsp;--&nbsp;print distribution specific information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58890"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>lsb_release</B
> [option...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58894"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>lsb_release</B
> command prints certain LSB (Linux Standard
Base) and Distribution information.</P
><P
>If no options are given, the <TT
CLASS="PARAMETER"
><I
>-v</I
></TT
> option is the default.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58900"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58903"
></A
><SPAN
STYLE="white-space: nowrap"
>-v, --version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays the LSB version the distribution is compliant with. The version
is expressed as a colon separated list of versioned LSB module identifiers. 
An LSB module identifier is a dash-separated tuple consisting of module name and version
or module name, version and architecture name, in that order.
The version output is presented as a single line of text beginning with
<TT
CLASS="LITERAL"
>LSB Version:</TT
> followed by a tab character, then the list of LSB module identifiers.
This format is intended to be easily parsable by programs which need to consume the data.
Excepting <TT
CLASS="LITERAL"
>core</TT
>, which must always be present, the list of
module identifiers may change over time depending on installations and removals
of system software. </P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN58909"
></A
><P
>Example:
<SAMP
CLASS="COMPUTEROUTPUT"
>LSB Version:	core-5.0-amd64:core-5.0-noarch:desktop-5.0-amd64:desktop-5.0-noarch:languages-5.0:imaging-5.0</SAMP
></P
><P
></P
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>An implementation may support multiple releases of the same module. To claim
compliance, the implementation shall list all relevant module identifiers.
Version specific library interfaces, if any, will be selected by the program interpreter,
which may change from release to release. Version specific commands and utilities, if any,
will be described in the relevant specification.</P
></BLOCKQUOTE
></DIV
><P
>For reporting or querying compliance with this release of the specification, use the
module names found in the <I
CLASS="CITETITLE"
>Package Dependencies</I
>
section of the <I
CLASS="CITETITLE"
>Package Format and Installation</I
>
chapter for that module specification. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58917"
></A
><SPAN
STYLE="white-space: nowrap"
>-i, --id</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays a string identifying the distribution provider.
The id output is a single line of text beginning with
<TT
CLASS="LITERAL"
>Distributor ID:</TT
> followed by a tab character, then the id string.
This specification assigns no meaning to the value of the string,
the contents are at the discretion of the distribution provider.</P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN58922"
></A
><P
>Example:
<SAMP
CLASS="COMPUTEROUTPUT"
>Distributor ID:	Frobnozz</SAMP
></P
><P
></P
></DIV
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58925"
></A
><SPAN
STYLE="white-space: nowrap"
>-d, --description</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays text describing the distribution.
The description output is a single line of text beginning with
<TT
CLASS="LITERAL"
>Description:</TT
> followed by a tab character, then the description string.
This specification assigns no meaning to the value of the string,
the contents are at the discretion of the distribution provider.</P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN58930"
></A
><P
>Example:
<SAMP
CLASS="COMPUTEROUTPUT"
>Description:	Frobnozz release 9 (Gilpher)</SAMP
></P
><P
></P
></DIV
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58933"
></A
><SPAN
STYLE="white-space: nowrap"
>-r, --release</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays the release number of distribution.
The release output is a single line of text beginning with
<TT
CLASS="LITERAL"
>Release:</TT
> followed by a tab character, then the release string.
This specification assigns no meaning to the value of the string,
the contents are at the discretion of the distribution provider.</P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN58938"
></A
><P
>Example:
<SAMP
CLASS="COMPUTEROUTPUT"
>Release:	9</SAMP
></P
><P
></P
></DIV
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58941"
></A
><SPAN
STYLE="white-space: nowrap"
>-c, --codename</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays a codename which corresponds to the distribution release.
The codename output is a single line of text beginning with
<TT
CLASS="LITERAL"
>Codename:</TT
> followed by a tab character, then the codename string.
This specification assigns no meaning to the value of the string,
the contents are at the discretion of the distribution provider.</P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN58946"
></A
><P
>Example:
<SAMP
CLASS="COMPUTEROUTPUT"
>Codename:	Gilpher</SAMP
></P
><P
></P
></DIV
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58949"
></A
><SPAN
STYLE="white-space: nowrap"
>-a, --all</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays all of the above information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58953"
></A
><SPAN
STYLE="white-space: nowrap"
>-s, --short</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays all of the above information in a short output format.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58957"
></A
><SPAN
STYLE="white-space: nowrap"
>-h, --help</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>displays a human-readable help message.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="M4"
></A
>m4</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58964"
></A
><H2
>Name</H2
>m4&nbsp;--&nbsp;macro processor</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58967"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>m4</B
> is as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
extensions as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN58972"
></A
><H2
>Extensions</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58975"
></A
><SPAN
STYLE="white-space: nowrap"
>-P</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>forces all builtins to be prefixed with <TT
CLASS="LITERAL"
>m4_</TT
>. For example,
<TT
CLASS="LITERAL"
>define</TT
> becomes <TT
CLASS="LITERAL"
>m4_define</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN58982"
></A
><SPAN
STYLE="white-space: nowrap"
>-I <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Add <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
> to the end of the search path
for includes.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="MD5SUM"
></A
>md5sum</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN58991"
></A
><H2
>Name</H2
>md5sum&nbsp;--&nbsp;generate or check MD5 message digests</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN58994"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>md5sum</B
> [-c  [file] | file...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59001"
></A
><H2
>Description</H2
><P
>For each file, write to standard output a line containing the MD5
message digest of that file, followed by one or more blank characters,
followed by the name of the file.  The MD5 message digest shall be
calculated according to <A
HREF="#STD.RFC1321"
>RFC 1321: The MD5 Message-Digest Algorithm</A
> and output as 32 hexadecimal digits.</P
><P
>If no file names are specified as operands, read from standard input
and use <TT
CLASS="LITERAL"
>"-"</TT
> as the file name in the output.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59007"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59010"
></A
><SPAN
STYLE="white-space: nowrap"
>-c [file]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>checks the MD5 message digest of all files named in <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
against the message digest listed
in the same file. The actual format of <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
is the same as the output
of <B
CLASS="COMMAND"
>md5sum</B
>.  That is, each line in the file describes a file. 
If <TT
CLASS="PARAMETER"
><I
>file</I
></TT
>
is not specified, read 
message digests from <CODE
CLASS="VARNAME"
>stdin</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59019"
></A
><H2
>Exit Status</H2
><P
><B
CLASS="COMMAND"
>md5sum</B
> shall exit with status <SPAN
CLASS="RETURNVALUE"
>0</SPAN
>
if the sum was generated successfully, or, in check mode, if the check
matched. Otherwise, <B
CLASS="COMMAND"
>md5sum</B
> shall exit with a non-zero
status.</P
></DIV
><H1
><A
NAME="MKNOD"
></A
>mknod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59028"
></A
><H2
>Name</H2
>mknod&nbsp;--&nbsp;make special files</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59031"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>mknod</B
> [-m <TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
> | --mode=<TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>]  name   type  [major minor]<BR><B
CLASS="COMMAND"
>mknod</B
> [--version]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59045"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>mknod</B
> command shall create a special file named
<TT
CLASS="PARAMETER"
><I
>name</I
></TT
> of the given <TT
CLASS="PARAMETER"
><I
>type</I
></TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> shall be one of the following:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59054"
></A
><SPAN
STYLE="white-space: nowrap"
>b</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a block (buffered) special file with the specified
<TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
> device numbers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59060"
></A
><SPAN
STYLE="white-space: nowrap"
>c, u</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a character (unbuffered) special file with the specified
<TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
> device numbers.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59066"
></A
><SPAN
STYLE="white-space: nowrap"
>p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a FIFO.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59070"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59073"
></A
><SPAN
STYLE="white-space: nowrap"
>-m <TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>, --mode=<TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>create the special file with file access permissions set as described in
<TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>. The permissions may be any absolute value (i.e.
one not containing <TT
CLASS="LITERAL"
>'+'</TT
> or <TT
CLASS="LITERAL"
>'-'</TT
>) acceptable to the
<B
CLASS="COMMAND"
>chmod</B
> command.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59083"
></A
><SPAN
STYLE="white-space: nowrap"
>--version</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>output version information and exit.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This option may be deprecated in a future release of this specification.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
></TBODY
></TABLE
><P
>If <TT
CLASS="PARAMETER"
><I
>type</I
></TT
> is <TT
CLASS="LITERAL"
>p</TT
>,
<TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
>
shall not be specified. Otherwise, these parameters are mandatory.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59094"
></A
><H2
>Future Directions</H2
><P
>This command may be deprecated in a future version of this specification.
The <TT
CLASS="PARAMETER"
><I
>major</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>minor</I
></TT
> operands
are insufficently portable to be specified usefully here.
Only a FIFO can be portably created by this command, and the <B
CLASS="COMMAND"
>mkfifo</B
>
command is a simpler interface for that purpose.</P
></DIV
><H1
><A
NAME="MKTEMP"
></A
>mktemp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59103"
></A
><H2
>Name</H2
>mktemp&nbsp;--&nbsp;make temporary file name (unique)</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59106"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>mktemp</B
> [-q] [-u]  template </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59112"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>mktemp</B
> command takes the given file name 
<TT
CLASS="PARAMETER"
><I
>template</I
></TT
> and 
overwrites a
portion of it to create a file name.  This file name shall be unique and
suitable for use by the application.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>template</I
></TT
> should have at least six trailing
<TT
CLASS="LITERAL"
>'X'</TT
>
characters. These characters are replaced with characters from the portable
filename character set in order to
generate a unique name.</P
><P
>If <B
CLASS="COMMAND"
>mktemp</B
> can successfully generate a unique file name, 
and the <TT
CLASS="PARAMETER"
><I
>-u</I
></TT
> option is not present,
the file shall be created with read and write permission only for the current user.
The <B
CLASS="COMMAND"
>mktemp</B
> command shall write
the filename generated to the standard output.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59124"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59127"
></A
><SPAN
STYLE="white-space: nowrap"
>-q</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>fail silently if an error occurs.  Diagnostic messages to <CODE
CLASS="VARNAME"
>stderr</CODE
>
are suppressed, but the command shall still exit with a non-zero exit status
if an error occurs.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59132"
></A
><SPAN
STYLE="white-space: nowrap"
>-u</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>operates in `unsafe' mode.  A unique name is generated,
but the temporary file shall be unlinked before
<B
CLASS="COMMAND"
>mktemp</B
> exits.  
Use of this option is not encouraged.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="MORE"
></A
>more</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59140"
></A
><H2
>Name</H2
>more&nbsp;--&nbsp;display files on a page-by-page basis</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59143"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>more</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59148"
></A
><H2
>Differences</H2
><P
>The <B
CLASS="COMMAND"
>more</B
> command need not respect the 
<TT
CLASS="LITERAL"
>LINES</TT
> and <TT
CLASS="LITERAL"
>COLUMNS</TT
> environment variables.</P
><P
>The following additional options may be supported:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59156"
></A
><SPAN
STYLE="white-space: nowrap"
>-<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies an integer which is the screen size (in lines).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59161"
></A
><SPAN
STYLE="white-space: nowrap"
>+<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>starts at line number <TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59167"
></A
><SPAN
STYLE="white-space: nowrap"
>+/<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Start at the first line matching the pattern, 
equivalent to executing the search forward (<TT
CLASS="LITERAL"
>/</TT
>)
command with the given pattern immediately after opening each file.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The following options from <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> may behave
differently:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59176"
></A
><SPAN
STYLE="white-space: nowrap"
>-e</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59180"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59184"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59188"
></A
><SPAN
STYLE="white-space: nowrap"
>-p</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Either clear the whole screen before displaying any text (instead
of the usual scrolling behavior), or provide the behavior
specified by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.  In the latter case, the
syntax is "<TT
CLASS="PARAMETER"
><I
>-p <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
></I
></TT
>".</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59195"
></A
><SPAN
STYLE="white-space: nowrap"
>-t</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>The <B
CLASS="COMMAND"
>more</B
> command need not support the following
interactive commands:

<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>g</TD
></TR
><TR
><TD
>G</TD
></TR
><TR
><TD
>u</TD
></TR
><TR
><TD
>control u</TD
></TR
><TR
><TD
>control f</TD
></TR
><TR
><TD
>newline</TD
></TR
><TR
><TD
>j</TD
></TR
><TR
><TD
>k</TD
></TR
><TR
><TD
>r</TD
></TR
><TR
><TD
>R</TD
></TR
><TR
><TD
>m</TD
></TR
><TR
><TD
>' (return to mark)</TD
></TR
><TR
><TD
>/!</TD
></TR
><TR
><TD
>?</TD
></TR
><TR
><TD
>N</TD
></TR
><TR
><TD
>:e</TD
></TR
><TR
><TD
>:t</TD
></TR
><TR
><TD
>control g</TD
></TR
><TR
><TD
>ZZ</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59221"
></A
><H2
>Rationale</H2
><P
>The +<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> and
+/<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> options are deprecated in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, and have been removed in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>; 
however this specification continues to
specify them because the publicly available 
<TT
CLASS="LITERAL"
>util-linux</TT
> package does not support the replacement
(-p <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>).  The
+<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> option as found in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
> is more general than is specified here,
but the <TT
CLASS="LITERAL"
>util-linux</TT
> package appears to only support the more
specific +<TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> and
+/<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> forms.</P
></DIV
><H1
><A
NAME="MOUNT"
></A
>mount</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59238"
></A
><H2
>Name</H2
>mount&nbsp;--&nbsp;mount a file system </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59241"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>mount</B
> [-hV]<BR><B
CLASS="COMMAND"
>mount</B
> [-a] [-fFnrsvw] [-t <TT
CLASS="REPLACEABLE"
><I
>vfstype</I
></TT
>]<BR><B
CLASS="COMMAND"
>mount</B
> [-fnrsvw] [-o <TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
> [,...]] [device | dir]<BR><B
CLASS="COMMAND"
>mount</B
> [-fnrsvw] [-t <TT
CLASS="REPLACEABLE"
><I
>vfstype</I
></TT
>] [-o options]  device   dir </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59268"
></A
><H2
>Description</H2
><P
>As described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, all files in the system
are organized in a directed graph, known as the file hierarchy,
rooted at <TT
CLASS="FILENAME"
>/</TT
>.
These files can be spread out over
several underlying devices.
The <B
CLASS="COMMAND"
>mount</B
> command shall attach the file system
found on some underlying device to the file hierarchy. </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59274"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59277"
></A
><SPAN
STYLE="white-space: nowrap"
>-v</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>invoke verbose mode. The <B
CLASS="COMMAND"
>mount</B
> command shall provide diagnostic
messages on <CODE
CLASS="VARNAME"
>stdout</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59283"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount all file systems (of the given types) mentioned in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59288"
></A
><SPAN
STYLE="white-space: nowrap"
>-F</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the <TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option is also present,
fork a new incarnation of <B
CLASS="COMMAND"
>mount</B
>
for each device to be mounted.  This will do the mounts on different devices or
different NFS servers in parallel.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59294"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>cause everything to be done except for the actual system call; if
it's not obvious, this `fakes' mounting the file system.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59298"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount without writing in <TT
CLASS="FILENAME"
>/etc/mtab</TT
>.  This is necessary for example
when <TT
CLASS="FILENAME"
>/etc</TT
> is on a read-only file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59304"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>ignore <B
CLASS="COMMAND"
>mount</B
> options not supported by a 
file system type.  Not all file systems support this option. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59309"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read-only. A synonym is <TT
CLASS="PARAMETER"
><I
>-o ro</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59314"
></A
><SPAN
STYLE="white-space: nowrap"
>-w</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read/write. (default) A synonym is
<TT
CLASS="PARAMETER"
><I
>-o rw</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59319"
></A
><SPAN
STYLE="white-space: nowrap"
>-L label</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file <TT
CLASS="FILENAME"
>/proc/partitions</TT
> is supported,
mount the partition that has the specified label.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59324"
></A
><SPAN
STYLE="white-space: nowrap"
>-U uuid</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file <TT
CLASS="FILENAME"
>/proc/partitions</TT
> is supported,
mount the partition that has the specified uuid.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59329"
></A
><SPAN
STYLE="white-space: nowrap"
>-t vfstype</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>indicate a file system type of <TT
CLASS="PARAMETER"
><I
>vfstype</I
></TT
>. </P
><P
>More than one type may be specified in a comma separated list.  The
list of file system types can be prefixed with <TT
CLASS="LITERAL"
>no</TT
> to specify the file
system types on which no action should be taken.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59336"
></A
><SPAN
STYLE="white-space: nowrap"
>-o</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>options are specified with a <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> flag followed by a comma-separated
string of options.  Some of these options are only useful when they
appear in the <TT
CLASS="FILENAME"
>/etc/fstab</TT
> file.  The following options apply to any
file system that is being mounted:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59343"
></A
><SPAN
STYLE="white-space: nowrap"
>async</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>perform all I/O to the file system asynchronously.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59347"
></A
><SPAN
STYLE="white-space: nowrap"
>atime</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>update inode access time for each access. (default)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59351"
></A
><SPAN
STYLE="white-space: nowrap"
>auto</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>,
indicate the device is mountable with <TT
CLASS="PARAMETER"
><I
>-a</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59357"
></A
><SPAN
STYLE="white-space: nowrap"
>defaults</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use default options:
<TT
CLASS="LITERAL"
>rw</TT
>, <TT
CLASS="LITERAL"
>suid</TT
>, <TT
CLASS="LITERAL"
>dev</TT
>, <TT
CLASS="LITERAL"
>exec</TT
>, <TT
CLASS="LITERAL"
>auto</TT
>, <TT
CLASS="LITERAL"
>nouser</TT
>, <TT
CLASS="LITERAL"
>async</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59376"
></A
><SPAN
STYLE="white-space: nowrap"
>dev</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>interpret character or block special devices on the file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59380"
></A
><SPAN
STYLE="white-space: nowrap"
>exec</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>permit execution of binaries.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59384"
></A
><SPAN
STYLE="white-space: nowrap"
>noatime</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not update file access times on this file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59388"
></A
><SPAN
STYLE="white-space: nowrap"
>noauto</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>,
indicates the device is only explicitly mountable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59393"
></A
><SPAN
STYLE="white-space: nowrap"
>nodev</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not interpret character or block special devices on the file
system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59397"
></A
><SPAN
STYLE="white-space: nowrap"
>noexec</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not allow execution of any binaries on the mounted file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59401"
></A
><SPAN
STYLE="white-space: nowrap"
>nosuid</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not allow set-user-identifier or set-group-identifier bits to take
effect.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59405"
></A
><SPAN
STYLE="white-space: nowrap"
>nouser</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>forbid an unprivileged user to mount the file system.
(default)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59409"
></A
><SPAN
STYLE="white-space: nowrap"
>remount</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>remount an already-mounted file system.  This is commonly
used to change the mount options for a file system, especially to make a
read-only file system writable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59413"
></A
><SPAN
STYLE="white-space: nowrap"
>ro</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read-only.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59417"
></A
><SPAN
STYLE="white-space: nowrap"
>rw</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mount the file system read-write.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59421"
></A
><SPAN
STYLE="white-space: nowrap"
>suid</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>allow set-user-identifier or set-group-identifier bits to take effect.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59425"
></A
><SPAN
STYLE="white-space: nowrap"
>sync</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do all I/O to the file system synchronously.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59429"
></A
><SPAN
STYLE="white-space: nowrap"
>user</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>allow an unprivilieged user to mount the file system.  This option implies
the options 
<TT
CLASS="LITERAL"
>noexec</TT
>, <TT
CLASS="LITERAL"
>nosuid</TT
>, <TT
CLASS="LITERAL"
>nodev</TT
>
unless overridden by subsequent options.</P
></TD
></TR
></TBODY
></TABLE
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59440"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59444"
></A
><SPAN
STYLE="white-space: nowrap"
>-V</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>output version and exit.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="MSGFMT"
></A
>msgfmt</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59451"
></A
><H2
>Name</H2
>msgfmt&nbsp;--&nbsp;create a message object from a message file </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59454"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>msgfmt</B
> [options...]  <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59460"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>msgfmt</B
> command
generates a binary message catalog from a textual translation description.
Message catalogs, or 
message object files, are stored in files with a <TT
CLASS="FILENAME"
>.mo</TT
> extension.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The format of message object files is not guaranteed to be portable.
Message catalogs should always be generated on the target architecture using the
<B
CLASS="COMMAND"
>msgfmt</B
> command.</P
></BLOCKQUOTE
></DIV
></P
><P
>The source message files, otherwise known as portable object files, have a
<TT
CLASS="FILENAME"
>.po</TT
> extension.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> operands shall be portable object files.
The <TT
CLASS="FILENAME"
>.po</TT
> file contains messages to be
displayed to users by system utilities or by
application programs. The portable object files are text files, 
and the messages in them can
be rewritten in any language supported by the system.</P
><P
>If any <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is <TT
CLASS="FILENAME"
>-</TT
>, 
a portable object file shall be read from the standard input.</P
><P
>The <B
CLASS="COMMAND"
>msgfmt</B
> command interprets data as characters 
according to the current setting of the
<CODE
CLASS="CONSTANT"
>LC_CTYPE</CODE
> locale category.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59479"
></A
><H2
>Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-c, --check</DT
><DD
><P
>Detect and diagnose input file anomalies which might represent translation
errors. The <TT
CLASS="LITERAL"
>msgid</TT
> and <TT
CLASS="LITERAL"
>msgstr</TT
> strings are studied and compared. It is
considered abnormal that one string starts or ends with a newline while the
other does not.</P
><P
>If the message is flagged as <TT
CLASS="LITERAL"
>c-format</TT
> (see <A
HREF="#MSGFMT-COMMENTS"
>Comment Handling</A
>),
check that the <TT
CLASS="LITERAL"
>msgid</TT
> string and the <TT
CLASS="LITERAL"
>msgstr</TT
> translation
have the same number of <TT
CLASS="LITERAL"
>%</TT
> format specifiers, with matching types.</P
></DD
><DT
>-D <TT
CLASS="PARAMETER"
><I
>directory</I
></TT
>, --directory=<TT
CLASS="PARAMETER"
><I
>directory</I
></TT
></DT
><DD
><P
>Add directory to list for input files search. 
If <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is not an absolute pathname
and <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> cannot be opened, search for it
in <TT
CLASS="PARAMETER"
><I
>directory</I
></TT
>. This option may be
repeated. Directories shall be searched in order, with the leftmost
<TT
CLASS="PARAMETER"
><I
>directory</I
></TT
> searched first.</P
></DD
><DT
>-f, --use-fuzzy</DT
><DD
><P
>Use entries marked as <TT
CLASS="LITERAL"
>fuzzy</TT
>
in output. If this option is not specified, such entries
are not included into the output. See <A
HREF="#MSGFMT-COMMENTS"
>Comment Handling</A
> below.</P
></DD
><DT
>-o <TT
CLASS="PARAMETER"
><I
>output-file</I
></TT
>, --output-file=<TT
CLASS="PARAMETER"
><I
>output-file</I
></TT
></DT
><DD
><P
>Specify the output file name as <TT
CLASS="FILENAME"
>output-file</TT
>. If multiple domains or
duplicate
msgids in the <TT
CLASS="FILENAME"
>.po</TT
> file are present, the behavior is unspecified.
If output-file is <TT
CLASS="FILENAME"
>-</TT
>, output is written
to standard output.</P
></DD
><DT
>--strict</DT
><DD
><P
>Ensure that all output files have a <TT
CLASS="FILENAME"
>.mo</TT
> extension.
Output files are named either by the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> (or
<TT
CLASS="PARAMETER"
><I
>--output-file</I
></TT
>) option, or by domains found in the input
files.</P
></DD
><DT
>-v, --verbose</DT
><DD
><P
>Print additional information to the standard error, including the number
of translated strings processed.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59535"
></A
><H2
>Operands</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> operands are treated as portable object files. 
The format of
portable object files is defined in EXTENDED DESCRIPTION.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59539"
></A
><H2
>Standard Input</H2
><P
>The standard input is not used unless a <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>
operand is specified as
"-".</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59543"
></A
><H2
>Environment Variables</H2
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59547"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LANGUAGE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies one or more locale names. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59552"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LANG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies locale name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59557"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LC_ALL</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies locale name for all categories. If defined, overrides <CODE
CLASS="ENVAR"
>LANG</CODE
>,
<CODE
CLASS="ENVAR"
>LC_CTYPE</CODE
> and <CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59565"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LC_CTYPE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Determine the locale for the interpretation of sequences of bytes
of text data as characters (for example, single-byte as opposed to multi-byte
characters in arguments and input files).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59570"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="ENVAR"
>LC_MESSAGES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Specifies messaging locale, and if present overrides <CODE
CLASS="ENVAR"
>LANG</CODE
> for messages.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59576"
></A
><H2
>Standard Output</H2
><P
>The standard output is not used unless the option-argument of the 
<TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option
is specified as <TT
CLASS="FILENAME"
>-</TT
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59581"
></A
><H2
>Extended Description</H2
><P
>The format of portable object files (<TT
CLASS="FILENAME"
>.po</TT
> files) is defined as follows. Each
<TT
CLASS="FILENAME"
>.po</TT
> file contains one or more lines, with each line containing either a
comment or a statement. Comments start the line with a hash mark (<TT
CLASS="LITERAL"
>#</TT
>) and end
with the newline character. Empty lines, or lines containing only white-space,
shall be ignored. 
Comments can in certain circumstances alter the behavior of 
<B
CLASS="COMMAND"
>msgfmt</B
>.  See 
<A
HREF="#MSGFMT-COMMENTS"
>Comment Handling</A
> below for details on comment processing.
The format of a statement is:</P
><P
><TT
CLASS="LITERAL"
>directive value</TT
></P
><P
>Each <TT
CLASS="LITERAL"
>directive</TT
> starts at the beginning of the line and is separated from
<TT
CLASS="LITERAL"
>value</TT
> by white space (such as one or more space or tab characters). The
<TT
CLASS="LITERAL"
>value</TT
>
consists of one or more quoted strings separated by white space. If two or
more strings are specified as <TT
CLASS="LITERAL"
>value</TT
>, they are normalized into single string
using the string normalization syntax specified in <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
>.
The following directives are supported:</P
><P
><TT
CLASS="LITERAL"
>domain domainname</TT
></P
><P
><TT
CLASS="LITERAL"
>msgid message_identifier</TT
></P
><P
><TT
CLASS="LITERAL"
>msgid_plural untranslated_string_plural</TT
></P
><P
><TT
CLASS="LITERAL"
>msgstr message_string</TT
></P
><P
><TT
CLASS="LITERAL"
>msgstr[<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>] message_string</TT
></P
><P
>The behavior of the <TT
CLASS="LITERAL"
>domain</TT
> directive is affected by the options used. See
OPTIONS for the behavior when the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is specified. 
If the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option
is not specified, the behavior of the <TT
CLASS="LITERAL"
>domain</TT
> directive is as follows:
<P
></P
><OL
TYPE="1"
><LI
><P
>All msgids from the beginning of each <TT
CLASS="FILENAME"
>.po</TT
> file to the first 
<TT
CLASS="LITERAL"
>domain</TT
>
directive are put into a default message object file, messages (or
<TT
CLASS="FILENAME"
>messages.mo</TT
> if the <TT
CLASS="PARAMETER"
><I
>--strict</I
></TT
> option is specified).</P
></LI
><LI
><P
>When <B
CLASS="COMMAND"
>msgfmt</B
> encounters a 
<TT
CLASS="LITERAL"
>domain domainname</TT
> directive in the <TT
CLASS="FILENAME"
>.po</TT
> file,
all following <TT
CLASS="PARAMETER"
><I
>msgids</I
></TT
> until the next <TT
CLASS="LITERAL"
>domain</TT
> directive are put into the
message object file <TT
CLASS="FILENAME"
>domainname</TT
> (or 
<TT
CLASS="FILENAME"
>domainname.mo</TT
> if <TT
CLASS="PARAMETER"
><I
>--strict</I
></TT
> option is
specified).</P
></LI
><LI
><P
>Duplicate <TT
CLASS="PARAMETER"
><I
>msgids</I
></TT
> are defined in the scope of each domain. That is, a
<TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
> is considered a duplicate only if the identical <TT
CLASS="PARAMETER"
><I
>msgid</I
></TT
>
exists in the same domain.</P
></LI
><LI
><P
>All duplicate <TT
CLASS="PARAMETER"
><I
>msgids</I
></TT
> are ignored.</P
></LI
></OL
>&#13;</P
><P
>The <TT
CLASS="LITERAL"
>msgid</TT
> directive specifies the value of a message identifier associated
with the directive that follows it. The <TT
CLASS="LITERAL"
>msgid_plural</TT
> directive specifies the
plural form message specified to the plural message handling functions
<TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
> or <TT
CLASS="FUNCTION"
>dcngettext()</TT
>. 
The message_identifier string
identifies a target string to be used at retrieval time. Each statement
containing a <TT
CLASS="LITERAL"
>msgid</TT
> directive shall be followed by a statement containing a
<TT
CLASS="LITERAL"
>msgstr</TT
> directive or <TT
CLASS="LITERAL"
>msgstr[n]</TT
> directives.</P
><P
>The <TT
CLASS="LITERAL"
>msgstr</TT
> directive specifies the target string associated with the
<TT
CLASS="PARAMETER"
><I
>message_identifier</I
></TT
> string declared in the immediately preceding 
<TT
CLASS="LITERAL"
>msgid</TT
> directive.</P
><P
>The <TT
CLASS="LITERAL"
>msgstr[<TT
CLASS="PARAMETER"
><I
>n</I
></TT
>]</TT
> (where 
<TT
CLASS="PARAMETER"
><I
>n</I
></TT
> = 0, 1, 2, ...) directive specifies the target string
to be used with plural form handling functions 
<TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
> and
<TT
CLASS="FUNCTION"
>dcngettext()</TT
>.</P
><P
>Message strings can contain the following escape sequences:
<DIV
CLASS="TABLE"
><A
NAME="AEN59659"
></A
><P
><B
>Table 17-1. Escape Sequences</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>\n</TT
></TD
><TD
>newline</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\t</TT
></TD
><TD
>tab</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\v</TT
></TD
><TD
>vertical tab</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\b</TT
></TD
><TD
>backspace</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\r</TT
></TD
><TD
>carriage return</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\f</TT
></TD
><TD
>formfeed</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\\</TT
></TD
><TD
>backslash</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\"</TT
></TD
><TD
>double quote</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\ddd</TT
></TD
><TD
>octal bit pattern</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\xHH</TT
></TD
><TD
>hexadecimal bit pattern</TD
></TR
></TBODY
></TABLE
></DIV
></P
><DIV
CLASS="REFSECT2"
><A
NAME="MSGFMT-COMMENTS"
></A
><H3
>Comment Handling</H3
><P
>Comments are introduced by a <TT
CLASS="LITERAL"
>#</TT
>, and continue to the
end of the line. The second character (i.e. the character following the
<TT
CLASS="LITERAL"
>#</TT
>) has special meaning. Regular comments should
follow a space character. Other comment types include:</P
><P
><TT
CLASS="LITERAL"
># normal-comments</TT
></P
><P
><TT
CLASS="LITERAL"
>#. automatic-comments</TT
></P
><P
><TT
CLASS="LITERAL"
>#: reference...</TT
></P
><P
><TT
CLASS="LITERAL"
>#, flag</TT
></P
><P
>Automatic and reference comments are typically generated by external utilities,
and are not specified by the LSB. The <B
CLASS="COMMAND"
>msgfmt</B
> command
shall ignore such comments.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Portable object files may be produced by unspecified tools. Some of the comment
types described here may arise from the use of such tools. It is beyond the
scope of this specification to describe these tools.</P
></BLOCKQUOTE
></DIV
></P
><P
>The <TT
CLASS="LITERAL"
>#,</TT
> comments require one or more flags separated by 
the comma (<TT
CLASS="LITERAL"
>,</TT
>) character.
The following flags can be specified:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59724"
></A
><SPAN
STYLE="white-space: nowrap"
>fuzzy</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This flag shows that the following <TT
CLASS="LITERAL"
>msgstr</TT
> string might not be a correct
translation. Only the translator (i.e. the individual undertaking
the translation) can judge if the translation
requires further modification, or is acceptable as is. Once satisfied with
the translation, the translator then removes this fuzzy flag. </P
><P
>If this flag is specified, the <B
CLASS="COMMAND"
>msgfmt</B
> utility will not generate the entry
for the immediately following <TT
CLASS="LITERAL"
>msgid</TT
> in the output message catalog,
unless the <TT
CLASS="PARAMETER"
><I
>--use-fuzzy</I
></TT
> is specified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59733"
></A
><SPAN
STYLE="white-space: nowrap"
>c-format</SPAN
>, <SPAN
STYLE="white-space: nowrap"
>no-c-format</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="LITERAL"
>c-format</TT
> flag indicates that the <TT
CLASS="LITERAL"
>msgid</TT
> string is
used as format string by <TT
CLASS="FUNCTION"
>printf()</TT
>-like functions. 
If the <TT
CLASS="LITERAL"
>c-format</TT
> flag is
given for a string the <B
CLASS="COMMAND"
>msgfmt</B
> utility may perform additional 
tests to check the
validity of the translation.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN59743"
></A
><H3
>Plurals</H3
><P
>The msgid entry with empty string ("") is called the header entry and
is treated specially. If the message string for the header entry contains
<TT
CLASS="LITERAL"
>nplurals=value</TT
>, the value indicates the number of plural forms. For example,
if <TT
CLASS="LITERAL"
>nplurals=4</TT
>, there are 4 plural forms. If <TT
CLASS="LITERAL"
>nplurals</TT
>
is defined, there
should be a <TT
CLASS="LITERAL"
>plural=expression</TT
> on the same line, separated by a semicolon (;)
character. The expression is a C language expression to determine which
version of <TT
CLASS="LITERAL"
>msgstr[n]</TT
> to be used based on the value of <TT
CLASS="LITERAL"
>n</TT
>,
the last argument
of <TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
> or <TT
CLASS="FUNCTION"
>dcngettext()</TT
>.
For example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>nplurals=2; plural=n == 1 ? 0 : 1</PRE
></TD
></TR
></TABLE
><P
>indicates that there are 2 plural forms in the language; <TT
CLASS="LITERAL"
>msgstr[0]</TT
> is used
if <TT
CLASS="LITERAL"
>n == 1</TT
>, otherwise <TT
CLASS="LITERAL"
>msgstr[1]</TT
> is used. Another example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2</PRE
></TD
></TR
></TABLE
><P
>indicates that there are 3 plural forms in the language; <TT
CLASS="LITERAL"
>msgstr[0]</TT
> is used
if <TT
CLASS="LITERAL"
>n == 1</TT
>, <TT
CLASS="LITERAL"
>msgstr[1]</TT
> is used if 
<TT
CLASS="LITERAL"
>n == 2</TT
>, otherwise <TT
CLASS="LITERAL"
>msgstr[2]</TT
> is used.</P
><P
>If the header entry contains <TT
CLASS="LITERAL"
>charset=<TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
></TT
> string, the 
<TT
CLASS="PARAMETER"
><I
>codeset</I
></TT
> is used to
indicate the codeset to be used to encode the message strings. If the output
string's codeset is different from the message string's codeset, codeset
conversion from the message strings's codeset to the output string's codeset
will be performed upon the call of <TT
CLASS="FUNCTION"
>gettext()</TT
>, <TT
CLASS="FUNCTION"
>dgettext()</TT
>,
<TT
CLASS="FUNCTION"
>dcgettext()</TT
>, <TT
CLASS="FUNCTION"
>ngettext()</TT
>, <TT
CLASS="FUNCTION"
>dngettext()</TT
>, and 
<TT
CLASS="FUNCTION"
>dcngettext()</TT
>. The output string's codeset is
determined by the current locale's codeset (the return value of
nl_langinfo(CODESET)) by default, and can be changed by the call of
<TT
CLASS="FUNCTION"
>bind_textdomain_codeset()</TT
>.</P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59778"
></A
><H2
>Exit Status</H2
><P
>The following exit values are returned:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59782"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Successful completion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59787"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="RETURNVALUE"
>&#62;0</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An error occurred.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59792"
></A
><H2
>Application Usage</H2
><P
>Neither <B
CLASS="COMMAND"
>msgfmt</B
> nor any <TT
CLASS="FUNCTION"
>gettext()</TT
> function
imposes a limit on the total length
of a message. Installing message catalogs under the C locale is pointless,
since they are ignored for the sake of efficiency.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59797"
></A
><H2
>Examples</H2
><P
>Example 1: Examples of creating message objects from message files.</P
><P
>In this example <TT
CLASS="FILENAME"
>module1.po</TT
>, <TT
CLASS="FILENAME"
>module2.po</TT
> and 
<TT
CLASS="FILENAME"
>module3.po</TT
> are portable message object
files.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% cat module1.po

# default domain "messages"

msgid "message one"

msgstr "mensaje nmero uno"

#

domain "help_domain"

msgid "help two"

msgstr "ayuda nmero dos"

#

domain "error_domain"

msgid "error three"

msgstr "error nmero tres"&#13;</PRE
></TD
></TR
></TABLE
><P
> </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% cat module2.po

# default domain "messages"

msgid "message four"

msgstr "mensaje nmero cuatro"

#

domain "error_domain"

msgid "error five"

msgstr "error nmero cinco"

#

domain "window_domain"

msgid "window six"

msgstr "ventana nmero seises"</PRE
></TD
></TR
></TABLE
><P
> </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% cat module3.po

# default domain "messages"

msgid "message seven"

msgstr "mensaje nmero siete"&#13;</PRE
></TD
></TR
></TABLE
><P
>The following command will produce the output files <TT
CLASS="FILENAME"
>messages</TT
>, 
<TT
CLASS="FILENAME"
>help_domain</TT
>, and <TT
CLASS="FILENAME"
>error_domain</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% msgfmt module1.po</PRE
></TD
></TR
></TABLE
><P
>The following command will produce the output files <TT
CLASS="FILENAME"
>messages.mo</TT
>,
<TT
CLASS="FILENAME"
>help_domain.mo</TT
>, <TT
CLASS="FILENAME"
>error_domain.mo</TT
>, and <TT
CLASS="FILENAME"
>window_domain.mo</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% msgfmt module1.po module2.po</PRE
></TD
></TR
></TABLE
><P
>The following example will produce the output file <TT
CLASS="FILENAME"
>hello.mo</TT
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>example% msgfmt -o hello.mo module3.po</PRE
></TD
></TR
></TABLE
></DIV
><H1
><A
NAME="NEWGRP"
></A
>newgrp</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59826"
></A
><H2
>Name</H2
>newgrp&nbsp;--&nbsp;change group ID</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59829"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>newgrp</B
> [group]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59833"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>newgrp</B
> command is as specified
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with differences as listed below.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN59838"
></A
><H3
>Differences</H3
><P
>The <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> option specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
need not be supported.</P
></DIV
></DIV
><H1
><A
NAME="OD"
></A
>od</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59846"
></A
><H2
>Name</H2
>od&nbsp;--&nbsp;dump files in octal and other formats </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59849"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>od</B
> [-abcdfilox] [-w <TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
> | --width-<TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>] [-v] [-A <TT
CLASS="REPLACEABLE"
><I
>address_base</I
></TT
>] [-j <TT
CLASS="REPLACEABLE"
><I
>skip</I
></TT
>] [-n <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>] [-t <TT
CLASS="REPLACEABLE"
><I
>type_string</I
></TT
>] [file...]<BR><B
CLASS="COMMAND"
>od</B
>  --traditional  [options] [file] [[+]offset [.] [b]] [[+]label [.] [b]]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59881"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>od</B
> command shall
provide all of the madatory functionality specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with extensions and 
differences to the XSI optional behavior as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN59886"
></A
><H2
>Extensions and Differences</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-s</DT
><DD
><P
>unspecified behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Applications wishing to achieve the <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>
behavior for <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> should instead use 
<TT
CLASS="PARAMETER"
><I
>-t d2</I
></TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
>-w<TT
CLASS="PARAMETER"
><I
>width</I
></TT
>, --width[=<TT
CLASS="PARAMETER"
><I
>width</I
></TT
>]</DT
><DD
><P
>each output line is limited to <TT
CLASS="PARAMETER"
><I
>width</I
></TT
> bytes from the input.</P
></DD
><DT
>--traditional</DT
><DD
><P
>accepts arguments in traditional form, see <A
HREF="#OD.TRAD.USAGE"
>Traditional Usage</A
>
below.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The XSI optional behavior 
for offset handling described in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> is not supported
unless the <TT
CLASS="PARAMETER"
><I
>--traditional</I
></TT
> option is also specified.</P
></BLOCKQUOTE
></DIV
></P
></DD
></DL
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN59914"
></A
><H3
>Pre-POSIX and XSI Specifications</H3
><P
>The LSB supports mixing options between the mandatory
and XSI optional synopsis forms in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
The LSB shall support the following options:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59919"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t a</I
></TT
>, selects named characters.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59924"
></A
><SPAN
STYLE="white-space: nowrap"
>-b</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t o1</I
></TT
>, selects octal bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59929"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t c</I
></TT
>, selects characters.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59934"
></A
><SPAN
STYLE="white-space: nowrap"
>-d</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t u2</I
></TT
>, selects unsigned decimal two byte units.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59939"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t fF</I
></TT
>, selects floats.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59944"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t d2</I
></TT
>, selects decimal two byte units.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This usage may change in future releases; portable applications should use
<TT
CLASS="PARAMETER"
><I
>-t d2</I
></TT
>.</P
></BLOCKQUOTE
></DIV
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59952"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t d4</I
></TT
>, selects decimal longs.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59957"
></A
><SPAN
STYLE="white-space: nowrap"
>-o</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t o2</I
></TT
>, selects octal two byte units.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN59962"
></A
><SPAN
STYLE="white-space: nowrap"
>-x</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to <TT
CLASS="PARAMETER"
><I
>-t x2</I
></TT
>, selects hexadecimal two byte units.</P
></TD
></TR
></TBODY
></TABLE
><P
>Note that the XSI option <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> need not be supported.</P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="OD.TRAD.USAGE"
></A
><H3
>Traditional Usage</H3
><P
>If the <TT
CLASS="PARAMETER"
><I
>--traditional</I
></TT
> option is specified,
there may be between zero and three operands specified.</P
><P
>If no operands are specified, then <B
CLASS="COMMAND"
>od</B
> shall read the standard input.</P
><P
>If there is exactly one operand, and it is an offset of the form 
<TT
CLASS="LITERAL"
>[+]offset[.][b]</TT
>,
then it shall be interpreted as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>. The file to
be dumped shall be the standard input.</P
><P
>If there are exactly two operands, and they are both of the form
<TT
CLASS="LITERAL"
>[+]offset[.][b]</TT
>, then the first shall be treated
as an offset (as above), and
the second shall be a label, in the same format as the offset. If a label is
specified, then the first output line produced for each input block shall be
preceded by the input offset, cumulative across input files, of the next byte to
be written, followed by the label, in parentheses. The label shall increment in
the same manner as the offset.</P
><P
>If there are three operands, then the first shall be the file to dump, the
second the offset, and the third the label.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Recent versions of <B
CLASS="COMMAND"
>coreutils</B
> contain an
<B
CLASS="COMMAND"
>od</B
> utility that conforms to
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>. However, in April 2005, this version
was not in widespread use. A future version of this specification
may remove the differences.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="PASSWD"
></A
>passwd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN59989"
></A
><H2
>Name</H2
>passwd&nbsp;--&nbsp;change user password</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN59992"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>passwd</B
> [-x max] [-n min] [-w warn] [-i inact]  name <BR><B
CLASS="COMMAND"
>passwd</B
> {-l | -u}  name </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60006"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>passwd</B
> changes authentication
information for user and group accounts, including
passwords and password expiry details, and may
be used to enable and disable accounts.
Only a user with appropriate privilege may change
the password for other users or modify the
expiry information.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60010"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60013"
></A
><SPAN
STYLE="white-space: nowrap"
>-x max</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the maximum number of days a password remains valid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60017"
></A
><SPAN
STYLE="white-space: nowrap"
>-n min</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the minimum number of days before a password may be changed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60021"
></A
><SPAN
STYLE="white-space: nowrap"
>-w warn</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>sets the number of days warning the user will receive before
their password will expire.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60025"
></A
><SPAN
STYLE="white-space: nowrap"
>-i inactive</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>disables an account after the password has been expired for the given
number of days.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60029"
></A
><SPAN
STYLE="white-space: nowrap"
>-l</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>disables an account by changing the password to a value which
matches no possible encrypted value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60033"
></A
><SPAN
STYLE="white-space: nowrap"
>-u</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>re-enables an account by changing the password back to its previous value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="PATCH"
></A
>patch</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60040"
></A
><H2
>Name</H2
>patch&nbsp;--&nbsp;apply a diff file to an original</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60043"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>patch</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
extensions as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60048"
></A
><H2
>Extensions</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60051"
></A
><SPAN
STYLE="white-space: nowrap"
>--binary</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reads and write all files in binary mode, except for standard output and
/dev/tty.  This option has no effect on POSIX-compliant systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60055"
></A
><SPAN
STYLE="white-space: nowrap"
>-u, --unified</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>interprets the patch file as a unified context diff.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="PIDOF"
></A
>pidof</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60062"
></A
><H2
>Name</H2
>pidof&nbsp;--&nbsp;find the process ID of a running program</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60065"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>pidof</B
> [-s] [-x] [-o omitpid...]  program... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60072"
></A
><H2
>Description</H2
><P
>Return the process ID of a process which is running the program named
on the command line.</P
><P
>The <B
CLASS="COMMAND"
>pidof</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60078"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60081"
></A
><SPAN
STYLE="white-space: nowrap"
>-s</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>instructs the program to only return one pid.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60085"
></A
><SPAN
STYLE="white-space: nowrap"
>-x</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>causes the program to also return process id's of
shells running the named scripts.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60089"
></A
><SPAN
STYLE="white-space: nowrap"
>-o</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>omits processes with specified process id.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="REMOVEINITD"
></A
>remove_initd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60096"
></A
><H2
>Name</H2
>remove_initd&nbsp;--&nbsp;clean up init script system modifications introduced by install_initd</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60099"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/lib/lsb/remove_initd</B
>  initd_file </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60103"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>remove_initd</B
> processes the removal of the
modifications made to a distribution's init script system by the 
<B
CLASS="COMMAND"
>install_initd</B
> program. This cleanup is performed
in the preuninstall script of a package; however, the package manager
is still responsible for removing the script from the repository.
See also <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
>.</P
></DIV
><H1
><A
NAME="RENICE"
></A
>renice</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60112"
></A
><H2
>Name</H2
>renice&nbsp;--&nbsp;alter priority of running processes</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60115"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>renice</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60120"
></A
><H2
>Differences</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60123"
></A
><SPAN
STYLE="white-space: nowrap"
>-n increment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="SED"
></A
>sed</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60130"
></A
><H2
>Name</H2
>sed&nbsp;--&nbsp;stream editor</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60133"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>sed</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60138"
></A
><H2
>LSB Differences</H2
><P
>Certain aspects of internationalized regular expressions are optional;
see <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
>.</P
></DIV
><H1
><A
NAME="BASELIB-SENDMAIL-1"
></A
>sendmail</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60146"
></A
><H2
>Name</H2
>sendmail&nbsp;--&nbsp;an electronic mail transport agent</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60149"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/sbin/sendmail</B
> [options] [address...]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60154"
></A
><H2
>Description</H2
><P
>To deliver electronic mail (email), implementations shall provide
the interface described here as a command named <B
CLASS="COMMAND"
>sendmail</B
>.
This interface shall be the default delivery method for applications
needing to transmit an email message.</P
><P
>This program sends an email message to one or more recipients,
routing the message as necessary.  This program is not intended
as a user interface routine.</P
><P
>With no options, <B
CLASS="COMMAND"
>sendmail</B
> reads its standard input up to an
end-of-file or a line consisting only of a single dot and sends a
copy of the message found there to all of the addresses listed.
It determines the network(s) to use based on the syntax and
contents of the addresses.</P
><P
>If an address is preceded by a backslash, <TT
CLASS="LITERAL"
>'\'</TT
>,
it is unspecified whether the
address is subject to local alias expansion.</P
><P
>The format of messages shall be as defined in 
<A
HREF="#STD.RFC2822"
>RFC 2822:Internet Message Format</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The required name <B
CLASS="COMMAND"
>sendmail</B
> was chosen for historical
reasons, but 
the behaviors specified here are intended to reflect functionality 
which can be provided by a number of other implementations such as
<B
CLASS="COMMAND"
>smail</B
>, 
<B
CLASS="COMMAND"
>exim</B
>
and others. This specification does not require that the 
specific <B
CLASS="COMMAND"
>sendmail</B
> program be the implementation
chosen to provide this functionality.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60173"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60176"
></A
><SPAN
STYLE="white-space: nowrap"
>-bm</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>read mail from standard input and deliver it to the recipient addresses.
This is the default mode of operation.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60180"
></A
><SPAN
STYLE="white-space: nowrap"
>-bp</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the user has sufficient privilege,
list information about messages currently in the mail queue.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60184"
></A
><SPAN
STYLE="white-space: nowrap"
>-bs</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use the SMTP protocol as described in 
<A
HREF="#STD.RFC2821"
>RFC 2821:Simple Mail Transfer Protocol</A
>; read SMTP commands on
standard input and write SMTP responses on standard output.</P
><P
>In this mode, <B
CLASS="COMMAND"
>sendmail</B
> shall accept
<TT
CLASS="LITERAL"
>\r\n</TT
> (CR-LF), as required by
<A
HREF="#STD.RFC2821"
>RFC 2821:Simple Mail Transfer Protocol</A
>, and <TT
CLASS="LITERAL"
>\n</TT
>
(LF) line terminators.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60194"
></A
><SPAN
STYLE="white-space: nowrap"
>-F fullname</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>explicitly set the full name of the sender for incoming
mail unless the message already contains a 
<TT
CLASS="LITERAL"
>From:</TT
> message
header.</P
><P
>If the user running <B
CLASS="COMMAND"
>sendmail</B
> is not sufficiently trusted,
then the actual sender may be indicated in the message,
depending on the configuration of the agent.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60201"
></A
><SPAN
STYLE="white-space: nowrap"
>-f name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>explicitly set the envelope sender address for incoming
mail.   If there is no 
<TT
CLASS="LITERAL"
>From:</TT
> header, the address specified
in the 
<TT
CLASS="LITERAL"
>From:</TT
> header will also be set.</P
><P
>If the user running <B
CLASS="COMMAND"
>sendmail</B
> is not sufficiently trusted,
then the actual sender shall be indicated in the message.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60209"
></A
><SPAN
STYLE="white-space: nowrap"
>-i</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>ignore dots alone on lines by themselves in incoming
messages.  If this options is not specified,
a line consisting of a single dot shall terminate the input.
If -bs is also used, the behavior is unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60213"
></A
><SPAN
STYLE="white-space: nowrap"
>-odb</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>deliver any mail in background, if supported; otherwise ignored.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60217"
></A
><SPAN
STYLE="white-space: nowrap"
>-odf</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>deliver any mail in foreground, if supported; otherwise ignored.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60221"
></A
><SPAN
STYLE="white-space: nowrap"
>-oem or -em</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>mail errors back to the sender. (default)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60225"
></A
><SPAN
STYLE="white-space: nowrap"
>-oep or -ep</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>write errors to the standard error output.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60229"
></A
><SPAN
STYLE="white-space: nowrap"
>-oeq or -eq</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not send notification of errors to the sender.  This
only works for mail delivered locally.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60233"
></A
><SPAN
STYLE="white-space: nowrap"
>-oi</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is equivalent to -i.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60237"
></A
><SPAN
STYLE="white-space: nowrap"
>-om</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>indicate that the sender of
a message should receive a copy of the message if the
sender appears in an alias expansion.  Ignored if aliases
are not supported.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60241"
></A
><SPAN
STYLE="white-space: nowrap"
>-t</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>read the message to obtain recipients from the <TT
CLASS="LITERAL"
>To:</TT
>, 
<TT
CLASS="LITERAL"
>Cc:</TT
>,
and <TT
CLASS="LITERAL"
>Bcc:</TT
> headers in the message instead of from the
command arguments.  If a 
<TT
CLASS="LITERAL"
>Bcc:</TT
> header is present, it is
removed from the message unless there is no <TT
CLASS="LITERAL"
>To:</TT
>
or <TT
CLASS="LITERAL"
>Cc:</TT
>
header, in which case a <TT
CLASS="LITERAL"
>Bcc:</TT
> header with no data is
created, in accordance with <A
HREF="#STD.RFC2822"
>RFC 2822:Internet Message Format</A
>.</P
><P
>If there are any operands, the recipients list is unspecified.</P
><P
>This option may be ignored when not in <TT
CLASS="PARAMETER"
><I
>-bm</I
></TT
> mode
(the default).</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is recommended that applications use as few options as
necessary, none if possible.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60258"
></A
><H2
>Exit status</H2
><P
>The <B
CLASS="COMMAND"
>sendmail</B
> command returns an exit status
indicating the results of the operation. The exit codes are
as defined in <TT
CLASS="FILENAME"
>&#60;sysexits.h&#62;</TT
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60264"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_OK</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>successful completion on all addresses.  Note this does not
necessarily indicate successful delivery.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60269"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_NOUSER</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The user specified did not exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60274"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_UNAVAILABLE</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A required service or resource was unavailable.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60279"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_USAGE</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Command was invoked incorrectly, such as wrong number of
arguments, syntax error in arguments, bad flags.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60284"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_SOFTWARE</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An internal sofware error was detected.   Includes bad arguments.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60289"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_OSERROR</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An operating system error was detected.  Includes failure to
execute <TT
CLASS="FUNCTION"
>fork()</TT
> or <TT
CLASS="FUNCTION"
>pipe()</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60296"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_NOHOST</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The host specified did not exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60301"
></A
><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="ERRORNAME"
>EX_TEMPFAIL</SPAN
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Temporary failure. Used to indicate the message could
not be sent immediately, perhaps because a connection
could not be created, but the request can be retried.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="SEQ"
></A
>seq</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60309"
></A
><H2
>Name</H2
>seq&nbsp;--&nbsp;generate a sequence of numbers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60312"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/usr/bin/seq</B
> [-f fmt_str] [-s sep_str] [first_num] [inc_num]  last_num </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60320"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>seq</B
> command shall output a sequence of numbers
from <TT
CLASS="PARAMETER"
><I
>first_num</I
></TT
> to
<TT
CLASS="PARAMETER"
><I
>last_num</I
></TT
>, stepping by the increment
<TT
CLASS="PARAMETER"
><I
>inc_num</I
></TT
>.  The <TT
CLASS="PARAMETER"
><I
>first_num</I
></TT
>
and <TT
CLASS="PARAMETER"
><I
>last_num</I
></TT
> parameters may be omitted, and
default to 1 even when <TT
CLASS="PARAMETER"
><I
>first_num</I
></TT
> is greater
than <TT
CLASS="PARAMETER"
><I
>last_num</I
></TT
>.  Floating-point values may be
specified for <TT
CLASS="PARAMETER"
><I
>first_num</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>inc_num</I
></TT
>, and <TT
CLASS="PARAMETER"
><I
>last_num</I
></TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>fmt_str</I
></TT
> parameter is a floating point format
string like the one used for the <TT
CLASS="FUNCTION"
>printf()</TT
> function in
C.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>sep_str</I
></TT
> parameter string separates the values
that are output. The default is a newline character (<TT
CLASS="LITERAL"
>/n</TT
>).

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>
If <TT
CLASS="PARAMETER"
><I
>first_num</I
></TT
> is less than
<TT
CLASS="PARAMETER"
><I
>last_num</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>inc_num</I
></TT
> is
negative, or <TT
CLASS="PARAMETER"
><I
>first_num</I
></TT
> is greater than
<TT
CLASS="PARAMETER"
><I
>last_num</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>inc_num</I
></TT
> is
positive, <B
CLASS="COMMAND"
>seq</B
> shall not generate any output.&#13;</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60349"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60352"
></A
><SPAN
STYLE="white-space: nowrap"
>-f fmt_str</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Format the numbers in the output sequence according to <TT
CLASS="PARAMETER"
><I
>fmt_str</I
></TT
>, a
floating point format string like the one used for the <TT
CLASS="FUNCTION"
>printf()</TT
> function
in C.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60358"
></A
><SPAN
STYLE="white-space: nowrap"
>-s sep_str</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Separate the numbers in the output sequence with <TT
CLASS="PARAMETER"
><I
>sep_str</I
></TT
>.
The default separator string is a newline character (<TT
CLASS="LITERAL"
>\n</TT
>).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60364"
></A
><SPAN
STYLE="white-space: nowrap"
>first_num</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The first number in the output sequence. Defaults to 1.
May be a floating point value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60368"
></A
><SPAN
STYLE="white-space: nowrap"
>inc_num</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The increment for the output sequence. Defaults to 1.
May be a floating point value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60372"
></A
><SPAN
STYLE="white-space: nowrap"
>last_num</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The last number in the output sequence.
May be a floating point value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="SH"
></A
>sh</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60379"
></A
><H2
>Name</H2
>sh&nbsp;--&nbsp;shell, the standard command language interpreter</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60382"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>sh</B
> utility shall behave as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
extensions listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="CMD-SH-INVOKE"
></A
><H2
>Shell Invocation</H2
><P
>The shell shall support an additional option, <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> 
(the letter <I
CLASS="EMPHASIS"
>ell</I
>).
If the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> option is specified, or if the first character
of argument zero (the command name) is a <TT
CLASS="LITERAL"
>'-'</TT
>, this invokation
of the shell is a <I
CLASS="EMPHASIS"
>login shell</I
>.</P
><P
>An interactive shell, as specified in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>,
that is also a login shell, or any shell if invoked with the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
>
option, shall, prior to reading from the input file,
first read and execute commands from the file
<TT
CLASS="FILENAME"
>/etc/profile</TT
>,
if that file exists, and then from a file called <TT
CLASS="FILENAME"
>~/.profile</TT
>,
if such a file exists.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification requires that the <B
CLASS="COMMAND"
>sh</B
> utility shall also read 
and execute commands in its current execution environment from all the shell scripts 
in the directory <TT
CLASS="FILENAME"
>/etc/profile.d</TT
>. Such scripts are read and executed
as a part of reading and executing <TT
CLASS="FILENAME"
>/etc/profile</TT
>.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="SHUTDOWN"
></A
>shutdown</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60408"
></A
><H2
>Name</H2
>shutdown&nbsp;--&nbsp;shut the system down</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60411"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>/sbin/shutdown</B
> [-t sec] [-h | -r] [-akfF]  time  [warning-message]<BR><B
CLASS="COMMAND"
>/sbin/shutdown</B
>  -c  [warning-message]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60425"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>shutdown</B
> command
shall shut the system down in a secure way (first synopsis), or cancel
a pending shutdown (second synopsis).  
When the shutdown is initiated, all logged-in users
shall be notified immediately that the system is going down, and users shall be
prevented from logging in to the system.
The <TT
CLASS="PARAMETER"
><I
>time</I
></TT
> specifies when the actual
shutdown shall commence. See below for details. At the specified time
all processes are first notified that the system is
going down by the signal <CODE
CLASS="CONSTANT"
>SIGTERM</CODE
>. After an interval
(see <TT
CLASS="PARAMETER"
><I
>-t</I
></TT
>) all processes shall be sent the signal
<CODE
CLASS="CONSTANT"
>SIGKILL</CODE
>.
If neither the <TT
CLASS="PARAMETER"
><I
>-h</I
></TT
> or the 
<TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> argument is specified, then the default behavior
shall be to take the system to a runlevel where administrative tasks can
be run. See also <A
HREF="#RUNLEVELS"
>Run Levels</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This is sometimes referred to as "single user mode".</P
></BLOCKQUOTE
></DIV
></P
><P
>The <TT
CLASS="PARAMETER"
><I
>-h</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> options
are mutually exclusive.
If either the <TT
CLASS="PARAMETER"
><I
>-h</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>-r</I
></TT
> options
are specified, the system shall be halted or rebooted respectively.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60443"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60446"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>use access control. See below.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60450"
></A
><SPAN
STYLE="white-space: nowrap"
>-t sec</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>tell the system to wait <TT
CLASS="PARAMETER"
><I
>sec</I
></TT
> seconds between 
sending processes the warning
and the kill signal, before changing to another runlevel. The default
period is unspecified.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60455"
></A
><SPAN
STYLE="white-space: nowrap"
>-k</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>do not really shutdown; only send the warning messages to everybody.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60459"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>reboot after shutdown.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60463"
></A
><SPAN
STYLE="white-space: nowrap"
>-h</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>halt after shutdown.  Actions after halting are unspecified (e.g. power off).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60467"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>advise the system to skip file system consistency checks on reboot.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60471"
></A
><SPAN
STYLE="white-space: nowrap"
>-F</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>advise the system to force file system consistency checks on reboot.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60475"
></A
><SPAN
STYLE="white-space: nowrap"
>-c</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>cancel an already running <B
CLASS="COMMAND"
>shutdown</B
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60480"
></A
><SPAN
STYLE="white-space: nowrap"
>time</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specify when to shut down.</P
><P
>The time argument shall have the following format:
<TT
CLASS="CMDSYNOPSIS"
>[now | [+]mins | hh:mm]</TT
>
If the format is <TT
CLASS="LITERAL"
>hh:mm</TT
>, <TT
CLASS="LITERAL"
>hh</TT
>
shall specify the hour (1 or 2
digits) and <TT
CLASS="LITERAL"
>mm</TT
> is the minute of the hour 
(exactly two digits), and the shutdown shall commence at the next
occurence of the specified time.  
If the format is <TT
CLASS="LITERAL"
>mins</TT
> (or <TT
CLASS="LITERAL"
>+mins</TT
>),
where <TT
CLASS="LITERAL"
>mins</TT
> is a decimal number,
shutdown shall commence in the specified number of minutes.
The word <TT
CLASS="LITERAL"
>now</TT
> is an alias for <TT
CLASS="LITERAL"
>+0</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60499"
></A
><SPAN
STYLE="white-space: nowrap"
>warning-message</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specify a message to send to all users.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="REFSECT2"
><A
NAME="AEN60503"
></A
><H3
>Access Control</H3
><P
>If the <B
CLASS="COMMAND"
>shutdown</B
> utility is invoked with the
<TT
CLASS="PARAMETER"
><I
>-a</I
></TT
> option, it shall check that an
authorized user is currently logged in on the system console. Authorized users
are listed, one per line, in the file 
<TT
CLASS="FILENAME"
>/etc/shutdown.allow</TT
>. Lines in this file
that begin with a <TT
CLASS="LITERAL"
>'#'</TT
> or are blank shall be ignored.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The intent of this scheme is to allow a keyboard sequence entered on
the system console (e.g. <TT
CLASS="LITERAL"
>CTRL-ALT-DEL</TT
>, or 
<TT
CLASS="LITERAL"
>STOP-A</TT
>) to automatically invoke
<B
CLASS="COMMAND"
>shutdown -a</B
>, and can be used to prevent unauthorized users from shutting the
system down in this fashion.</P
></BLOCKQUOTE
></DIV
></P
></DIV
></DIV
><H1
><A
NAME="SU"
></A
>su</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60518"
></A
><H2
>Name</H2
>su&nbsp;--&nbsp;change user ID</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60521"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>su</B
> [options] [-] [username  [ARGS]]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60528"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>su</B
> command shall start a shell
running with the real and effective user and group IDs of
the user <TT
CLASS="PARAMETER"
><I
>username</I
></TT
>.
If <TT
CLASS="PARAMETER"
><I
>username</I
></TT
> is not specified, 
<B
CLASS="COMMAND"
>su</B
> shall default to an unspecified user with
all appropriate privileges. If the <TT
CLASS="PARAMETER"
><I
>-s</I
></TT
> or 
<TT
CLASS="PARAMETER"
><I
>--shell</I
></TT
> is not specified, the shell to be invoked shall be that
specified for <TT
CLASS="PARAMETER"
><I
>username</I
></TT
> in the user database
(see <TT
CLASS="FUNCTION"
>getpwnam()</TT
>),
or <TT
CLASS="FILENAME"
>/bin/sh</TT
> if there is no shell specified
in the user database.</P
><P
>If the <TT
CLASS="PARAMETER"
><I
>-</I
></TT
> option
is specified, or if the first operand is <TT
CLASS="LITERAL"
>-</TT
>, the 
environment for the shell shall be initialized as if the new shell was a login shell
(see <A
HREF="#CMD-SH-INVOKE"
>Shell Invocation</A
>).</P
><P
>If the invoking user does not have appropriate privileges, the <B
CLASS="COMMAND"
>su</B
>
command shall prompt for a password and validate this before continuing.
Invalid
passwords shall produce an error message.  
The <B
CLASS="COMMAND"
>su</B
> command shall log in an unspecified manner all invokations,
whether successful or unsuccessful.</P
><P
>Any operands specified after the <TT
CLASS="PARAMETER"
><I
>username</I
></TT
>
shall be passed to the invoked shell.</P
><P
>If the option <TT
CLASS="PARAMETER"
><I
>-</I
></TT
> is not specified, 
and if the first operand is not <TT
CLASS="LITERAL"
>-</TT
>,
the environemnt for the new shell shall be intialized from the current
environment. If none of the 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-p</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--preserve-environment</I
></TT
> 
options are specified, the environment 
may be modified in unspecified ways before invoking the shell.
If any of the 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>-p</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>--preserve-environment</I
></TT
> 
options are specified, the environment shall not be altered.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Although the <B
CLASS="COMMAND"
>su</B
> command shall not alter the
environment, the invoked shell may still alter it before it is ready
to intepret any commands.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60569"
></A
><H2
>Standard Options</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-</DT
><DD
><P
>the invoked shell shall be a login shell.</P
></DD
><DT
>-c <TT
CLASS="PARAMETER"
><I
>command</I
></TT
>, --command=<TT
CLASS="PARAMETER"
><I
>command</I
></TT
></DT
><DD
><P
>Invoke the shell with the option <TT
CLASS="LITERAL"
>-c <TT
CLASS="PARAMETER"
><I
>command</I
></TT
></TT
>.</P
></DD
><DT
>-m, -p, --preserve-environment</DT
><DD
><P
>The current environment shall be passed to the invoked shell. If the environment
variable <CODE
CLASS="ENVAR"
>SHELL</CODE
> is set, it shall specify the shell to invoke, if it matches
an entry in <TT
CLASS="FILENAME"
>/etc/shells</TT
>. If there is no matching entry in
<TT
CLASS="FILENAME"
>/etc/shells</TT
>, 
this option shall be ignored if the <TT
CLASS="PARAMETER"
><I
>-</I
></TT
> option is also specified, or if the
first operand is <TT
CLASS="LITERAL"
>-</TT
>.</P
></DD
><DT
>-s <TT
CLASS="PARAMETER"
><I
>shell</I
></TT
>, --shell=<TT
CLASS="PARAMETER"
><I
>shell</I
></TT
></DT
><DD
><P
>Invoke <TT
CLASS="PARAMETER"
><I
>shell</I
></TT
> as the comamnd interpreter.
The shell specified
shall be present in <TT
CLASS="FILENAME"
>/etc/shells</TT
>.</P
></DD
></DL
></DIV
></DIV
><H1
><A
NAME="SYNC"
></A
>sync</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60604"
></A
><H2
>Name</H2
>sync&nbsp;--&nbsp;flush file system buffers</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60607"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>sync</B
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60610"
></A
><H2
>Description</H2
><P
>Force changed blocks to disk, update the super block.</P
></DIV
><H1
><A
NAME="TAR"
></A
>tar</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60616"
></A
><H2
>Name</H2
>tar&nbsp;--&nbsp;file archiver</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60619"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>tar</B
> is as specified in 
<A
HREF="#STD.SUSV2"
>SUSv2</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60624"
></A
><H2
>Differences</H2
><P
>Some elements of the Pattern Matching Notation are optional;
see <A
HREF="#LOCALIZATION-GLOB"
>Pattern Matching Notation</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60629"
></A
><SPAN
STYLE="white-space: nowrap"
>-h</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>doesn't dump symlinks; dumps the files they point to.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60633"
></A
><SPAN
STYLE="white-space: nowrap"
>-z</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>filters the archive through <B
CLASS="COMMAND"
>gzip</B
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="UMOUNT"
></A
>umount</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60641"
></A
><H2
>Name</H2
>umount&nbsp;--&nbsp;unmount file systems</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60644"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>umount</B
> [-hV]<BR><B
CLASS="COMMAND"
>umount</B
>  -a  [-nrv] [-t vfstype]<BR><B
CLASS="COMMAND"
>umount</B
> [-nrv]  device | dir... </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60659"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>umount</B
> detaches the file system(s) mentioned from the file
hierarchy.  A file system is specified by giving the directory where
it has been mounted.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60663"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60666"
></A
><SPAN
STYLE="white-space: nowrap"
>-v</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>invokes verbose mode.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60670"
></A
><SPAN
STYLE="white-space: nowrap"
>-n</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>unmounts without writing in /etc/mtab.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60674"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>tries to remount read-only if unmounting fails.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60678"
></A
><SPAN
STYLE="white-space: nowrap"
>-a</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>unmounts all of the file systems described in /etc/mtab except
for the proc file system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60682"
></A
><SPAN
STYLE="white-space: nowrap"
>-t vfstype</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>indicates that the actions should only be taken on file systems of the
specified type.  More than one type may be specified in a comma
separated list.  The list of file system types can be prefixed with no
to specify the file system types on which no action should be taken.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60686"
></A
><SPAN
STYLE="white-space: nowrap"
>-f</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>forces unmount (in case of an unreachable NFS system).</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60690"
></A
><H2
>LSB Deprecated Options</H2
><P
>The behaviors specified in this section are expected to
disappear from a future version of the LSB; applications should only
use the non-LSB-deprecated behaviors.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60694"
></A
><SPAN
STYLE="white-space: nowrap"
>-V</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>print version and exits.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="USERADD"
></A
>useradd</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60701"
></A
><H2
>Name</H2
>useradd&nbsp;--&nbsp;create a new user or update default new user information</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60704"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>useradd</B
> [-c comment] [-d home_dir] [-g initial_group] [-G group...] [-m  [-k skeleton_dir]] [-p passwd] [-r] [-s shell] [-u uid  [-o]]  login <BR><B
CLASS="COMMAND"
>useradd</B
>  -D  [-g default_group] [-b default_home] [-s default_shell]</TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60725"
></A
><H2
>Description</H2
><P
>When invoked without the <TT
CLASS="PARAMETER"
><I
>-D</I
></TT
>
option, and with appropriate privilege, 
<B
CLASS="COMMAND"
>useradd</B
> creates a new
user account using the values specified on the command line and the
default values from the system.  The new user account will be entered
into the system files as needed, the home directory will be created,
and initial files copied, depending on the command line options.
If the group named <TT
CLASS="PARAMETER"
><I
>group</I
></TT
> does not exist,
or the user names <TT
CLASS="PARAMETER"
><I
>login</I
></TT
> already exists,
or the user ID <TT
CLASS="PARAMETER"
><I
>uid</I
></TT
> is already in use
and no <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is specified, then
<B
CLASS="COMMAND"
>useradd</B
> shall issue a diagnostic message and exit
with a non-zero exit status.</P
><P
>When invoked with the <TT
CLASS="PARAMETER"
><I
>-D</I
></TT
>
option, <B
CLASS="COMMAND"
>useradd</B
> will either 
display the current default values, or,
with appropriate privilege, update the default values from 
the command line.  If no options are specified, <B
CLASS="COMMAND"
>useradd</B
> 
displays the current default values.</P
><P
>The <B
CLASS="COMMAND"
>useradd</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60742"
></A
><H2
>Standard Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60745"
></A
><SPAN
STYLE="white-space: nowrap"
>-c comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the new user's password file comment field value.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60749"
></A
><SPAN
STYLE="white-space: nowrap"
>-d home_dir</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates the new user using home_dir as the value for the
user's login directory.  The default is to append the login name to
default_home and use that as the login directory name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60753"
></A
><SPAN
STYLE="white-space: nowrap"
>-g initial_group</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the group name or number of the user's initial login group. 
The group name shall exist. A group number shall refer to an already 
existing group. If <TT
CLASS="PARAMETER"
><I
>-g</I
></TT
>
is not specified, the implementation will follow 
the normal user
default for that system. This may create a new group or choose a default
group that normal users are placed in. Applications which require control
of the groups into which a user is placed should specify 
<TT
CLASS="PARAMETER"
><I
>-g</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60759"
></A
><SPAN
STYLE="white-space: nowrap"
>-G group[,...]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies a list of supplementary groups which the user is also a member of.
Each group is separated from the next by a comma, with no intervening
whitespace.  The groups are subject to the same restrictions as the
group given with the 
<TT
CLASS="PARAMETER"
><I
>-g</I
></TT
> option.  The default is for the user to belong
only to the initial group.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60764"
></A
><SPAN
STYLE="white-space: nowrap"
>-m [-k skeleton_dir]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the user's home directory will be created if it does not exist. 
The files contained in <TT
CLASS="FILENAME"
>skeleton_dir</TT
>
will be copied to the home directory
if the <TT
CLASS="PARAMETER"
><I
>-k</I
></TT
>
option is used, otherwise the files contained in 
<TT
CLASS="FILENAME"
>/etc/skel</TT
>
will be used instead.  Any directories contained in 
<TT
CLASS="FILENAME"
>skeleton_dir</TT
> or
<TT
CLASS="FILENAME"
>/etc/skel</TT
> 
will be created in the user's home directory as well.  The
<TT
CLASS="PARAMETER"
><I
>-k</I
></TT
> 
option is only valid in conjunction with the 
<TT
CLASS="PARAMETER"
><I
>-m</I
></TT
> option.  The
default is to not create the directory and to not copy any files.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60775"
></A
><SPAN
STYLE="white-space: nowrap"
>-p passwd</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is the encrypted password, as returned by <TT
CLASS="FUNCTION"
>crypt()</TT
>.
The default is to
disable the account.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60780"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>creates a system account, that is, a user with a
User ID in the range reserved for system account users. If there is not a
User ID free in the reserved range the command will fail.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60784"
></A
><SPAN
STYLE="white-space: nowrap"
>-s shell</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the name of the user's login shell.  The default is to leave this
field blank, which causes the system to select the default login
shell.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60788"
></A
><SPAN
STYLE="white-space: nowrap"
>-u uid [-o]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the numerical value of the user's ID.  This value shall be unique,
unless the <TT
CLASS="PARAMETER"
><I
>-o</I
></TT
> option is used.  The value shall be non-negative.
The default is the smallest ID value greater than 499 which is not yet used. </P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60793"
></A
><H2
>Change Default Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60796"
></A
><SPAN
STYLE="white-space: nowrap"
>-b default_home</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the initial path prefix for a new user's home directory.  The user's
name will be affixed to the end of default_home to create the new
directory name if the -d option is not used when creating a new
account.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60800"
></A
><SPAN
STYLE="white-space: nowrap"
>-g default_group</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the group name or ID for a new user's initial group.  The named 
group shall exist, and a numerical group ID shall have an existing entry.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60804"
></A
><SPAN
STYLE="white-space: nowrap"
>-s default_shell</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the name of the new user's login shell.  The named program will be
used for all future new user accounts.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60808"
></A
><SPAN
STYLE="white-space: nowrap"
>-c comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the new user's password file comment field value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60812"
></A
><H2
>Application Usage</H2
><P
>The <TT
CLASS="PARAMETER"
><I
>-D</I
></TT
> 
option will typically be used by system administration
packages.  Most applications should not change defaults which will
affect other applications and users.</P
></DIV
><H1
><A
NAME="USERDEL"
></A
>userdel</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60819"
></A
><H2
>Name</H2
>userdel&nbsp;--&nbsp;delete a user account and related files</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60822"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>userdel</B
> [-r]  login </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60827"
></A
><H2
>Description</H2
><P
>Delete the user account named <TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
>.  If there is also a group named
<TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
>, this command may
delete the group as well, or may leave it alone.
If the user named <TT
CLASS="PARAMETER"
><I
>login</I
></TT
> does not exist
or is currently logged in,
<B
CLASS="COMMAND"
>userdel</B
> shall issue a diagnostic message and exit
with a non-zero exit status.</P
><P
>The <B
CLASS="COMMAND"
>userdel</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60837"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60840"
></A
><SPAN
STYLE="white-space: nowrap"
>-r</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>removes files in the user's home directory along with the home
directory itself.  Files located in other file system will have to be
searched for and deleted manually.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="USERMOD"
></A
>usermod</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60847"
></A
><H2
>Name</H2
>usermod&nbsp;--&nbsp;modify a user account</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN60850"
></A
><H2
>Synopsis</H2
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>usermod</B
> [-c comment] [-d home_dir  [ -m]] [-g initial_group] [-G group [,...]] [-l login_name] [-p passwd] [-s shell] [-u uid  [ -o]]  login </TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60865"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>usermod</B
> command shall modify an entry in the user
account database.</P
><P
>The <B
CLASS="COMMAND"
>usermod</B
> command is a system administration utility,
see <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
>.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60872"
></A
><H2
>Options</H2
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60875"
></A
><SPAN
STYLE="white-space: nowrap"
>-c comment</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the new value of the user's password file comment field.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60879"
></A
><SPAN
STYLE="white-space: nowrap"
>-d home_dir</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the user's new login directory.  If the -m option is given the
contents of the current home directory will be moved to the new home
directory, which is created if it does not already exist.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60883"
></A
><SPAN
STYLE="white-space: nowrap"
>-g initial_group</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the group name or number of the user's new initial login group. 
The group name shall exist.  A group number shall refer to an already
existing group.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60887"
></A
><SPAN
STYLE="white-space: nowrap"
>-G group,[...]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies a list of supplementary groups which the user is also a member of.
Each group is separated from the next by a comma, with no intervening
whitespace.  The groups are subject to the same restrictions as the
group given with the -g option.  If the user is currently a member of
a group which is not listed, the user will be removed from the group.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60891"
></A
><SPAN
STYLE="white-space: nowrap"
>-l login_name</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>changes the name of the user from login to login_name.
Nothing else is changed.  In particular, the user's home directory
name should probably be changed to reflect the new login name.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60895"
></A
><SPAN
STYLE="white-space: nowrap"
>-p passwd</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>is the encrypted password, as returned by crypt(3).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60899"
></A
><SPAN
STYLE="white-space: nowrap"
>-s shell</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the name of the user's new login shell.  Setting this field to blank
causes the system to select the default login shell.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60903"
></A
><SPAN
STYLE="white-space: nowrap"
>-u uid [-o]</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>specifies the numerical value of the user's ID.  This value shall be unique,
unless the -o option is used.  The value shall be non-negative.  Any
files which the user owns and which are located in the directory tree
rooted at the user's home directory will have the file user ID changed
automatically.  Files outside of the user's home directory shall be
altered manually.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><H1
><A
NAME="XARGS"
></A
>xargs</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60910"
></A
><H2
>Name</H2
>xargs&nbsp;--&nbsp;build and execute command lines from standard input</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60913"
></A
><H2
>Description</H2
><P
><B
CLASS="COMMAND"
>xargs</B
> is as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, but with
differences as listed below.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60918"
></A
><H2
>Differences</H2
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60922"
></A
><SPAN
STYLE="white-space: nowrap"
>-E</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60926"
></A
><SPAN
STYLE="white-space: nowrap"
>-I</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60930"
></A
><SPAN
STYLE="white-space: nowrap"
>-L</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>has unspecified behavior.</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These options have been implemented in <B
CLASS="COMMAND"
>findutils-4.2.9</B
>,
but this version of the utilities is not in widespread use as of
April 2005. However, future versions of this specification will require
support for these arguments.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><H1
><A
NAME="ZCAT"
></A
>zcat</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN60940"
></A
><H2
>Name</H2
>zcat&nbsp;--&nbsp;uncompress files to standard output</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN60943"
></A
><H2
>Description</H2
><P
>The <B
CLASS="COMMAND"
>zcat</B
> utility shall behave as described
in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, with differences listed below.</P
><P
>The <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> requires that if 
<B
CLASS="COMMAND"
>zcat</B
> exists, it must be a symbolic or hard link
to <TT
CLASS="FILENAME"
>/bin/gzip</TT
>.  This specification additionally
allows <B
CLASS="COMMAND"
>zcat</B
> to be a wrapper script which
calls <B
CLASS="COMMAND"
>gzip -c -d</B
>.</P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN60954"
></A
><H3
>Differences</H3
><P
>The <B
CLASS="COMMAND"
>zcat</B
> utility shall write to standard output the uncompressed form of files
that have been compressed using any of the compression methods supported by the
<B
CLASS="COMMAND"
>gzip</B
> utility. It is the equivalent of 
<B
CLASS="COMMAND"
>gzip -c -d</B
>. Input files are not affected.</P
></DIV
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCEXECENV"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VII. Execution Environment</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>18. <A
HREF="#EXECENVFHS"
>File System Hierarchy</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#DEV"
><TT
CLASS="FILENAME"
>/dev</TT
>: Device Files</A
></DT
><DT
>18.2. <A
HREF="#ETC"
><TT
CLASS="FILENAME"
>/etc</TT
>: Host-specific system configuration</A
></DT
><DD
><DL
><DT
>18.2.1. <A
HREF="#FHS-NAME-RULES"
>File Naming Conventions</A
></DT
></DL
></DD
><DT
>18.3. <A
HREF="#FHS-USER-ACCOUNTING-DBS"
>User Accounting Databases</A
></DT
><DT
>18.4. <A
HREF="#FHS-SYSADMIN"
>Path For System Administration Utilities</A
></DT
></DL
></DD
><DT
>19. <A
HREF="#EXECSTUFF"
>Additional Recommendations</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#PERMISSIONS-SHOULD"
>Recommendations for applications on ownership and permissions</A
></DT
><DD
><DL
><DT
>19.1.1. <A
HREF="#PERMISSIONS-DIRWRITE"
>Directory Write Permissions</A
></DT
><DT
>19.1.2. <A
HREF="#PERMISSIONS-FILEWRITE"
>File Write Permissions</A
></DT
><DT
>19.1.3. <A
HREF="#PERMISSIONS-FILEREAD"
>File Read and execute Permissions</A
></DT
><DT
>19.1.4. <A
HREF="#PERMISSIONS-SBITS"
>SUID and SGID Permissions</A
></DT
><DT
>19.1.5. <A
HREF="#PRIVILEDGED-USERS"
>Privileged users</A
></DT
><DT
>19.1.6. <A
HREF="#CHANGING-PERMISSIONS"
>Changing permissions</A
></DT
><DT
>19.1.7. <A
HREF="#PERMISSION-MEDIA"
>Removable Media (Cdrom, Floppy, etc.)</A
></DT
><DT
>19.1.8. <A
HREF="#PERMISSION-INSTALLERS"
>Installable applications</A
></DT
></DL
></DD
></DL
></DD
><DT
>20. <A
HREF="#EXECENV-ADDNTL-BHVR"
>Additional Behaviors</A
></DT
><DD
><DL
><DT
>20.1. <A
HREF="#AEN61171"
>Mandatory Optional Behaviors</A
></DT
><DD
><DL
><DT
>20.1.1. <A
HREF="#ADDL-BEHAVIORS-TEST"
>Special Requirements</A
></DT
></DL
></DD
><DT
>20.2. <A
HREF="#EXEC-OPT-MANDATORY"
>Optional Mandatory Behaviors</A
></DT
><DT
>20.3. <A
HREF="#EXECUTABLE-SCRIPTS"
>Executable Scripts</A
></DT
></DL
></DD
><DT
>21. <A
HREF="#LOCALIZATION"
>Localization</A
></DT
><DD
><DL
><DT
>21.1. <A
HREF="#AEN61343"
>Introduction</A
></DT
><DT
>21.2. <A
HREF="#LOCALIZATION-REGEX"
>Regular Expressions</A
></DT
><DT
>21.3. <A
HREF="#LOCALIZATION-GLOB"
>Pattern Matching Notation</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="EXECENVFHS"
></A
>Chapter 18. File System Hierarchy</H1
><P
>An LSB conforming implementation shall provide the mandatory portions of the
file system hierarchy specified in the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> (FHS),
together with any additional requirements made in this specification.</P
><P
>An LSB conforming application shall conform to the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
>.</P
><P
>The FHS allows many components or subsystems to be optional. An application
shall check for the existence of an optional component before using it, and
should behave in a reasonable manner if the optional component is not
present.</P
><P
>The FHS requirement to locate the operating system kernel in either
<TT
CLASS="FILENAME"
>/</TT
> or <TT
CLASS="FILENAME"
>/boot</TT
> does not apply if
the operating system kernel does not exist as a file in the file system.</P
><P
>The FHS specifies certain behaviors for a variety of commands if they
are present (for example, <B
CLASS="COMMAND"
>ping</B
> or <B
CLASS="COMMAND"
>python</B
>).
However, conforming applications
shall not rely on any commands beyond those required by this specification.
The mere existence of a command may not be used as an indication that the
command behaves in any particular way.</P
><P
>The following directories or links need not be present:
<TT
CLASS="FILENAME"
>/etc/X11</TT
> 
<TT
CLASS="FILENAME"
>/usr/bin/X11</TT
>
<TT
CLASS="FILENAME"
>/usr/lib/X11</TT
>
<TT
CLASS="FILENAME"
>/proc</TT
></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DEV"
>18.1. <TT
CLASS="FILENAME"
>/dev</TT
>: Device Files</A
></H2
><P
>The devices described in 
Chapter 6. "Operating System Specific Annex",
Section 6.1. "Linux", subsection 6.1.3. "/dev: Devices and special files"
in the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> are required on an LSB conforming system.
Other devices may also exist in <TT
CLASS="FILENAME"
>/dev</TT
>. 
Device names may exist as symbolic links to other device nodes
located in <TT
CLASS="FILENAME"
>/dev</TT
> or
subdirectories of <TT
CLASS="FILENAME"
>/dev</TT
>.
There is no requirement concerning major/minor number values.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="ETC"
>18.2. <TT
CLASS="FILENAME"
>/etc</TT
>: Host-specific system configuration</A
></H2
><P
>In addition to the requirements for <TT
CLASS="FILENAME"
>/etc</TT
> in the
<A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
>, an LSB conforming system shall also provide the
following directories or symbolic links to directories:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN60995"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.d</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing extended <B
CLASS="COMMAND"
>crontab</B
> files;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61002"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.daily</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once a day;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61008"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.hourly</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once per hour;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61014"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.monthly</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once per month;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61020"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/cron.weekly</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts to be executed once a week;
see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61026"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/init.d</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing system initialization scripts;
see <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61032"
></A
><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="FILENAME"
>/etc/profile.d</TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A directory containing shell scripts. 
Script names should follow the same conventions
as specified for cron jobs (see <A
HREF="#CRONJOBS"
>Cron Jobs</A
>, but should
have the suffix <TT
CLASS="FILENAME"
>.sh</TT
>.
The behavior is unspecified if a script is installed in this directory that
does not have the suffix <TT
CLASS="FILENAME"
>.sh</TT
>.</P
><P
>The <B
CLASS="COMMAND"
>sh</B
> utility
shall read and execute commands in its current execution environment 
from all the shell scripts in this directory that have the suffix <TT
CLASS="FILENAME"
>.sh</TT
>
when invoked as an interactive login shell,
or if the <TT
CLASS="PARAMETER"
><I
>-l</I
></TT
> (the letter <I
CLASS="EMPHASIS"
>ell</I
>)
is specified (see <A
HREF="#CMD-SH-INVOKE"
>Shell Invocation</A
>).</P
></TD
></TR
></TBODY
></TABLE
>
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Future Directions: </B
>These directories are required at this version of the LSB since there is not
yet an agreed method for abstracting the implementation so that applications
need not be aware of these locations during installation. </P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FHS-NAME-RULES"
>18.2.1. File Naming Conventions</A
></H3
><P
>Conforming implementations and applications installing files into any
of the above locations under
<TT
CLASS="FILENAME"
>/etc</TT
> may only use filenames
from the following managed namespaces:
<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>Assigned names.  Such names must be chosen from
the character set <TT
CLASS="LITERAL"
>[a-z0-9]</TT
>.
In order to avoid conflicts these 
names shall be registered. This specification establishes
a registry of provider, package and script names which is maintained
at the Linux Assigned Names and Numbers Authority (LANANA).
See <A
HREF="http://www.lanana.org"
TARGET="_top"
>www.lanana.org</A
>
to register names or look up already registered names.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Commonly used names should be registered to avoid conflicts
and promote name reuse across distributions.
Project developers are encouraged to reserve names with the LANANA
as early as possible as registration is on a first-come,
first-served basis.</P
></BLOCKQUOTE
></DIV
></LI
><LI
STYLE="list-style-type: disc"
><P
>Hierarchical names.  Script names in this category take the form: 
<TT
CLASS="FILENAME"
>&#60;hier1&#62;-&#60;hier2&#62;-...-&#60;name&#62;</TT
>,
where name is taken from the character set 
<TT
CLASS="LITERAL"
>[a-z0-9],</TT
> 
and where there may be one or more 
<TT
CLASS="FILENAME"
>&#60;hier-<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>&#62;</TT
> components.  
<TT
CLASS="FILENAME"
>&#60;hier1&#62;</TT
> may either be an LSB provider name 
registered with the LANANA,
or it may be a domain name registered to the provider in the DNS system,
containing at least one <TT
CLASS="LITERAL"
>'.'</TT
>
(e.g. "<TT
CLASS="LITERAL"
>debian.org</TT
>", "<TT
CLASS="LITERAL"
>staroffice.sun.com</TT
>").
The LSB provider name registered with the LANANA 
shall only consist of the ASCII characters <TT
CLASS="LITERAL"
>[a-z0-9]</TT
>.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Reserved names.  Names that
begin with the character '<TT
CLASS="LITERAL"
>_</TT
>' are reserved for
distribution use only.  Names in this form should be used
for essential system packages only.</P
></LI
></UL
>

<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>As this specification cannot enforce rules for applications which
do not choose to conform to it, conforming applications need to be
aware that the managed namespaces may have been polluted 
with unregistered filenames and should check
for namespace collisions and take appropriate steps if they occur.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>In general, if a package or system script is likely to be used
on multiple systems, the package developers or the distribution should
register the name through the LANANA, and distributions should strive to
use the same name whenever possible.  For applications which may not
be essential or may not be commonly installed, the hierarchical namespace
may be more appropriate.  An advantage to the hierarchical namespace
is that there is no need to consult with the LANANA before using a 
specific name.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Short names are highly desirable, since system
administrators may wish to manually start and stop services.
Given this, they should be standardized on a per-package basis.  This
is the rationale behind having the LANANA organization assign these
names.  The LANANA may be called upon to handle other namespace issues,
such as package/prerequisites naming.</P
></BLOCKQUOTE
></DIV
>&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FHS-USER-ACCOUNTING-DBS"
>18.3. User Accounting Databases</A
></H2
><P
>The <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> specifies two optional locations for user
accounting databases 
used by the <TT
CLASS="FUNCTION"
>getutent()</TT
>, <TT
CLASS="FUNCTION"
>getutent_r()</TT
>, <TT
CLASS="FUNCTION"
>getutxent()</TT
>, <TT
CLASS="FUNCTION"
>getutxid()</TT
>, <TT
CLASS="FUNCTION"
>getutxline()</TT
>, and <TT
CLASS="FUNCTION"
>pututxline()</TT
> functions. These are
<TT
CLASS="FILENAME"
>/var/run/utmp</TT
> and <TT
CLASS="FILENAME"
>/var/run/wtmp</TT
>.</P
><P
>The LSB does not specify the format or structure of these files, or even if
they are files at all. They should be used only as "magic cookies" to
the <TT
CLASS="FUNCTION"
>utmpname()</TT
> function. </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FHS-SYSADMIN"
>18.4. Path For System Administration Utilities</A
></H2
><P
>Certain utilities used for system administration 
(and other privileged commands)
may be stored in 
<TT
CLASS="FILENAME"
>/sbin</TT
>, 
<TT
CLASS="FILENAME"
>/usr/sbin</TT
>, and 
<TT
CLASS="FILENAME"
>/usr/local/sbin</TT
>. Applications
requiring to use commands identified as system administration utilities
should add these directories to their 
<CODE
CLASS="ENVAR"
>PATH</CODE
>. By default, as described in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, standard utilities shall be found on the 
<CODE
CLASS="ENVAR"
>PATH</CODE
> returned
by <B
CLASS="COMMAND"
>getconf PATH</B
> (or <B
CLASS="COMMAND"
>command -p getconf PATH</B
>
to be guaranteed to invoke the correct version of <B
CLASS="COMMAND"
>getconf</B
>).</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="EXECSTUFF"
></A
>Chapter 19. Additional Recommendations</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="PERMISSIONS-SHOULD"
>19.1. Recommendations for applications on ownership and permissions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-DIRWRITE"
>19.1.1. Directory Write Permissions</A
></H3
><P
>The application should not depend on having directory write 
permission in any directory except 
<TT
CLASS="FILENAME"
>/tmp</TT
>, <TT
CLASS="FILENAME"
>/var/tmp</TT
>, and the invoking user's home directory.</P
><P
>In addition, the application may store variable data in 
<TT
CLASS="FILENAME"
>/var/opt/<TT
CLASS="REPLACEABLE"
><I
>package</I
></TT
></TT
>,
(where <TT
CLASS="REPLACEABLE"
><I
>package</I
></TT
> is the name of the 
application package), if such a directory is created with appropriate permissions during the package installation.</P
><P
>For these directories the application should be able to work 
with directory write permissions restricted by the 
<CODE
CLASS="CONSTANT"
>S_ISVTXT</CODE
> bit, implementing the restricted
deletion mode as described for the XSI option for <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-FILEWRITE"
>19.1.2. File Write Permissions</A
></H3
><P
>The application should not depend on file write permission to
any file that it does not itself create.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-FILEREAD"
>19.1.3. File Read and execute Permissions</A
></H3
><P
>The application should not depend on having read permission to
every file and directory.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSIONS-SBITS"
>19.1.4. SUID and SGID Permissions</A
></H3
><P
>The application should not depend on the set user ID or set group ID
(the <CODE
CLASS="CONSTANT"
>S_ISUID</CODE
> or <CODE
CLASS="CONSTANT"
>S_ISGID</CODE
>
permission bits)
permissions of a 
file not packaged with the application. Instead, the distribution is 
responsible for assuming that all system commands have the required 
permissions and work correctly.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>In order to implement common security policies it is strongly advisable
for applications to use the minimum set of security attributes necessary for
correct operation. Applications that require substantial appropriate privilege
are likely to cause problems with such security policies.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PRIVILEDGED-USERS"
>19.1.5. Privileged users</A
></H3
><P
>In general, applications should not depend on running as a privileged user.
This specification uses the term "appropriate privilege" throughout to identify
operations that cannot be achieved without some special granting of additional
privilege.</P
><P
>Applications that have a reason to run with appropriate privilege
should outline this reason clearly in their documentation.
Users of the application should be informed, that "this application 
demands security privileges, which could interfere with system security".</P
><P
>The application should not contain binary-only software that 
requires being run with appropriate privilege, as this makes security auditing 
harder or even impossible. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHANGING-PERMISSIONS"
>19.1.6. Changing permissions</A
></H3
><P
>The application shall not change permissions of files and 
directories that do not belong to its own package. 
Should an application require that certain files and directories
not directly belonging to the package have a particular ownership,
the application shall document this requirement, and may fail during
installation if the permissions on these files is inappropriate.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSION-MEDIA"
>19.1.7. Removable Media (Cdrom, Floppy, etc.)</A
></H3
><P
>Applications that expect to be runnable from removable
media should not depend on logging in as a privileged user,
and should be prepared to deal with a restrictive
environment.  Examples of such restrictions could be
default mount options that disable set-user/group-ID
attributes, disabling block or character-special files on
the medium, or remapping the user and group IDs of files away
from any privileged value.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>System vendors and local system administrators
want to run applications from removable media, but want the
possibility to control what the application can do.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PERMISSION-INSTALLERS"
>19.1.8. Installable applications</A
></H3
><P
>Where the installation of an application needs additional privileges, it must
clearly document all files and system databases that are modified outside of
those in 
<TT
CLASS="FILENAME"
>/opt/<TT
CLASS="REPLACEABLE"
><I
>pkg-name</I
></TT
></TT
>,
<TT
CLASS="FILENAME"
>/etc/opt/<TT
CLASS="REPLACEABLE"
><I
>pkg-name</I
></TT
></TT
>,
and <TT
CLASS="FILENAME"
>/var/opt/<TT
CLASS="REPLACEABLE"
><I
>pkg-name</I
></TT
></TT
>,
other than those that may be
updated by system logging or auditing activities.
&#13;</P
><P
>Without this, the local system administrator 
would have to blindly trust a piece of software,
particularly with respect to its security.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="EXECENV-ADDNTL-BHVR"
></A
>Chapter 20. Additional Behaviors</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN61171"
>20.1. Mandatory Optional Behaviors</A
></H2
><P
>This section specifies behaviors in which there is optional
behavior in one of the standards on which this specification relies,
and where this specification requires a specific behavior.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not require the kernel to be Linux; the set of mandated 
options reflects current existing practice, but may be modified in
future releases.</P
></BLOCKQUOTE
></DIV
></P
><P
>LSB conforming implementations shall support the following options defined
within the <I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>_POSIX_FSYNC</TD
></TR
><TR
><TD
>_POSIX_MAPPED_FILES</TD
></TR
><TR
><TD
>_POSIX_MEMLOCK</TD
></TR
><TR
><TD
>_POSIX_MEMLOCK_RANGE</TD
></TR
><TR
><TD
>_POSIX_MEMORY_PROTECTION</TD
></TR
><TR
><TD
>_POSIX_PRIORITY_SCHEDULING</TD
></TR
><TR
><TD
>_POSIX_REALTIME_SIGNALS</TD
></TR
><TR
><TD
>_POSIX_THREAD_ATTR_STACKADDR</TD
></TR
><TR
><TD
>_POSIX_THREAD_ATTR_STACKSIZE</TD
></TR
><TR
><TD
>_POSIX_THREAD_PROCESS_SHARED</TD
></TR
><TR
><TD
>_POSIX_THREAD_SAFE_FUNCTIONS</TD
></TR
><TR
><TD
>_POSIX_THREADS</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>The <TT
CLASS="FUNCTION"
>opendir()</TT
>
function shall consume a file descriptor in the same
fashion as <TT
CLASS="FUNCTION"
>open()</TT
>, and therefore may fail with 
<CODE
CLASS="CONSTANT"
>EMFILE</CODE
> or <CODE
CLASS="CONSTANT"
>ENFILE</CODE
>.</P
><P
>The <CODE
CLASS="CONSTANT"
>START</CODE
> and 
<CODE
CLASS="CONSTANT"
>STOP</CODE
> <TT
CLASS="STRUCTNAME"
>termios</TT
>
characters shall be changeable, as
described as optional behavior in the "General Terminal Interface"
section of the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>.</P
><P
>The <TT
CLASS="FUNCTION"
>access()</TT
> function
function shall fail with <CODE
CLASS="VARNAME"
>errno</CODE
>
set to <CODE
CLASS="CONSTANT"
>EINVAL</CODE
> if the 
<TT
CLASS="PARAMETER"
><I
>amode</I
></TT
> argument contains bits other than 
those set by the bitwise inclusive OR of 
<CODE
CLASS="CONSTANT"
>R_OK</CODE
>, 
<CODE
CLASS="CONSTANT"
>W_OK</CODE
>, 
<CODE
CLASS="CONSTANT"
>X_OK</CODE
> and 
<CODE
CLASS="CONSTANT"
>F_OK</CODE
>.</P
><P
>The <TT
CLASS="FUNCTION"
>link()</TT
> function shall require access
to the existing file in
order to succeed, as described as optional behavior in the 
<I
CLASS="CITETITLE"
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
></I
>.</P
><P
>Calling <TT
CLASS="FUNCTION"
>unlink()</TT
> on a directory shall fail.
Calling <TT
CLASS="FUNCTION"
>link()</TT
> specifying a directory as the first
argument shall fail.  See also <A
HREF="#BASELIB-UNLINK-3"
>unlink</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Linux allows <TT
CLASS="FUNCTION"
>rename()</TT
> on a directory without
having write access, but this specification does not require this behavior.</P
></BLOCKQUOTE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ADDL-BEHAVIORS-TEST"
>20.1.1. Special Requirements</A
></H3
><P
>LSB conforming systems shall enforce certain special additional restrictions
above and beyond those required by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These additional restrictions are required in order to support the testing
and certification programs associated with the LSB. In each case, these are values
that defined macros must not have; conforming applications that use these values
shall trigger a failure in the interface that is otherwise described as a "may fail".</P
></BLOCKQUOTE
></DIV
></P
><P
>The <TT
CLASS="FUNCTION"
>fcntl()</TT
> function shall treat the "cmd" value -1 as
invalid.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>whence</I
></TT
> value <CODE
CLASS="CONSTANT"
>-1</CODE
>
shall be an invalid value for the
<TT
CLASS="FUNCTION"
>lseek()</TT
>, <TT
CLASS="FUNCTION"
>fseek()</TT
> and 
<TT
CLASS="FUNCTION"
>fcntl()</TT
> functions.</P
><P
>The value <CODE
CLASS="CONSTANT"
>-5</CODE
> shall be an invalid signal number.</P
><P
>If the <TT
CLASS="FUNCTION"
>sigaddset()</TT
> or 
<TT
CLASS="FUNCTION"
>sigdelset()</TT
> functions are passed an
invalid signal number, they shall return with <SPAN
CLASS="ERRORNAME"
>EINVAL</SPAN
>.
Implementations
are only required to enforce this requirement for signal numbers which
are specified to be invalid by this specification (such as the <CODE
CLASS="CONSTANT"
>-5</CODE
>
mentioned above).</P
><P
>The mode value <CODE
CLASS="CONSTANT"
>-1</CODE
> to the <TT
CLASS="FUNCTION"
>access()</TT
>
function shall be treated as
invalid.</P
><P
>A value of <CODE
CLASS="CONSTANT"
>-1</CODE
> shall be an invalid "_PC_..." value for
<TT
CLASS="FUNCTION"
>pathconf()</TT
>.</P
><P
>A value of <CODE
CLASS="CONSTANT"
>-1</CODE
> shall be an invalid "_SC..." value for
<TT
CLASS="FUNCTION"
>sysconf()</TT
>.</P
><P
>The <TT
CLASS="PARAMETER"
><I
>nl_item</I
></TT
> value <CODE
CLASS="CONSTANT"
>-1</CODE
>
shall be invalid for <TT
CLASS="FUNCTION"
>nl_langinfo()</TT
>.</P
><P
>The value <CODE
CLASS="CONSTANT"
>-1</CODE
> shall be an invalid "_CS_..." value for 
<TT
CLASS="FUNCTION"
>confstr()</TT
>.</P
><P
>The value <CODE
CLASS="CONSTANT"
>"a"</CODE
> shall be an invalid <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>
argument to <TT
CLASS="FUNCTION"
>popen()</TT
>.</P
><P
>The <TT
CLASS="FUNCTION"
>fcntl()</TT
> function shall fail and set <CODE
CLASS="VARNAME"
>errno</CODE
> to
<SPAN
CLASS="ERRORCODE"
>EDEADLK</SPAN
> if the
<TT
CLASS="PARAMETER"
><I
>cmd</I
></TT
> argument is <CODE
CLASS="CONSTANT"
>F_SETLKW</CODE
>,
and the lock is blocked by a lock from another process already blocked by the current process.</P
><P
>The <TT
CLASS="FUNCTION"
>opendir()</TT
> function shall consume a file descriptor;
the <TT
CLASS="FUNCTION"
>readdir()</TT
> function shall fail and set <CODE
CLASS="VARNAME"
>errno</CODE
>
to <SPAN
CLASS="ERRORCODE"
>EBADF</SPAN
> if the underlying file descriptor is closed.</P
><P
>The <TT
CLASS="FUNCTION"
>link()</TT
> function shall not work across file systems, and
shall fail and set <CODE
CLASS="VARNAME"
>errno</CODE
> to <SPAN
CLASS="ERRORCODE"
>EXDEV</SPAN
>
as described as optional behavior in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="EXEC-OPT-MANDATORY"
>20.2. Optional Mandatory Behaviors</A
></H2
><P
>This section specifies behaviors that are mandatory
in one of the standards on which this specification relies, but which
are optional in this specification.</P
><P
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> describes the behavior of the file access
time, available as the <CODE
CLASS="STRUCTFIELD"
>st_atime</CODE
> field of
the <TT
CLASS="STRUCTNAME"
>stat</TT
> and <TT
CLASS="STRUCTNAME"
>stat64</TT
>
structures.  An LSB conforming implementation need not update this
information every time a file is accessed.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>A subsequent edition of the POSIX standard no longer mandates updating
of <CODE
CLASS="STRUCTFIELD"
>st_atime</CODE
> but the older edition is still the
guiding standard for this specification, thus this exception is needed.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="EXECUTABLE-SCRIPTS"
>20.3. Executable Scripts</A
></H2
><P
>An executable script is an executable file of which the first two
characters are <TT
CLASS="LITERAL"
>#!</TT
> as defined in the portable character
set. In <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, this construct is undefined, but
reserved for implementations which wish to provide this functionality.
LSB conforming implementations shall support executable scripts.</P
><P
>A successful call to a function of the exec family with an executable
script as the first parameter shall result in a new process, where the
process image started is that of the interpreter. The path name of the
interpreter follows the <TT
CLASS="LITERAL"
>#!</TT
> characters.</P
><P
>If the executable script has a first line
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61299"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#! interpreter [arg]</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
then <TT
CLASS="PARAMETER"
><I
>interpreter</I
></TT
> shall be called with an
argument array consisting of an unspecified zeroth argument, followed
by <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
> (if present), followed by a path name for
the script, followed by the arguments following the zeroth argument in
the exec call of the script.</P
><P
>The interpreter shall not perform any operations on the first line of
an executable script.</P
><P
>The first line of the executable script shall meet all of the following
criteria otherwise the results are unspecified:</P
><P
><P
></P
><OL
TYPE="1"
><LI
><P
>Is of one of the forms:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61309"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#!interpreter
#! interpreter
#!interpreter arg
#! interpreter arg</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
></LI
><LI
><P
>The <TT
CLASS="PARAMETER"
><I
>interpreter</I
></TT
> argument is an absolute pathname
of an executable file other than an executable script.</P
></LI
><LI
><P
>Neither the <TT
CLASS="PARAMETER"
><I
>interpreter</I
></TT
> argument nor the
<TT
CLASS="PARAMETER"
><I
>arg</I
></TT
> argument, if present, contain any quoting
characters.</P
></LI
><LI
><P
>Neither the <TT
CLASS="PARAMETER"
><I
>interpreter</I
></TT
> argument nor the
<TT
CLASS="PARAMETER"
><I
>arg</I
></TT
> argument, if present, contain any whitespace
characters.</P
></LI
><LI
><P
>The length of the entire line is no longer than 80 bytes.</P
></LI
></OL
></P
><P
>If the interpreter is required by this specification to be in a
specfic named directory, a conforming application must use that
path for <TT
CLASS="PARAMETER"
><I
>interpreter</I
></TT
>, as implementations are
not prohibited from having other, possibly non-conforming, versions
of the same interpreter installed on the system.  If the interpreter
is a required command in this specification, but does not have a
required path, the application should take special measures to
insure the appropriate version is selected.  If the interpreter is
not a required command in this specification, the application must
make appropriate provisions that the interpreter is available at
the appropriate path.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>In case the path is not specified, it is recommended that an installation
script for executable scripts use the standard <CODE
CLASS="ENVAR"
>PATH</CODE
>
returned by a call to the <B
CLASS="COMMAND"
>getconf</B
> command with the
argument <TT
CLASS="PARAMETER"
><I
>PATH</I
></TT
>, combined with the 
<B
CLASS="COMMAND"
>command</B
> command to determine the location of a
standard command.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>For example to determine the location of the standard <B
CLASS="COMMAND"
>awk</B
>
command:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61334"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>PATH=`getconf PATH` command -v awk</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>The installation script should ensure that the returned
pathname is an absolute pathname prior to use, since a shell builtin 
might be returned for some utilities.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Use of the common form <TT
CLASS="LITERAL"
>#!/usr/bin/env interpreter</TT
>
is not recommended as the <CODE
CLASS="ENVAR"
>PATH</CODE
> will be unknown at execution
time and an alternative version of <TT
CLASS="PARAMETER"
><I
>interpreter</I
></TT
>
might be selected.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOCALIZATION"
></A
>Chapter 21. Localization</H1
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN61343"
>21.1. Introduction</A
></H2
><P
>In order to install a message catalog, the installation procedure 
shall supply the message catalog in a format readable by the
<B
CLASS="COMMAND"
>msgfmt</B
> command, which shall be invoked to compile
the message catalog into an appropriate binary format on the target system.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Rationale: </B
>The original intent was to allow an application to contain the binary
GNU MO format files. However, the format of these files is not
officially stable, hence it is necessary to compile these catalogs
on the target system. These binary catalogs
may differ from architecture to architecture
as well.</P
></BLOCKQUOTE
></DIV
>
The resulting binary message catalog shall be
located in the package's private area under <TT
CLASS="FILENAME"
>/opt</TT
>, and the
application may use <TT
CLASS="FUNCTION"
>bindtextdomain()</TT
> to specify this
location.</P
><P
>Implementations shall support the POSIX and C locales as specified in
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>. Other locales may be supported.</P
><P
>Implementations may define additional locale categories not defined by that standard.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Implementations choosing additional locale categories should be aware
of <A
HREF="#STD.TR14652"
>ISO/IEC TR14652</A
> and are advised not to choose names that conflict with that
specification. If implementations provide locale categories whose names
are part of the FDCC set of <A
HREF="#STD.TR14652"
>ISO/IEC TR14652</A
>, they should behave as defined by
that specification.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LOCALIZATION-REGEX"
>21.2. Regular Expressions</A
></H2
><P
>Utilities that process regular expressions shall support Basic
Regular Expressions and Extended Regular Expressions as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, with the following exceptions:</P
><P
>Range expression (such as <TT
CLASS="LITERAL"
>[a-z]</TT
>) can be based on code point
order instead of collating element order.</P
><P
>Equivalence class expression (such as <TT
CLASS="LITERAL"
>[=a=]</TT
>) and multi-character
collating element expression (such as <TT
CLASS="LITERAL"
>[.ch.]</TT
>) are optional.</P
><P
>Handling of a multi-character collating element is
optional.</P
><P
>This affects at least the following utilities: 
<P
></P
><UL
><LI
><P
><B
CLASS="COMMAND"
>awk</B
> (see <A
HREF="#AWK"
>awk</A
>)</P
></LI
><LI
><P
><B
CLASS="COMMAND"
>grep</B
> (see <A
HREF="#GREP"
>grep</A
>)
(including <B
CLASS="COMMAND"
>egrep </B
>, see <A
HREF="#EGREP"
>egrep</A
>)</P
></LI
><LI
><P
><B
CLASS="COMMAND"
>sed</B
> (see <A
HREF="#SED"
>sed</A
>)</P
></LI
></UL
>
It also affects the behavior of interfaces in the base libraries, including
at least 
<P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>regexec()</TT
> (see <A
HREF="#BASELIB-REGEXEC-2"
>regexec</A
>)</P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LOCALIZATION-GLOB"
>21.3. Pattern Matching Notation</A
></H2
><P
>Utilities that perform filename pattern matching (also known as Filename
Globbing) shall do it as specified in 
<A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, Pattern Matching Notation,
with the following exceptions:</P
><P
>Pattern bracket expressions (such as 
<TT
CLASS="LITERAL"
>[a-z]</TT
>) can be based on code point
order instead of collating element order.</P
><P
>Equivalence class expression (such as <TT
CLASS="LITERAL"
>[=a=]</TT
>) and multi-character
collating element expression (such as <TT
CLASS="LITERAL"
>[.ch.]</TT
>) are optional.</P
><P
>Handling of a multi-character collating element is
optional.</P
><P
>This affects at least the following utilities: 
<B
CLASS="COMMAND"
>cpio</B
>
(<A
HREF="#CPIO"
>cpio</A
>), 
<B
CLASS="COMMAND"
>find</B
> and
<B
CLASS="COMMAND"
>tar</B
> (<A
HREF="#TAR"
>tar</A
>).</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCSYSINIT"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>VIII. System Initialization</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>22. <A
HREF="#SYSINIT"
>System Initialization</A
></DT
><DD
><DL
><DT
>22.1. <A
HREF="#CRONJOBS"
>Cron Jobs</A
></DT
><DT
>22.2. <A
HREF="#INISCRPTACT"
>Init Script Actions</A
></DT
><DT
>22.3. <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
></DT
><DT
>22.4. <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
></DT
><DT
>22.5. <A
HREF="#RUNLEVELS"
>Run Levels</A
></DT
><DT
>22.6. <A
HREF="#FACILNAME"
>Facility Names</A
></DT
><DT
>22.7. <A
HREF="#SCRPTNAMES"
>Script Names</A
></DT
><DT
>22.8. <A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYSINIT"
></A
>Chapter 22. System Initialization</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="CRONJOBS"
>22.1. Cron Jobs</A
></H2
><P
>In addition to the individual user <TT
CLASS="FILENAME"
>crontab</TT
> files specified
by <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, which are located in
<TT
CLASS="FILENAME"
>/var/spool/cron</TT
> as specified by the
<A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> (FHS),
the process that executes scheduled commands shall also process the following
additional <TT
CLASS="FILENAME"
>crontab</TT
> files, which are in a
different format (see below).
<TT
CLASS="FILENAME"
>/etc/crontab</TT
>, <TT
CLASS="FILENAME"
>/etc/cron.d/*</TT
>.
The installation of a package shall not modify
the crontab file <TT
CLASS="FILENAME"
>/etc/crontab</TT
>,
and shall not directly modify the user crontab files in
<TT
CLASS="FILENAME"
>/var/spool/cron/crontabs</TT
>. but may
use the <B
CLASS="COMMAND"
>crontab</B
> command to modify the latter.</P
><P
>If a package wishes to install a job that has to be executed periodically,
it shall place an executable <I
CLASS="FIRSTTERM"
>cron script</I
> in one of the
following directories:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.hourly</TT
></TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.daily</TT
></TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.weekly</TT
></TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>/etc/cron.monthly</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
><P
>As these directory names suggest, the files within them are executed on a
hourly, daily, weekly, or monthly basis, respectively, under the control of an
entry in one of the system <TT
CLASS="FILENAME"
>crontab</TT
> files, at an
unspecified time of day.
See below for the rules concerning the names of cron scripts.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>It is recommended that cron scripts installed in any of these directories be
script files rather than compiled binaries so that they may be
modified by the local system administrator. Conforming applications
may only install cron scripts which use an interpreter required by
this specification or provided by this or another conforming application.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>This specification does not define the concept of a package
<I
CLASS="FIRSTTERM"
>upgrade</I
>. Implementations may do different
things when packages are upgraded, including not replacing a
cron script if it marked as a configuration file,
particularly if the cron script appears to have been modified since
installation.  In some circumstances, the cron script may
not be removed when the package is uninstalled. 
Applications should design their installation
procedure and cron scripts to be robust in the face of such
behavior.  In particular, cron scripts should not fail obscurely
if run in unexpected circumstances. Testing for the existence
of application binaries before executing them is suggested.</P
></BLOCKQUOTE
></DIV
><P
>If a certain task has to be executed at other than the predefined
frequencies, the package shall install a file
<TT
CLASS="FILENAME"
>/etc/cron.d/<TT
CLASS="REPLACEABLE"
><I
>cron-name</I
></TT
></TT
>.
The file shall have  the same format as that described for the 
<B
CLASS="COMMAND"
>crontab</B
> command in <A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, except that 
there shall be an additional field, <TT
CLASS="PARAMETER"
><I
>username</I
></TT
>, before
the name of the command to execute. For completeness, the seven fields shall
be:
<P
></P
><OL
TYPE="1"
><LI
><P
>Minute [0,59]</P
></LI
><LI
><P
>Hour [0,23]</P
></LI
><LI
><P
>Day of the month [1,31]</P
></LI
><LI
><P
>Month of the year [1,12]</P
></LI
><LI
><P
>Day of the week [0,6] (with 0=Sunday)</P
></LI
><LI
><P
>Username</P
></LI
><LI
><P
>command [args ...]</P
></LI
></OL
>

This file shall be processed by the system automatically, with the named
command being run at the specified time, as the specified username.</P
><P
>Applications installing files in these directories shall use the
LSB naming conventions (see <A
HREF="#FHS-NAME-RULES"
>File Naming Conventions</A
>).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INISCRPTACT"
>22.2. Init Script Actions</A
></H2
><P
>Conforming applications which need to execute commands on changes
to the system run level (including boot and shutdown),
may install one or more <I
CLASS="FIRSTTERM"
>init scripts</I
>.
Init scripts provided by conforming applications shall accept a single
argument which selects the action:</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><B
CLASS="COMMAND"
>start</B
></TD
><TD
>start the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>stop</B
></TD
><TD
>stop the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>restart</B
></TD
><TD
>stop and restart the service if the service
is already running, otherwise start the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>try-restart</B
></TD
><TD
>restart the service if the service
is already running</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>reload</B
></TD
><TD
>cause the configuration of the service to be
reloaded without actually stopping and restarting the service</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>force-reload</B
></TD
><TD
>cause the configuration to be reloaded
if the service supports this, otherwise restart the service if it is
running</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>status</B
></TD
><TD
>print the current status of the service</TD
></TR
></TBODY
></TABLE
><P
></P
><P
>The <B
CLASS="COMMAND"
>start</B
>, <B
CLASS="COMMAND"
>stop</B
>, <B
CLASS="COMMAND"
>restart</B
>, <B
CLASS="COMMAND"
>force-reload</B
>, and <B
CLASS="COMMAND"
>status</B
> actions shall be supported
by all init scripts; the <B
CLASS="COMMAND"
>reload</B
> and the <B
CLASS="COMMAND"
>try-restart</B
> actions are optional. Other
init-script actions may be defined by the init script.</P
><P
>Init scripts shall ensure that they will behave sensibly if invoked
with <B
CLASS="COMMAND"
>start</B
> when the service is already running, or with <B
CLASS="COMMAND"
>stop</B
> when
not running, and that they do not kill similarly-named user processes. 
The best way to achieve this is to use the init-script functions provided by
<TT
CLASS="FILENAME"
>/lib/lsb/init-functions</TT
> (see 
<A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
>)</P
><P
>If a service reloads its configuration automatically (as in the case
of cron, for example), the <B
CLASS="COMMAND"
>reload</B
> action of the init
script shall behave as if the configuration was reloaded successfully.
The <B
CLASS="COMMAND"
>restart</B
>,
<B
CLASS="COMMAND"
>try-restart</B
>, <B
CLASS="COMMAND"
>reload</B
> and 
<B
CLASS="COMMAND"
>force-reload</B
> actions may be atomic; that is if a service
is known not to be operational after a restart or reload, the script may return
an error without any further action.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not define the concept of a package
<I
CLASS="FIRSTTERM"
>upgrade</I
>. Implementations may do different
things when packages are upgraded, including not replacing an
init script if it is marked as a configuration file,
particularly if the file appears to have been modified since
installation.  In some circumstances, the init script may
not be removed when the package is uninstalled. 
Applications should design their installation
procedure and init scripts to be robust in the face of such
behavior.  In particular, init scripts should not fail obscurely
if run in unexpected circumstances. Testing for the existence
of application binaries before executing them is suggested.</P
></BLOCKQUOTE
></DIV
><P
>If the <B
CLASS="COMMAND"
>status</B
> action is requested,
the init script will return the following 
exit status codes.  

<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>0</SPAN
></TD
><TD
>program is running or service is OK</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>1</SPAN
></TD
><TD
>program is dead and /var/run pid file exists</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>2</SPAN
></TD
><TD
>program is dead and /var/lock lock file exists</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>3</SPAN
></TD
><TD
>program is not running</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>4</SPAN
></TD
><TD
>program or service status is unknown</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>5-99</SPAN
></TD
><TD
>reserved for future LSB use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>100-149</SPAN
></TD
><TD
>reserved for distribution use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>150-199</SPAN
></TD
><TD
>reserved for application use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>200-254</SPAN
></TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>For all other init-script actions, the init
script shall return an exit status of zero if the action 
was successful.  Otherwise, the exit status shall
be non-zero, as defined below.  In addition to straightforward
success, the following situations are also to be considered
successful:

<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>restarting a service (instead of reloading it) with the <B
CLASS="COMMAND"
>force-reload</B
> argument</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>start</B
> on a service already running</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>stop</B
> on a service already stopped or not running</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>restart</B
> on a service already stopped or not running</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>running <B
CLASS="COMMAND"
>try-restart</B
> on a service already stopped or not running</P
></LI
></UL
>&#13;</P
><P
>In case of an error while processing any init-script action except
for <B
CLASS="COMMAND"
>status</B
>, the init script shall print an error
message and exit with a non-zero status code:

<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>1</SPAN
></TD
><TD
>generic or unspecified error (current practice)</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>2</SPAN
></TD
><TD
>invalid or excess argument(s)</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>3</SPAN
></TD
><TD
>unimplemented feature (for example, "reload")</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>4</SPAN
></TD
><TD
>user had insufficient privilege</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>5</SPAN
></TD
><TD
>program is not installed</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>6</SPAN
></TD
><TD
>program is not configured</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>7</SPAN
></TD
><TD
>program is not running</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>8-99</SPAN
></TD
><TD
>reserved for future LSB use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>100-149</SPAN
></TD
><TD
>reserved for distribution use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>150-199</SPAN
></TD
><TD
>reserved for application use</TD
></TR
><TR
><TD
><SPAN
CLASS="ERRORCODE"
>200-254</SPAN
></TD
><TD
>reserved</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>Error and status messages should be printed with the logging
functions (see <A
HREF="#INISCRPTFUNC"
>Init Script Functions</A
>) 
<TT
CLASS="FUNCTION"
>log_success_msg()</TT
>,
<TT
CLASS="FUNCTION"
>log_failure_msg()</TT
> and 
<TT
CLASS="FUNCTION"
>log_warning_msg()</TT
>.
Scripts may write to
standard error or standard output, but implementations need not
present text written to standard error/output to the user or do
anything else with it.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Since init scripts may be run manually by a system administrator with
non-standard environment variable values for <CODE
CLASS="ENVAR"
>PATH</CODE
>, 
<CODE
CLASS="ENVAR"
>USER</CODE
>, <CODE
CLASS="ENVAR"
>LOGNAME</CODE
>, etc., 
init scripts should not depend on the values of these environment
variables.  They should set them to some known/default values if they
are needed.&#13;</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INITSCRCOMCONV"
>22.3. Comment Conventions for Init Scripts</A
></H2
><P
>Conforming applications may install one or more init scripts.
These init scripts must be activated by invoking the
<B
CLASS="COMMAND"
>install_initd</B
> command.
Prior to package removal, the changes applied by
<B
CLASS="COMMAND"
>install_initd</B
> must be undone by
invoking <B
CLASS="COMMAND"
>remove_initd</B
>.
See <A
HREF="#INITSRCINSTRM"
>Installation and Removal of Init Scripts</A
> for more details.</P
><P
> 
<B
CLASS="COMMAND"
>install_initd</B
> and <B
CLASS="COMMAND"
>remove_initd</B
>
determine actions to take by decoding a specially formatted
block of lines in the script. This block shall be delimited
by the lines 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>### BEGIN INIT INFO
### END INIT INFO</PRE
></TD
></TR
></TABLE
>
The delimiter lines may contain trailing whitespace, which shall be
ignored.  All lines inside the block shall begin with a hash
character <TT
CLASS="LITERAL"
>'#'</TT
> in the first column, so the shell
interprets them as comment lines which do not affect operation of
the script. The lines shall be of the form:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
># {keyword}: arg1 [arg2...]</PRE
></TD
></TR
></TABLE
>
with exactly one space character between the <TT
CLASS="LITERAL"
>'#'</TT
>
and the keyword, with a single exception.  In lines following a
line containing the <B
CLASS="COMMAND"
>Description</B
> keyword, and until the
next keyword or block ending delimiter is seen,
a line where the <TT
CLASS="LITERAL"
>'#'</TT
>
is followed by more than one space or a tab character
shall be treated as a continuation of the previous line.</P
><P
>The information extracted from the block is used by the
installation tool or the init-script system to assure
that init scripts are run in the correct order.   
It is unspecified whether the information is evaluated
only when <B
CLASS="COMMAND"
>install_initd</B
> runs, when
the init scripts are executed, or both. The information
extracted includes run levels, defined in <A
HREF="#RUNLEVELS"
>Run Levels</A
>,
and boot facilities, defined in <A
HREF="#FACILNAME"
>Facility Names</A
>.</P
><P
>The following keywords, with their arguments, are defined:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Provides:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>boot facilities provided by this init script.
When an init script is run with a <B
CLASS="COMMAND"
>start</B
> argument,
the boot facility or facilities specified by the 
<B
CLASS="COMMAND"
>Provides</B
> keyword shall be deemed present
and hence init scripts which require those boot facilities
should be started later.  When an init script is run with a 
<B
CLASS="COMMAND"
>stop</B
> argument, the boot facilities specified by
the <B
CLASS="COMMAND"
>Provides</B
> keyword are deemed  no longer present.  </P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Required-Start:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which must be available during startup of this service.
The init-script system should insure init scripts which
provide the <B
CLASS="COMMAND"
>Required-Start</B
> facilities
are started before starting this script.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Required-Stop:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which must
be available during the shutdown of this service.  The
init-script system should avoid stopping init scripts which provide
the <B
CLASS="COMMAND"
>Required-Stop</B
>
facilities until this script is stopped.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Should-Start:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which, if present, should
be available during startup of this service. This allows for weak dependencies
which do not cause the service to fail if a facility is not available.
The service may provide reduced functionality in this situation.
Conforming applications should not rely on the existence of this feature.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Should-Stop:</B
>  boot_facility_1  [boot_facility_2...]</TT
></DT
><DD
><P
>facilities which should be available during shutdown of this service.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Default-Start:</B
>  run_level_1  [run_level_2...]</TT
>, <TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Default-Stop:</B
>  run_level_1  [run_level_2...]</TT
></DT
><DD
><P
>which run levels should by default run the init script with a 
<B
CLASS="COMMAND"
>start</B
> (<B
CLASS="COMMAND"
>stop</B
>) argument
to start (stop) the services controlled by the init script.
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61690"
></A
><P
>For example, if a service should run in runlevels 3, 4, and 5 only,
specify "Default-Start: 3 4 5" and "Default-Stop: 0 1 2 6".</P
><P
></P
></DIV
></P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Short-Description:</B
>  short_description </TT
></DT
><DD
><P
>provide a brief description of the actions of the init script.
Limited to a single line of text.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>Description:</B
>  multiline_description </TT
></DT
><DD
><P
>provide a more complete description of the actions of the init script.
May span mulitple lines.  In a multiline description,
each continuation line shall begin with a '#' followed by tab character
or a '#' followed by at least two space characters.  The multiline
description is terminated by the first line that does not match this
criteria.</P
></DD
></DL
></DIV
><P
>Additional keywords may be defined in future versions of
this specification. Also, implementations 
may define local extensions by using the prefix
<B
CLASS="COMMAND"
>X-<TT
CLASS="REPLACEABLE"
><I
>implementor</I
></TT
></B
>.
For example, <B
CLASS="COMMAND"
>X-RedHat-foobardecl</B
>, or 
<B
CLASS="COMMAND"
>X-Debian-xyzzydecl</B
>.  </P
><P
>Example:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61712"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	### BEGIN INIT INFO
	# Provides: lsb-ourdb
	# Required-Start: $local_fs $network $remote_fs
	# Required-Stop: $local_fs $network $remote_fs
	# Default-Start:  2 3 4 5
	# Default-Stop: 0 1 6
	# Short-Description: start and stop OurDB
	# Description: OurDB is a very fast and reliable database
	#	 engine used for illustrating init scripts
	### END INIT INFO</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>The comment conventions described in this section are only required for
init scripts installed by conforming applications. Conforming
runtime implementations are not required to use this scheme in their system
provided init scripts.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not require, but is designed to allow, the
development of a system which runs init scripts in parallel.  Hence,
enforced-serialization of scripts is avoided unless it is explicitly
necessary. </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INITSRCINSTRM"
>22.4. Installation and Removal of Init Scripts</A
></H2
><P
>Conforming applications may install one or more initialization scripts
(or <I
CLASS="EMPHASIS"
>init scripts</I
>).
An init script shall be installed in <TT
CLASS="FILENAME"
>/etc/init.d</TT
>
(which may be a symbolic link to another location), by the package
installer.</P
><P
>During the installer's post-install processing phase the program
<B
CLASS="COMMAND"
>/usr/lib/lsb/install_initd</B
> must be called to
activate the init script. Activation consists of arranging for
the init script to be called in the correct order on system
run-level changes (including system boot and shutdown), based on
dependencies supplied in the init script (see <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
>).
The <B
CLASS="COMMAND"
>install_initd</B
> command should be thought of as
a wrapper which hides the implementation details;
how any given implementation arranges for the init
script to be called at the appropriate time is not specified.</P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61726"
></A
><A
NAME="AEN61727"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Example: if an init script specified 
"Default-Start: 3 4 5" and "Default-Stop: 0 1 2 6",
<B
CLASS="COMMAND"
>install_initd</B
> might create
"start" symbolic links with names starting with 'S' in 
<TT
CLASS="FILENAME"
>/etc/rc3.d</TT
>,
<TT
CLASS="FILENAME"
>/etc/rc4.d</TT
> and
<TT
CLASS="FILENAME"
>/etc/rc5.d</TT
>
and "stop" symbolic links with names starting with 'K' in
<TT
CLASS="FILENAME"
>/etc/rc0.d</TT
>,
<TT
CLASS="FILENAME"
>/etc/rc1.d</TT
>,
<TT
CLASS="FILENAME"
>/etc/rc2.d</TT
> and
<TT
CLASS="FILENAME"
>/etc/rc6.d</TT
>. Such
a scheme would be similar to the System V Init
mechanism, but is by no means the only way
this specification could be implemented.</P
></BLOCKQUOTE
><P
></P
></DIV
><P
>The <B
CLASS="COMMAND"
>install_initd</B
> command takes a single argument, the full pathname
of the installed init script. The init script must already be installed
in <TT
CLASS="FILENAME"
>/etc/init.d</TT
>.
The <B
CLASS="COMMAND"
>install_initd</B
> command will not copy it there, only activate
it once it has been installed.
For example:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61741"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	/usr/lib/lsb/install_initd /etc/init.d/example.com-coffeed</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>The <B
CLASS="COMMAND"
>install_initd</B
> command
shall return an exit status of zero if the
init-script activation was successful or if the init script was
already activated. If the dependencies in the init script 
(see <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
>)  cannot be met, 
an exit status of one shall be returned and the init script shall not be
activated.</P
><P
> 
When a software package is removed, <B
CLASS="COMMAND"
>/usr/lib/lsb/remove_initd</B
>
must be called to deactivate the init script. This must occur
before the init script itself is removed, as the dependency
information in the script may be required for successful completion.
Thus the installer's pre-remove processing phase must call
<B
CLASS="COMMAND"
>remove_initd</B
>, and pass the full pathname of
the installed init script.
The package installer is still responsible for removing 
the init script.
For example:
<DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><A
NAME="AEN61749"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	/usr/lib/lsb/remove_initd /etc/init.d/example.com-coffeed</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>The <B
CLASS="COMMAND"
>remove_initd</B
> program shall return an exit status
of zero if the init script has been successfully deactivated or if the
init script is not activated. If another init script which depends
on a boot facility provided by this init script is activated,
an exit status of one shall be returned and the init script shall
remain activated. The installer must fail on such an exit code
so it does not subsequently remove the init script.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This specification does not describe a mechanism for the system
administrator to manipulate the run levels at which an init script
is started or stopped. There is no assurance that modifying the
comment block for this purpose will have the desired effect.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="RUNLEVELS"
>22.5. Run Levels</A
></H2
><P
>The following <I
CLASS="FIRSTTERM"
>run levels</I
> are specified for use by the 
<B
CLASS="COMMAND"
>Default-Start</B
> and <B
CLASS="COMMAND"
>Default-Stop</B
> 
actions defined in <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
> as hints
to the <B
CLASS="COMMAND"
>install_initd</B
> command.
Conforming implementations are not required to provide these exact
run levels or give them the meanings described here,
and may map any level described here to a different level which
provides the equivalent functionality. Applications may not depend
on specific run-level numbers.</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>0</TD
><TD
>halt</TD
></TR
><TR
><TD
>1</TD
><TD
>single user mode</TD
></TR
><TR
><TD
>2</TD
><TD
>multiuser with no network services exported</TD
></TR
><TR
><TD
>3</TD
><TD
>normal/full multiuser</TD
></TR
><TR
><TD
>4</TD
><TD
>reserved for local use, default is normal/full multiuser</TD
></TR
><TR
><TD
>5</TD
><TD
>multiuser with a display manager or equivalent</TD
></TR
><TR
><TD
>6</TD
><TD
>reboot</TD
></TR
></TBODY
></TABLE
><P
></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>These run levels were chosen as reflecting the most frequent existing
practice, and in the absence of other considerations, implementors are
strongly encouraged to follow this convention to provide consistency
for system administrators who need to work with multiple distributions.  </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FACILNAME"
>22.6. Facility Names</A
></H2
><P
>Boot <I
CLASS="FIRSTTERM"
>facilities</I
> are used to indicate dependencies
in initialization scripts, as defined in <A
HREF="#INITSCRCOMCONV"
>Comment Conventions for Init Scripts</A
>. 
Facility names
are assigned to scripts by the <B
CLASS="COMMAND"
>Provides:</B
> keyword.
Facility names that begin with a
dollar sign (<TT
CLASS="LITERAL"
>'$'</TT
>) are reserved system facility names.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Facility names are only recognized in the context of the
init script comment block and are not available in the body of
the init script. In particular, the use of the leading '$' character
does not imply system facility names are subject to shell variable
expansion, since they appear inside comments.</P
></BLOCKQUOTE
></DIV
>
Conforming applications shall not provide facilities that begin with a dollar
sign.  Implementations shall provide the following facility names:</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61790"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$local_fs</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>all local file systems are mounted</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61795"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$network</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>basic networking support is available. Example:
a server program could listen on a socket.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61800"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$named</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>IP name-to-address translation, using the interfaces
described in this specification, are available to the level
the system normally provides them. Example: if a DNS
query daemon normally provides this facility, then that
daemon has been started. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61805"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$portmap</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>daemons providing SunRPC/ONCRPC portmapping 
service as defined in <A
HREF="#STD.RFC1833"
>RFC 1833: Binding Protocols for ONC RPC Version 2</A
>
(if present) are running.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61811"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$remote_fs</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>all remote file systems are available. In some
configurations, file systems such as <TT
CLASS="FILENAME"
>/usr</TT
>
may be remote.  Many
applications that require <B
CLASS="COMMAND"
>$local_fs</B
> will probably
also require <B
CLASS="COMMAND"
>$remote_fs</B
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61819"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$syslog</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>system logger is operational.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN61824"
></A
><SPAN
STYLE="white-space: nowrap"
><B
CLASS="COMMAND"
>$time</B
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>the system time has been set,
for example by using a network-based time program such as 
<B
CLASS="COMMAND"
>ntp</B
> or 
<B
CLASS="COMMAND"
>rdate</B
>, or 
via the hardware Real Time Clock.</P
></TD
></TR
></TBODY
></TABLE
><P
>Other (non-system) facilities may be defined by other conforming applications.
These facilities shall be named using the same conventions defined for
naming init scripts (see <A
HREF="#SCRPTNAMES"
>Script Names</A
>).
Commonly, the facility provided by a conforming init script will have
the same name as the name assigned to the init script.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SCRPTNAMES"
>22.7. Script Names</A
></H2
><P
>Since init scripts live in a single directory, they must
share a single namespace. To avoid conflicts, 
applications installing files in this directories shall use the
LSB naming conventions (see <A
HREF="#FHS-NAME-RULES"
>File Naming Conventions</A
>).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INISCRPTFUNC"
>22.8. Init Script Functions</A
></H2
><P
>Each conforming init script shall execute the commands in the file
<TT
CLASS="FILENAME"
>/lib/lsb/init-functions</TT
> in the 
current environment (see shell special built-in command <B
CLASS="COMMAND"
>dot</B
>).
This file shall cause the
following shell script commands to be defined in an unspecified manner.  
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>This can be done either by
adding a directory to the 
<CODE
CLASS="ENVAR"
>PATH</CODE
> variable which defines these commands, or by
defining shell aliases or functions.  </P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Although the commands made available via this mechanism need not
be conforming applications in their own right, applications that
use them should only depend on features described in this specification.</P
></BLOCKQUOTE
></DIV
>
Conforming scripts
shall not specify the "exit on error" option (i.e. 
<B
CLASS="COMMAND"
>set -e</B
>) when sourcing this file, or calling any of the
commands thus made available. </P
><P
>The <B
CLASS="COMMAND"
>start_daemon</B
>, <B
CLASS="COMMAND"
>killproc</B
> and
<B
CLASS="COMMAND"
>pidofproc</B
> functions shall use 
the following algorithm for determining
the status and the process identifiers of the specified program. 
<P
></P
><OL
TYPE="1"
><LI
><P
>If the <TT
CLASS="PARAMETER"
><I
>-p pidfile</I
></TT
> option is specified,
and the named <TT
CLASS="FILENAME"
>pidfile</TT
> exists,
a single line at the start of the <TT
CLASS="FILENAME"
>pidfile</TT
> shall be read. 
If this line contains one or more numeric values, separated by spaces,
these values shall be used.
If the <TT
CLASS="PARAMETER"
><I
>-p pidfile</I
></TT
> option is specified and the named 
<TT
CLASS="FILENAME"
>pidfile</TT
> does not exist, the functions
shall assume that the daemon is not running.</P
></LI
><LI
><P
>Otherwise, 
<TT
CLASS="FILENAME"
>/var/run/<TT
CLASS="REPLACEABLE"
><I
>basename</I
></TT
>.pid</TT
> 
shall be read in a similar fashion.
If this contains one or more numeric values on the first line, these values
shall be used.
Optionally, implementations may use unspecified additional
methods to locate the process identifiers required.</P
></LI
></OL
>
The method used
to determine the status is implementation defined, but should allow for
non-binary programs.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Commonly used methods check either for the
existence of the <TT
CLASS="FILENAME"
>/proc/pid</TT
> directory or use
<TT
CLASS="FILENAME"
>/proc/pid/exe</TT
> and <TT
CLASS="FILENAME"
>/proc/pid/cmdline</TT
>.
Relying only on <TT
CLASS="FILENAME"
>/proc/pid/exe</TT
> is discouraged since this
specification does not specify the existence of, or semantics
for, <TT
CLASS="FILENAME"
>/proc</TT
>. Additionally, using
<TT
CLASS="FILENAME"
>/proc/pid/exe</TT
>
may result in a not-running status for daemons that are written in a script
language.</P
></BLOCKQUOTE
></DIV
>
Conforming implementations may use other mechanisms besides those based on
pidfiles, unless the <TT
CLASS="PARAMETER"
><I
>-p pidfile</I
></TT
>
option has been used. Conforming applications
should not rely on such mechanisms and should
always use a <TT
CLASS="FILENAME"
>pidfile</TT
>.
When a program is stopped, it should delete its
<TT
CLASS="FILENAME"
>pidfile</TT
>. Multiple process identifiers
shall be separated by a single space in the <TT
CLASS="FILENAME"
>pidfile</TT
>
and in the output of <B
CLASS="COMMAND"
>pidofproc</B
>.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>start_daemon</B
> [-f] [-n nicelevel] [-p pidfile]  pathname  [args...]</TT
></DT
><DD
><P
>runs the specified program as a daemon.
The <B
CLASS="COMMAND"
>start_daemon</B
> function
shall check if the program is already running
using the algorithm given above. If so, it shall not
start another copy of the daemon unless the <TT
CLASS="PARAMETER"
><I
>-f</I
></TT
>
option is given. The <TT
CLASS="PARAMETER"
><I
>-n</I
></TT
> option specifies a nice
level. See <B
CLASS="COMMAND"
>nice</B
>.
<B
CLASS="COMMAND"
>start_daemon</B
> shall
return the LSB defined exit status codes. It
shall return 0 if the program has been successfully started or
is running and not 0 otherwise.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>killproc</B
> [-p pidfile]  pathname  [signal]</TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>killproc</B
> function
shall stop the specified program. The program is 
found using the algorithm given above. If a
signal is specified, using the
<TT
CLASS="PARAMETER"
><I
>-<TT
CLASS="REPLACEABLE"
><I
>signal_name</I
></TT
></I
></TT
> or
<TT
CLASS="PARAMETER"
><I
>-<TT
CLASS="REPLACEABLE"
><I
>signal_number</I
></TT
></I
></TT
> syntaxes
as specified by the <B
CLASS="COMMAND"
>kill</B
> command,
the program is sent that signal.
Otherwise, a <CODE
CLASS="CONSTANT"
>SIGTERM</CODE
> followed by a 
<CODE
CLASS="CONSTANT"
>SIGKILL</CODE
>
after an unspecified number of seconds shall be sent.
If a program has been terminated, the <TT
CLASS="FILENAME"
>pidfile</TT
>
should be removed if the
terminated process has not already done so.
The <B
CLASS="COMMAND"
>killproc</B
> function
shall return the LSB defined exit status codes. If called
without a signal, it shall return 0 if the program has been stopped or
is not running and not 0 otherwise. If a signal is given, it shall return 0
only if the program is running. </P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>pidofproc</B
> [-p pidfile]  pathname </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>pidofproc</B
> function shall return
one or more process identifiers for a particular
daemon using the algorithm given above. Only process identifiers
of running processes should be returned.
Multiple process identifiers shall be separated by a single space.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>A process may exit between <B
CLASS="COMMAND"
>pidofproc</B
> discovering its identity
and the caller of <B
CLASS="COMMAND"
>pidofproc</B
> being able to act on that identity.
As a result, no test assertion can be made that the process identifiers
returned by <B
CLASS="COMMAND"
>pidofproc</B
> <I
CLASS="EMPHASIS"
>shall</I
> be
running processes.</P
></BLOCKQUOTE
></DIV
>
The <B
CLASS="COMMAND"
>pidofproc</B
> function
shall return the LSB defined exit status
codes for "status". It shall return 0 if the program is
running and not 0 otherwise.</P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>log_success_msg</B
>  message </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>log_success_msg</B
> function
shall cause the system to write a success
message to an unspecified log file. The format of the message is
unspecified.
The <B
CLASS="COMMAND"
>log_success_msg</B
> function
may also write a message to the standard output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The message should be relatively short; no
more than 60 characters is highly desirable.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>log_failure_msg</B
>  message </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>log_failure_msg</B
> function
shall cause the system to write a failure
message to an unspecified log file. The format of the message is
unspecified.
The <B
CLASS="COMMAND"
>log_failure_msg</B
> function
may also write a message to the standard output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The message should be relatively short; no
more than 60 characters is highly desirable.</P
></BLOCKQUOTE
></DIV
></P
></DD
><DT
><TT
CLASS="CMDSYNOPSIS"
><B
CLASS="COMMAND"
>log_warning_msg</B
>  message </TT
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>log_warning_msg</B
> function
shall cause the system to write a warning
message to an unspecified log file. The format of the message is
unspecified.
The <B
CLASS="COMMAND"
>log_warning_msg</B
> function
may also write a message to the standard output.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The message should be relatively short; no
more than 60 characters is highly desirable.</P
></BLOCKQUOTE
></DIV
></P
></DD
></DL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCUSERSGROUPS"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>IX. Users &#38; Groups</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>23. <A
HREF="#USERSGROUPS"
>Users &#38; Groups</A
></DT
><DD
><DL
><DT
>23.1. <A
HREF="#USERGRPDATABASE"
>User and Group Database</A
></DT
><DT
>23.2. <A
HREF="#USERNAMES"
>User &#38; Group Names</A
></DT
><DT
>23.3. <A
HREF="#UIDRANGE"
>User ID Ranges</A
></DT
><DT
>23.4. <A
HREF="#USERGRPRAT"
>Rationale</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="USERSGROUPS"
></A
>Chapter 23. Users &#38; Groups</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="USERGRPDATABASE"
>23.1. User and Group Database</A
></H2
><P
>The format of the User and Group databases is not specified. Programs may only
read these databases using the provided API. Changes to these databases should
be made using the provided commands.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="USERNAMES"
>23.2. User &#38; Group Names</A
></H2
><P
><A
HREF="#TBL-REQUIREDUSERS"
>Table 23-1</A
> describes required mnemonic user 
and group names.   This specification makes no attempt to numerically 
assign user or group identity numbers, with the exception that both the 
User ID and Group ID for the user <TT
CLASS="LITERAL"
>root</TT
> shall be equal to 0.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-REQUIREDUSERS"
></A
><P
><B
>Table 23-1. Required User &#38; Group Names</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>User</TH
><TH
>Group</TH
><TH
>Comments</TH
></TR
></THEAD
><TBODY
><TR
><TD
>root</TD
><TD
>root</TD
><TD
>Administrative user
with all appropriate privileges</TD
></TR
><TR
><TD
>bin</TD
><TD
>bin</TD
><TD
>Legacy User ID/Group ID<A
NAME="AEN61990"
HREF="#FTN.AEN61990"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
></TD
></TR
><TR
><TD
>daemon</TD
><TD
>daemon</TD
><TD
>Legacy User ID/Group ID<A
NAME="AEN61998"
HREF="#FTN.AEN61998"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
></TD
></TR
></TBODY
><TR
><TD
COLSPAN="3"
>Notes:<BR><A
NAME="FTN.AEN61990"
>a. </A
>The <TT
CLASS="LITERAL"
>bin</TT
> User ID/Group ID is included for compatibility with legacy applications.
New applications should no longer use the <TT
CLASS="LITERAL"
>bin</TT
> User ID/Group ID.<BR><A
NAME="FTN.AEN61998"
>b. </A
>The <TT
CLASS="LITERAL"
>daemon</TT
> User ID/Group ID was used as an unprivileged User ID/Group ID for daemons to
execute under in order to limit their access to the system.  Generally
daemons should now run under individual User ID/Group IDs in order to further
partition daemons from one another.<BR></TD
></TR
></TABLE
></DIV
><P
></P
><P
><A
HREF="#TBL-OPTUSERS"
>Table 23-2</A
> is a table of optional mnemonic user and group names.   This 
specification makes no attempt to numerically assign uid or gid numbers.
If the username exists on a system, then they should be in the suggested
corresponding group.
These user and group names are for use by distributions, not by applications.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-OPTUSERS"
></A
><P
><B
>Table 23-2. Optional User &#38; Group Names</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>User</TH
><TH
>Group</TH
><TH
>Comments</TH
></TR
></THEAD
><TBODY
><TR
><TD
>adm</TD
><TD
>adm</TD
><TD
>Administrative special privileges</TD
></TR
><TR
><TD
>lp</TD
><TD
>lp</TD
><TD
>Printer special privileges</TD
></TR
><TR
><TD
>sync</TD
><TD
>sync</TD
><TD
>Login to sync the system</TD
></TR
><TR
><TD
>shutdown</TD
><TD
>shutdown</TD
><TD
>Login to shutdown the system</TD
></TR
><TR
><TD
>halt</TD
><TD
>halt</TD
><TD
>Login to halt the system</TD
></TR
><TR
><TD
>mail</TD
><TD
>mail</TD
><TD
>Mail special privileges</TD
></TR
><TR
><TD
>news</TD
><TD
>news</TD
><TD
>News special privileges</TD
></TR
><TR
><TD
>uucp</TD
><TD
>uucp</TD
><TD
>UUCP special privileges</TD
></TR
><TR
><TD
>operator</TD
><TD
>root</TD
><TD
>Operator special privileges</TD
></TR
><TR
><TD
>man</TD
><TD
>man</TD
><TD
>Man special privileges</TD
></TR
><TR
><TD
>nobody</TD
><TD
>nobody</TD
><TD
>Used by NFS</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Only a minimum working set of "user names" and their corresponding 
"user groups" are required.
Applications cannot assume non system user or group names will be defined.</P
><P
>Applications cannot assume any policy for the default file creation mask 
(<B
CLASS="COMMAND"
>umask</B
>) or the default
directory permissions a user may have. Applications should enforce user
only file permissions on private files such as mailboxes.  The location of
the users home directory is also not defined by policy other than the
recommendations of the <A
HREF="#STD.FHS"
>Filesystem Hierarchy Standard</A
> and should be obtained by 
the <TT
CLASS="FUNCTION"
>getpwnam()</TT
>, <TT
CLASS="FUNCTION"
>getpwnam_r()</TT
>, <TT
CLASS="FUNCTION"
>getpwent()</TT
>, <TT
CLASS="FUNCTION"
>getpwuid()</TT
>, and <TT
CLASS="FUNCTION"
>getpwuid_r()</TT
> functions.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="UIDRANGE"
>23.3. User ID Ranges</A
></H2
><P
>The system User IDs from 0 to 99 should be statically allocated by the system,
and shall not be created by applications.</P
><P
>The system User IDs from 100 to 499 should be reserved for dynamic
allocation by system administrators and post install scripts using <B
CLASS="COMMAND"
>useradd</B
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="USERGRPRAT"
>23.4. Rationale</A
></H2
><P
>The purpose of specifying optional users and groups is to reduce the
potential for name conflicts between applications and distributions.</P
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="TOCLIBNSS"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>X. Network Security Services</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>24. <A
HREF="#NSSLIBS"
>Libraries</A
></DT
><DD
><DL
><DT
>24.1. <A
HREF="#LIBNSPR4"
>Interfaces for libnspr4</A
></DT
><DD
><DL
><DT
>24.1.1. <A
HREF="#AEN62102"
>Netscape Portable Runtime</A
></DT
></DL
></DD
><DT
>24.2. <A
HREF="#LIBNSPR4-DDEFS"
>Data Definitions for libnspr4</A
></DT
><DD
><DL
><DT
>24.2.1. <A
HREF="#AEN62509"
>nspr4/nspr.h</A
></DT
><DT
>24.2.2. <A
HREF="#AEN62513"
>nspr4/plarena.h</A
></DT
><DT
>24.2.3. <A
HREF="#AEN62517"
>nspr4/plhash.h</A
></DT
><DT
>24.2.4. <A
HREF="#AEN62521"
>nspr4/pratom.h</A
></DT
><DT
>24.2.5. <A
HREF="#AEN62525"
>nspr4/prclist.h</A
></DT
><DT
>24.2.6. <A
HREF="#AEN62529"
>nspr4/prcvar.h</A
></DT
><DT
>24.2.7. <A
HREF="#AEN62533"
>nspr4/prerror.h</A
></DT
><DT
>24.2.8. <A
HREF="#AEN62537"
>nspr4/prinit.h</A
></DT
><DT
>24.2.9. <A
HREF="#AEN62541"
>nspr4/prinrval.h</A
></DT
><DT
>24.2.10. <A
HREF="#AEN62545"
>nspr4/prio.h</A
></DT
><DT
>24.2.11. <A
HREF="#AEN62549"
>nspr4/private/pprio.h</A
></DT
><DT
>24.2.12. <A
HREF="#AEN62553"
>nspr4/prlock.h</A
></DT
><DT
>24.2.13. <A
HREF="#AEN62557"
>nspr4/prmem.h</A
></DT
><DT
>24.2.14. <A
HREF="#AEN62561"
>nspr4/prmon.h</A
></DT
><DT
>24.2.15. <A
HREF="#AEN62565"
>nspr4/prnetdb.h</A
></DT
><DT
>24.2.16. <A
HREF="#AEN62569"
>nspr4/prthread.h</A
></DT
><DT
>24.2.17. <A
HREF="#AEN62573"
>nspr4/prtime.h</A
></DT
><DT
>24.2.18. <A
HREF="#AEN62577"
>nspr4/prtypes.h</A
></DT
></DL
></DD
><DT
>24.3. <A
HREF="#LIBNSS3"
>Interfaces for libnss3</A
></DT
><DD
><DL
><DT
>24.3.1. <A
HREF="#AEN62599"
>NSS Utility</A
></DT
></DL
></DD
><DT
>24.4. <A
HREF="#LIBNSS3-DDEFS"
>Data Definitions for libnss3</A
></DT
><DD
><DL
><DT
>24.4.1. <A
HREF="#AEN62707"
>nss3/blapit.h</A
></DT
><DT
>24.4.2. <A
HREF="#AEN62711"
>nss3/cert.h</A
></DT
><DT
>24.4.3. <A
HREF="#AEN62715"
>nss3/certt.h</A
></DT
><DT
>24.4.4. <A
HREF="#AEN62719"
>nss3/cmsreclist.h</A
></DT
><DT
>24.4.5. <A
HREF="#AEN62723"
>nss3/cryptoht.h</A
></DT
><DT
>24.4.6. <A
HREF="#AEN62727"
>nss3/hasht.h</A
></DT
><DT
>24.4.7. <A
HREF="#AEN62731"
>nss3/key.h</A
></DT
><DT
>24.4.8. <A
HREF="#AEN62735"
>nss3/keyhi.h</A
></DT
><DT
>24.4.9. <A
HREF="#AEN62739"
>nss3/keyt.h</A
></DT
><DT
>24.4.10. <A
HREF="#AEN62743"
>nss3/keythi.h</A
></DT
><DT
>24.4.11. <A
HREF="#AEN62747"
>nss3/nss.h</A
></DT
><DT
>24.4.12. <A
HREF="#AEN62751"
>nss3/nssb64.h</A
></DT
><DT
>24.4.13. <A
HREF="#AEN62755"
>nss3/nssb64t.h</A
></DT
><DT
>24.4.14. <A
HREF="#AEN62759"
>nss3/nssilckt.h</A
></DT
><DT
>24.4.15. <A
HREF="#AEN62763"
>nss3/nssrwlkt.h</A
></DT
><DT
>24.4.16. <A
HREF="#AEN62767"
>nss3/ocspt.h</A
></DT
><DT
>24.4.17. <A
HREF="#AEN62771"
>nss3/pk11pub.h</A
></DT
><DT
>24.4.18. <A
HREF="#AEN62775"
>nss3/pkcs11t.h</A
></DT
><DT
>24.4.19. <A
HREF="#AEN62779"
>nss3/pkcs7t.h</A
></DT
><DT
>24.4.20. <A
HREF="#AEN62783"
>nss3/secasn1t.h</A
></DT
><DT
>24.4.21. <A
HREF="#AEN62787"
>nss3/seccomon.h</A
></DT
><DT
>24.4.22. <A
HREF="#AEN62791"
>nss3/secdert.h</A
></DT
><DT
>24.4.23. <A
HREF="#AEN62795"
>nss3/secdigt.h</A
></DT
><DT
>24.4.24. <A
HREF="#AEN62799"
>nss3/secmodt.h</A
></DT
><DT
>24.4.25. <A
HREF="#AEN62803"
>nss3/secoidt.h</A
></DT
><DT
>24.4.26. <A
HREF="#AEN62807"
>nss3/secpkcs5.h</A
></DT
><DT
>24.4.27. <A
HREF="#AEN62811"
>nss3/secport.h</A
></DT
></DL
></DD
><DT
>24.5. <A
HREF="#LIBSSL3"
>Interfaces for libssl3</A
></DT
><DD
><DL
><DT
>24.5.1. <A
HREF="#AEN62833"
>NSS SSL</A
></DT
></DL
></DD
><DT
>24.6. <A
HREF="#LIBSSL3-DDEFS"
>Data Definitions for libssl3</A
></DT
><DD
><DL
><DT
>24.6.1. <A
HREF="#AEN63013"
>nss3/ecl-exp.h</A
></DT
><DT
>24.6.2. <A
HREF="#AEN63017"
>nss3/ssl.h</A
></DT
><DT
>24.6.3. <A
HREF="#AEN63021"
>nss3/sslerr.h</A
></DT
><DT
>24.6.4. <A
HREF="#AEN63025"
>nss3/sslproto.h</A
></DT
><DT
>24.6.5. <A
HREF="#AEN63029"
>nss3/sslt.h</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NSSLIBS"
></A
>Chapter 24. Libraries</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="LIBNSPR4"
>24.1. Interfaces for libnspr4</A
></H2
><P
><A
HREF="#LIB-LIBNSPR4-DEF"
>Table 24-1</A
> defines the library name and shared object name
for the libnspr4 library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBNSPR4-DEF"
></A
><P
><B
>Table 24-1. libnspr4 Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libnspr4</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libnspr4.so</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBNSPR4.1"
></A
>[NSPR] <A
HREF="#STD.NSPR"
>NSPR Reference</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62102"
>24.1.1. Netscape Portable Runtime</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN62105"
>24.1.1.1. Interfaces for Netscape Portable Runtime</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for Netscape Portable Runtime specified in <A
HREF="#TBL-LIBNSPR4-NETSC-INTS"
>Table 24-2</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNSPR4-NETSC-INTS"
></A
><P
><B
>Table 24-2. libnspr4 - Netscape Portable Runtime Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>PR_Abort <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Accept <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_AtomicAdd <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_AtomicDecrement <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_AtomicIncrement <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_AtomicSet <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Bind <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Calloc <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Cleanup <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ClearInterrupt <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Close <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Connect <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ConnectContinue <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_ConvertIPv4AddrToIPv6 <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_CreateIOLayerStub <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_CreatePipe <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_DestroyCondVar <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_DestroyLock <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_EnumerateAddrInfo <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_ExplodeTime <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_FormatTime <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Free <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_FreeAddrInfo <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GMTParameters <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetAddrInfoByName <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetCanonNameFromAddrInfo <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetDefaultIOMethods <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetDescType <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetError <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetErrorText <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetErrorTextLength <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetLayersIdentity <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetOSError <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetSocketOption <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetThreadPrivate <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetThreadScope <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetThreadState <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_GetUniqueIdentity <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_ImplodeTime <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ImportTCPSocket <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Init <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Initialize <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_InitializeNetAddr <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Initialized <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Interrupt <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_IntervalNow <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_IntervalToMicroseconds <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_IntervalToMilliseconds <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_IntervalToSeconds <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Listen <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_LocalTimeParameters <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Lock <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Malloc <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_MicrosecondsToInterval <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_MillisecondsToInterval <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_NetAddrToString <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_NewCondVar <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_NewLock <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_NewThreadPrivateIndex <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_NormalizeTime <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_NotifyAllCondVar <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_NotifyCondVar <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Now <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Open <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_OpenTCPSocket <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_OpenUDPSocket <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ParseTimeString <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_ParseTimeStringToExplodedTime <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Poll <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_PopIOLayer <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_ProcessExit <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_PushIOLayer <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Read <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Realloc <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Recv <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_RecvFrom <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_SecondsToInterval <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Send <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_SendTo <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_SetError <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_SetErrorText <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_SetSocketOption <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_SetThreadPrivate <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Shutdown <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Sleep <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_StringToNetAddr <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_TicksPerSecond <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Unlock <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_WaitCondVar <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
><TD
>PR_Write <A
HREF="#REFSTD.LIBNSPR4.1"
>[NSPR]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNSPR4-DDEFS"
>24.2. Data Definitions for libnspr4</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libnspr4.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62509"
>24.2.1. nspr4/nspr.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define nspr_h___</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62513"
>24.2.2. nspr4/plarena.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define plarena_h___

typedef struct PLArenaPool {
    struct PLArena first;
    struct PLArena *current;
    PRUint32 arenasize;
    PRUword mask;
} PLArenaPool;
struct PLArena {
    struct PLArena *next;
    PRUword base;
    PRUword limit;
    PRUword avail;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62517"
>24.2.3. nspr4/plhash.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define plhash_h___

typedef PRUint32 PLHashNumber;
typedef PRIntn(*PLHashComparator) (const void *, const void *);
typedef struct PLHashAllocOps {
    void *(*allocTable) (void *, PRSize);
    void (*freeTable) (void *, void *);
    struct PLHashEntry *(*allocEntry) (void *, const void *);
    void (*freeEntry) (void *, struct PLHashEntry *, PRUintn);
} PLHashAllocOps;
typedef PLHashNumber(*PLHashFunction) (const void *);
struct PLHashEntry {
    struct PLHashEntry *next;
    PLHashNumber keyHash;
    const void *key;
    void *value;
};
struct PLHashTable {
    struct PLHashEntry **buckets;
    PRUint32 nentries;
    PRUint32 shift;
    PLHashFunction keyHash;
    PLHashComparator keyCompare;
    PLHashComparator valueCompare;
    const PLHashAllocOps *allocOps;
    void *allocPriv;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62521"
>24.2.4. nspr4/pratom.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define PR_ATOMIC_ADD(val)	PR_AtomicAdd(val)
#define PR_ATOMIC_DECREMENT(val)	PR_AtomicDecrement(val)
#define PR_ATOMIC_INCREMENT(val)	PR_AtomicIncrement(val)
#define PR_ATOMIC_SET(val)	PR_AtomicSet(val)

extern PRInt32 PR_AtomicAdd(PRInt32 * ptr, PRInt32 val);
extern PRInt32 PR_AtomicDecrement(PRInt32 * val);
extern PRInt32 PR_AtomicIncrement(PRInt32 * val);
extern PRInt32 PR_AtomicSet(PRInt32 * val, PRInt32 newval);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62525"
>24.2.5. nspr4/prclist.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prclist_h___

typedef struct PRCListStr {
    PRCList *next;
    PRCList *prev;
} PRCList;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62529"
>24.2.6. nspr4/prcvar.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct PRCondVar PRCondVar;
extern void PR_DestroyCondVar(PRCondVar * cvar);
extern PRCondVar *PR_NewCondVar(PRLock * lock);
extern PRStatus PR_NotifyAllCondVar(PRCondVar * cvar);
extern PRStatus PR_NotifyCondVar(PRCondVar * cvar);
extern PRStatus PR_WaitCondVar(PRCondVar * cvar, PRIntervalTime timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62533"
>24.2.7. nspr4/prerror.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prerror_h___

typedef PRInt32 PRErrorCode;
extern PRErrorCode PR_GetError(void);
extern PRInt32 PR_GetErrorText(char *text);
extern PRInt32 PR_GetErrorTextLength(void);
extern PRInt32 PR_GetOSError(void);
extern void PR_SetError(PRErrorCode errorCode, PRInt32 oserr);
extern void PR_SetErrorText(PRIntn textLength, const char *text);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62537"
>24.2.8. nspr4/prinit.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prinit_h___

typedef PRIntn(*PRPrimordialFn) (PRIntn argc, char **argv);
typedef PRStatus(*PRCallOnceFN) (void);
typedef PRStatus(*PRCallOnceWithArgFN) (void *arg);
extern void PR_Abort(void);
extern PRStatus PR_Cleanup(void);
extern void PR_Init(PRThreadType type, PRThreadPriority priority,
		    PRUintn maxPTDs);
extern PRIntn PR_Initialize(PRPrimordialFn prmain, PRIntn argc,
			    char **argv, PRUintn maxPTDs);
extern PRBool PR_Initialized(void);
extern void PR_ProcessExit(PRIntn status);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62541"
>24.2.9. nspr4/prinrval.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prinrval_h
#define PR_INTERVAL_NO_WAIT	0UL
#define PR_INTERVAL_NO_TIMEOUT	0xffffffffUL

typedef PRUint32 PRIntervalTime;
extern PRIntervalTime PR_IntervalNow(void);
extern PRUint32 PR_IntervalToMicroseconds(PRIntervalTime ticks);
extern PRUint32 PR_IntervalToMilliseconds(PRIntervalTime ticks);
extern PRUint32 PR_IntervalToSeconds(PRIntervalTime ticks);
extern PRIntervalTime PR_MicrosecondsToInterval(PRUint32 micro);
extern PRIntervalTime PR_MillisecondsToInterval(PRUint32 milli);
extern PRIntervalTime PR_SecondsToInterval(PRUint32 seconds);
extern PRUint32 PR_TicksPerSecond(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62545"
>24.2.10. nspr4/prio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prio_h___
#define PR_RDONLY	0x01
#define PR_WRONLY	0x02
#define PR_RDWR	0x04
#define PR_CREATE_FILE	0x08
#define PR_APPEND	0x10
#define PR_TRUNCATE	0x20
#define PR_SYNC	0x40
#define PR_EXCL	0x80

typedef enum PRDescType {
    PR_DESC_FILE = 1,
    PR_DESC_SOCKET_TCP = 2,
    PR_DESC_SOCKET_UDP = 3,
    PR_DESC_LAYERED = 4,
    PR_DESC_PIPE = 5
} PRDescType;
typedef struct PRIPv6Addr {
    union {
	PRUint8 _S6_u8[15];
	PRUint16 _S6_u16[7];
	PRUint32 _S6_u32[3];
	PRUint64 _S6_u64[1];
    } _S6_un;
} PRIPv6Addr;
typedef enum PRTransmitFileFlags {
    PR_TRANSMITFILE_KEEP_OPEN = 0,
    PR_TRANSMITFILE_CLOSE_SOCKET = 1
} PRTransmitFileFlags;
typedef struct PRLinger {
    PRBool polarity;
    PRIntervalTime linger;
} PRLinger;
typedef struct PRFilePrivate PRFilePrivate;
typedef struct PRFileDesc {
    const struct PRIOMethods *methods;
    PRFilePrivate *secret;
    PRFileDesc *lower;
    PRFileDesc *higher;
    void (*dtor) (PRFileDesc *);
    PRDescIdentity identity;
} PRFileDesc;
typedef union PRNetAddr {
    struct {
	PRUint16 family;
	char data[14];
    } raw;
    struct {
	PRUint16 family;
	PRUint16 port;
	PRUint32 ip;
	char pad[7];
    } inet;
    struct {
	PRUint16 family;
	PRUint16 port;
	PRUint32 flowinfo;
	PRIPv6Addr ip;
	PRUint32 scope_id;
    } ipv6;
    struct {
	PRUint16 family;
	char path[103];
    } local;
} PRNetAddr;
typedef struct PRMcastRequest {
    union PRNetAddr mcaddr;
    union PRNetAddr ifaddr;
} PRMcastRequest;
typedef struct PRIOVec {
    char *iov_base;
    int iov_len;
} PRIOVec;
typedef struct PRSocketOptionData {
    PRSockOption option;
    union {
	PRUintn ip_ttl;
	PRUintn mcast_ttl;
	PRUintn tos;
	PRBool non_blocking;
	PRBool reuse_addr;
	PRBool keep_alive;
	PRBool mcast_loopback;
	PRBool no_delay;
	PRBool broadcast;
	PRSize max_segment;
	PRSize recv_buffer_size;
	PRSize send_buffer_size;
	PRLinger linger;
	PRMcastRequest add_member;
	PRMcastRequest drop_member;
	union PRNetAddr mcast_if;
    } value;
} PRSocketOptionData;
typedef PRStatus(*PRFsyncFN) (PRFileDesc * fd);
typedef PRStatus(*PRListenFN) (PRFileDesc * fd, PRIntn how);
typedef enum PRSeekWhence {
    PR_SEEK_SET = 0,
    PR_SEEK_CUR = 1,
    PR_SEEK_END = 2
} PRSeekWhence;
typedef PRInt32(*PRAcceptreadFN) (PRFileDesc * sd, PRFileDesc * *nd,
				  PRNetAddr * *raddr, void *buf,
				  PRInt32 amount, PRIntervalTime t);
typedef PRStatus(*PRCloseFN) (PRFileDesc * fd);
typedef PRInt32(*PRTransmitfileFN) (PRFileDesc * sd, PRFileDesc * fd,
				    const void *headers, PRInt32 hlen,
				    PRTransmitFileFlags flags,
				    PRIntervalTime t);
typedef enum PRSockOption {
    PR_SockOpt_Nonblocking,
    PR_SockOpt_Linger = 1,
    PR_SockOpt_Reuseaddr = 2,
    PR_SockOpt_Keepalive = 3,
    PR_SockOpt_RecvBufferSize = 4,
    PR_SockOpt_SendBufferSize = 5,
    PR_SockOpt_IpTimeToLive = 6,
    PR_SockOpt_IpTypeOfService = 7,
    PR_SockOpt_AddMember = 8,
    PR_SockOpt_DropMember = 9,
    PR_SockOpt_McastInterface = 10,
    PR_SockOpt_McastTimeToLive = 11,
    PR_SockOpt_McastLoopback = 12,
    PR_SockOpt_NoDelay = 13,
    PR_SockOpt_MaxSegment = 14,
    PR_SockOpt_Broadcast = 15,
    PR_SockOpt_Last = 16
} PRSockOption;
typedef PRFileDesc *(*PRAcceptFN) (PRFileDesc * fd, PRNetAddr * addr,
				   PRIntervalTime timeout);
typedef PRStatus(*PRConnectcontinueFN) (PRFileDesc * fd,
					PRInt16 out_flags);
typedef PRInt32(*PRReadFN) (PRFileDesc * fd, void *buf, PRInt32 amount);
typedef struct PRFileInfo64 {
    PRFileType type;
    PROffset64 size;
    PRTime creationTime;
    PRTime modifyTime;
} PRFileInfo64;
typedef PRStatus(*PRGetsocketoptionFN) (PRFileDesc * fd,
					PRSocketOptionData * data);
typedef PRInt32(*PRSendtoFN) (PRFileDesc * fd, const void *buf,
			      PRInt32 amount, PRIntn flags,
			      const PRNetAddr * addr,
			      PRIntervalTime timeout);
typedef PRStatus(*PRGetsocknameFN) (PRFileDesc * fd, PRNetAddr * addr);
typedef PRInt32(*PRSendFN) (PRFileDesc * fd, const void *buf,
			    PRInt32 amount, PRIntn flags,
			    PRIntervalTime timeout);
typedef PROffset32(*PRSeekFN) (PRFileDesc * fd, PROffset32 offset,
			       PRSeekWhence how);
typedef PRInt64(*PRAvailable64FN) (PRFileDesc * fd);
typedef PRInt32(*PRAvailableFN) (PRFileDesc * fd);
typedef struct PRFileInfo {
    PRFileType type;
    PROffset32 size;
    PRTime creationTime;
    PRTime modifyTime;
} PRFileInfo;
typedef PROffset64(*PRSeek64FN) (PRFileDesc * fd, PROffset64 offset,
				 PRSeekWhence how);
typedef PRStatus(*PRSetsocketoptionFN) (PRFileDesc * fd,
					const PRSocketOptionData * data);
typedef PRInt32(*PRRecvFN) (PRFileDesc * fd, void *buf, PRInt32 amount,
			    PRIntn flags, PRIntervalTime timeout);
typedef struct PRSendFileData {
    PRFileDesc *fd;
    PRUint32 file_offset;
    PRSize file_nbytes;
    const void *header;
    PRInt32 hlen;
    const void *trailer;
    PRInt32 tlen;
} PRSendFileData;
typedef PRIntn PRDescIdentity;
typedef PRStatus(*PRConnectFN) (PRFileDesc * fd, const PRNetAddr * addr,
				PRIntervalTime timeout);
typedef PRInt32(*PRSendfileFN) (PRFileDesc * networkSocket,
				PRSendFileData * sendData,
				PRTransmitFileFlags flags,
				PRIntervalTime timeout);
typedef PRInt32(*PRRecvfromFN) (PRFileDesc * fd, void *buf, PRInt32 amount,
				PRIntn flags, PRNetAddr * addr,
				PRIntervalTime timeout);
typedef struct PRPollDesc {
    PRFileDesc *fd;
    PRInt16 in_flags;
    PRInt16 out_flags;
} PRPollDesc;
typedef PRInt32(*PRWriteFN) (PRFileDesc * fd, const void *buf,
			     PRInt32 amount);
typedef PRStatus(*PRFileInfo64FN) (PRFileDesc * fd, PRFileInfo64 * info);
typedef PRStatus(*PRShutdownFN) (PRFileDesc * fd, PRIntn how);
typedef PRIntn(*PRReservedFN) (PRFileDesc * fd);
typedef PRStatus(*PRFileInfoFN) (PRFileDesc * fd, PRFileInfo * info);
typedef PRInt32(*PRWritevFN) (PRFileDesc * fd, const PRIOVec * iov,
			      PRInt32 iov_size, PRIntervalTime timeout);
typedef enum PRFileType {
    PR_FILE_FILE = 1,
    PR_FILE_DIRECTORY = 2,
    PR_FILE_OTHER = 3
} PRFileType;
typedef PRStatus(*PRBindFN) (PRFileDesc * fd, const PRNetAddr * addr);
typedef PRInt16(*PRPollFN) (PRFileDesc * fd, PRInt16 in_flags,
			    PRInt16 * out_flags);
struct PRIOMethods {
    PRDescType file_type;
    PRCloseFN close;
    PRReadFN read;
    PRWriteFN write;
    PRAvailableFN available;
    PRAvailable64FN available64;
    PRFsyncFN fsync;
    PRSeekFN seek;
    PRSeek64FN seek64;
    PRFileInfoFN fileInfo;
    PRFileInfo64FN fileInfo64;
    PRWritevFN writev;
    PRConnectFN connect;
    PRAcceptFN accept;
    PRBindFN bind;
    PRListenFN listen;
    PRShutdownFN shutdown;
    PRRecvFN recv;
    PRSendFN send;
    PRRecvfromFN recvfrom;
    PRSendtoFN sendto;
    PRPollFN poll;
    PRAcceptreadFN acceptread;
    PRTransmitfileFN transmitfile;
    PRGetsocknameFN getsockname;
    PRGetpeernameFN getpeername;
    PRReservedFN reserved_fn_6;
    PRReservedFN reserved_fn_5;
    PRGetsocketoptionFN getsocketoption;
    PRSetsocketoptionFN setsocketoption;
    PRSendfileFN sendfile;
    PRConnectcontinueFN connectcontinue;
    PRReservedFN reserved_fn_3;
    PRReservedFN reserved_fn_2;
    PRReservedFN reserved_fn_1;
    PRReservedFN reserved_fn_0;
};
typedef PRStatus(*PRGetpeernameFN) (PRFileDesc * fd, PRNetAddr * addr);
typedef enum PRShutdownHow {
    PR_SHUTDOWN_RCV = 0,
    PR_SHUTDOWN_SEND = 1,
    PR_SHUTDOWN_BOTH = 2
} PRShutdownHow;
extern PRFileDesc *PR_Accept(PRFileDesc * fd, PRNetAddr * addr,
			     PRIntervalTime timeout);
extern PRStatus PR_Bind(PRFileDesc * fd, const PRNetAddr * addr);
extern PRStatus PR_Close(PRFileDesc * fd);
extern PRStatus PR_Connect(PRFileDesc * fd, const PRNetAddr * addr,
			   PRIntervalTime timeout);
extern PRStatus PR_ConnectContinue(PRFileDesc * fd, PRInt16 out_flags);
extern PRFileDesc *PR_CreateIOLayerStub(PRDescIdentity ident,
					const struct PRIOMethods *methods);
extern PRStatus PR_CreatePipe(PRFileDesc * *readPipe,
			      PRFileDesc * *writePipe);
extern const struct PRIOMethods *PR_GetDefaultIOMethods(void);
extern PRDescType PR_GetDescType(PRFileDesc * file);
extern PRDescIdentity PR_GetLayersIdentity(PRFileDesc * fd);
extern PRStatus PR_GetSocketOption(PRFileDesc * fd,
				   PRSocketOptionData * data);
extern PRDescIdentity PR_GetUniqueIdentity(const char *layer_name);
extern PRStatus PR_Listen(PRFileDesc * fd, PRIntn backlog);
extern PRFileDesc *PR_Open(const char *name, PRIntn flags, PRIntn mode);
extern PRFileDesc *PR_OpenTCPSocket(PRIntn af);
extern PRFileDesc *PR_OpenUDPSocket(PRIntn af);
extern PRInt32 PR_Poll(PRPollDesc * pds, PRIntn npds,
		       PRIntervalTime timeout);
extern PRFileDesc *PR_PopIOLayer(PRFileDesc * fd_stack, PRDescIdentity id);
extern PRStatus PR_PushIOLayer(PRFileDesc * fd_stack, PRDescIdentity id,
			       PRFileDesc * layer);
extern PRInt32 PR_Read(PRFileDesc * fd, void *buf, PRInt32 amount);
extern PRInt32 PR_Recv(PRFileDesc * fd, void *buf, PRInt32 amount,
		       PRIntn flags, PRIntervalTime timeout);
extern PRInt32 PR_RecvFrom(PRFileDesc * fd, void *buf, PRInt32 amount,
			   PRIntn flags, PRNetAddr * addr,
			   PRIntervalTime timeout);
extern PRInt32 PR_Send(PRFileDesc * fd, const void *buf, PRInt32 amount,
		       PRIntn flags, PRIntervalTime timeout);
extern PRInt32 PR_SendTo(PRFileDesc * fd, const void *buf, PRInt32 amount,
			 PRIntn flags, const PRNetAddr * addr,
			 PRIntervalTime timeout);
extern PRStatus PR_SetSocketOption(PRFileDesc * fd,
				   const PRSocketOptionData * data);
extern PRStatus PR_Shutdown(PRFileDesc * fd, PRShutdownHow how);
extern PRInt32 PR_Write(PRFileDesc * fd, const void *buf, PRInt32 amount);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62549"
>24.2.11. nspr4/private/pprio.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define pprio_h___

typedef PRInt32 PROsfd;
extern PRFileDesc *PR_ImportTCPSocket(PROsfd osfd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62553"
>24.2.12. nspr4/prlock.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prlock_h___

typedef struct PRLock PRLock;
extern void PR_DestroyLock(PRLock * lock);
extern void PR_Lock(PRLock * lock);
extern PRLock *PR_NewLock(void);
extern PRStatus PR_Unlock(PRLock * lock);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62557"
>24.2.13. nspr4/prmem.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define PR_NEW(_struct)	((_struct *) PR_MALLOC(sizeof(_struct)))
#define PR_NEWZAP(_struct)	((_struct*)PR_Calloc(1, sizeof(_struct)))
#define PR_CALLOC(_size)	(PR_Calloc(1, (_size)))
#define PR_MALLOC(_bytes)	(PR_Malloc(_bytes))
#define PR_REALLOC(_ptr, _size)	(PR_Realloc((_ptr), (_size)))
#define PR_FREEIF(_ptr)	if (_ptr) PR_DELETE(_ptr)
#define PR_DELETE(_ptr)	{ PR_Free(_ptr); (_ptr) = NULL; }

extern void *PR_Calloc(PRUint32 nelem, PRUint32 elsize);
extern void PR_Free(void *ptr);
extern void *PR_Malloc(PRUint32 size);
extern void *PR_Realloc(void *ptr, PRUint32 size);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62561"
>24.2.14. nspr4/prmon.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prmon_h___

typedef struct PRMonitor PRMonitor;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62565"
>24.2.15. nspr4/prnetdb.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prnetdb_h___
#define PR_NetAddrFamily(addr)	((addr)-&#62;raw.family)
#define PR_NetAddrInetPort(addr)	\
     ((addr)-&#62;raw.family == PR_AF_INET6 ? (addr)-&#62;ipv6.port : (addr)-&#62;inet.port)

typedef struct PRHostEnt {
    char *h_name;
    char **h_aliases;
    PRInt32 h_addrtype;
    PRInt32 h_length;
    char **h_addr_list;
} PRHostEnt;
typedef struct PRAddrInfo PRAddrInfo;
typedef enum PRNetAddrValue {
    PR_IpAddrNull,
    PR_IpAddrAny,
    PR_IpAddrLoopback,
    PR_IpAddrV4Mapped
} PRNetAddrValue;
extern void PR_ConvertIPv4AddrToIPv6(PRUint32 v4addr, PRIPv6Addr * v6addr);
extern void *PR_EnumerateAddrInfo(void *enumPtr,
				  const PRAddrInfo * addrInfo,
				  PRUint16 port, PRNetAddr * result);
extern void PR_FreeAddrInfo(PRAddrInfo * addrInfo);
extern PRAddrInfo *PR_GetAddrInfoByName(const char *hostname, PRUint16 af,
					PRIntn flags);
extern const char *PR_GetCanonNameFromAddrInfo(const PRAddrInfo *
					       addrInfo);
extern PRStatus PR_InitializeNetAddr(PRNetAddrValue val, PRUint16 port,
				     PRNetAddr * addr);
extern PRStatus PR_NetAddrToString(const PRNetAddr * addr, char *string,
				   PRUint32 size);
extern PRStatus PR_StringToNetAddr(const char *string, PRNetAddr * addr);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62569"
>24.2.16. nspr4/prthread.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prthread_h___

typedef struct PRThread PRThread;
typedef enum PRThreadType {
    PR_USER_THREAD,
    PR_SYSTEM_THREAD
} PRThreadType;
typedef enum PRThreadScope {
    PR_LOCAL_THREAD,
    PR_GLOBAL_THREAD,
    PR_GLOBAL_BOUND_THREAD
} PRThreadScope;
typedef enum PRThreadState {
    PR_JOINABLE_THREAD,
    PR_UNJOINABLE_THREAD
} PRThreadState;
typedef enum PRThreadPriority {
    PR_PRIORITY_FIRST = 0,
    PR_PRIORITY_LOW = 0,
    PR_PRIORITY_NORMAL = 1,
    PR_PRIORITY_HIGH = 2,
    PR_PRIORITY_URGENT = 3,
    PR_PRIORITY_LAST = 3
} PRThreadPriority;
typedef void (*PRThreadPrivateDTOR) (void *priv);
extern PRStatus PR_ClearInterrupt(void);
extern void *PR_GetThreadPrivate(PRUintn tpdIndex);
extern PRThreadScope PR_GetThreadScope(const PRThread * thread);
extern PRThreadState PR_GetThreadState(const PRThread * thread);
extern PRStatus PR_Interrupt(PRThread * thread);
extern PRStatus PR_NewThreadPrivateIndex(PRUintn * newIndex,
					 PRThreadPrivateDTOR destructor);
extern PRStatus PR_SetThreadPrivate(PRUintn tpIndex, void *priv);
extern PRStatus PR_Sleep(PRIntervalTime ticks);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62573"
>24.2.17. nspr4/prtime.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prtime_h___

typedef PRInt64 PRTime;
typedef struct PRTimeParameters {
    PRInt32 tp_gmt_offset;
    PRInt32 tp_dst_offset;
} PRTimeParameters;
typedef struct PRExplodedTime {
    PRInt32 tm_usec;
    PRInt32 tm_sec;
    PRInt32 tm_min;
    PRInt32 tm_hour;
    PRInt32 tm_mday;
    PRInt32 tm_month;
    PRInt16 tm_year;
    PRInt8 tm_wday;
    PRInt16 tm_yday;
    PRTimeParameters tm_params;
} PRExplodedTime;
typedef PRTimeParameters(*PRTimeParamFn) (const PRExplodedTime * gmt);
extern void PR_ExplodeTime(PRTime usecs, PRTimeParamFn params,
			   PRExplodedTime * expoded);
extern PRUint32 PR_FormatTime(char *buf, int buflen, const char *fmt,
			      const PRExplodedTime * tm);
extern PRTimeParameters PR_GMTParameters(const PRExplodedTime * gmt);
extern PRTime PR_ImplodeTime(const PRExplodedTime * exploded);
extern PRTimeParameters PR_LocalTimeParameters(const PRExplodedTime * gmt);
extern void PR_NormalizeTime(PRExplodedTime * exploded,
			     PRTimeParamFn params);
extern PRTime PR_Now(void);
extern PRStatus PR_ParseTimeString(const char *string,
				   PRBool default_to_gmt, PRTime * result);
extern PRStatus PR_ParseTimeStringToExplodedTime(const char *string,
						 PRBool default_to_gmt,
						 PRExplodedTime * result);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62577"
>24.2.18. nspr4/prtypes.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define prtypes_h___

typedef int PRInt32;
typedef unsigned long int PRUword;
typedef int PRIntn;
typedef unsigned long int PRUint64;
typedef unsigned char PRUint8;
typedef short int PRInt16;
typedef long int PRInt64;
typedef PRIntn PRBool;
typedef unsigned short PRUint16;
typedef unsigned int PRUint32;
typedef size_t PRSize;
typedef unsigned int PRUintn;
typedef PRInt64 PROffset64;
typedef PRInt32 PROffset32;
typedef enum {
    PR_FAILURE = -1,
    PR_SUCCESS = 0
} PRStatus;
typedef signed char PRInt8;</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNSS3"
>24.3. Interfaces for libnss3</A
></H2
><P
><A
HREF="#LIB-LIBNSS3-DEF"
>Table 24-3</A
> defines the library name and shared object name
for the libnss3 library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBNSS3-DEF"
></A
><P
><B
>Table 24-3. libnss3 Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libnss3</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libnss3.so</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBNSS3.1"
></A
>[NSS SSL] <A
HREF="#STD.NSS.SSL"
>Mozilla's NSS SSL Reference</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62599"
>24.3.1. NSS Utility</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN62602"
>24.3.1.1. Interfaces for NSS Utility</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for NSS Utility specified in <A
HREF="#TBL-LIBNSS3-NSS-U-INTS"
>Table 24-4</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBNSS3-NSS-U-INTS"
></A
><P
><B
>Table 24-4. libnss3 - NSS Utility Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>CERT_CheckCertValidTimes(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>CERT_DestroyCertificate(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>CERT_DupCertificate(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_FreeNicknames(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>CERT_GetCertNicknames(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>CERT_GetDefaultCertDB(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_VerifyCertName(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>CERT_VerifyCertNow(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>NSS_Init(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>NSS_InitReadWrite(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>NSS_NoDB_Init(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>NSS_Shutdown(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>PK11_FindCertFromNickname(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>PK11_FindKeyByAnyCert(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>PK11_GetSlotName(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>PK11_GetTokenName(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>PK11_IsHW(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>PK11_IsPresent(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>PK11_IsReadOnly(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>PK11_SetPasswordFunc(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
><TD
>SECKEY_DestroyPrivateKey(NSS_3.2) <A
HREF="#REFSTD.LIBNSS3.1"
>[NSS SSL]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBNSS3-DDEFS"
>24.4. Data Definitions for libnss3</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libnss3.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62707"
>24.4.1. nss3/blapit.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _BLAPIT_H_
#define PQG_PBITS_TO_INDEX(bits)	 \
   (((bits) &#60; 512 || (bits) &#62; 1024 || (bits) % 64) ? -1 : \
 (int)((bits)-512)/64)
#define PQG_INDEX_TO_PBITS(j)	 \
   (((unsigned)(j) &#62; 8) ? -1 : (512 + 64 * (j)))
#define NSS_AES	0
#define NSS_DES	0
#define NSS_RC2	0
#define NSS_RC5	0
#define NSS_AES_CBC	1
#define NSS_DES_CBC	1
#define NSS_RC2_CBC	1
#define NSS_RC5_CBC	1
#define DSA_MAX_P_BITS	1024
#define DH_MIN_P_BITS	128
#define RSA_MIN_MODULUS_BITS	128
#define AES_BLOCK_SIZE	16
#define DSA_Q_BITS	160
#define NSS_DES_EDE3	2
#define DSA_SUBPRIME_LEN	20
#define NSS_FREEBL_DEFAULT_CHUNKSIZE	2048
#define DH_MAX_P_BITS	2236
#define NSS_DES_EDE3_CBC	3
#define DSA_SIGNATURE_LEN	40
#define DSA_MIN_P_BITS	512
#define AES_KEY_WRAP_BLOCK_SIZE	8
#define AES_KEY_WRAP_IV_BYTES	8
#define DES_KEY_LENGTH	8

typedef struct PQGParamsStr {
    PLArenaPool *arena;
    SECItem prime;
    SECItem subPrime;
    SECItem base;
} PQGParams;
typedef struct PQGVerifyStr {
    PLArenaPool *arena;
    unsigned int counter;
    SECItem seed;
    SECItem h;
} PQGVerify;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62711"
>24.4.2. nss3/cert.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _CERT_H_

extern SECCertTimeValidity CERT_CheckCertValidTimes(CERTCertificate * cert,
						    PRTime t,
						    PRBool allowOverride);
extern void CERT_DestroyCertificate(CERTCertificate * cert);
extern CERTCertificate *CERT_DupCertificate(CERTCertificate * c);
extern void CERT_FreeNicknames(CERTCertNicknames * nicknames);
extern CERTCertNicknames *CERT_GetCertNicknames(CERTCertDBHandle * handle,
						int what, void *wincx);
extern CERTCertDBHandle *CERT_GetDefaultCertDB(void);
extern SECStatus CERT_VerifyCertName(CERTCertificate * cert,
				     const char *hostname);
extern SECStatus CERT_VerifyCertNow(CERTCertDBHandle * handle,
				    CERTCertificate * cert,
				    PRBool checkSig,
				    SECCertUsage certUsage, void *wincx);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62715"
>24.4.3. nss3/certt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _CERTT_H_
#define NS_CERT_TYPE_CA	 \
	( NS_CERT_TYPE_SSL_CA | NS_CERT_TYPE_EMAIL_CA | \
	NS_CERT_TYPE_OBJECT_SIGNING_CA | EXT_KEY_USAGE_STATUS_RESPONDER )
#define NS_CERT_TYPE_APP	 \
	( NS_CERT_TYPE_SSL_CLIENT | NS_CERT_TYPE_SSL_SERVER | \
	NS_CERT_TYPE_EMAIL | NS_CERT_TYPE_OBJECT_SIGNING )
#define SEC_GET_TRUST_FLAGS(trust,type)	 \
	(((type)==trustSSL)?((trust)-&#62;sslFlags): \
	(((type)==trustEmail)?((trust)-&#62;emailFlags): \
	(((type)==trustObjectSigning)?((trust)-&#62;objectSigningFlags):0)))
#define KU_ALL	 \
	(KU_DIGITAL_SIGNATURE | KU_NON_REPUDIATION | KU_KEY_ENCIPHERMENT | \
	KU_DATA_ENCIPHERMENT | KU_KEY_AGREEMENT | KU_KEY_CERT_SIGN | \
	KU_CRL_SIGN)
#define CERT_LIST_END(n,l)	(((void *)n) == ((void *)&#38;l-&#62;list))
#define CERT_LIST_NEXT(n)	((CERTCertListNode *)n-&#62;links.next)
#define CERT_LIST_HEAD(l)	((CERTCertListNode *)PR_LIST_HEAD(&#38;l-&#62;list))
#define certificateUsageSSLClient	(0x0001)
#define certificateUsageSSLServer	(0x0002)
#define certificateUsageSSLServerWithStepUp	(0x0004)
#define certificateUsageSSLCA	(0x0008)
#define certificateUsageEmailSigner	(0x0010)
#define certificateUsageEmailRecipient	(0x0020)
#define certificateUsageObjectSigner	(0x0040)
#define certificateUsageUserCertImport	(0x0080)
#define NS_CERT_TYPE_OBJECT_SIGNING_CA	(0x01)
#define certificateUsageVerifyCA	(0x0100)
#define KU_CRL_SIGN	(0x02)
#define NS_CERT_TYPE_EMAIL_CA	(0x02)
#define RF_CERTIFICATE_HOLD	(0x02)
#define certificateUsageProtectedObjectSigner	(0x0200)
#define KU_KEY_CERT_SIGN	(0x04)
#define NS_CERT_TYPE_SSL_CA	(0x04)
#define RF_CESSATION_OF_OPERATION	(0x04)
#define certificateUsageStatusResponder	(0x0400)
#define KU_KEY_AGREEMENT	(0x08)
#define NS_CERT_TYPE_RESERVED	(0x08)
#define RF_SUPERSEDED	(0x08)
#define certificateUsageAnyCA	(0x0800)
#define KU_DATA_ENCIPHERMENT	(0x10)
#define NS_CERT_TYPE_OBJECT_SIGNING	(0x10)
#define RF_AFFILIATION_CHANGED	(0x10)
#define KU_KEY_ENCIPHERMENT	(0x20)
#define NS_CERT_TYPE_EMAIL	(0x20)
#define RF_CA_COMPROMISE	(0x20)
#define KU_NON_REPUDIATION	(0x40)
#define NS_CERT_TYPE_SSL_SERVER	(0x40)
#define RF_KEY_COMPROMISE	(0x40)
#define EXT_KEY_USAGE_STATUS_RESPONDER	(0x4000)
#define KU_KEY_AGREEMENT_OR_ENCIPHERMENT	(0x4000)
#define KU_DIGITAL_SIGNATURE	(0x80)
#define NS_CERT_TYPE_SSL_CLIENT	(0x80)
#define RF_UNUSED	(0x80)
#define EXT_KEY_USAGE_TIME_STAMP	(0x8000)
#define KU_NS_GOVT_APPROVED	(0x8000)
#define CERT_UNLIMITED_PATH_CONSTRAINT	-2
#define SEC_CERTIFICATE_REQUEST_VERSION	0
#define SEC_CERTIFICATE_VERSION_1	0
#define SEC_CRL_VERSION_1	0
#define SEC_CERTIFICATE_VERSION_2	1
#define SEC_CERT_CLASS_CA	1
#define SEC_CERT_NICKNAMES_ALL	1
#define SEC_CRL_VERSION_2	1
#define SEC_CERTIFICATE_VERSION_3	2
#define SEC_CERT_CLASS_SERVER	2
#define SEC_CERT_NICKNAMES_USER	2
#define CERT_MAX_CERT_CHAIN	20
#define SEC_CERT_CLASS_USER	3
#define SEC_CERT_NICKNAMES_SERVER	3
#define SEC_CERT_CLASS_EMAIL	4
#define SEC_CERT_NICKNAMES_CA	4
#define certificateUsageHighest	certificateUsageAnyCA
#define CERT_LIST_EMPTY(l)	CERT_LIST_END(CERT_LIST_HEAD(l), l)

typedef struct CERTAVAStr {
    SECItem type;
    SECItem value;
} CERTAVA;
typedef struct CERTAttributeStr {
    SECItem attrType;
    SECItem **attrValue;
} CERTAttribute;
typedef struct CERTAuthInfoAccessStr {
    SECItem method;
    SECItem derLocation;
    CERTGeneralName *location;
} CERTAuthInfoAccess;
typedef struct CERTAuthKeyIDStr {
    SECItem keyID;
    CERTGeneralName *authCertIssuer;
    SECItem authCertSerialNumber;
    SECItem **DERAuthCertIssuer;
} CERTAuthKeyID;
typedef struct CERTBasicConstraintsStr {
    PRBool isCA;
    int pathLenConstraint;
} CERTBasicConstraints;
typedef struct NSSTrustDomainStr CERTCertDBHandle;
typedef struct CERTCertExtensionStr {
    SECItem id;
    SECItem critical;
    SECItem value;
} CERTCertExtension;
typedef struct CERTCertListStr {
    PRCList list;
    PLArenaPool *arena;
} CERTCertList;
typedef struct CERTCertListNodeStr {
    PRCList links;
    CERTCertificate *cert;
    void *appData;
} CERTCertListNode;
typedef struct CERTCertNicknamesStr {
    PLArenaPool *arena;
    void *head;
    int numnicknames;
    char **nicknames;
    int what;
    int totallen;
} CERTCertNicknames;
typedef struct CERTCertTrustStr {
    unsigned int sslFlags;
    unsigned int emailFlags;
    unsigned int objectSigningFlags;
} CERTCertTrust;
typedef struct CERTSignedDataStr {
    SECItem data;
    SECAlgorithmID signatureAlgorithm;
    SECItem signature;
} CERTSignedData;
typedef struct CERTCertificateListStr {
    SECItem *certs;
    int len;
    PLArenaPool *arena;
} CERTCertificateList;
typedef struct CERTNameStr {
    PLArenaPool *arena;
    CERTRDN **rdns;
} CERTName;
typedef struct CERTCrlStr {
    PLArenaPool *arena;
    SECItem version;
    SECAlgorithmID signatureAlg;
    SECItem derName;
    CERTName name;
    SECItem lastUpdate;
    SECItem nextUpdate;
    CERTCrlEntry **entries;
    CERTCertExtension **extensions;
} CERTCrl;
typedef struct CERTCrlDistributionPointsStr {
    CRLDistributionPoint **distPoints;
} CERTCrlDistributionPoints;
typedef struct CERTCrlEntryStr {
    SECItem serialNumber;
    SECItem revocationDate;
    CERTCertExtension **extensions;
} CERTCrlEntry;
typedef struct CERTCrlHeadNodeStr {
    PLArenaPool *arena;
    CERTCertDBHandle *dbhandle;
    CERTCrlNode *first;
    CERTCrlNode *last;
} CERTCrlHeadNode;
typedef struct CERTCrlNodeStr {
    CERTCrlNode *next;
    int type;
    CERTSignedCrl *crl;
} CERTCrlNode;
typedef struct CERTDistNamesStr {
    PLArenaPool *arena;
    int nnames;
    SECItem *names;
    void *head;
} CERTDistNames;
typedef struct OtherNameStr {
    SECItem name;
    SECItem oid;
} OtherName;
typedef struct CERTGeneralNameListStr {
    PLArenaPool *arena;
    CERTGeneralName *name;
    int refCount;
    int len;
    PRLock *lock;
} CERTGeneralNameList;
typedef struct CERTIssuerAndSNStr {
    SECItem derIssuer;
    CERTName issuer;
    SECItem serialNumber;
} CERTIssuerAndSN;
typedef struct CERTSubjectPublicKeyInfoStr {
    PLArenaPool *arena;
    SECAlgorithmID algorithm;
    SECItem subjectPublicKey;
} CERTSubjectPublicKeyInfo;
typedef struct CERTGeneralNameStr {
    CERTGeneralNameType type;
    union {
	CERTName directoryName;
	OtherName OthName;
	SECItem other;
    } name;
    SECItem derDirectoryName;
    PRCList l;
} CERTGeneralName;
typedef struct CERTNameConstraintsStr {
    CERTNameConstraint *permited;
    CERTNameConstraint *excluded;
    SECItem **DERPermited;
    SECItem **DERExcluded;
} CERTNameConstraints;
typedef struct CERTOKDomainNameStr {
    CERTOKDomainName *next;
    char name[1];
} CERTOKDomainName;
typedef struct CERTPrivKeyUsagePeriodStr {
    SECItem notBefore;
    SECItem notAfter;
    PLArenaPool *arena;
} CERTPrivKeyUsagePeriod;
typedef struct CERTRDNStr {
    CERTAVA **avas;
} CERTRDN;
typedef struct CERTSignedCrlStr {
    PLArenaPool *arena;
    CERTCrl crl;
    void *reserved1;
    PRBool reserved2;
    PRBool isperm;
    PRBool istemp;
    int referenceCount;
    CERTCertDBHandle *dbhandle;
    CERTSignedData signatureWrap;
    char *url;
    SECItem *derCrl;
    PK11SlotInfo *slot;
    CK_OBJECT_HANDLE pkcs11ID;
    void *opaque;
} CERTSignedCrl;
typedef struct CERTValidityStr {
    PLArenaPool *arena;
    SECItem notBefore;
    SECItem notAfter;
} CERTValidity;
typedef struct CERTStatusConfigStr {
    CERTStatusChecker statusChecker;
    CERTStatusDestroy statusDestroy;
    void *statusContext;
} CERTStatusConfig;
typedef struct CERTSubjectListStr {
    PLArenaPool *arena;
    int ncerts;
    char *emailAddr;
    CERTSubjectNode *head;
    CERTSubjectNode *tail;
    void *entry;
} CERTSubjectList;
typedef struct CERTSubjectNodeStr {
    struct CERTSubjectNodeStr *next;
    struct CERTSubjectNodeStr *prev;
    SECItem certKey;
    SECItem keyID;
} CERTSubjectNode;
typedef struct CERTCertificateRequestStr {
    PLArenaPool *arena;
    SECItem version;
    CERTName subject;
    CERTSubjectPublicKeyInfo subjectPublicKeyInfo;
    CERTAttribute **attributes;
} CERTCertificateRequest;
typedef struct CERTCertificateStr {
    PLArenaPool *arena;
    char *subjectName;
    char *issuerName;
    CERTSignedData signatureWrap;
    SECItem derCert;
    SECItem derIssuer;
    SECItem derSubject;
    SECItem derPublicKey;
    SECItem certKey;
    SECItem version;
    SECItem serialNumber;
    SECAlgorithmID signature;
    CERTName issuer;
    CERTValidity validity;
    CERTName subject;
    CERTSubjectPublicKeyInfo subjectPublicKeyInfo;
    SECItem issuerID;
    SECItem subjectID;
    CERTCertExtension **extensions;
    char *emailAddr;
    CERTCertDBHandle *dbhandle;
    SECItem subjectKeyID;
    PRBool keyIDGenerated;
    unsigned int keyUsage;
    unsigned int rawKeyUsage;
    PRBool keyUsagePresent;
    PRUint32 nsCertType;
    PRBool keepSession;
    PRBool timeOK;
    CERTOKDomainName *domainOK;
    PRBool isperm;
    PRBool istemp;
    char *nickname;
    char *dbnickname;
    struct NSSCertificateStr *nssCertificate;
    CERTCertTrust *trust;
    int referenceCount;
    CERTSubjectList *subjectList;
    CERTAuthKeyID *authKeyID;
    PRBool isRoot;
    union {
	void *apointer;
	struct {
	    unsigned int hasUnsupportedCriticalExt;
	} bits;
    } options;
    int series;
    PK11SlotInfo *slot;
    CK_OBJECT_HANDLE pkcs11ID;
    PRBool ownSlot;
} CERTCertificate;
typedef struct CERTVerifyLogStr {
    PLArenaPool *arena;
    unsigned int count;
    struct CERTVerifyLogNodeStr *head;
    struct CERTVerifyLogNodeStr *tail;
} CERTVerifyLog;
typedef struct CRLDistributionPointStr {
    DistributionPointTypes distPointType;
    union {
	CERTGeneralName *fullName;
	CERTRDN relativeName;
    } distPoint;
    SECItem reasons;
    CERTGeneralName *crlIssuer;
    SECItem derDistPoint;
    SECItem derRelativeName;
    SECItem **derCrlIssuer;
    SECItem **derFullName;
    SECItem bitsmap;
} CRLDistributionPoint;
typedef enum SECCertUsageEnum {
    certUsageSSLClient,
    certUsageSSLServer = 1,
    certUsageSSLServerWithStepUp = 2,
    certUsageSSLCA = 3,
    certUsageEmailSigner = 4,
    certUsageEmailRecipient = 5,
    certUsageObjectSigner = 6,
    certUsageUserCertImport = 7,
    certUsageVerifyCA = 8,
    certUsageProtectedObjectSigner = 9,
    certUsageStatusResponder = 10,
    certUsageAnyCA = 11
} SECCertUsage;
typedef PRInt64 SECCertificateUsage;
typedef enum SECCertTimeValidityEnum {
    secCertTimeValid,
    secCertTimeExpired = 1,
    secCertTimeNotValidYet = 2,
    secCertTimeUndetermined = 3
} SECCertTimeValidity;
typedef enum CERTCompareValidityStatusEnum {
    certValidityUndetermined,
    certValidityChooseB = 1,
    certValidityEqual = 2,
    certValidityChooseA = 3
} CERTCompareValidityStatus;
typedef enum CERTGeneralNameTypeEnum {
    certOtherName = 1,
    certRFC822Name = 2,
    certDNSName = 3,
    certX400Address = 4,
    certDirectoryName = 5,
    certEDIPartyName = 6,
    certURI = 7,
    certIPAddress = 8,
    certRegisterID = 9
} CERTGeneralNameType;
typedef struct CERTNameConstraintStr {
    CERTGeneralName name;
    SECItem DERName;
    SECItem min;
    SECItem max;
    PRCList l;
} CERTNameConstraint;
typedef enum DistributionPointTypesEnum {
    generalName = 1,
    relativeDistinguishedName = 2
} DistributionPointTypes;
struct CERTVerifyLogNodeStr {
    CERTCertificate *cert;
    long int error;
    unsigned int depth;
    void *arg;
    struct CERTVerifyLogNodeStr *next;
    struct CERTVerifyLogNodeStr *prev;
};
typedef SECStatus(*CERTStatusChecker) (CERTCertDBHandle *,
				       CERTCertificate *, PRInt64, void *);
typedef SECStatus(*CERTStatusDestroy) (CERTStatusConfig *);
typedef struct {
    SECOidTag oid;
    SECItem qualifierID;
    SECItem qualifierValue;
} CERTPolicyQualifier;
typedef struct {
    SECOidTag oid;
    SECItem policyID;
    CERTPolicyQualifier **policyQualifiers;
} CERTPolicyInfo;
typedef struct {
    PLArenaPool *arena;
    CERTPolicyInfo **policyInfos;
} CERTCertificatePolicies;
typedef struct {
    SECItem organization;
    SECItem **noticeNumbers;
} CERTNoticeReference;
typedef struct {
    PLArenaPool *arena;
    CERTNoticeReference noticeReference;
    SECItem derNoticeReference;
    SECItem displayText;
} CERTUserNotice;
typedef struct {
    PLArenaPool *arena;
    SECItem **oids;
} CERTOidSequence;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62719"
>24.4.4. nss3/cmsreclist.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _CMSRECLIST_H

typedef struct NSSCMSRecipientStr {
    int riIndex;
    int subIndex;
    enum {
	RLIssuerSN,
	RLSubjKeyID = 1
    } kind;
    union {
	CERTIssuerAndSN *issuerAndSN;
	SECItem *subjectKeyID;
    } id;
    CERTCertificate *cert;
    SECKEYPrivateKey *privkey;
    PK11SlotInfo *slot;
} NSSCMSRecipient;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62723"
>24.4.5. nss3/cryptoht.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _CRYPTOHT_H_

typedef struct SGNContextStr SGNContext;
typedef struct VFYContextStr VFYContext;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62727"
>24.4.6. nss3/hasht.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _HASHT_H_
#define MD2_LENGTH	16
#define MD5_LENGTH	16
#define SHA1_LENGTH	20
#define SHA256_LENGTH	32
#define SHA384_LENGTH	48
#define SHA512_LENGTH	64
#define HASH_LENGTH_MAX	SHA512_LENGTH

typedef struct SECHashObjectStr {
    unsigned int length;
    void *(*create) (void);
    void *(*clone) (void *);
    void (*destroy) (void *, PRBool);
    void (*begin) (void *);
    void (*update) (void *, const unsigned char *, unsigned int);
    void (*end) (void *, unsigned char *, unsigned int *, unsigned int);
    unsigned int blocklength;
    HASH_HashType type;
} SECHashObject;
typedef struct HASHContextStr {
    const struct SECHashObjectStr *hashobj;
    void *hash_context;
} HASHContext;
typedef enum {
    HASH_AlgNULL,
    HASH_AlgMD2 = 1,
    HASH_AlgMD5 = 2,
    HASH_AlgSHA1 = 3,
    HASH_AlgSHA256 = 4,
    HASH_AlgSHA384 = 5,
    HASH_AlgSHA512 = 6,
    HASH_AlgTOTAL = 7
} HASH_HashType;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62731"
>24.4.7. nss3/key.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _KEY_H_</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62735"
>24.4.8. nss3/keyhi.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _KEYHI_H_

extern void SECKEY_DestroyPrivateKey(SECKEYPrivateKey * key);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62739"
>24.4.9. nss3/keyt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _KEYT_H_</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62743"
>24.4.10. nss3/keythi.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _KEYTHI_H_

typedef enum {
    nullKey,
    rsaKey = 1,
    dsaKey = 2,
    fortezzaKey = 3,
    dhKey = 4,
    keaKey = 5,
    ecKey = 6
} KeyType;
typedef struct SECKEYRSAPublicKeyStr {
    PLArenaPool *arena;
    SECItem modulus;
    SECItem publicExponent;
} SECKEYRSAPublicKey;
typedef struct SECKEYPQGParamsStr {
    PLArenaPool *arena;
    SECItem prime;
    SECItem subPrime;
    SECItem base;
} SECKEYPQGParams;
typedef struct SECKEYDSAPublicKeyStr {
    SECKEYPQGParams params;
    SECItem publicValue;
} SECKEYDSAPublicKey;
typedef struct SECKEYDHParamsStr {
    PLArenaPool *arena;
    SECItem prime;
    SECItem base;
} SECKEYDHParams;
typedef struct SECKEYDHPublicKeyStr {
    PLArenaPool *arena;
    SECItem prime;
    SECItem base;
    SECItem publicValue;
} SECKEYDHPublicKey;
typedef SECItem SECKEYECParams;
typedef struct SECKEYECPublicKeyStr {
    SECKEYECParams DEREncodedParams;
    int size;
    SECItem publicValue;
} SECKEYECPublicKey;
typedef struct SECKEYFortezzaPublicKeyStr {
    int KEAversion;
    int DSSversion;
    unsigned char KMID[8];
    SECItem clearance;
    SECItem KEApriviledge;
    SECItem DSSpriviledge;
    SECItem KEAKey;
    SECItem DSSKey;
    SECKEYPQGParams params;
    SECKEYPQGParams keaParams;
} SECKEYFortezzaPublicKey;
typedef struct SECKEYKEAParamsStr {
    PLArenaPool *arena;
    SECItem hash;
} SECKEYKEAParams;
typedef struct SECKEYKEAPublicKeyStr {
    SECKEYKEAParams params;
    SECItem publicValue;
} SECKEYKEAPublicKey;
typedef struct SECKEYPublicKeyStr {
    PLArenaPool *arena;
    KeyType keyType;
    PK11SlotInfo *pkcs11Slot;
    CK_OBJECT_HANDLE pkcs11ID;
    union {
	SECKEYRSAPublicKey rsa;
	SECKEYDSAPublicKey dsa;
	SECKEYDHPublicKey dh;
	SECKEYKEAPublicKey kea;
	SECKEYFortezzaPublicKey fortezza;
	SECKEYECPublicKey ec;
    } u;
} SECKEYPublicKey;
typedef struct SECKEYPrivateKeyStr {
    PLArenaPool *arena;
    KeyType keyType;
    PK11SlotInfo *pkcs11Slot;
    CK_OBJECT_HANDLE pkcs11ID;
    PRBool pkcs11IsTemp;
    void *wincx;
    PRUint32 staticflags;
} SECKEYPrivateKey;
typedef struct {
    PRCList links;
    SECKEYPrivateKey *key;
} SECKEYPrivateKeyListNode;
typedef struct {
    PRCList list;
    PLArenaPool *arena;
} SECKEYPrivateKeyList;
typedef struct {
    PRCList list;
    PLArenaPool *arena;
} SECKEYPublicKeyList;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62747"
>24.4.11. nss3/nss.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __nss_h_
#define NSS_VERSION	"3.11.4"
#define NSS_INIT_READONLY	0x1
#define NSS_INIT_NOROOTINIT	0x10
#define NSS_INIT_NOPK11FINALIZE	0x100
#define NSS_INIT_NOCERTDB	0x2
#define NSS_INIT_OPTIMIZESPACE	0x20
#define NSS_INIT_RESERVED	0x200
#define NSS_INIT_NOMODDB	0x4
#define NSS_INIT_PK11THREADSAFE	0x40
#define NSS_INIT_FORCEOPEN	0x8
#define NSS_INIT_PK11RELOAD	0x80
#define NSS_VMINOR	11
#define NSS_VMAJOR	3
#define NSS_VPATCH	4
#define NSS_INIT_COOPERATE	NSS_INIT_PK11THREADSAFE | NSS_INIT_PK11RELOAD | NSS_INIT_NOPK11FINALIZE | NSS_INIT_RESERVED
#define SECMOD_DB	"secmod.db"

extern SECStatus NSS_Init(const char *configdir);
extern SECStatus NSS_InitReadWrite(const char *configdir);
extern SECStatus NSS_NoDB_Init(const char *configdir);
extern SECStatus NSS_Shutdown(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62751"
>24.4.12. nss3/nssb64.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _NSSB64_H_</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62755"
>24.4.13. nss3/nssb64t.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _NSSB64T_H_

typedef struct NSSBase64DecoderStr NSSBase64Decoder;
typedef struct NSSBase64EncoderStr NSSBase64Encoder;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62759"
>24.4.14. nss3/nssilckt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _NSSILCKT_H_

typedef enum {
    nssILockArena,
    nssILockSession = 1,
    nssILockObject = 2,
    nssILockRefLock = 3,
    nssILockCert = 4,
    nssILockCertDB = 5,
    nssILockDBM = 6,
    nssILockCache = 7,
    nssILockSSL = 8,
    nssILockList = 9,
    nssILockSlot = 10,
    nssILockFreelist = 11,
    nssILockOID = 12,
    nssILockAttribute = 13,
    nssILockPK11cxt = 14,
    nssILockRWLock = 15,
    nssILockOther = 16,
    nssILockSelfServ = 17,
    nssILockKeyDB = 18,
    nssILockLast = 19
} nssILockType;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62763"
>24.4.15. nss3/nssrwlkt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define nssrwlkt_h___

typedef struct nssRWLockStr NSSRWLock;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62767"
>24.4.16. nss3/ocspt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _OCSPT_H_

typedef struct CERTOCSPRequestStr CERTOCSPRequest;
typedef struct CERTOCSPResponseStr CERTOCSPResponse;
typedef struct CERTOCSPCertIDStr CERTOCSPCertID;
typedef struct CERTOCSPSingleResponseStr CERTOCSPSingleResponse;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62771"
>24.4.17. nss3/pk11pub.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _PK11PUB_H_

extern CERTCertificate *PK11_FindCertFromNickname(const char *nickname,
						  void *wincx);
extern SECKEYPrivateKey *PK11_FindKeyByAnyCert(CERTCertificate * cert,
					       void *wincx);
extern char *PK11_GetSlotName(PK11SlotInfo * slot);
extern char *PK11_GetTokenName(PK11SlotInfo * slot);
extern PRBool PK11_IsHW(PK11SlotInfo * slot);
extern PRBool PK11_IsPresent(PK11SlotInfo * slot);
extern PRBool PK11_IsReadOnly(PK11SlotInfo * slot);
extern void PK11_SetPasswordFunc(PK11PasswordFunc func);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62775"
>24.4.18. nss3/pkcs11t.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _PKCS11T_H_

typedef unsigned char CK_BYTE;
typedef CK_BYTE CK_CHAR;
typedef CK_BYTE CK_UTF8CHAR;
typedef unsigned long int CK_ULONG;
typedef CK_ULONG CK_FLAGS;
typedef void *CK_VOID_PTR;
typedef struct CK_VERSION {
    CK_BYTE major;
    CK_BYTE minor;
} CK_VERSION;
typedef struct CK_INFO {
    CK_VERSION cryptokiVersion;
    CK_UTF8CHAR manufacturerID[31];
    CK_FLAGS flags;
    CK_UTF8CHAR libraryDescription[31];
    CK_VERSION libraryVersion;
} CK_INFO;
typedef CK_ULONG CK_SLOT_ID;
typedef struct CK_SLOT_INFO {
    CK_UTF8CHAR slotDescription[63];
    CK_UTF8CHAR manufacturerID[31];
    CK_FLAGS flags;
    CK_VERSION hardwareVersion;
    CK_VERSION firmwareVersion;
} CK_SLOT_INFO;
typedef struct CK_TOKEN_INFO {
    CK_UTF8CHAR label[31];
    CK_UTF8CHAR manufacturerID[31];
    CK_UTF8CHAR model[15];
    CK_CHAR serialNumber[15];
    CK_FLAGS flags;
    CK_ULONG ulMaxSessionCount;
    CK_ULONG ulSessionCount;
    CK_ULONG ulMaxRwSessionCount;
    CK_ULONG ulRwSessionCount;
    CK_ULONG ulMaxPinLen;
    CK_ULONG ulMinPinLen;
    CK_ULONG ulTotalPublicMemory;
    CK_ULONG ulFreePublicMemory;
    CK_ULONG ulTotalPrivateMemory;
    CK_ULONG ulFreePrivateMemory;
    CK_VERSION hardwareVersion;
    CK_VERSION firmwareVersion;
    CK_CHAR utcTime[15];
} CK_TOKEN_INFO;
typedef CK_ULONG CK_SESSION_HANDLE;
typedef CK_ULONG CK_OBJECT_HANDLE;
typedef CK_ULONG CK_OBJECT_CLASS;
typedef CK_ULONG CK_KEY_TYPE;
typedef CK_ULONG CK_ATTRIBUTE_TYPE;
typedef struct CK_ATTRIBUTE {
    CK_ATTRIBUTE_TYPE type;
    CK_VOID_PTR pValue;
    CK_ULONG ulValueLen;
} CK_ATTRIBUTE;
typedef CK_ATTRIBUTE *CK_ATTRIBUTE_PTR;
typedef CK_ULONG CK_MECHANISM_TYPE;
typedef struct CK_MECHANISM {
    CK_MECHANISM_TYPE mechanism;
    CK_VOID_PTR pParameter;
    CK_ULONG ulParameterLen;
} CK_MECHANISM;
typedef CK_MECHANISM *CK_MECHANISM_PTR;
typedef CK_ULONG CK_RV;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62779"
>24.4.19. nss3/pkcs7t.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _PKCS7T_H_

typedef struct SEC_PKCS7RecipientInfoStr {
    SECItem version;
    CERTIssuerAndSN *issuerAndSN;
    SECAlgorithmID keyEncAlg;
    SECItem encKey;
    CERTCertificate *cert;
} SEC_PKCS7RecipientInfo;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62783"
>24.4.20. nss3/secasn1t.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECASN1T_H_

typedef struct sec_ASN1Template_struct {
    unsigned long int kind;
    unsigned long int offset;
    const void *sub;
    unsigned int size;
} SEC_ASN1Template;
typedef struct sec_DecoderContext_struct SEC_ASN1DecoderContext;
typedef struct sec_EncoderContext_struct SEC_ASN1EncoderContext;
typedef enum {
    SEC_ASN1_Identifier,
    SEC_ASN1_Length = 1,
    SEC_ASN1_Contents = 2,
    SEC_ASN1_EndOfContents = 3
} SEC_ASN1EncodingPart;
typedef void (*SEC_ASN1NotifyProc) (void *, PRBool, void *, int);
typedef void (*SEC_ASN1WriteProc) (void *, const char *, unsigned long int,
				   int, SEC_ASN1EncodingPart);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62787"
>24.4.21. nss3/seccomon.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECCOMMON_H_

typedef enum {
    siBuffer,
    siClearDataBuffer = 1,
    siCipherDataBuffer = 2,
    siDERCertBuffer = 3,
    siEncodedCertBuffer = 4,
    siDERNameBuffer = 5,
    siEncodedNameBuffer = 6,
    siAsciiNameString = 7,
    siAsciiString = 8,
    siDEROID = 9,
    siUnsignedInteger = 10,
    siUTCTime = 11,
    siGeneralizedTime = 12,
    siVisibleString = 13,
    siUTF8String = 14,
    siBMPString = 15
} SECItemType;
typedef struct SECItemStr {
    SECItemType type;
    unsigned char *data;
    unsigned int len;
} SECItem;
typedef enum _SECStatus {
    SECWouldBlock = -2,
    SECFailure = -1,
    SECSuccess
} SECStatus;
typedef enum _SECComparison {
    SECLessThan = -1,
    SECEqual,
    SECGreaterThan = 1
} SECComparison;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62791"
>24.4.22. nss3/secdert.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECDERT_H_

typedef struct DERTemplateStr {
    unsigned long int kind;
    unsigned int offset;
    DERTemplate *sub;
    unsigned long int arg;
} DERTemplate;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62795"
>24.4.23. nss3/secdigt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECDIGT_H_

typedef struct SGNDigestInfoStr {
    PLArenaPool *arena;
    SECAlgorithmID digestAlgorithm;
    SECItem digest;
} SGNDigestInfo;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62799"
>24.4.24. nss3/secmodt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECMODT_H_
#define SECMOD_MAKE_NSS_FLAGS(fips,slot)	 \
	"Flags=internal,critical"fips" \
	slotparams=("#slot"={"SECMOD_SLOT_FLAGS"})"
#define SECMOD_FIPS_NAME	"NSS Internal FIPS PKCS #11 Module"
#define SECMOD_INT_NAME	"NSS Internal PKCS #11 Module"
#define SECMOD_SLOT_FLAGS	"slotFlags=[RSA,DSA,DH,RC2,RC4,DES,RANDOM,SHA1,MD5,MD2,SSL,TLS,AES,SHA256,SHA512]"
#define SECMOD_EXTERNAL	0
#define CRL_IMPORT_DEFAULT_OPTIONS	0x00000000
#define CRL_IMPORT_BYPASS_CHECKS	0x00000001
#define PK11_ATTR_TOKEN	0x00000001L
#define SECMOD_RSA_FLAG	0x00000001L
#define PK11_ATTR_SESSION	0x00000002L
#define SECMOD_DSA_FLAG	0x00000002L
#define PK11_ATTR_PRIVATE	0x00000004L
#define SECMOD_RC2_FLAG	0x00000004L
#define PK11_ATTR_PUBLIC	0x00000008L
#define SECMOD_RC4_FLAG	0x00000008L
#define PK11_ATTR_MODIFIABLE	0x00000010L
#define SECMOD_DES_FLAG	0x00000010L
#define PK11_ATTR_UNMODIFIABLE	0x00000020L
#define SECMOD_DH_FLAG	0x00000020L
#define PK11_ATTR_SENSITIVE	0x00000040L
#define SECMOD_FORTEZZA_FLAG	0x00000040L
#define PK11_ATTR_INSENSITIVE	0x00000080L
#define SECMOD_RC5_FLAG	0x00000080L
#define PK11_ATTR_EXTRACTABLE	0x00000100L
#define SECMOD_SHA1_FLAG	0x00000100L
#define PK11_ATTR_UNEXTRACTABLE	0x00000200L
#define SECMOD_MD5_FLAG	0x00000200L
#define SECMOD_MD2_FLAG	0x00000400L
#define SECMOD_SSL_FLAG	0x00000800L
#define SECMOD_TLS_FLAG	0x00001000L
#define SECMOD_AES_FLAG	0x00002000L
#define SECMOD_SHA256_FLAG	0x00004000L
#define SECMOD_SHA512_FLAG	0x00008000L
#define SECMOD_END_WAIT	0x01
#define SECMOD_WAIT_SIMULATED_EVENT	0x02
#define SECMOD_WAIT_PKCS11_EVENT	0x04
#define SECMOD_RESERVED_FLAG	0X08000000L
#define SECMOD_FRIENDLY_FLAG	0x10000000L
#define PK11_OWN_PW_DEFAULTS	0x20000000L
#define PK11_DISABLE_FLAG	0x40000000L
#define SECMOD_RANDOM_FLAG	0x80000000L
#define CKM_FAKE_RANDOM	0x80000efeL
#define CKM_INVALID_MECHANISM	0xffffffffL
#define SECMOD_INTERNAL	1
#define SECMOD_FIPS	2
#define PK11_PW_AUTHENTICATED	"AUTH"
#define PK11_PW_RETRY	"RETRY"
#define SECMOD_INT_FLAGS	SECMOD_MAKE_NSS_FLAGS("",1)
#define SECMOD_FIPS_FLAGS	SECMOD_MAKE_NSS_FLAGS(",fips",3)
#define PK11_PW_TRY	"TRY"

typedef struct SECMODModuleStr {
    PLArenaPool *arena;
    PRBool internal;
    PRBool loaded;
    PRBool isFIPS;
    char *dllName;
    char *commonName;
    void *library;
    void *functionList;
    PRLock *refLock;
    int refCount;
    PK11SlotInfo **slots;
    int slotCount;
    PK11PreSlotInfo *slotInfo;
    int slotInfoCount;
    SECMODModuleID moduleID;
    PRBool isThreadSafe;
    unsigned long int ssl[1];
    char *libraryParams;
    void *moduleDBFunc;
    SECMODModule *parent;
    PRBool isCritical;
    PRBool isModuleDB;
    PRBool moduleDBOnly;
    int trustOrder;
    int cipherOrder;
    unsigned long int evControlMask;
    CK_VERSION cryptokiVersion;
} SECMODModule;
typedef struct SECMODModuleListStr {
    SECMODModuleList *next;
    SECMODModule *module;
} SECMODModuleList;
typedef NSSRWLock SECMODListLock;
typedef struct PK11SlotInfoStr PK11SlotInfo;
typedef struct PK11PreSlotInfoStr PK11PreSlotInfo;
typedef struct PK11SymKeyStr PK11SymKey;
typedef struct PK11ContextStr PK11Context;
typedef struct PK11SlotListStr PK11SlotList;
typedef struct PK11SlotListElementStr PK11SlotListElement;
typedef unsigned long int SECMODModuleID;
typedef struct PK11DefaultArrayEntryStr PK11DefaultArrayEntry;
typedef struct PK11GenericObjectStr PK11GenericObject;
typedef void (*PK11FreeDataFunc) (void *);
typedef enum {
    PK11CertListUnique,
    PK11CertListUser = 1,
    PK11CertListRootUnique = 2,
    PK11CertListCA = 3,
    PK11CertListCAUnique = 4,
    PK11CertListUserUnique = 5,
    PK11CertListAll = 6
} PK11CertListType;
typedef PRUint32 PK11AttrFlags;
typedef enum {
    PK11_OriginNULL,
    PK11_OriginDerive = 1,
    PK11_OriginGenerated = 2,
    PK11_OriginFortezzaHack = 3,
    PK11_OriginUnwrap = 4
} PK11Origin;
typedef enum {
    PK11_DIS_NONE,
    PK11_DIS_USER_SELECTED = 1,
    PK11_DIS_COULD_NOT_INIT_TOKEN = 2,
    PK11_DIS_TOKEN_VERIFY_FAILED = 3,
    PK11_DIS_TOKEN_NOT_PRESENT = 4
} PK11DisableReasons;
typedef enum {
    PK11_TypeGeneric,
    PK11_TypePrivKey = 1,
    PK11_TypePubKey = 2,
    PK11_TypeCert = 3,
    PK11_TypeSymKey = 4
} PK11ObjectType;
typedef char *(*PK11PasswordFunc) (PK11SlotInfo *, PRBool, void *);
typedef struct SECKEYAttributeStr {
    SECItem attrType;
    SECItem **attrValue;
} SECKEYAttribute;
typedef struct SECKEYPrivateKeyInfoStr {
    PLArenaPool *arena;
    SECItem version;
    SECAlgorithmID algorithm;
    SECItem privateKey;
    SECKEYAttribute **attributes;
} SECKEYPrivateKeyInfo;
typedef struct SECKEYEncryptedPrivateKeyInfoStr {
    PLArenaPool *arena;
    SECAlgorithmID algorithm;
    SECItem encryptedData;
} SECKEYEncryptedPrivateKeyInfo;
typedef enum {
    PK11TokenNotRemovable,
    PK11TokenPresent = 1,
    PK11TokenChanged = 2,
    PK11TokenRemoved = 3
} PK11TokenStatus;
typedef enum {
    PK11TokenRemovedOrChangedEvent,
    PK11TokenPresentEvent = 1
} PK11TokenEvent;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62803"
>24.4.25. nss3/secoidt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECOIDT_H_

typedef struct SECOidDataStr {
    SECItem oid;
    SECOidTag offset;
    const char *desc;
    unsigned long int mechanism;
    SECSupportExtenTag supportedExtension;
} SECOidData;
typedef struct SECAlgorithmIDStr {
    SECItem algorithm;
    SECItem parameters;
} SECAlgorithmID;
typedef enum {
    SEC_OID_UNKNOWN,
    SEC_OID_MD2 = 1,
    SEC_OID_MD4 = 2,
    SEC_OID_MD5 = 3,
    SEC_OID_SHA1 = 4,
    SEC_OID_RC2_CBC = 5,
    SEC_OID_RC4 = 6,
    SEC_OID_DES_EDE3_CBC = 7,
    SEC_OID_RC5_CBC_PAD = 8,
    SEC_OID_DES_ECB = 9,
    SEC_OID_DES_CBC = 10,
    SEC_OID_DES_OFB = 11,
    SEC_OID_DES_CFB = 12,
    SEC_OID_DES_MAC = 13,
    SEC_OID_DES_EDE = 14,
    SEC_OID_ISO_SHA_WITH_RSA_SIGNATURE = 15,
    SEC_OID_PKCS1_RSA_ENCRYPTION = 16,
    SEC_OID_PKCS1_MD2_WITH_RSA_ENCRYPTION = 17,
    SEC_OID_PKCS1_MD4_WITH_RSA_ENCRYPTION = 18,
    SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION = 19,
    SEC_OID_PKCS1_SHA1_WITH_RSA_ENCRYPTION = 20,
    SEC_OID_PKCS5_PBE_WITH_MD2_AND_DES_CBC = 21,
    SEC_OID_PKCS5_PBE_WITH_MD5_AND_DES_CBC = 22,
    SEC_OID_PKCS5_PBE_WITH_SHA1_AND_DES_CBC = 23,
    SEC_OID_PKCS7 = 24,
    SEC_OID_PKCS7_DATA = 25,
    SEC_OID_PKCS7_SIGNED_DATA = 26,
    SEC_OID_PKCS7_ENVELOPED_DATA = 27,
    SEC_OID_PKCS7_SIGNED_ENVELOPED_DATA = 28,
    SEC_OID_PKCS7_DIGESTED_DATA = 29,
    SEC_OID_PKCS7_ENCRYPTED_DATA = 30,
    SEC_OID_PKCS9_EMAIL_ADDRESS = 31,
    SEC_OID_PKCS9_UNSTRUCTURED_NAME = 32,
    SEC_OID_PKCS9_CONTENT_TYPE = 33,
    SEC_OID_PKCS9_MESSAGE_DIGEST = 34,
    SEC_OID_PKCS9_SIGNING_TIME = 35,
    SEC_OID_PKCS9_COUNTER_SIGNATURE = 36,
    SEC_OID_PKCS9_CHALLENGE_PASSWORD = 37,
    SEC_OID_PKCS9_UNSTRUCTURED_ADDRESS = 38,
    SEC_OID_PKCS9_EXTENDED_CERTIFICATE_ATTRIBUTES = 39,
    SEC_OID_PKCS9_SMIME_CAPABILITIES = 40,
    SEC_OID_AVA_COMMON_NAME = 41,
    SEC_OID_AVA_COUNTRY_NAME = 42,
    SEC_OID_AVA_LOCALITY = 43,
    SEC_OID_AVA_STATE_OR_PROVINCE = 44,
    SEC_OID_AVA_ORGANIZATION_NAME = 45,
    SEC_OID_AVA_ORGANIZATIONAL_UNIT_NAME = 46,
    SEC_OID_AVA_DN_QUALIFIER = 47,
    SEC_OID_AVA_DC = 48,
    SEC_OID_NS_TYPE_GIF = 49,
    SEC_OID_NS_TYPE_JPEG = 50,
    SEC_OID_NS_TYPE_URL = 51,
    SEC_OID_NS_TYPE_HTML = 52,
    SEC_OID_NS_TYPE_CERT_SEQUENCE = 53,
    SEC_OID_MISSI_KEA_DSS_OLD = 54,
    SEC_OID_MISSI_DSS_OLD = 55,
    SEC_OID_MISSI_KEA_DSS = 56,
    SEC_OID_MISSI_DSS = 57,
    SEC_OID_MISSI_KEA = 58,
    SEC_OID_MISSI_ALT_KEA = 59,
    SEC_OID_NS_CERT_EXT_NETSCAPE_OK = 60,
    SEC_OID_NS_CERT_EXT_ISSUER_LOGO = 61,
    SEC_OID_NS_CERT_EXT_SUBJECT_LOGO = 62,
    SEC_OID_NS_CERT_EXT_CERT_TYPE = 63,
    SEC_OID_NS_CERT_EXT_BASE_URL = 64,
    SEC_OID_NS_CERT_EXT_REVOCATION_URL = 65,
    SEC_OID_NS_CERT_EXT_CA_REVOCATION_URL = 66,
    SEC_OID_NS_CERT_EXT_CA_CRL_URL = 67,
    SEC_OID_NS_CERT_EXT_CA_CERT_URL = 68,
    SEC_OID_NS_CERT_EXT_CERT_RENEWAL_URL = 69,
    SEC_OID_NS_CERT_EXT_CA_POLICY_URL = 70,
    SEC_OID_NS_CERT_EXT_HOMEPAGE_URL = 71,
    SEC_OID_NS_CERT_EXT_ENTITY_LOGO = 72,
    SEC_OID_NS_CERT_EXT_USER_PICTURE = 73,
    SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME = 74,
    SEC_OID_NS_CERT_EXT_COMMENT = 75,
    SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL = 76,
    SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME = 77,
    SEC_OID_NS_KEY_USAGE_GOVT_APPROVED = 78,
    SEC_OID_X509_SUBJECT_DIRECTORY_ATTR = 79,
    SEC_OID_X509_SUBJECT_KEY_ID = 80,
    SEC_OID_X509_KEY_USAGE = 81,
    SEC_OID_X509_PRIVATE_KEY_USAGE_PERIOD = 82,
    SEC_OID_X509_SUBJECT_ALT_NAME = 83,
    SEC_OID_X509_ISSUER_ALT_NAME = 84,
    SEC_OID_X509_BASIC_CONSTRAINTS = 85,
    SEC_OID_X509_NAME_CONSTRAINTS = 86,
    SEC_OID_X509_CRL_DIST_POINTS = 87,
    SEC_OID_X509_CERTIFICATE_POLICIES = 88,
    SEC_OID_X509_POLICY_MAPPINGS = 89,
    SEC_OID_X509_POLICY_CONSTRAINTS = 90,
    SEC_OID_X509_AUTH_KEY_ID = 91,
    SEC_OID_X509_EXT_KEY_USAGE = 92,
    SEC_OID_X509_AUTH_INFO_ACCESS = 93,
    SEC_OID_X509_CRL_NUMBER = 94,
    SEC_OID_X509_REASON_CODE = 95,
    SEC_OID_X509_INVALID_DATE = 96,
    SEC_OID_X500_RSA_ENCRYPTION = 97,
    SEC_OID_RFC1274_UID = 98,
    SEC_OID_RFC1274_MAIL = 99,
    SEC_OID_PKCS12 = 100,
    SEC_OID_PKCS12_MODE_IDS = 101,
    SEC_OID_PKCS12_ESPVK_IDS = 102,
    SEC_OID_PKCS12_BAG_IDS = 103,
    SEC_OID_PKCS12_CERT_BAG_IDS = 104,
    SEC_OID_PKCS12_OIDS = 105,
    SEC_OID_PKCS12_PBE_IDS = 106,
    SEC_OID_PKCS12_SIGNATURE_IDS = 107,
    SEC_OID_PKCS12_ENVELOPING_IDS = 108,
    SEC_OID_PKCS12_PKCS8_KEY_SHROUDING = 109,
    SEC_OID_PKCS12_KEY_BAG_ID = 110,
    SEC_OID_PKCS12_CERT_AND_CRL_BAG_ID = 111,
    SEC_OID_PKCS12_SECRET_BAG_ID = 112,
    SEC_OID_PKCS12_X509_CERT_CRL_BAG = 113,
    SEC_OID_PKCS12_SDSI_CERT_BAG = 114,
    SEC_OID_PKCS12_PBE_WITH_SHA1_AND_128_BIT_RC4 = 115,
    SEC_OID_PKCS12_PBE_WITH_SHA1_AND_40_BIT_RC4 = 116,
    SEC_OID_PKCS12_PBE_WITH_SHA1_AND_TRIPLE_DES_CBC = 117,
    SEC_OID_PKCS12_PBE_WITH_SHA1_AND_128_BIT_RC2_CBC = 118,
    SEC_OID_PKCS12_PBE_WITH_SHA1_AND_40_BIT_RC2_CBC = 119,
    SEC_OID_PKCS12_RSA_ENCRYPTION_WITH_128_BIT_RC4 = 120,
    SEC_OID_PKCS12_RSA_ENCRYPTION_WITH_40_BIT_RC4 = 121,
    SEC_OID_PKCS12_RSA_ENCRYPTION_WITH_TRIPLE_DES = 122,
    SEC_OID_PKCS12_RSA_SIGNATURE_WITH_SHA1_DIGEST = 123,
    SEC_OID_ANSIX9_DSA_SIGNATURE = 124,
    SEC_OID_ANSIX9_DSA_SIGNATURE_WITH_SHA1_DIGEST = 125,
    SEC_OID_BOGUS_DSA_SIGNATURE_WITH_SHA1_DIGEST = 126,
    SEC_OID_VERISIGN_USER_NOTICES = 127,
    SEC_OID_PKIX_CPS_POINTER_QUALIFIER = 128,
    SEC_OID_PKIX_USER_NOTICE_QUALIFIER = 129,
    SEC_OID_PKIX_OCSP = 130,
    SEC_OID_PKIX_OCSP_BASIC_RESPONSE = 131,
    SEC_OID_PKIX_OCSP_NONCE = 132,
    SEC_OID_PKIX_OCSP_CRL = 133,
    SEC_OID_PKIX_OCSP_RESPONSE = 134,
    SEC_OID_PKIX_OCSP_NO_CHECK = 135,
    SEC_OID_PKIX_OCSP_ARCHIVE_CUTOFF = 136,
    SEC_OID_PKIX_OCSP_SERVICE_LOCATOR = 137,
    SEC_OID_PKIX_REGCTRL_REGTOKEN = 138,
    SEC_OID_PKIX_REGCTRL_AUTHENTICATOR = 139,
    SEC_OID_PKIX_REGCTRL_PKIPUBINFO = 140,
    SEC_OID_PKIX_REGCTRL_PKI_ARCH_OPTIONS = 141,
    SEC_OID_PKIX_REGCTRL_OLD_CERT_ID = 142,
    SEC_OID_PKIX_REGCTRL_PROTOCOL_ENC_KEY = 143,
    SEC_OID_PKIX_REGINFO_UTF8_PAIRS = 144,
    SEC_OID_PKIX_REGINFO_CERT_REQUEST = 145,
    SEC_OID_EXT_KEY_USAGE_SERVER_AUTH = 146,
    SEC_OID_EXT_KEY_USAGE_CLIENT_AUTH = 147,
    SEC_OID_EXT_KEY_USAGE_CODE_SIGN = 148,
    SEC_OID_EXT_KEY_USAGE_EMAIL_PROTECT = 149,
    SEC_OID_EXT_KEY_USAGE_TIME_STAMP = 150,
    SEC_OID_OCSP_RESPONDER = 151,
    SEC_OID_NETSCAPE_SMIME_KEA = 152,
    SEC_OID_FORTEZZA_SKIPJACK = 153,
    SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_128_BIT_RC4 = 154,
    SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_40_BIT_RC4 = 155,
    SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_3KEY_TRIPLE_DES_CBC = 156,
    SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_2KEY_TRIPLE_DES_CBC = 157,
    SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_128_BIT_RC2_CBC = 158,
    SEC_OID_PKCS12_V2_PBE_WITH_SHA1_AND_40_BIT_RC2_CBC = 159,
    SEC_OID_PKCS12_SAFE_CONTENTS_ID = 160,
    SEC_OID_PKCS12_PKCS8_SHROUDED_KEY_BAG_ID = 161,
    SEC_OID_PKCS12_V1_KEY_BAG_ID = 162,
    SEC_OID_PKCS12_V1_PKCS8_SHROUDED_KEY_BAG_ID = 163,
    SEC_OID_PKCS12_V1_CERT_BAG_ID = 164,
    SEC_OID_PKCS12_V1_CRL_BAG_ID = 165,
    SEC_OID_PKCS12_V1_SECRET_BAG_ID = 166,
    SEC_OID_PKCS12_V1_SAFE_CONTENTS_BAG_ID = 167,
    SEC_OID_PKCS9_X509_CERT = 168,
    SEC_OID_PKCS9_SDSI_CERT = 169,
    SEC_OID_PKCS9_X509_CRL = 170,
    SEC_OID_PKCS9_FRIENDLY_NAME = 171,
    SEC_OID_PKCS9_LOCAL_KEY_ID = 172,
    SEC_OID_BOGUS_KEY_USAGE = 173,
    SEC_OID_X942_DIFFIE_HELMAN_KEY = 174,
    SEC_OID_NETSCAPE_NICKNAME = 175,
    SEC_OID_NETSCAPE_RECOVERY_REQUEST = 176,
    SEC_OID_CERT_RENEWAL_LOCATOR = 177,
    SEC_OID_NS_CERT_EXT_SCOPE_OF_USE = 178,
    SEC_OID_CMS_EPHEMERAL_STATIC_DIFFIE_HELLMAN = 179,
    SEC_OID_CMS_3DES_KEY_WRAP = 180,
    SEC_OID_CMS_RC2_KEY_WRAP = 181,
    SEC_OID_SMIME_ENCRYPTION_KEY_PREFERENCE = 182,
    SEC_OID_AES_128_ECB = 183,
    SEC_OID_AES_128_CBC = 184,
    SEC_OID_AES_192_ECB = 185,
    SEC_OID_AES_192_CBC = 186,
    SEC_OID_AES_256_ECB = 187,
    SEC_OID_AES_256_CBC = 188,
    SEC_OID_SDN702_DSA_SIGNATURE = 189,
    SEC_OID_MS_SMIME_ENCRYPTION_KEY_PREFERENCE = 190,
    SEC_OID_SHA256 = 191,
    SEC_OID_SHA384 = 192,
    SEC_OID_SHA512 = 193,
    SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION = 194,
    SEC_OID_PKCS1_SHA384_WITH_RSA_ENCRYPTION = 195,
    SEC_OID_PKCS1_SHA512_WITH_RSA_ENCRYPTION = 196,
    SEC_OID_AES_128_KEY_WRAP = 197,
    SEC_OID_AES_192_KEY_WRAP = 198,
    SEC_OID_AES_256_KEY_WRAP = 199,
    SEC_OID_ANSIX962_EC_PUBLIC_KEY = 200,
    SEC_OID_ANSIX962_ECDSA_SHA1_SIGNATURE = 201,
    SEC_OID_ANSIX962_EC_PRIME192V1 = 202,
    SEC_OID_ANSIX962_EC_PRIME192V2 = 203,
    SEC_OID_ANSIX962_EC_PRIME192V3 = 204,
    SEC_OID_ANSIX962_EC_PRIME239V1 = 205,
    SEC_OID_ANSIX962_EC_PRIME239V2 = 206,
    SEC_OID_ANSIX962_EC_PRIME239V3 = 207,
    SEC_OID_ANSIX962_EC_PRIME256V1 = 208,
    SEC_OID_SECG_EC_SECP112R1 = 209,
    SEC_OID_SECG_EC_SECP112R2 = 210,
    SEC_OID_SECG_EC_SECP128R1 = 211,
    SEC_OID_SECG_EC_SECP128R2 = 212,
    SEC_OID_SECG_EC_SECP160K1 = 213,
    SEC_OID_SECG_EC_SECP160R1 = 214,
    SEC_OID_SECG_EC_SECP160R2 = 215,
    SEC_OID_SECG_EC_SECP192K1 = 216,
    SEC_OID_SECG_EC_SECP224K1 = 217,
    SEC_OID_SECG_EC_SECP224R1 = 218,
    SEC_OID_SECG_EC_SECP256K1 = 219,
    SEC_OID_SECG_EC_SECP384R1 = 220,
    SEC_OID_SECG_EC_SECP521R1 = 221,
    SEC_OID_ANSIX962_EC_C2PNB163V1 = 222,
    SEC_OID_ANSIX962_EC_C2PNB163V2 = 223,
    SEC_OID_ANSIX962_EC_C2PNB163V3 = 224,
    SEC_OID_ANSIX962_EC_C2PNB176V1 = 225,
    SEC_OID_ANSIX962_EC_C2TNB191V1 = 226,
    SEC_OID_ANSIX962_EC_C2TNB191V2 = 227,
    SEC_OID_ANSIX962_EC_C2TNB191V3 = 228,
    SEC_OID_ANSIX962_EC_C2ONB191V4 = 229,
    SEC_OID_ANSIX962_EC_C2ONB191V5 = 230,
    SEC_OID_ANSIX962_EC_C2PNB208W1 = 231,
    SEC_OID_ANSIX962_EC_C2TNB239V1 = 232,
    SEC_OID_ANSIX962_EC_C2TNB239V2 = 233,
    SEC_OID_ANSIX962_EC_C2TNB239V3 = 234,
    SEC_OID_ANSIX962_EC_C2ONB239V4 = 235,
    SEC_OID_ANSIX962_EC_C2ONB239V5 = 236,
    SEC_OID_ANSIX962_EC_C2PNB272W1 = 237,
    SEC_OID_ANSIX962_EC_C2PNB304W1 = 238,
    SEC_OID_ANSIX962_EC_C2TNB359V1 = 239,
    SEC_OID_ANSIX962_EC_C2PNB368W1 = 240,
    SEC_OID_ANSIX962_EC_C2TNB431R1 = 241,
    SEC_OID_SECG_EC_SECT113R1 = 242,
    SEC_OID_SECG_EC_SECT113R2 = 243,
    SEC_OID_SECG_EC_SECT131R1 = 244,
    SEC_OID_SECG_EC_SECT131R2 = 245,
    SEC_OID_SECG_EC_SECT163K1 = 246,
    SEC_OID_SECG_EC_SECT163R1 = 247,
    SEC_OID_SECG_EC_SECT163R2 = 248,
    SEC_OID_SECG_EC_SECT193R1 = 249,
    SEC_OID_SECG_EC_SECT193R2 = 250,
    SEC_OID_SECG_EC_SECT233K1 = 251,
    SEC_OID_SECG_EC_SECT233R1 = 252,
    SEC_OID_SECG_EC_SECT239K1 = 253,
    SEC_OID_SECG_EC_SECT283K1 = 254,
    SEC_OID_SECG_EC_SECT283R1 = 255,
    SEC_OID_SECG_EC_SECT409K1 = 256,
    SEC_OID_SECG_EC_SECT409R1 = 257,
    SEC_OID_SECG_EC_SECT571K1 = 258,
    SEC_OID_SECG_EC_SECT571R1 = 259,
    SEC_OID_NETSCAPE_AOLSCREENNAME = 260,
    SEC_OID_AVA_SURNAME = 261,
    SEC_OID_AVA_SERIAL_NUMBER = 262,
    SEC_OID_AVA_STREET_ADDRESS = 263,
    SEC_OID_AVA_TITLE = 264,
    SEC_OID_AVA_POSTAL_ADDRESS = 265,
    SEC_OID_AVA_POSTAL_CODE = 266,
    SEC_OID_AVA_POST_OFFICE_BOX = 267,
    SEC_OID_AVA_GIVEN_NAME = 268,
    SEC_OID_AVA_INITIALS = 269,
    SEC_OID_AVA_GENERATION_QUALIFIER = 270,
    SEC_OID_AVA_HOUSE_IDENTIFIER = 271,
    SEC_OID_AVA_PSEUDONYM = 272,
    SEC_OID_PKIX_CA_ISSUERS = 273,
    SEC_OID_PKCS9_EXTENSION_REQUEST = 274,
    SEC_OID_ANSIX962_ECDSA_SIGNATURE_RECOMMENDED_DIGEST = 275,
    SEC_OID_ANSIX962_ECDSA_SIGNATURE_SPECIFIED_DIGEST = 276,
    SEC_OID_ANSIX962_ECDSA_SHA224_SIGNATURE = 277,
    SEC_OID_ANSIX962_ECDSA_SHA256_SIGNATURE = 278,
    SEC_OID_ANSIX962_ECDSA_SHA384_SIGNATURE = 279,
    SEC_OID_ANSIX962_ECDSA_SHA512_SIGNATURE = 280,
    SEC_OID_X509_HOLD_INSTRUCTION_CODE = 281,
    SEC_OID_X509_DELTA_CRL_INDICATOR = 282,
    SEC_OID_X509_ISSUING_DISTRIBUTION_POINT = 283,
    SEC_OID_X509_CERT_ISSUER = 284,
    SEC_OID_X509_FRESHEST_CRL = 285,
    SEC_OID_X509_INHIBIT_ANY_POLICY = 286,
    SEC_OID_X509_SUBJECT_INFO_ACCESS = 287,
    SEC_OID_CAMELLIA_128_CBC = 288,
    SEC_OID_CAMELLIA_192_CBC = 289,
    SEC_OID_CAMELLIA_256_CBC = 290,
    SEC_OID_PKCS5_PBKDF2 = 291,
    SEC_OID_PKCS5_PBES2 = 292,
    SEC_OID_PKCS5_PBMAC1 = 293,
    SEC_OID_HMAC_SHA1 = 294,
    SEC_OID_HMAC_SHA224 = 295,
    SEC_OID_HMAC_SHA256 = 296,
    SEC_OID_HMAC_SHA384 = 297,
    SEC_OID_HMAC_SHA512 = 298,
    SEC_OID_PKIX_TIMESTAMPING = 299,
    SEC_OID_PKIX_CA_REPOSITORY = 300,
    SEC_OID_ISO_SHA1_WITH_RSA_SIGNATURE = 301,
    SEC_OID_TOTAL = 302
} SECOidTag;
typedef enum {
    INVALID_CERT_EXTENSION,
    UNSUPPORTED_CERT_EXTENSION = 1,
    SUPPORTED_CERT_EXTENSION = 2
} SECSupportExtenTag;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62807"
>24.4.26. nss3/secpkcs5.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECPKCS5_H_

typedef enum {
    pbeBitGenIDNull,
    pbeBitGenCipherKey = 1,
    pbeBitGenCipherIV = 2,
    pbeBitGenIntegrityKey = 3
} PBEBitGenID;
typedef struct PBEBitGenContextStr PBEBitGenContext;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62811"
>24.4.27. nss3/secport.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _SECPORT_H_

typedef PRBool(*PORTCharConversionWSwapFunc) (PRBool, unsigned char *,
					      unsigned int,
					      unsigned char *,
					      unsigned int, unsigned int *,
					      PRBool);
typedef PRBool(*PORTCharConversionFunc) (PRBool, unsigned char *,
					 unsigned int, unsigned char *,
					 unsigned int, unsigned int *);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBSSL3"
>24.5. Interfaces for libssl3</A
></H2
><P
><A
HREF="#LIB-LIBSSL3-DEF"
>Table 24-5</A
> defines the library name and shared object name
for the libssl3 library</P
><DIV
CLASS="TABLE"
><A
NAME="LIB-LIBSSL3-DEF"
></A
><P
><B
>Table 24-5. libssl3 Definition</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Library:</TD
><TD
>libssl3</TD
></TR
><TR
><TD
>SONAME:</TD
><TD
>libssl3.so</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The behavior of the interfaces in this library is specified by the following specifications:<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
NAME="REFSTD.LIBSSL3.1"
></A
>[NSS SSL] <A
HREF="#STD.NSS.SSL"
>Mozilla's NSS SSL Reference</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN62833"
>24.5.1. NSS SSL</A
></H3
><P
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN62836"
>24.5.1.1. Interfaces for NSS SSL</A
></H4
><P
>An LSB conforming implementation shall provide the generic functions
for NSS SSL specified in <A
HREF="#TBL-LIBSSL3-NSS-S-INTS"
>Table 24-6</A
>,
with the full mandatory functionality as described in the referenced
underlying specification.</P
><DIV
CLASS="TABLE"
><A
NAME="TBL-LIBSSL3-NSS-S-INTS"
></A
><P
><B
>Table 24-6. libssl3 - NSS SSL Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>NSS_CmpCertChainWCANames(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>NSS_FindCertKEAType(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>NSS_GetClientAuthData(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_AuthCertificate(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_AuthCertificateHook(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_BadCertHook(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPolicyGet(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_CipherPolicySet(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_CipherPrefGet(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPrefGetDefault(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_CipherPrefSet(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_CipherPrefSetDefault(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_ClearSessionCache(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_ConfigMPServerSIDCache(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_ConfigSecureServer(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_ConfigServerSessionIDCache(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_DataPending(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_ForceHandshake(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_GetClientAuthDataHook(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_GetSessionID(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_HandshakeCallback(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_ImportFD(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_InheritMPServerSIDCache(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_InvalidateSession(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_OptionGet(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_OptionGetDefault(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_OptionSet(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_OptionSetDefault(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_PeerCertificate(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_ReHandshake(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_ResetHandshake(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_RevealPinArg(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_RevealURL(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_SecurityStatus(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_SetPKCS11PinArg(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>SSL_SetSockPeerID(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_SetURL(NSS_3.2) <A
HREF="#REFSTD.LIBSSL3.1"
>[NSS SSL]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="LIBSSL3-DDEFS"
>24.6. Data Definitions for libssl3</A
></H2
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libssl3.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63013"
>24.6.1. nss3/ecl-exp.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __ecl_exp_h_
#define ECCurve_SECG_CHAR2_163R2	ECCurve_NIST_B163
#define ECCurve_SECG_CHAR2_233R1	ECCurve_NIST_B233
#define ECCurve_WTLS_11	ECCurve_NIST_B233
#define ECCurve_SECG_CHAR2_283R1	ECCurve_NIST_B283
#define ECCurve_SECG_CHAR2_409R1	ECCurve_NIST_B409
#define ECCurve_SECG_CHAR2_571R1	ECCurve_NIST_B571
#define ECCurve_SECG_CHAR2_163K1	ECCurve_NIST_K163
#define ECCurve_WTLS_3	ECCurve_NIST_K163
#define ECCurve_SECG_CHAR2_233K1	ECCurve_NIST_K233
#define ECCurve_WTLS_10	ECCurve_NIST_K233
#define ECCurve_SECG_CHAR2_283K1	ECCurve_NIST_K283
#define ECCurve_SECG_CHAR2_409K1	ECCurve_NIST_K409
#define ECCurve_SECG_CHAR2_571K1	ECCurve_NIST_K571
#define ECCurve_SECG_PRIME_192R1	ECCurve_NIST_P192
#define ECCurve_X9_62_PRIME_192V1	ECCurve_NIST_P192
#define ECCurve_SECG_PRIME_224R1	ECCurve_NIST_P224
#define ECCurve_WTLS_12	ECCurve_NIST_P224
#define ECCurve_SECG_PRIME_256R1	ECCurve_NIST_P256
#define ECCurve_X9_62_PRIME_256V1	ECCurve_NIST_P256
#define ECCurve_SECG_PRIME_384R1	ECCurve_NIST_P384
#define ECCurve_SECG_PRIME_521R1	ECCurve_NIST_P521
#define ECCurve_WTLS_4	ECCurve_SECG_CHAR2_113R1
#define ECCurve_WTLS_6	ECCurve_SECG_PRIME_112R1
#define ECCurve_WTLS_7	ECCurve_SECG_PRIME_160R1
#define ECCurve_WTLS_5	ECCurve_X9_62_CHAR2_PNB163V1

enum ECField {
    ECField_GFp = 0,
    ECField_GF2m = 1
};
typedef struct ECCurveParamsStr {
    char *text;
    enum ECField field;
    unsigned int size;
    char *irr;
    char *curvea;
    char *curveb;
    char *genx;
    char *geny;
    char *order;
    int cofactor;
} ECCurveParams;
enum ECCurveName {
    ECCurve_noName = 0,
    ECCurve_NIST_P192 = 1,
    ECCurve_NIST_P224 = 2,
    ECCurve_NIST_P256 = 3,
    ECCurve_NIST_P384 = 4,
    ECCurve_NIST_P521 = 5,
    ECCurve_NIST_K163 = 6,
    ECCurve_NIST_B163 = 7,
    ECCurve_NIST_K233 = 8,
    ECCurve_NIST_B233 = 9,
    ECCurve_NIST_K283 = 10,
    ECCurve_NIST_B283 = 11,
    ECCurve_NIST_K409 = 12,
    ECCurve_NIST_B409 = 13,
    ECCurve_NIST_K571 = 14,
    ECCurve_NIST_B571 = 15,
    ECCurve_X9_62_PRIME_192V2 = 16,
    ECCurve_X9_62_PRIME_192V3 = 17,
    ECCurve_X9_62_PRIME_239V1 = 18,
    ECCurve_X9_62_PRIME_239V2 = 19,
    ECCurve_X9_62_PRIME_239V3 = 20,
    ECCurve_X9_62_CHAR2_PNB163V1 = 21,
    ECCurve_X9_62_CHAR2_PNB163V2 = 22,
    ECCurve_X9_62_CHAR2_PNB163V3 = 23,
    ECCurve_X9_62_CHAR2_PNB176V1 = 24,
    ECCurve_X9_62_CHAR2_TNB191V1 = 25,
    ECCurve_X9_62_CHAR2_TNB191V2 = 26,
    ECCurve_X9_62_CHAR2_TNB191V3 = 27,
    ECCurve_X9_62_CHAR2_PNB208W1 = 28,
    ECCurve_X9_62_CHAR2_TNB239V1 = 29,
    ECCurve_X9_62_CHAR2_TNB239V2 = 30,
    ECCurve_X9_62_CHAR2_TNB239V3 = 31,
    ECCurve_X9_62_CHAR2_PNB272W1 = 32,
    ECCurve_X9_62_CHAR2_PNB304W1 = 33,
    ECCurve_X9_62_CHAR2_TNB359V1 = 34,
    ECCurve_X9_62_CHAR2_PNB368W1 = 35,
    ECCurve_X9_62_CHAR2_TNB431R1 = 36,
    ECCurve_SECG_PRIME_112R1 = 37,
    ECCurve_SECG_PRIME_112R2 = 38,
    ECCurve_SECG_PRIME_128R1 = 39,
    ECCurve_SECG_PRIME_128R2 = 40,
    ECCurve_SECG_PRIME_160K1 = 41,
    ECCurve_SECG_PRIME_160R1 = 42,
    ECCurve_SECG_PRIME_160R2 = 43,
    ECCurve_SECG_PRIME_192K1 = 44,
    ECCurve_SECG_PRIME_224K1 = 45,
    ECCurve_SECG_PRIME_256K1 = 46,
    ECCurve_SECG_CHAR2_113R1 = 47,
    ECCurve_SECG_CHAR2_113R2 = 48,
    ECCurve_SECG_CHAR2_131R1 = 49,
    ECCurve_SECG_CHAR2_131R2 = 50,
    ECCurve_SECG_CHAR2_163R1 = 51,
    ECCurve_SECG_CHAR2_193R1 = 52,
    ECCurve_SECG_CHAR2_193R2 = 53,
    ECCurve_SECG_CHAR2_239K1 = 54,
    ECCurve_WTLS_1 = 55,
    ECCurve_WTLS_8 = 56,
    ECCurve_WTLS_9 = 57,
    ECCurve_pastLastCurve = 58
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63017"
>24.6.2. nss3/ssl.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __ssl_h_
#define SSL_IS_SSL2_CIPHER(which)	(((which) &#38; 0xfff0) == 0xff00)
#define SSL_REQUIRE_NEVER	((PRBool)0)
#define SSL_REQUIRE_ALWAYS	((PRBool)1)
#define SSL_REQUIRE_FIRST_HANDSHAKE	((PRBool)2)
#define SSL_REQUIRE_NO_ERROR	((PRBool)3)
#define SSL_SECURITY_STATUS_NOOPT	-1
#define SSL_NOT_ALLOWED	0
#define SSL_SECURITY_STATUS_OFF	0
#define SSL_ALLOWED	1
#define SSL_SECURITY	1
#define SSL_SECURITY_STATUS_ON_HIGH	1
#define SSL_REQUIRE_CERTIFICATE	10
#define SSL_ENABLE_FDX	11
#define SSL_V2_COMPATIBLE_HELLO	12
#define SSL_ENABLE_TLS	13
#define SSL_ROLLBACK_DETECTION	14
#define SSL_NO_STEP_DOWN	15
#define SSL_BYPASS_PKCS11	16
#define SSL_NO_LOCKS	17
#define SSL_RESTRICTED	2
#define SSL_SECURITY_STATUS_ON_LOW	2
#define SSL_SOCKS	2
#define SSL_REQUEST_CERTIFICATE	3
#define SSL_HANDSHAKE_AS_CLIENT	5
#define SSL_HANDSHAKE_AS_SERVER	6
#define SSL_ENABLE_SSL2	7
#define SSL_ENABLE_SSL3	8
#define SSL_NO_CACHE	9
#define SSL_ENV_VAR_NAME	"SSL_INHERITANCE"

typedef SECStatus(*SSLAuthCertificate) (void *, PRFileDesc *, PRBool,
					PRBool);
typedef SECStatus(*SSLGetClientAuthData) (void *, PRFileDesc *,
					  CERTDistNames *,
					  CERTCertificate * *,
					  SECKEYPrivateKey * *);
typedef SECStatus(*SSLBadCertHandler) (void *, PRFileDesc *);
typedef void (*SSLHandshakeCallback) (PRFileDesc *, void *);
extern SECStatus NSS_CmpCertChainWCANames(CERTCertificate * cert,
					  CERTDistNames * caNames);
extern SSLKEAType NSS_FindCertKEAType(CERTCertificate * cert);
extern SECStatus NSS_GetClientAuthData(void *arg, PRFileDesc * socket,
				       struct CERTDistNamesStr *caNames,
				       struct CERTCertificateStr
				       **pRetCert,
				       struct SECKEYPrivateKeyStr
				       **pRetKey);
extern SECStatus SSL_AuthCertificate(void *arg, PRFileDesc * fd,
				     PRBool checkSig, PRBool isServer);
extern SECStatus SSL_AuthCertificateHook(PRFileDesc * fd,
					 SSLAuthCertificate f, void *arg);
extern SECStatus SSL_BadCertHook(PRFileDesc * fd, SSLBadCertHandler f,
				 void *arg);
extern SECStatus SSL_CipherPolicyGet(PRInt32 cipher, PRInt32 * policy);
extern SECStatus SSL_CipherPolicySet(PRInt32 cipher, PRInt32 policy);
extern SECStatus SSL_CipherPrefGet(PRFileDesc * fd, PRInt32 cipher,
				   PRBool * enabled);
extern SECStatus SSL_CipherPrefGetDefault(PRInt32 cipher,
					  PRBool * enabled);
extern SECStatus SSL_CipherPrefSet(PRFileDesc * fd, PRInt32 cipher,
				   PRBool enabled);
extern SECStatus SSL_CipherPrefSetDefault(PRInt32 cipher, PRBool enabled);
extern void SSL_ClearSessionCache(void);
extern SECStatus SSL_ConfigMPServerSIDCache(int maxCacheEntries,
					    PRUint32 timeout,
					    PRUint32 ssl3_timeout,
					    const char *directory);
extern SECStatus SSL_ConfigSecureServer(PRFileDesc * fd,
					CERTCertificate * cert,
					SECKEYPrivateKey * key,
					SSLKEAType kea);
extern SECStatus SSL_ConfigServerSessionIDCache(int maxCacheEntries,
						PRUint32 timeout,
						PRUint32 ssl3_timeout,
						const char *directory);
extern int SSL_DataPending(PRFileDesc * fd);
extern SECStatus SSL_ForceHandshake(PRFileDesc * fd);
extern SECStatus SSL_GetClientAuthDataHook(PRFileDesc * fd,
					   SSLGetClientAuthData f,
					   void *a);
extern SECItem *SSL_GetSessionID(PRFileDesc * fd);
extern SECStatus SSL_HandshakeCallback(PRFileDesc * fd,
				       SSLHandshakeCallback cb,
				       void *client_data);
extern PRFileDesc *SSL_ImportFD(PRFileDesc * model, PRFileDesc * fd);
extern SECStatus SSL_InheritMPServerSIDCache(const char *envString);
extern SECStatus SSL_InvalidateSession(PRFileDesc * fd);
extern SECStatus SSL_OptionGet(PRFileDesc * fd, PRInt32 option,
			       PRBool * on);
extern SECStatus SSL_OptionGetDefault(PRInt32 option, PRBool * on);
extern SECStatus SSL_OptionSet(PRFileDesc * fd, PRInt32 option, PRBool on);
extern SECStatus SSL_OptionSetDefault(PRInt32 option, PRBool on);
extern CERTCertificate *SSL_PeerCertificate(PRFileDesc * fd);
extern SECStatus SSL_ReHandshake(PRFileDesc * fd, PRBool flushCache);
extern SECStatus SSL_ResetHandshake(PRFileDesc * fd, PRBool asServer);
extern void *SSL_RevealPinArg(PRFileDesc * socket);
extern char *SSL_RevealURL(PRFileDesc * socket);
extern SECStatus SSL_SecurityStatus(PRFileDesc * fd, int *on,
				    char **cipher, int *keySize,
				    int *secretKeySize, char **issuer,
				    char **subject);
extern SECStatus SSL_SetPKCS11PinArg(PRFileDesc * fd, void *a);
extern SECStatus SSL_SetSockPeerID(PRFileDesc * fd, const char *peerID);
extern SECStatus SSL_SetURL(PRFileDesc * fd, const char *url);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63021"
>24.6.3. nss3/sslerr.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __SSL_ERR_H_
#define IS_SSL_ERROR(code)	 \
	(((code) &#62;= SSL_ERROR_BASE) &#38;&#38; ((code) &#60; SSL_ERROR_LIMIT))
#define SSL_ERROR_BASE	(-0x3000)
#define SSL_ERROR_LIMIT	(SSL_ERROR_BASE + 1000)

typedef enum {
    SSL_ERROR_EXPORT_ONLY_SERVER = (SSL_ERROR_BASE + 0),
    SSL_ERROR_US_ONLY_SERVER = (SSL_ERROR_BASE + 1),
    SSL_ERROR_NO_CYPHER_OVERLAP = (SSL_ERROR_BASE + 2),
    SSL_ERROR_NO_CERTIFICATE = (SSL_ERROR_BASE + 3),
    SSL_ERROR_BAD_CERTIFICATE = (SSL_ERROR_BASE + 4),
    SSL_ERROR_BAD_CLIENT = (SSL_ERROR_BASE + 6),
    SSL_ERROR_BAD_SERVER = (SSL_ERROR_BASE + 7),
    SSL_ERROR_UNSUPPORTED_CERTIFICATE_TYPE = (SSL_ERROR_BASE + 8),
    SSL_ERROR_UNSUPPORTED_VERSION = (SSL_ERROR_BASE + 9),
    SSL_ERROR_WRONG_CERTIFICATE = (SSL_ERROR_BASE + 11),
    SSL_ERROR_BAD_CERT_DOMAIN = (SSL_ERROR_BASE + 12),
    SSL_ERROR_POST_WARNING = (SSL_ERROR_BASE + 13),
    SSL_ERROR_SSL2_DISABLED = (SSL_ERROR_BASE + 14),
    SSL_ERROR_BAD_MAC_READ = (SSL_ERROR_BASE + 15),
    SSL_ERROR_BAD_MAC_ALERT = (SSL_ERROR_BASE + 16),
    SSL_ERROR_BAD_CERT_ALERT = (SSL_ERROR_BASE + 17),
    SSL_ERROR_REVOKED_CERT_ALERT = (SSL_ERROR_BASE + 18),
    SSL_ERROR_EXPIRED_CERT_ALERT = (SSL_ERROR_BASE + 19),
    SSL_ERROR_SSL_DISABLED = (SSL_ERROR_BASE + 20),
    SSL_ERROR_FORTEZZA_PQG = (SSL_ERROR_BASE + 21),
    SSL_ERROR_UNKNOWN_CIPHER_SUITE = (SSL_ERROR_BASE + 22),
    SSL_ERROR_NO_CIPHERS_SUPPORTED = (SSL_ERROR_BASE + 23),
    SSL_ERROR_BAD_BLOCK_PADDING = (SSL_ERROR_BASE + 24),
    SSL_ERROR_RX_RECORD_TOO_LONG = (SSL_ERROR_BASE + 25),
    SSL_ERROR_TX_RECORD_TOO_LONG = (SSL_ERROR_BASE + 26),
    SSL_ERROR_RX_MALFORMED_HELLO_REQUEST = (SSL_ERROR_BASE + 27),
    SSL_ERROR_RX_MALFORMED_CLIENT_HELLO = (SSL_ERROR_BASE + 28),
    SSL_ERROR_RX_MALFORMED_SERVER_HELLO = (SSL_ERROR_BASE + 29),
    SSL_ERROR_RX_MALFORMED_CERTIFICATE = (SSL_ERROR_BASE + 30),
    SSL_ERROR_RX_MALFORMED_SERVER_KEY_EXCH = (SSL_ERROR_BASE + 31),
    SSL_ERROR_RX_MALFORMED_CERT_REQUEST = (SSL_ERROR_BASE + 32),
    SSL_ERROR_RX_MALFORMED_HELLO_DONE = (SSL_ERROR_BASE + 33),
    SSL_ERROR_RX_MALFORMED_CERT_VERIFY = (SSL_ERROR_BASE + 34),
    SSL_ERROR_RX_MALFORMED_CLIENT_KEY_EXCH = (SSL_ERROR_BASE + 35),
    SSL_ERROR_RX_MALFORMED_FINISHED = (SSL_ERROR_BASE + 36),
    SSL_ERROR_RX_MALFORMED_CHANGE_CIPHER = (SSL_ERROR_BASE + 37),
    SSL_ERROR_RX_MALFORMED_ALERT = (SSL_ERROR_BASE + 38),
    SSL_ERROR_RX_MALFORMED_HANDSHAKE = (SSL_ERROR_BASE + 39),
    SSL_ERROR_RX_MALFORMED_APPLICATION_DATA = (SSL_ERROR_BASE + 40),
    SSL_ERROR_RX_UNEXPECTED_HELLO_REQUEST = (SSL_ERROR_BASE + 41),
    SSL_ERROR_RX_UNEXPECTED_CLIENT_HELLO = (SSL_ERROR_BASE + 42),
    SSL_ERROR_RX_UNEXPECTED_SERVER_HELLO = (SSL_ERROR_BASE + 43),
    SSL_ERROR_RX_UNEXPECTED_CERTIFICATE = (SSL_ERROR_BASE + 44),
    SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH = (SSL_ERROR_BASE + 45),
    SSL_ERROR_RX_UNEXPECTED_CERT_REQUEST = (SSL_ERROR_BASE + 46),
    SSL_ERROR_RX_UNEXPECTED_HELLO_DONE = (SSL_ERROR_BASE + 47),
    SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY = (SSL_ERROR_BASE + 48),
    SSL_ERROR_RX_UNEXPECTED_CLIENT_KEY_EXCH = (SSL_ERROR_BASE + 49),
    SSL_ERROR_RX_UNEXPECTED_FINISHED = (SSL_ERROR_BASE + 50),
    SSL_ERROR_RX_UNEXPECTED_CHANGE_CIPHER = (SSL_ERROR_BASE + 51),
    SSL_ERROR_RX_UNEXPECTED_ALERT = (SSL_ERROR_BASE + 52),
    SSL_ERROR_RX_UNEXPECTED_HANDSHAKE = (SSL_ERROR_BASE + 53),
    SSL_ERROR_RX_UNEXPECTED_APPLICATION_DATA = (SSL_ERROR_BASE + 54),
    SSL_ERROR_RX_UNKNOWN_RECORD_TYPE = (SSL_ERROR_BASE + 55),
    SSL_ERROR_RX_UNKNOWN_HANDSHAKE = (SSL_ERROR_BASE + 56),
    SSL_ERROR_RX_UNKNOWN_ALERT = (SSL_ERROR_BASE + 57),
    SSL_ERROR_CLOSE_NOTIFY_ALERT = (SSL_ERROR_BASE + 58),
    SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT = (SSL_ERROR_BASE + 59),
    SSL_ERROR_DECOMPRESSION_FAILURE_ALERT = (SSL_ERROR_BASE + 60),
    SSL_ERROR_HANDSHAKE_FAILURE_ALERT = (SSL_ERROR_BASE + 61),
    SSL_ERROR_ILLEGAL_PARAMETER_ALERT = (SSL_ERROR_BASE + 62),
    SSL_ERROR_UNSUPPORTED_CERT_ALERT = (SSL_ERROR_BASE + 63),
    SSL_ERROR_CERTIFICATE_UNKNOWN_ALERT = (SSL_ERROR_BASE + 64),
    SSL_ERROR_GENERATE_RANDOM_FAILURE = (SSL_ERROR_BASE + 65),
    SSL_ERROR_SIGN_HASHES_FAILURE = (SSL_ERROR_BASE + 66),
    SSL_ERROR_EXTRACT_PUBLIC_KEY_FAILURE = (SSL_ERROR_BASE + 67),
    SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE = (SSL_ERROR_BASE + 68),
    SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE = (SSL_ERROR_BASE + 69),
    SSL_ERROR_ENCRYPTION_FAILURE = (SSL_ERROR_BASE + 70),
    SSL_ERROR_DECRYPTION_FAILURE = (SSL_ERROR_BASE + 71),
    SSL_ERROR_SOCKET_WRITE_FAILURE = (SSL_ERROR_BASE + 72),
    SSL_ERROR_MD5_DIGEST_FAILURE = (SSL_ERROR_BASE + 73),
    SSL_ERROR_SHA_DIGEST_FAILURE = (SSL_ERROR_BASE + 74),
    SSL_ERROR_MAC_COMPUTATION_FAILURE = (SSL_ERROR_BASE + 75),
    SSL_ERROR_SYM_KEY_CONTEXT_FAILURE = (SSL_ERROR_BASE + 76),
    SSL_ERROR_SYM_KEY_UNWRAP_FAILURE = (SSL_ERROR_BASE + 77),
    SSL_ERROR_PUB_KEY_SIZE_LIMIT_EXCEEDED = (SSL_ERROR_BASE + 78),
    SSL_ERROR_IV_PARAM_FAILURE = (SSL_ERROR_BASE + 79),
    SSL_ERROR_INIT_CIPHER_SUITE_FAILURE = (SSL_ERROR_BASE + 80),
    SSL_ERROR_SESSION_KEY_GEN_FAILURE = (SSL_ERROR_BASE + 81),
    SSL_ERROR_NO_SERVER_KEY_FOR_ALG = (SSL_ERROR_BASE + 82),
    SSL_ERROR_TOKEN_INSERTION_REMOVAL = (SSL_ERROR_BASE + 83),
    SSL_ERROR_TOKEN_SLOT_NOT_FOUND = (SSL_ERROR_BASE + 84),
    SSL_ERROR_NO_COMPRESSION_OVERLAP = (SSL_ERROR_BASE + 85),
    SSL_ERROR_HANDSHAKE_NOT_COMPLETED = (SSL_ERROR_BASE + 86),
    SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE = (SSL_ERROR_BASE + 87),
    SSL_ERROR_CERT_KEA_MISMATCH = (SSL_ERROR_BASE + 88),
    SSL_ERROR_NO_TRUSTED_SSL_CLIENT_CA = (SSL_ERROR_BASE + 89),
    SSL_ERROR_SESSION_NOT_FOUND = (SSL_ERROR_BASE + 90),
    SSL_ERROR_DECRYPTION_FAILED_ALERT = (SSL_ERROR_BASE + 91),
    SSL_ERROR_RECORD_OVERFLOW_ALERT = (SSL_ERROR_BASE + 92),
    SSL_ERROR_UNKNOWN_CA_ALERT = (SSL_ERROR_BASE + 93),
    SSL_ERROR_ACCESS_DENIED_ALERT = (SSL_ERROR_BASE + 94),
    SSL_ERROR_DECODE_ERROR_ALERT = (SSL_ERROR_BASE + 95),
    SSL_ERROR_DECRYPT_ERROR_ALERT = (SSL_ERROR_BASE + 96),
    SSL_ERROR_EXPORT_RESTRICTION_ALERT = (SSL_ERROR_BASE + 97),
    SSL_ERROR_PROTOCOL_VERSION_ALERT = (SSL_ERROR_BASE + 98),
    SSL_ERROR_INSUFFICIENT_SECURITY_ALERT = (SSL_ERROR_BASE + 99),
    SSL_ERROR_INTERNAL_ERROR_ALERT = (SSL_ERROR_BASE + 100),
    SSL_ERROR_USER_CANCELED_ALERT = (SSL_ERROR_BASE + 101),
    SSL_ERROR_NO_RENEGOTIATION_ALERT = (SSL_ERROR_BASE + 102),
    SSL_ERROR_SERVER_CACHE_NOT_CONFIGURED = (SSL_ERROR_BASE + 103),
    SSL_ERROR_UNSUPPORTED_EXTENSION_ALERT = (SSL_ERROR_BASE + 104),
    SSL_ERROR_CERTIFICATE_UNOBTAINABLE_ALERT = (SSL_ERROR_BASE + 105),
    SSL_ERROR_UNRECOGNIZED_NAME_ALERT = (SSL_ERROR_BASE + 106),
    SSL_ERROR_BAD_CERT_STATUS_RESPONSE_ALERT = (SSL_ERROR_BASE + 107),
    SSL_ERROR_BAD_CERT_HASH_VALUE_ALERT = (SSL_ERROR_BASE + 108)
} SSLErrorCodes;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63025"
>24.6.4. nss3/sslproto.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __sslproto_h_
#define SSL_MT_ERROR	0
#define SSL_NULL_WITH_NULL_NULL	0x0000
#define SSL_PE_NO_CYPHERS	0x0001
#define SSL_RSA_WITH_NULL_MD5	0x0001
#define SSL_LIBRARY_VERSION_2	0x0002
#define SSL_PE_NO_CERTIFICATE	0x0002
#define SSL_RSA_WITH_NULL_SHA	0x0002
#define SSL_RSA_EXPORT_WITH_RC4_40_MD5	0x0003
#define SSL_PE_BAD_CERTIFICATE	0x0004
#define SSL_RSA_WITH_RC4_128_MD5	0x0004
#define SSL_RSA_WITH_RC4_128_SHA	0x0005
#define SSL_PE_UNSUPPORTED_CERTIFICATE_TYPE	0x0006
#define SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5	0x0006
#define SSL_RSA_WITH_IDEA_CBC_SHA	0x0007
#define SSL_RSA_EXPORT_WITH_DES40_CBC_SHA	0x0008
#define SSL_RSA_WITH_DES_CBC_SHA	0x0009
#define SSL_RSA_WITH_3DES_EDE_CBC_SHA	0x000a
#define SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA	0x000b
#define SSL_DH_DSS_WITH_DES_CBC_SHA	0x000c
#define SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA	0x000d
#define SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA	0x000e
#define SSL_DH_RSA_WITH_DES_CBC_SHA	0x000f
#define SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA	0x0010
#define SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA	0x0011
#define SSL_DHE_DSS_WITH_DES_CBC_SHA	0x0012
#define SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA	0x0013
#define SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA	0x0014
#define SSL_DHE_RSA_WITH_DES_CBC_SHA	0x0015
#define SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA	0x0016
#define SSL_DH_ANON_EXPORT_WITH_RC4_40_MD5	0x0017
#define SSL_DH_ANON_WITH_RC4_128_MD5	0x0018
#define SSL_DH_ANON_EXPORT_WITH_DES40_CBC_SHA	0x0019
#define SSL_DH_ANON_WITH_DES_CBC_SHA	0x001a
#define SSL_DH_ANON_WITH_3DES_EDE_CBC_SHA	0x001b
#define SSL_FORTEZZA_DMS_WITH_NULL_SHA	0x001c
#define SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA	0x001d
#define SSL_FORTEZZA_DMS_WITH_RC4_128_SHA	0x001e
#define TLS_RSA_WITH_AES_128_CBC_SHA	0x002F
#define TLS_DH_DSS_WITH_AES_128_CBC_SHA	0x0030
#define TLS_DH_RSA_WITH_AES_128_CBC_SHA	0x0031
#define TLS_DHE_DSS_WITH_AES_128_CBC_SHA	0x0032
#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA	0x0033
#define TLS_DH_ANON_WITH_AES_128_CBC_SHA	0x0034
#define TLS_RSA_WITH_AES_256_CBC_SHA	0x0035
#define TLS_DH_DSS_WITH_AES_256_CBC_SHA	0x0036
#define TLS_DH_RSA_WITH_AES_256_CBC_SHA	0x0037
#define TLS_DHE_DSS_WITH_AES_256_CBC_SHA	0x0038
#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA	0x0039
#define TLS_DH_ANON_WITH_AES_256_CBC_SHA	0x003A
#define TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA	0x0062
#define TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA	0x0063
#define TLS_RSA_EXPORT1024_WITH_RC4_56_SHA	0x0064
#define TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA	0x0065
#define TLS_DHE_DSS_WITH_RC4_128_SHA	0x0066
#define SSL_AT_MD5_WITH_RSA_ENCRYPTION	0x01
#define SSL_CK_RC4_128_WITH_MD5	0x01
#define SSL_CT_X509_CERTIFICATE	0x01
#define SSL_CK_RC4_128_EXPORT40_WITH_MD5	0x02
#define SSL_CK_RC2_128_CBC_WITH_MD5	0x03
#define SSL_LIBRARY_VERSION_3_0	0x0300
#define SSL_LIBRARY_VERSION_3_1_TLS	0x0301
#define SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5	0x04
#define SSL_CK_IDEA_128_CBC_WITH_MD5	0x05
#define SSL_CK_DES_64_CBC_WITH_MD5	0x06
#define SSL_CK_DES_192_EDE3_CBC_WITH_MD5	0x07
#define TLS_ECDH_ECDSA_WITH_NULL_SHA	0xC001
#define TLS_ECDH_ECDSA_WITH_RC4_128_SHA	0xC002
#define TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA	0xC003
#define TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA	0xC004
#define TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA	0xC005
#define TLS_ECDHE_ECDSA_WITH_NULL_SHA	0xC006
#define TLS_ECDHE_ECDSA_WITH_RC4_128_SHA	0xC007
#define TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA	0xC008
#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA	0xC009
#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA	0xC00A
#define TLS_ECDH_RSA_WITH_NULL_SHA	0xC00B
#define TLS_ECDH_RSA_WITH_RC4_128_SHA	0xC00C
#define TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA	0xC00D
#define TLS_ECDH_RSA_WITH_AES_128_CBC_SHA	0xC00E
#define TLS_ECDH_RSA_WITH_AES_256_CBC_SHA	0xC00F
#define TLS_ECDHE_RSA_WITH_NULL_SHA	0xC010
#define TLS_ECDHE_RSA_WITH_RC4_128_SHA	0xC011
#define TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA	0xC012
#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA	0xC013
#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA	0xC014
#define TLS_ECDH_anon_WITH_NULL_SHA	0xC015
#define TLS_ECDH_anon_WITH_RC4_128_SHA	0xC016
#define TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA	0xC017
#define TLS_ECDH_anon_WITH_AES_128_CBC_SHA	0xC018
#define TLS_ECDH_anon_WITH_AES_256_CBC_SHA	0xC019
#define SSL_RSA_FIPS_WITH_DES_CBC_SHA	0xfefe
#define SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA	0xfeff
#define SSL_RSA_OLDFIPS_WITH_3DES_EDE_CBC_SHA	0xffe0
#define SSL_RSA_OLDFIPS_WITH_DES_CBC_SHA	0xffe1
#define SSL_HL_CLIENT_FINISHED_HBYTES	1
#define SSL_HL_SERVER_FINISHED_HBYTES	1
#define SSL_HL_SERVER_VERIFY_HBYTES	1
#define SSL_MT_CLIENT_HELLO	1
#define SSL_HL_CLIENT_MASTER_KEY_HBYTES	10
#define SSL_HL_SERVER_HELLO_HBYTES	11
#define SSL_HL_REQUEST_CERTIFICATE_HBYTES	2
#define SSL_MT_CLIENT_MASTER_KEY	2
#define SSL_HL_ERROR_HBYTES	3
#define SSL_MT_CLIENT_FINISHED	3
#define SSL_MT_SERVER_HELLO	4
#define SSL_MT_SERVER_VERIFY	5
#define SSL_HL_CLIENT_CERTIFICATE_HBYTES	6
#define SSL_MT_SERVER_FINISHED	6
#define SSL_MT_REQUEST_CERTIFICATE	7
#define SSL_MT_CLIENT_CERTIFICATE	8
#define SSL_HL_CLIENT_HELLO_HBYTES	9</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63029"
>24.6.5. nss3/sslt.h</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __sslt_h_

typedef enum {
    ssl_kea_null,
    ssl_kea_rsa = 1,
    ssl_kea_dh = 2,
    ssl_kea_fortezza = 3,
    ssl_kea_ecdh = 4,
    ssl_kea_size = 5
} SSLKEAType;
typedef enum {
    ssl_sign_null,
    ssl_sign_rsa = 1,
    ssl_sign_dsa = 2,
    ssl_sign_ecdsa = 3
} SSLSignType;
typedef enum {
    ssl_auth_null,
    ssl_auth_rsa = 1,
    ssl_auth_dsa = 2,
    ssl_auth_kea = 3,
    ssl_auth_ecdsa = 4
} SSLAuthType;
typedef enum {
    ssl_calg_null,
    ssl_calg_rc4 = 1,
    ssl_calg_rc2 = 2,
    ssl_calg_des = 3,
    ssl_calg_3des = 4,
    ssl_calg_idea = 5,
    ssl_calg_fortezza = 6,
    ssl_calg_aes = 7,
    ssl_calg_camellia = 8
} SSLCipherAlgorithm;
typedef enum {
    ssl_mac_null,
    ssl_mac_md5 = 1,
    ssl_mac_sha = 2,
    ssl_hmac_md5 = 3,
    ssl_hmac_sha = 4
} SSLMACAlgorithm;
typedef struct SSLChannelInfoStr {
    PRUint32 length;
    PRUint16 protocolVersion;
    PRUint16 cipherSuite;
    PRUint32 authKeyBits;
    PRUint32 keaKeyBits;
    PRUint32 creationTime;
    PRUint32 lastAccessTime;
    PRUint32 expirationTime;
    PRUint32 sessionIDLength;
    PRUint8 sessionID[31];
} SSLChannelInfo;
typedef struct SSLCipherSuiteInfoStr {
    PRUint16 length;
    PRUint16 cipherSuite;
    const char *cipherSuiteName;
    const char *authAlgorithmName;
    SSLAuthType authAlgorithm;
    const char *keaTypeName;
    SSLKEAType keaType;
    const char *symCipherName;
    SSLCipherAlgorithm symCipher;
    PRUint16 symKeyBits;
    PRUint16 symKeySpace;
    PRUint16 effectiveKeyBits;
    const char *macAlgorithmName;
    SSLMACAlgorithm macAlgorithm;
    PRUint16 macBits;
    PRUintn isFIPS:1;
    PRUintn isExportable:1;
    PRUintn nonStandard:1;
    PRUintn reservedBits:29;
} SSLCipherSuiteInfo;</PRE
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="PART"
><A
NAME="PACKAGEFMT"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>XI. Package Format and Installation</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>25. <A
HREF="#SWINSTALL"
>Software Installation</A
></DT
><DD
><DL
><DT
>25.1. <A
HREF="#SWINSTALL-INTRO"
>Introduction</A
></DT
><DT
>25.2. <A
HREF="#PKGFORMAT"
>Package File Format</A
></DT
><DD
><DL
><DT
>25.2.1. <A
HREF="#AEN63069"
>Lead Section</A
></DT
><DT
>25.2.2. <A
HREF="#AEN63120"
>Header Structure</A
></DT
><DT
>25.2.3. <A
HREF="#AEN63358"
>Signature Section</A
></DT
><DT
>25.2.4. <A
HREF="#AEN63524"
>Header Section</A
></DT
><DT
>25.2.5. <A
HREF="#AEN64809"
>Payload Section</A
></DT
></DL
></DD
><DT
>25.3. <A
HREF="#PKGSCRIPTS"
>Package Script Restrictions</A
></DT
><DT
>25.4. <A
HREF="#PKGTOOLS"
>Package Tools</A
></DT
><DT
>25.5. <A
HREF="#PKGNAMECONV"
>Package Naming Conventions</A
></DT
><DT
>25.6. <A
HREF="#PKGDEPEND"
>Package Dependencies</A
></DT
><DT
>25.7. <A
HREF="#PKGARCHCON"
>Package Architecture Considerations</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SWINSTALL"
></A
>Chapter 25. Software Installation</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="SWINSTALL-INTRO"
>25.1. Introduction</A
></H2
><P
>Applications shall either be packaged in the RPM packaging format as
defined in this specification, or supply an installer which is LSB
conforming (for example, calls LSB commands and utilities).
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Supplying an RPM format package is encouraged because it makes systems
easier to manage.  
This specification does not require the implementation to use
RPM as the package manager; it only specifies the format of
the package file and requires that implementations must have some method
of installing conforming packages.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Applications are also encouraged to uninstall cleanly.</P
></BLOCKQUOTE
></DIV
></P
><P
>A package in the RPM format may include a dependency on the LSB Core and other
LSB specifications, as described in <A
HREF="#PKGDEPEND"
>Section 25.6</A
>.
Packages that are not in the RPM format may test for the presence of 
a conforming implementation by means of
the <B
CLASS="COMMAND"
>lsb_release</B
> utility.</P
><P
>Implementations shall provide a mechanism for installing applications in
the RPM packaging format with some restrictions listed below.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><A
NAME="PKG-2"
></A
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>The implementation itself may use a different packaging format for its
own packages, and may use any available mechanism for 
installing conforming packages, including translation into a different format.</P
></BLOCKQUOTE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGFORMAT"
>25.2. Package File Format</A
></H2
><P
>An RPM format file consists of 4 sections, the Lead, Signature, Header, and
the Payload. All values are stored in network byte order.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63052"
></A
><P
><B
>Table 25-1. RPM File Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Lead</TD
></TR
><TR
><TD
>Signature</TD
></TR
><TR
><TD
>Header</TD
></TR
><TR
><TD
>Payload</TD
></TR
></TBODY
></TABLE
></DIV
><P
>These 4 sections shall exist in the order specified. </P
><P
>The lead section is used to identify the package file.</P
><P
>The signature section is used to verify the integrity, and optionally, the
authenticity of the majority of the package file.</P
><P
>The header section contains all available information about the package. Entries
such as the package's name, version, and file list, are contained in the header.</P
><P
>The payload section holds the files to be installed.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63069"
>25.2.1. Lead Section</A
></H3
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct rpmlead {
    unsigned char magic[4];
    unsigned char major, minor;
    short type;
    short archnum;
    char name[66];
    short osnum;
    short signature_type;
    char reserved[16];
} ;</PRE
></TD
></TR
></TABLE
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63074"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>magic</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this file as an RPM format file. This value shall be
<TT
CLASS="LITERAL"
>"\355\253\356\333"</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63080"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>major</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the major version number of the file format version. This
value shall be 3.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63085"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>minor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the minor revision number of file format version. This value
shall be 0.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63090"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>type</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating whether this is a source or binary package.
This value shall be 0 to indicate a binary package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63095"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>archnum</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the architecture for which this package is valid. This value
is specified in the relevant architecture specific part of the LSB Core Specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63100"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>name</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A NUL terminated string that provides the package name. This name shall
conform with the Package Naming Conventions section of this specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63105"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>osnum</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the Operating System for which this package is valid. This
value shall be 1.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63110"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>signature_type</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value indicating the type of the signature used in the Signature part of the
file. This value shall be 5.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63115"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>reserved</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Reserved space. The value is undefined.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63120"
>25.2.2. Header Structure</A
></H3
><P
>The Header structure is used for both the Signature and Header Sections. A
Header Structure consists of 3 parts, a Header record, followed by 1 or more
Index records, followed by 0 or more bytes of data associated with the Index
records. A Header structure shall be aligned to an 8 byte boundary.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63123"
></A
><P
><B
>Table 25-2. Signature Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>Header Record</TD
></TR
><TR
><TD
>Array of Index Records</TD
></TR
><TR
><TD
>Store of Index Values</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN63133"
>25.2.2.1. Header Record</A
></H4
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct rpmheader {
    unsigned char magic[4];
    unsigned char reserved[4];
    int nindex;
    int hsize;
};</PRE
></TD
></TR
></TABLE
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63138"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>magic</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this record as an RPM header record. This value shall be
<TT
CLASS="LITERAL"
>"\216\255\350\001"</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63144"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>reserved</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Reserved space.  This value shall be <TT
CLASS="LITERAL"
>"\000\000\000\000"</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63150"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>nindex</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The number of Index Records that follow this Header Record. There should be at
least 1 Index Record.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63155"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>hsize</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The size in bytes of the storage area for the data pointed to by the
Index Records.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN63160"
>25.2.2.2. Index Record</A
></H4
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct rpmhdrindex {
    int tag;
    int type;
    int offset;
    int count;
};</PRE
></TD
></TR
></TABLE
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63165"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>tag</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the purpose of the data associated with this Index Record.
The value of this field is dependent on the context in which the Index Record
is used, and is defined below and in later sections.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63170"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>type</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the type of the data associated with this Index Record. The
possible <CODE
CLASS="STRUCTFIELD"
>type</CODE
> values are defined below.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63176"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>offset</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Location in the Store of the data associated with this Index Record. This value
should between 0 and the value contained in the <CODE
CLASS="STRUCTFIELD"
>hsize</CODE
>
of the Header Structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63182"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>count</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Size of the data associated with this Index Record. The
<CODE
CLASS="STRUCTFIELD"
>count</CODE
> is the number of elements whose size is
defined by the type of this Record.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN63188"
>25.2.2.2.1. Index Type Values</A
></H5
><P
>The possible values for the <CODE
CLASS="STRUCTFIELD"
>type</CODE
> field are defined
in this table.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63192"
></A
><P
><B
>Table 25-3. Index Type values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Type</TH
><TH
>Value</TH
><TH
>Size (in bytes)</TH
><TH
>Alignment</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_NULL_TYPE</CODE
></TD
><TD
>0</TD
><TD
>Not Implemented.</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_CHAR_TYPE</CODE
></TD
><TD
>1</TD
><TD
>1</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT8_TYPE</CODE
></TD
><TD
>2</TD
><TD
>1</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT16_TYPE</CODE
></TD
><TD
>3</TD
><TD
>2</TD
><TD
>2</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT32_TYPE</CODE
></TD
><TD
>4</TD
><TD
>4</TD
><TD
>4</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_INT64_TYPE</CODE
></TD
><TD
>5</TD
><TD
>Reserved.</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_STRING_TYPE</CODE
></TD
><TD
>6</TD
><TD
>variable, NUL terminated</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_BIN_TYPE</CODE
></TD
><TD
>7</TD
><TD
>1</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_STRING_ARRAY_TYPE</CODE
></TD
><TD
>8</TD
><TD
>Variable, sequence of NUL terminated strings</TD
><TD
>1</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
></TD
><TD
>9</TD
><TD
>variable, sequence of NUL terminated strings</TD
><TD
>1</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The string arrays specified for entries of type
<CODE
CLASS="CONSTANT"
>RPM_STRING_ARRAY_TYPE</CODE
> and
<CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
>
are vectors of strings in a contiguous block of memory, each element separated
from its neighbors by a NUL character.</P
><P
>Index records with type <CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
> shall always
have a <CODE
CLASS="STRUCTFIELD"
>count</CODE
> of 1. The array entries in an index of
type <CODE
CLASS="CONSTANT"
>RPM_I18NSTRING_TYPE</CODE
> correspond to the locale names
contained in the <CODE
CLASS="CONSTANT"
>RPMTAG_HDRI18NTABLE</CODE
> index.</P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN63270"
>25.2.2.2.2. Index Tag Values</A
></H5
><P
>Some values are designated as header private, and may appear in any header
structure. These are defined here. Additional values are defined in later
sections.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63273"
></A
><P
><B
>Table 25-4. Header Private Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERSIGNATURES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>62</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>16</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERIMMUTABLE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>63</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>16</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERI18NTABLE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>100</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERSIGNATURES</CODE
></DT
><DD
><P
>The signature tag differentiates a signature header from a metadata header, and identifies the original contents of the signature header.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERIMMUTABLE</CODE
></DT
><DD
><P
>This tag contains an index record which specifies the portion of the Header Record which was used for the calculation of a signature. This data shall be preserved or any header-only signature will be invalidated.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_HEADERI18NTABLE</CODE
></DT
><DD
><P
>Contains a list of locales for which strings are provided in other parts of the package.</P
></DD
></DL
></DIV
><P
>Not all Index records defined here will be present in all packages. Each tag
value has a status which is defined here.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63331"
></A
><SPAN
STYLE="white-space: nowrap"
>Required</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record shall be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63335"
></A
><SPAN
STYLE="white-space: nowrap"
>Optional</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record may be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63339"
></A
><SPAN
STYLE="white-space: nowrap"
>Informational</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record may be present, but does not contribute to the processing of the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63343"
></A
><SPAN
STYLE="white-space: nowrap"
>Deprecated</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record should not be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63347"
></A
><SPAN
STYLE="white-space: nowrap"
>Obsolete</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record shall not be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63351"
></A
><SPAN
STYLE="white-space: nowrap"
>Reserved</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This Index Record shall not be present.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN63355"
>25.2.2.3. Header Store</A
></H4
><P
>The header store contains the values specified by the Index structures. These
values are aligned according to their type and padding is used if needed. The
store is located immediately following the Index structures.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63358"
>25.2.3. Signature Section</A
></H3
><P
>The Signature section is implemented using the Header structure. The signature
section defines the following additional tag values which may be used in
the Index structures.</P
><P
>These values exist to provide additional information about the rest of the
package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63362"
></A
><P
><B
>Table 25-5. Signature Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SIZE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1000</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PAYLOADSIZE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1007</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SIZE</CODE
></DT
><DD
><P
>This tag specifies the combined size of the Header and Payload sections.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PAYLOADSIZE</CODE
></DT
><DD
><P
>This tag specifies the uncompressed size of the Payload archive, including the cpio headers.</P
></DD
></DL
></DIV
><P
>These values exist to ensure the integrity of the rest of the package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63405"
></A
><P
><B
>Table 25-6. Signature Digest Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SHA1</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>269</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_MD5</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1004</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>16</TT
></TD
><TD
>Required</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63437"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_SHA1</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This index contains the SHA1 checksum of the entire Header Section, including the Header Record, Index Records and Header store.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63442"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_MD5</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the 128-bit MD5 checksum of the combined Header and Archive sections.</P
></TD
></TR
></TBODY
></TABLE
><P
>These values exist to provide authentication of the package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63448"
></A
><P
><B
>Table 25-7. Signature Signing Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_DSA</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>267</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>65</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_RSA</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>268</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PGP</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1002</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_GPG</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1005</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>BIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>65</TT
></TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63500"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_DSA</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tag contains the DSA signature of the Header section. The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>. If this tag is present, then the SIGTAG_GPG tag shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63506"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_RSA</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tag contains the RSA signature of the Header section.The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>. If this tag is present, then the SIGTAG_PGP shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63512"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_PGP</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the RSA signature of the combined Header and Payload sections. The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63518"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMSIGTAG_GPG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tag contains the DSA signature of the combined Header and Payload sections. The data is formatted as a Version 3 Signature Packet as specified in <A
HREF="#STD.RFC2440"
>RFC 2440: OpenPGP Message Format</A
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN63524"
>25.2.4. Header Section</A
></H3
><P
>The Header section is implemented using the Header structure. The Header
section defines the following additional tag values which may be used in
the Index structures.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN63527"
>25.2.4.1. Package Information</A
></H4
><P
>The following tag values are used to indicate information that describes the
package as a whole.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63530"
></A
><P
><B
>Table 25-8. Package Info Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_NAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1000</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_VERSION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1001</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_RELEASE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1002</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_SUMMARY</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1004</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>I18NSTRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DESCRIPTION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1005</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>I18NSTRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_SIZE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1009</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTRIBUTION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1010</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_VENDOR</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1011</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_LICENSE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1014</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PACKAGER</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1015</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_GROUP</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1016</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>I18NSTRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_URL</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1020</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1021</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCH</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1022</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_SOURCERPM</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1044</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCHIVESIZE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1046</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_RPMVERSION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1064</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_COOKIE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1094</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTURL</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1123</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFORMAT</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1124</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADCOMPRESSOR</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1125</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1126</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_NAME</CODE
></DT
><DD
><P
>This tag specifies the name of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_VERSION</CODE
></DT
><DD
><P
>This tag specifies the version of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_RELEASE</CODE
></DT
><DD
><P
>This tag specifies the release of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_SUMMARY</CODE
></DT
><DD
><P
>This tag specifies the summary description of the package. The summary value pointed to by this index record contains a one line description of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_DESCRIPTION</CODE
></DT
><DD
><P
>This tag specifies the description of the package. The description value pointed to by this index record contains a full desription of the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_SIZE</CODE
></DT
><DD
><P
>This tag specifies the sum of the sizes of the regular files in the archive.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTRIBUTION</CODE
></DT
><DD
><P
>A string containing the name of the distribution on which the package was built.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_VENDOR</CODE
></DT
><DD
><P
>A string containing the name of the organization that produced the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_LICENSE</CODE
></DT
><DD
><P
>This tag specifies the license which applies to this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PACKAGER</CODE
></DT
><DD
><P
>A string identifying the tool used to build the package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_GROUP</CODE
></DT
><DD
><P
>This tag specifies the administrative group to which this package belongs.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_URL</CODE
></DT
><DD
><P
>Generic package information URL.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OS</CODE
></DT
><DD
><P
>This tag specifies the OS of the package. The OS value pointed to by this index record shall be "linux".</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCH</CODE
></DT
><DD
><P
>This tag specifies the architecture of the package. The architecture value pointed to by this index record is defined in architecture specific LSB specification.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_SOURCERPM</CODE
></DT
><DD
><P
>This tag specifies the name of the source RPM.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_ARCHIVESIZE</CODE
></DT
><DD
><P
>This tag specifies the uncompressed size of the Payload archive, including the cpio headers.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_RPMVERSION</CODE
></DT
><DD
><P
>This tag indicates the version of RPM tool used to build this package. The value is unused.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_COOKIE</CODE
></DT
><DD
><P
>This tag contains an opaque string whose contents are undefined.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_DISTURL</CODE
></DT
><DD
><P
>URL for package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFORMAT</CODE
></DT
><DD
><P
>This tag specifies the format of the Archive section. The format value pointed to by this index record shall be 'cpio'.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADCOMPRESSOR</CODE
></DT
><DD
><P
>This tag specifies the compression used on the Archive section. The compression value pointed to by this index record shall be 'gzip'.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PAYLOADFLAGS</CODE
></DT
><DD
><P
>This tag indicates the compression level used for the Payload. This value shall always be '9'.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN63872"
>25.2.4.2. Installation Information</A
></H4
><P
>The following tag values are used to provide information needed during the
installation of the package.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN63875"
></A
><P
><B
>Table 25-9. Installation Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1023</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTIN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1024</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1025</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1026</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREINPROG</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1085</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTINPROG</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1086</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUNPROG</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1087</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUNPROG</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1088</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63967"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREIN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the preinstall scriptlet. If present, then RPMTAG_PREINPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63972"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTIN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the postinstall scriptlet. If present, then RPMTAG_POSTINPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63977"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>his tag specifies the preuninstall scriptlet. If present, then RPMTAG_PREUNPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63982"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUN</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specified the postuninstall scriptlet. If present, then RPMTAG_POSTUNPROG shall also be present.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63987"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREINPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the name of the intepreter to which the preinstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63993"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTINPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the name of the intepreter to which the postinstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN63999"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_PREUNPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the name of the intepreter to which the preuninstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64005"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_POSTUNPROG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This program specifies the name of the intepreter to which the postuninstall scriptlet will be passed. The intepreter pointed to by this index record shall be <TT
CLASS="FILENAME"
>/bin/sh</TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN64011"
>25.2.4.3. File Information</A
></H4
><P
>The following tag values are used to provide information about the files
in the payload. This information is provided in the header to allow more
efficient access of the information.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN64014"
></A
><P
><B
>Table 25-10. File Info Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OLDFILENAMES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1027</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILESIZES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1028</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMODES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1030</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT16</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILERDEVS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1033</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT16</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMTIMES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1034</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMD5S</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1035</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELINKTOS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1036</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1037</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEUSERNAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1039</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEGROUPNAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1040</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1095</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEINODES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1096</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELANGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1097</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1116</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_BASENAMES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1117</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRNAMES</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1118</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64170"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_OLDFILENAMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the filenames when not in a compressed format as determined by the absence of rpmlib(CompressedFileNames) in the RPMTAG_REQUIRENAME index.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64175"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILESIZES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the size of each file in the archive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64180"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMODES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the mode of each file in the archive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64185"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILERDEVS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the device number from which the file was copied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64190"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMTIMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the modification time in seconds since the epoch of each file in the archive.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64195"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEMD5S</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the ASCII representation of the MD5 sum of the corresponding file contents. This value is empty if the corresponding archive entry is not a regular file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64200"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELINKTOS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The target for a symlink, otherwise NULL.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64205"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEFLAGS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the bit(s) to classify and control how files are to be installed. See below.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64210"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEUSERNAME</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the owner of the corresponding file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64215"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEGROUPNAME</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the group of the corresponding file.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64220"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the 16 bit device number from which the file was copied.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64225"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEINODES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the inode value from the original file system on the the system on which it was built.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64230"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_FILELANGS</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies a per-file locale marker used to install only locale specific subsets of files when the package is installed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64235"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the index into the array provided by the RPMTAG_DIRNAMES Index which contains the directory name for the corresponding filename.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64240"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_BASENAMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This tag specifies the base portion of the corresponding filename.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64245"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMTAG_DIRNAMES</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
></TBODY
></TABLE
><P
>One of <CODE
CLASS="CONSTANT"
>RPMTAG_OLDFILENAMES</CODE
> or the tuple
<CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES,RPMTAG_BASENAMES,RPMTAG_DIRNAMES</CODE
> shall be present, but not
both.</P
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN64253"
>25.2.4.3.1. File Flags</A
></H5
><P
>The <CODE
CLASS="CONSTANT"
>RPMTAG_FILEFLAGS</CODE
> tag value shall identify 
various characteristics of the file in the payload that it describes. It
shall be an
<SPAN
CLASS="TYPE"
>INT32</SPAN
> value consisting of either the
value <CODE
CLASS="CONSTANT"
>RPMFILE_NONE</CODE
> (0) or the bitwise inclusive or of one
or more of the following values:
<DIV
CLASS="TABLE"
><A
NAME="AEN64259"
></A
><P
><B
>Table 25-11. File Flags</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_CONFIG</CODE
></TD
><TD
>(1 &#60;&#60; 0)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_DOC</CODE
></TD
><TD
>(1 &#60;&#60; 1)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_DONOTUSE</CODE
></TD
><TD
>(1 &#60;&#60; 2)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_MISSINGOK</CODE
></TD
><TD
>(1 &#60;&#60; 3)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_NOREPLACE</CODE
></TD
><TD
>(1 &#60;&#60; 4)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_SPECFILE</CODE
></TD
><TD
>(1 &#60;&#60; 5)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_GHOST</CODE
></TD
><TD
>(1 &#60;&#60; 6)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_LICENSE</CODE
></TD
><TD
>(1 &#60;&#60; 7)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_README</CODE
></TD
><TD
>(1 &#60;&#60; 8)</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMFILE_EXCLUDE</CODE
></TD
><TD
>(1 &#60;&#60; 9)</TD
></TR
></TBODY
></TABLE
></DIV
></P
><P
>These bits have the following meaning:
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64309"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_CONFIG</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is a configuration file, and an existing file should be saved during
a package upgrade operation and not removed during a pakage removal operation.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64314"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_DOC</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file contains documentation.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64319"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_DONOTUSE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This value is reserved for future use; conforming
packages may not use this flag.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64324"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_MISSINGOK</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file need not exist on the installed system.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64329"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_NOREPLACE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Similar to the <CODE
CLASS="CONSTANT"
>RPMFILE_CONFIG</CODE
>, this
flag indicates that during an upgrade operation the original
file on the system should not be altered.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64335"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_SPECFILE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is a package specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64340"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_GHOST</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file is not actually included in the payload, but
should still be considered as a part of the package. 
For example, a log file
generated by the application at run time.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64345"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_LICENSE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file contains the license conditions.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64350"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_README</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The file contains high level notes about the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64355"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="CONSTANT"
>RPMFILE_EXCLUDE</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The corresponding file is not a part of the package,
and should not be installed.</P
></TD
></TR
></TBODY
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN64360"
>25.2.4.4. Dependency Information</A
></H4
><P
>The following tag values are used to provide information about
interdependencies between packages.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN64363"
></A
><P
><B
>Table 25-12. Package Dependency Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDENAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1047</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1048</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIRENAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1049</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREVERSION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1050</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1053</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTNAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1054</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTVERSION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1055</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETENAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1090</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1112</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEVERSION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1113</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Required</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1114</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEVERSION</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1115</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDENAME</CODE
></DT
><DD
><P
>This tag indicates the name of the dependency provided by this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the dependency range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIRENAME</CODE
></DT
><DD
><P
>This tag indicates the dependencies for this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_REQUIREVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_REQUIRENAME Index.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the conflict range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTNAME</CODE
></DT
><DD
><P
>This tag indicates the conflicting dependencies for this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CONFLICTVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_CONFLICTNAME Index.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETENAME</CODE
></DT
><DD
><P
>This tag indicates the obsoleted dependencies for this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the conflict range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDEVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_PROVIDENAME Index.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEFLAGS</CODE
></DT
><DD
><P
>Bits(s) to specify the conflict range and context.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETEVERSION</CODE
></DT
><DD
><P
>This tag indicates the versions associated with the values found in the RPMTAG_OBSOLETENAME Index.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN64545"
>25.2.4.4.1. Package Dependency Values</A
></H5
><P
>The package dependencies are stored in the
<CODE
CLASS="VARNAME"
>RPMTAG_REQUIRENAME</CODE
> and
<CODE
CLASS="VARNAME"
>RPMTAG_REQUIREVERSION</CODE
>
index records. The following values may be used.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN64550"
></A
><P
><B
>Table 25-13. Index Type values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Version</TH
><TH
>Meaning</TH
><TH
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
>rpmlib(VersionedDependencies)</TD
><TD
>3.0.3-1</TD
><TD
>Indicates that the package contains <CODE
CLASS="CONSTANT"
>RPMTAG_PROVIDENAME</CODE
>,
<CODE
CLASS="CONSTANT"
>RPMTAG_OBSOLETENAME</CODE
> or 
<CODE
CLASS="CONSTANT"
>RPMTAG_PREREQ</CODE
> records that have a version associated
with them.</TD
><TD
>Optional</TD
></TR
><TR
><TD
>rpmlib(PayloadFilesHavePrefix)</TD
><TD
>4.0-1</TD
><TD
>Indicates the filenames in the Archive have had "." prepended to them.</TD
><TD
>Optional</TD
></TR
><TR
><TD
>rpmlib(CompressedFileNames)</TD
><TD
>3.0.4-1</TD
><TD
>Indicates that the filenames in the Payload are represented in the
<CODE
CLASS="CONSTANT"
>RPMTAG_DIRINDEXES</CODE
>, 
<CODE
CLASS="CONSTANT"
>RPMTAG_DIRNAME</CODE
> and 
<CODE
CLASS="CONSTANT"
>RPMTAG_BASENAMES</CODE
> indexes.</TD
><TD
>Optional</TD
></TR
><TR
><TD
><B
CLASS="COMMAND"
>/bin/sh</B
></TD
><TD
>&nbsp;</TD
><TD
>Interpreter usually required for installation scripts.</TD
><TD
>Optional</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Additional dependencies are specified in the Package Dependencies section of
this specification, and in the relevant architecture specific part of the LSB Core Specification.</P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN64588"
>25.2.4.4.2. Package Dependencies Attributes</A
></H5
><P
>The package dependency attributes are stored in the
<CODE
CLASS="VARNAME"
>RPMTAG_REQUIREFLAGS</CODE
>,
<CODE
CLASS="VARNAME"
>RPMTAG_PROVIDEFLAGS</CODE
> and
<CODE
CLASS="VARNAME"
>RPMTAG_OBSOLETEFLAGS</CODE
>
index records. The following values may be used.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN64594"
></A
><P
><B
>Table 25-14. Package Dependency Attributes</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Name</TH
><TH
>Value</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_LESS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x02</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_GREATER</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x04</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_EQUAL</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x08</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_PREREQ</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x40</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_INTERP</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x100</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_PRE</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x200</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_POST</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x400</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_PREUN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x800</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_SCRIPT_POSTUN</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x1000</TT
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMSENSE_RPMLIB</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>0x1000000</TT
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN64663"
>25.2.4.5. Other Information</A
></H4
><P
>The following tag values are also found in the Header section.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN64666"
></A
><P
><B
>Table 25-15. Other Tag Values</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
>Name</TH
><TH
ALIGN="CENTER"
>Tag Value</TH
><TH
ALIGN="CENTER"
>Type</TH
><TH
ALIGN="CENTER"
>Count</TH
><TH
ALIGN="CENTER"
>Status</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDTIME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1006</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDHOST</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1007</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEVERIFYFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1045</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTIME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1080</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>INT32</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGNAME</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1081</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTEXT</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1082</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING_ARRAY</CODE
></TD
><TD
></TD
><TD
>Optional</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_OPTFLAGS</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1122</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_RHNPLATFORM</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1131</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Deprecated</TD
></TR
><TR
><TD
><CODE
CLASS="CONSTANT"
>RPMTAG_PLATFORM</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1132</TT
></TD
><TD
><CODE
CLASS="CONSTANT"
>STRING</CODE
></TD
><TD
><TT
CLASS="LITERAL"
>1</TT
></TD
><TD
>Informational</TD
></TR
></TBODY
></TABLE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDTIME</CODE
></DT
><DD
><P
>This tag specifies the time as seconds since the epoch at which the package was built.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_BUILDHOST</CODE
></DT
><DD
><P
>This tag specifies the hostname of the system on which which the package was built.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_FILEVERIFYFLAGS</CODE
></DT
><DD
><P
>This tag specifies the bit(s) to control how files are to be verified after install, specifying which checks should be performed.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTIME</CODE
></DT
><DD
><P
>This tag specifies the Unix time in seconds since the epoch associated with each entry in the Changelog file.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGNAME</CODE
></DT
><DD
><P
>This tag specifies the name of who made a change to this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_CHANGELOGTEXT</CODE
></DT
><DD
><P
>This tag specifies the changes asssociated with a changelog entry.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_OPTFLAGS</CODE
></DT
><DD
><P
>This tag indicates additional flags which may have been passed to the compiler when building this package.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_RHNPLATFORM</CODE
></DT
><DD
><P
>This tag contains an opaque string whose contents are undefined.</P
></DD
><DT
><CODE
CLASS="CONSTANT"
>RPMTAG_PLATFORM</CODE
></DT
><DD
><P
>This tag contains an opaque string whose contents are undefined.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN64809"
>25.2.5. Payload Section</A
></H3
><P
>The Payload section contains a compressed cpio archive. The format of this
section is defined by <A
HREF="#STD.RFC1952"
>RFC 1952: GZIP File Format Specification</A
>.</P
><P
>When uncompressed, the cpio archive contains a sequence of records for each
file. Each record contains a CPIO Header, Filename, Padding, and File Data.</P
><DIV
CLASS="TABLE"
><A
NAME="AEN64814"
></A
><P
><B
>Table 25-16. CPIO File Format</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>CPIO Header</TD
><TD
>Header structure as defined below.</TD
></TR
><TR
><TD
>Filename</TD
><TD
>NUL terminated ASCII string containing the name of the file.</TD
></TR
><TR
><TD
>Padding</TD
><TD
>0-3 bytes as needed to align the file stream to a 4 byte boundary.</TD
></TR
><TR
><TD
>File data</TD
><TD
>The contents of the file.</TD
></TR
><TR
><TD
>Padding</TD
><TD
>0-3 bytes as needed to align the file stream to a 4 byte boundary.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>The CPIO Header uses the following header structure (sometimes referred to
as "new ASCII" or "SVR4 cpio"). All numbers are stored as ASCII
representations of their hexadecimal value with leading zeros as needed to fill
the field.  With the exception of <CODE
CLASS="STRUCTFIELD"
>c_namesize</CODE
>
and the corresponding name string, and <CODE
CLASS="STRUCTFIELD"
>c_checksum</CODE
>,
all information contained in the CPIO Header is also represented in the
Header Section.
The values in the CPIO Header shall match the values contained in the
Header Section.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct {
    char c_magic[6];
    char c_ino[8];
    char c_mode[8];
    char c_uid[8];
    char c_gid[8];
    char c_nlink[8];
    char c_mtime[8];
    char c_filesize[8];
    char c_devmajor[8];
    char c_devminor[8];
    char c_rdevmajor[8];
    char c_rdevminor[8];
    char c_namesize[8];
    char c_checksum[8];
};</PRE
></TD
></TR
></TABLE
><P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64839"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_magic</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this cpio format. This value shall be <TT
CLASS="LITERAL"
>"070701"</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64845"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_ino</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This field contains the inode number from the filesystem from which the
file was read.
This field is ignored when installing a package.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEINODES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64851"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_mode</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Permission bits of the file. This is an ascii representation of the hexadecimal
number representing the bit as defined for the
<CODE
CLASS="STRUCTFIELD"
>st_mode</CODE
> field of the <TT
CLASS="STRUCTNAME"
>stat</TT
>
structure defined for the <CODE
CLASS="VARNAME"
>stat</CODE
> function.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEMODES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64860"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_uid</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this owner of this file.
This value matches the uid value of the corresponding user in the
RPMTAG_FILEUSERNAME as found on the system where this package was built. The
username specified in RPMTAG_FILEUSERNAME should take precedence when
installing the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64865"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_gid</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying this group of this file.
This value matches the gid value of the corresponding user in the
RPMTAG_FILEGROUPNAME as found on the system where this package was built. The
groupname specified in RPMTAG_FILEGROUPNAME should take precedence when
installing the package.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64870"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_nlink</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the number of links associated with this file. If the value
is greater than 1, then this filename will be linked to 1 or more files in this
archive that has a matching value for the c_ino, c_devmajor and c_devminor
fields.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64875"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_mtime</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the modification time of the file when it was read.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEMTIMES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64881"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_filesize</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the size of the file.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILESIZES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64887"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_devmajor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The major number of the device containing the file system from which the
file was read.
With the exception of processing files with c_nlink &#62;1, this field is ignored
when installing a package.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64893"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_devminor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The minor number of the device containing the file system from which the
file was read.
With the exception of processing files with c_nlink &#62;1, this field is ignored
when installing a package.
This field shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_FILEDEVICES</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64899"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_rdevmajor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The major number of the raw device containing the file system from which the
file was read.
This field is ignored when installing a package.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_RDEVS</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64905"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_rdevminor</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The minor number of the raw device containing the file system from which the
file was read.
This field is ignored when installing a package.
This field  shall match the corresponding value in the
<CODE
CLASS="CONSTANT"
>RPMTAG_RDEVS</CODE
> index in the Header section.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64911"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_namesize</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value identifying the length of the filename, which is located immediately
following the CPIO Header structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64916"
></A
><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="STRUCTFIELD"
>c_checksum</CODE
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Value containing the CRC checksum of the file data. This field is not used,
and shall contain the value "00000000".
This field is ignored when installing a package.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>A record with the filename "TRAILER!!!" indicates the last record in the
archive.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGSCRIPTS"
>25.3. Package Script Restrictions</A
></H2
><P
>Scripts used as part of the package install and uninstall shall only use
commands and interfaces that are specified by the LSB. All other commands are
not guaranteed to be present, or to behave in expected ways.</P
><P
>Packages shall not use RPM triggers.</P
><P
>Packages shall not depend on the order in which scripts are executed
(pre-install, pre-uninstall, etc), when doing an upgrade.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGTOOLS"
>25.4. Package Tools</A
></H2
><P
>The LSB does not specify the interface to the tools used to manipulate 
LSB-conformant packages. Each conforming implementation shall provide 
documentation for installing LSB packages.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGNAMECONV"
>25.5. Package Naming Conventions</A
></H2
><P
>Packages supplied by distributions and applications should adhere to the
following conventions for the name field within the package.  The rules
are optional for the filename of the package file itself.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>There are discrepancies among implementations
concerning whether the name might be <TT
CLASS="LITERAL"
>frobnicator-1.7-21-ppc32.rpm</TT
> or
<TT
CLASS="LITERAL"
>frobnicator-1.7-21-powerpc32.rpm</TT
>.  
The architecture aside, recommended
practice is for the filename of the package file to match the name
within the package.</P
></BLOCKQUOTE
></DIV
></P
><P
>The following conventions apply to the name portion of the field alone, 
not including any release or version portion.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If the package name with the release and version is 
<TT
CLASS="LITERAL"
>frobnicator-1.7-21</TT
>, the name part is
<TT
CLASS="LITERAL"
>frobnicator</TT
> and falls under the conventions 
for a name with no hyphens.</P
></BLOCKQUOTE
></DIV
></P
><P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>If the name begins with <TT
CLASS="LITERAL"
>lsb-</TT
> and contains no other hyphens,
the name should be a package name registered with the 
<A
HREF="http://www.lanana.org"
TARGET="_top"
>Linux Assigned Names and 
Numbers Authority</A
> (LANANA), which shall maintain a
registry of LSB names.
The name may be registered by either an implementation or an application.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>If the name begins with <TT
CLASS="LITERAL"
>lsb-</TT
> and
contains more than one hyphen the portion of the name between
the first and second hyphens should be either an LSB provider 
name registered with the LANANA
(for example <TT
CLASS="LITERAL"
>lsb-gnome-gnumeric</TT
> 
if <TT
CLASS="LITERAL"
>gnome</TT
> is registered), 
or a domain name registered to the provider in the DNS system.
(for example <TT
CLASS="LITERAL"
>lsb-distro.example.com-database</TT
>).
The LSB provider name registered
with the LANANA shall only consist of the ASCII characters <TT
CLASS="LITERAL"
>[a-z0-9]</TT
>.
The domain name, in accordance with DNS rules, shall be lower case only.
The provider name or domain name may be either that of a distribution
or an application.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Package names containing no hyphens are reserved for use by
distributions.  Applications shall not use such names.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Package names which do not start with <TT
CLASS="LITERAL"
>lsb-</TT
> and which contain a
hyphen are open to both distributions and applications.  Distributions
may name packages in any part of this namespace.  They are encouraged
to use names from one of the other namespaces available to them, but
this is not mandatory due to the large amount of current practice to
the contrary.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>Widespread existing practice includes such names as
<TT
CLASS="LITERAL"
>ssh-common</TT
>, <TT
CLASS="LITERAL"
>ssh-client</TT
>,
<TT
CLASS="LITERAL"
>kernel-pcmcia</TT
>, and the like.  Possible alternative names include
<TT
CLASS="LITERAL"
>sshcommon</TT
>, <TT
CLASS="LITERAL"
>foolinux-ssh-common</TT
>
(where <TT
CLASS="LITERAL"
>foolinux</TT
> is registered to the
distribution), or <TT
CLASS="LITERAL"
>lsb-foolinux-ssh-common</TT
>.</P
></BLOCKQUOTE
></DIV
>
Applications may name their packages this way, but only if the portion
of the name before the first hyphen is a provider name or registered
domain name as described above.
<DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
STYLE="color: #006600; background-color: #FFFFCC;"
><B
>Note: </B
>If an application vendor has domain name such as <TT
CLASS="LITERAL"
>visicalc.example.com</TT
> and has
registered <TT
CLASS="LITERAL"
>visicalc</TT
> as a provider name, 
they could name packages either in the
<TT
CLASS="LITERAL"
>visicalc-base</TT
> style or the
<TT
CLASS="LITERAL"
>visicalc.example.com-charting</TT
> style.</P
><P
STYLE="color: #006600; background-color: #FFFFCC;"
>Package names in this namespace are
available to both the distribution and an application.  Distributions
and applications need to consider the potential for conflicts
when deciding to use these names rather than the alternatives (such as
names starting with <TT
CLASS="LITERAL"
>lsb-</TT
>).</P
></BLOCKQUOTE
></DIV
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGDEPEND"
>25.6. Package Dependencies</A
></H2
><P
>Packages shall have a dependency that indicates which LSB modules are
required.
LSB module descriptions are dash seperated tuples containing the name 'lsb',
the module name, and the architecture name. The following dependencies may be
used.
<P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64980"
></A
><SPAN
STYLE="white-space: nowrap"
>lsb-core</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This dependency is used to indicate that the application is dependent
on features contained in the LSB Core specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64984"
></A
><SPAN
STYLE="white-space: nowrap"
>lsb-core-<TT
CLASS="REPLACEABLE"
><I
>arch</I
></TT
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This dependency is used to indicate that the application is dependent
on features contained in the LSB Core specification and that the
package contains architecture specific features.  This architecture
specific dependency is described in the relevant architecture specific
part of the LSB Core specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN64989"
></A
><SPAN
STYLE="white-space: nowrap"
>lsb-core-noarch</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This dependency is used to indicate that the application is dependent
on features contained in the LSB Core specification and that the package 
does not contain any architecture specific files.</P
></TD
></TR
></TBODY
></TABLE
></P
><P
>These dependencies shall have a version of 5.0.</P
><P
>Packages shall not depend on other system-provided dependencies.  They
shall not depend on non-system-provided dependencies unless 
the package provider also makes available the LSB conforming
packages needed to satisfy such dependencies.</P
><P
>Other modules in the LSB may supplement this list. The architecture
specific dependencies are described in the relevant architecture
specific LSB.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PKGARCHCON"
>25.7. Package Architecture Considerations</A
></H2
><P
>Packages which do not contain any architecture specific files should specify an
architecture of <TT
CLASS="LITERAL"
>noarch</TT
>. An LSB runtime
environment shall accept values <TT
CLASS="LITERAL"
>noarch</TT
>, or
the value specified in the relevant architecture specific part of the LSB Core Specification.</P
><P
>Additional specifications or restrictions may be found in the architecture
specific LSB specification.</P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="APP-A"
></A
>Appendix A. Alphabetical Listing of Interfaces by Library</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="APP-LIBC"
>A.1. libc</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LFS"
>Large File Support</A
> [LFS]</TD
></TR
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.RPC.XDR"
>RFC 5531/4506 RPC &#38; XDR</A
> [RPC + XDR]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV2"
>SUSv2</A
> [SUSv2]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
> [SUSv3]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> [SUSv4]</TD
></TR
><TR
><TD
><A
HREF="#STD.SVID.4"
>SVID Issue 4</A
> [SVID.4]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN65023"
></A
><P
><B
>Table A-1. libc Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Exit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>getdelim<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scandir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_IO_feof<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getdomainname<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>scandir64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>_IO_getc<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getdtablesize<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>scanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>_IO_putc<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getegid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_get_priority_max<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_IO_puts<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_get_priority_min<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__assert_fail<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>geteuid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_getaffinity(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__chk_fail(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_getparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__confstr_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_getscheduler<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__ctype_b_loc(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrent_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sched_rr_get_interval<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__ctype_get_mb_cur_max<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrgid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_setaffinity(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__ctype_tolower_loc(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrgid_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_setparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__ctype_toupper_loc(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrnam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_setscheduler<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__cxa_atexit<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrnam_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sched_yield<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__cxa_finalize<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgrouplist<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>seed48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__errno_location<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getgroups<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>seed48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fgets_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostbyaddr<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>seekdir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fgets_unlocked_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostbyaddr_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>select<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fgetws_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostbyname<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>semctl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fgetws_unlocked_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostbyname2<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>semget<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fpending<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostbyname2_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>semop<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostbyname_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>send<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fwprintf_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sendfile<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fxstat<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gethostname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sendfile64(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__fxstat64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getifaddrs(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sendmsg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fxstatat(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getitimer<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sendto<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fxstatat64(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getline<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setbuf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__getcwd_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getloadavg<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setbuffer<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__getgroups_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getlogin<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setcontext<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>__gethostname_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getlogin_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setegid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__getlogin_r_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getnameinfo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__getpagesize<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getopt<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>seteuid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__getpgid<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getopt_long<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setgid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__h_errno_location<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getopt_long_only<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setgrent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__isinf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpagesize<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setgroups<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__isinff<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpeername<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sethostname<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__isinfl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpgid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setitimer<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__isnan<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpgrp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setlocale<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__isnanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setlogmask<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__isnanl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getppid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setpgid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__libc_current_sigrtmax<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpriority<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setpgrp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__libc_current_sigrtmin<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getprotobyname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setpriority<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__libc_start_main<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getprotobyname_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setprotoent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__lxstat<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getprotobynumber<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setpwent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__lxstat64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getprotobynumber_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setregid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__mbsnrtowcs_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getprotoent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setreuid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__mbsrtowcs_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getprotoent_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setrlimit<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__mbstowcs_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpwent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setrlimit64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
></TR
><TR
><TD
>__memcpy_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpwent_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setservent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__memmove_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpwnam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setsid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__mempcpy<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpwnam_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setsockopt<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__mempcpy_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpwuid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setstate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__memset_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getpwuid_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setstate_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__pread64_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getrlimit<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setuid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__pread_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getrlimit64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>setutent<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__printf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getrusage<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setutxent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__rawmemchr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getservbyname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setvbuf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__read_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getservbyname_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>shmat<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__readlink_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getservbyport<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>shmctl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__realpath_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getservbyport_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>shmdt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__recv_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getservent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>shmget<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__recvfrom_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getservent_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>shutdown<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__register_atfork(GLIBC_2.3.2)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getsid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigaction<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__sigsetjmp<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getsockname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigaddset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__snprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getsockopt<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigaltstack<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__sprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getsubopt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigandset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__stack_chk_fail(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gettext<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigdelset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__stpcpy<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gettimeofday<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigemptyset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__stpcpy_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getuid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigfillset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__stpncpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getutent<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sighold<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strcat_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getutent_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigignore<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strcpy_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getutxent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>siginterrupt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strdup<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getutxid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigisemptyset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strncat_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getutxline<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigismember<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strncpy_chk(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getw<A
HREF="#STD.SUSV2"
>[SUSv2]</A
></TD
><TD
>siglongjmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strtod_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getwc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>signal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strtof_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getwc_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigorset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strtok_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getwchar<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigpause<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__strtol_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getwchar_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigpending<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strtold_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>getwd<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>sigprocmask<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strtoll_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>glob<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigqueue<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strtoul_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>glob64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigrelse<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__strtoull_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>globfree<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigreturn<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__swprintf_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>globfree64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__sysconf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gmtime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigsuspend<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__syslog_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gmtime_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigtimedwait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__sysv_signal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gnu_get_libc_release<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigwait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__ttyname_r_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gnu_get_libc_version<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigwaitinfo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vfprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>grantpt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sleep<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vfwprintf_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>hcreate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>snprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>hcreate_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sockatmark<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vsnprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>hdestroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>socket<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vsprintf_chk<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>hdestroy_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>socketpair<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vswprintf_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>hsearch<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vsyslog_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>hsearch_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>srand<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__vwprintf_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>htonl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>srand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcpcpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>htons<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>srand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcpncpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iconv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>srandom<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcrtomb_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iconv_close<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>srandom_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcscat_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iconv_open<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcscpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>if_freenameindex<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>statfs<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcsncat_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>if_indextoname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>statfs64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcsncpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>if_nameindex<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>statvfs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcsnrtombs_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>if_nametoindex<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>statvfs64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
></TR
><TR
><TD
>__wcsrtombs_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>imaxabs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>stime<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcstod_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>imaxdiv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>stpcpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcstof_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>index<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>stpncpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcstol_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inet_addr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strcasecmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcstold_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inet_aton<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strcasecmp_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wcstombs_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inet_ntoa<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strcasestr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__wcstoul_internal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inet_ntop<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strcat<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wctomb_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inet_pton<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strchr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wmemcpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>initgroups<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strcmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wmemmove_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>initstate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strcoll<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wmempcpy_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>initstate_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strcoll_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wmemset_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inotify_add_watch(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strcpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__wprintf_chk(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inotify_init(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strcspn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__xmknod<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inotify_rm_watch(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strdup<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__xmknodat(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>insque<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strerror<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__xpg_basename<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ioctl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>strerror_l(GLIBC_2.6)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__xpg_sigpause<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isalnum<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strerror_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>__xpg_strerror_r(GLIBC_2.3.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isalnum_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strfmon<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__xstat<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isalpha<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strfmon_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__xstat64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isalpha_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strftime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_exit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isascii<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strftime_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_longjmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isatty<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strlen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_setjmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isblank<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strncasecmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_tolower<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isblank_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strncasecmp_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_toupper<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iscntrl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strncat<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>a64l<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iscntrl_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strncmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>abort<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isdigit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strncpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>abs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isdigit_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strndup<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>accept<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isgraph<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strnlen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>access<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isgraph_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strpbrk<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acct<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>islower<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strptime<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>adjtime<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>islower_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strrchr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>alarm<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isprint<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strsep<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>alphasort<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isprint_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strsignal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>alphasort64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ispunct<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strspn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_add<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ispunct_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strstr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_add_sep<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isspace<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtod<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_append<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isspace_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtof<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_count<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isupper<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtoimax<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_create<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>isupper_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtok<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_create_sep<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswalnum<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtok_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_delete<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswalnum_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtol<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_extract<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswalpha<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtold<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_insert<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswalpha_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtoll<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_next<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswblank<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtoq<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>argz_replace<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswblank_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtoul<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>argz_stringify<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswcntrl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtoull<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asctime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswcntrl_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtoumax<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asctime_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswctype<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strtouq<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>asprintf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswctype_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strxfrm<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atof<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswdigit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>strxfrm_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atoi<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswdigit_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svc_getreqset<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>atol<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswgraph<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svc_register<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>atoll<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswgraph_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svc_run<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>authnone_create<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>iswlower<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svc_sendreply<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>backtrace<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswlower_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_auth<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>backtrace_symbols<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswprint<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_decode<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>backtrace_symbols_fd<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswprint_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_noproc<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>basename<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswpunct<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_noprog<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>bcmp<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>iswpunct_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_progvers<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>bcopy<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>iswspace<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_systemerr<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>bind<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>iswspace_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcerr_weakauth<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>bind_textdomain_codeset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswupper<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcfd_create<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
></TR
><TR
><TD
>bindresvport<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswupper_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcraw_create<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
></TR
><TR
><TD
>bindtextdomain<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>iswxdigit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svctcp_create<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>brk<A
HREF="#STD.SUSV2"
>[SUSv2]</A
></TD
><TD
>iswxdigit_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>svcudp_create<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>bsd_signal<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>isxdigit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>swab<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>bsearch<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>isxdigit_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>swapcontext<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>btowc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>jrand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>swprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>bzero<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>jrand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>swscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>calloc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>key_decryptsession<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>symlink<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>callrpc<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
><TD
>kill<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>symlinkat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catclose<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>killpg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catgets<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>l64a<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sysconf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>catopen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>labs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sysinfo<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>cfgetispeed<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lchown<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>syslog<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cfgetospeed<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lcong48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>system<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>cfmakeraw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>lcong48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tcdrain<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cfsetispeed<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ldiv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcflow<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cfsetospeed<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lfind<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcflush<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cfsetspeed<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>link<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tcgetattr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>chdir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>linkat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcgetpgrp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>chmod<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>listen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcgetsid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>chown<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llabs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcsendbreak<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>chroot<A
HREF="#STD.SUSV2"
>[SUSv2]</A
></TD
><TD
>lldiv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcsetattr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clearerr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>localeconv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcsetpgrp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clearerr_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>localtime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tdelete<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clnt_create<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>localtime_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>telldir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clnt_pcreateerror<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>lockf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tempnam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clnt_perrno<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>lockf64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>textdomain<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>clnt_perror<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>longjmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tfind<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clnt_spcreateerror<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>lrand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>time<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clnt_sperrno<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>lrand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>times<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clnt_sperror<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
><TD
>lsearch<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tmpfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clntraw_create<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
><TD
>lseek<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tmpfile64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
></TR
><TR
><TD
>clnttcp_create<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
><TD
>lseek64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>tmpnam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clntudp_bufcreate<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
><TD
>lutimes(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>toascii<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clntudp_create<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
><TD
>makecontext<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>tolower<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>malloc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tolower_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>close<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mblen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>toupper<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>closedir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mbrlen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>toupper_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>closelog<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mbrtowc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>towctrans<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>confstr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mbsinit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>towctrans_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>connect<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mbsnrtowcs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>towlower<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>creat<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mbsrtowcs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>towlower_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>creat64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>mbstowcs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>towupper<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ctermid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mbtowc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>towupper_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ctime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>memccpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>truncate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ctime_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>memchr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>truncate64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
></TR
><TR
><TD
>cuserid<A
HREF="#STD.SUSV2"
>[SUSv2]</A
></TD
><TD
>memcmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tsearch<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>daemon<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>memcpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ttyname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dcgettext<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>memmem<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ttyname_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dcngettext<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>memmove<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>twalk<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dgettext<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>memrchr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tzset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>difftime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>memset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ualarm<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>dirfd<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mkdir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ulimit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dirname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mkdirat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>umask<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>div<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mkdtemp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>uname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dl_iterate_phdr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>mkfifo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ungetc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dngettext<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>mkfifoat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ungetwc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mkstemp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>unlink<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>drand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mkstemp64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>unlinkat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>drand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>mktemp<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>unlockpt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dup<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mktime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>unsetenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>dup2<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>uselocale(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>duplocale(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mlockall<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>usleep<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ecvt<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>mmap<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>utime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>endgrent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mmap64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>utimensat(GLIBC_2.6)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>endprotoent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mprotect<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>utimes<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>endpwent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mrand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>utmpname<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>endservent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mrand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>vasprintf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>endutent<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>mremap<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>vdprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>endutxent<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>msgctl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>verrx<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>envz_add<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>msgget<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vfork<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>envz_entry<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>msgrcv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vfprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>envz_get<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>msgsnd<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vfscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>envz_merge<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>msync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vfwprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>envz_remove<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>munlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vfwscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>envz_strip<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>munlockall<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>epoll_create(GLIBC_2.3.2)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>munmap<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>epoll_ctl(GLIBC_2.3.2)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>nanosleep<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vsnprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>epoll_wait(GLIBC_2.3.2)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>newlocale(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vsprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>erand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nftw<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vsscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>erand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>nftw64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>vswprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>err<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ngettext<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>vswscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>error<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>nice<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vsyslog<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>errx<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>nl_langinfo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vwprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>execl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nrand48<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vwscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>execle<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nrand48_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>execlp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ntohl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wait4<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>execv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ntohs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>waitid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>execve<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>open<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>waitpid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>execvp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>open64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>warn<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>exit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>open_memstream<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>warnx<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>faccessat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>open_wmemstream(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcpcpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fchdir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>openat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcpncpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fchmod<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>openat64(GLIBC_2.4)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wcrtomb<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fchmodat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>opendir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcscasecmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fchown<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>openlog<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcscasecmp_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fchownat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pathconf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcscat<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fclose<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pause<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcschr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fcntl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pclose<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcscmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fcvt<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>perror<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcscoll<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fdatasync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pipe<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcscoll_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fdopen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pmap_getport<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wcscpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fdopendir(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pmap_set<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wcscspn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>feof<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pmap_unset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wcsdup<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>feof_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>poll<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsftime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ferror<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>popen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcslen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ferror_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_fadvise<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsncasecmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fexecve<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_fadvise64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wcsncasecmp_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fflush<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_fallocate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsncat<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fflush_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_fallocate64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wcsncmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ffs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_madvise<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsncpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_memalign<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsnlen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetc_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_openpt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsnrtombs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetpos<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcspbrk<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetpos64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>posix_spawn_file_actions_addclose<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsrchr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgets<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawn_file_actions_adddup2<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsrtombs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgets_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_spawn_file_actions_addopen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsspn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetwc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawn_file_actions_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsstr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetwc_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_spawn_file_actions_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstod<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetws<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstof<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fgetws_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_spawnattr_getflags<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstoimax<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fileno<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getpgroup<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstok<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fileno_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_spawnattr_getschedparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstol<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>flock<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_spawnattr_getschedpolicy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstold<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>flockfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getsigdefault<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstoll<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fmemopen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_getsigmask<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstombs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fmtmsg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstoq<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>fnmatch<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>posix_spawnattr_setflags<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstoul<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fopen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setpgroup<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstoull<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fopen64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>posix_spawnattr_setschedparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstoumax<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fork<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setschedpolicy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcstouq<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>fpathconf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setsigdefault<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcswcs<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>fprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnattr_setsigmask<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcswidth<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>posix_spawnp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsxfrm<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputc_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pread<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcsxfrm_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pread64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wctob<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputs_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>printf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wctomb<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputwc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pselect<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wctrans<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputwc_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>psiginfo(GLIBC_2.10)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wctrans_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputws<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>psignal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wctype<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fputws_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ptrace<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>wctype_l(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fread<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ptsname<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wcwidth<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fread_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>putc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wmemchr<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>free<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>putc_unlocked<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wmemcmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>freeaddrinfo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>putchar<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wmemcpy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>freeifaddrs(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>putchar_unlocked<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wmemmove<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>freelocale(GLIBC_2.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>putenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wmemset<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>freopen<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>puts<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wordexp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>freopen64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>pututxline<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wordfree<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>putw<A
HREF="#STD.SUSV2"
>[SUSv2]</A
></TD
><TD
>wprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fseek<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>putwc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>write<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fseeko<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>putwc_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>writev<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fseeko64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>putwchar<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>fsetpos<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>putwchar_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>xdr_accepted_reply<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fsetpos64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>pwrite<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_array<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fstatfs<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pwrite64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>xdr_bool<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fstatfs64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>qsort<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_bytes<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fstatvfs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>raise<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_callhdr<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fstatvfs64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>rand<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_callmsg<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fsync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>rand_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_char<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftell<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>random<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_double<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftello<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>random_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>xdr_enum<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftello64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>read<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_float<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftime<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>readdir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_free<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftok<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>readdir64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>xdr_int<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftruncate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>readdir64_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>xdr_long<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftruncate64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>readdir_r<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_opaque<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftrylockfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>readlink<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_opaque_auth<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftw<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>readlinkat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_pointer<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>ftw64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>readv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_reference<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>funlockfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>realloc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_rejected_reply<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>futimens(GLIBC_2.6)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>realpath<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_replymsg<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>futimes(GLIBC_2.3)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>recv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_short<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fwide<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>recvfrom<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_string<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fwprintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>recvmsg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_u_char<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fwrite<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>regcomp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_u_int<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>fwrite_unlocked<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>regerror<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_u_long<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>fwscanf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>regexec<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>xdr_u_short<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>gai_strerror<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>regfree<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_union<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>gcvt<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>remove<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_vector<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>getaddrinfo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>remque<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_void<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>getc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>rename<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdr_wrapstring<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>getc_unlocked<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>renameat(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdrmem_create<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>getchar<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>rewind<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdrrec_create<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>getchar_unlocked<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>rewinddir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdrrec_endofrecord<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
></TR
><TR
><TD
>getcontext<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>rindex<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>xdrrec_eof<A
HREF="#STD.SVID.4"
>[SVID.4]</A
></TD
></TR
><TR
><TD
>getcwd<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>rmdir<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>xdrrec_skiprecord<A
HREF="#STD.RPC.XDR"
>[RPC + XDR]</A
></TD
></TR
><TR
><TD
>getdate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sbrk<A
HREF="#STD.SUSV2"
>[SUSv2]</A
></TD
><TD
>xdrstdio_create<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN67505"
></A
><P
><B
>Table A-2. libc Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__daylight<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>__tzname<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>in6addr_loopback<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>__environ<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_sys_errlist<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>__timezone<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>in6addr_any<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBCRYPT"
>A.2. libcrypt</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> [SUSv4]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN67537"
></A
><P
><B
>Table A-3. libcrypt Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>crypt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>encrypt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>setkey<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>crypt_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>encrypt_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>setkey_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBDL"
>A.3. libdl</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> [SUSv4]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN67564"
></A
><P
><B
>Table A-4. libdl Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>dladdr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>dlerror<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>dlsym<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>dlclose<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>dlopen<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>dlvsym<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBGCC-S"
>A.4. libgcc_s</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN67589"
></A
><P
><B
>Table A-5. libgcc_s Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>_Unwind_Backtrace<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_GetGR<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_RaiseException<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_DeleteException<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_GetIP<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_Resume<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_FindEnclosingFunction<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_GetIPInfo(GCC_4.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_Resume_or_Rethrow<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_ForcedUnwind<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_GetLanguageSpecificData<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_SetGR<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>_Unwind_GetCFA<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_GetRegionStart<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>_Unwind_SetIP<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBM"
>A.5. libm</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
> [SUSv3]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> [SUSv4]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN67639"
></A
><P
><B
>Table A-6. libm Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__finite<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>csinl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llroundf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__finitef<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>csqrt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llroundl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__finitel<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>csqrtf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fpclassify<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>csqrtl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log10<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__fpclassifyf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ctan<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log10f<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__signbit<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ctanf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log10l<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__signbitf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ctanh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log1p<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acos<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ctanhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log1pf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acosf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ctanhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log1pl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acosh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ctanl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>log2<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acoshf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>drem<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>log2f<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acoshl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>dremf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>log2l<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>acosl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>dreml<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>logb<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asin<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>erf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>logbf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asinf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>erfc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>logbl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asinh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>erfcf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>logf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asinhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>erfcl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>logl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asinhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>erff<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lrint<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>asinl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>erfl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lrintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atan<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>exp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lrintl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atan2<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>exp10<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>lround<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atan2f<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>exp10f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>lroundf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atan2l<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>exp10l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>lroundl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atanf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>exp2<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>matherr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>atanh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>exp2f<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>modf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atanhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>expf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>modff<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atanhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>expl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>modfl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>atanl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>expm1<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nan<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cabs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>expm1f<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nanf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cabsf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>expm1l<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nanl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cabsl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fabs<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nearbyint<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacos<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fabsf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nearbyintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacosf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fabsl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nearbyintl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacosh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fdim<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nextafter<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacoshf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fdimf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nextafterf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacoshl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fdiml<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nextafterl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cacosl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>feclearexcept<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>nexttoward<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>carg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fedisableexcept<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>nexttowardf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cargf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>feenableexcept<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>nexttowardl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cargl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fegetenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pow<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>casin<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fegetexcept<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pow10<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>casinf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fegetexceptflag<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pow10f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>casinh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fegetround<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pow10l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>casinhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>feholdexcept<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>powf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>casinhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>feraiseexcept<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>powl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>casinl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fesetenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>remainder<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catan<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fesetexceptflag<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>remainderf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catanf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fesetround<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>remainderl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catanh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fetestexcept<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>remquo<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catanhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>feupdateenv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>remquof<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catanhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>finite<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>remquol<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>catanl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>finitef<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>rint<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cbrt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>finitel<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>rintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cbrtf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>floor<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>rintl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cbrtl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>floorf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>round<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ccos<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>floorl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>roundf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ccosf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fma<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>roundl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ccosh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmaf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalb<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>ccoshf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalbf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>ccoshl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmax<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalbl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>ccosl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmaxf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalbln<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ceil<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmaxl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalblnf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ceilf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmin<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalblnl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ceill<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fminf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalbn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cexp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fminl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalbnf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cexpf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmod<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>scalbnl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cexpl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmodf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>significand<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>cimag<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>fmodl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>significandf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>cimagf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>frexp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>significandl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>cimagl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>frexpf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sin<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clog<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>frexpl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sincos<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>clog10<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gamma<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sincosf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>clog10f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gammaf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sincosl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>clog10l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gammal<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sinf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clogf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>hypot<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sinh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>clogl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>hypotf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sinhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>conj<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>hypotl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sinhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>conjf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ilogb<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sinl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>conjl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ilogbf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sqrt<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>copysign<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ilogbl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sqrtf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>copysignf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>j0<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sqrtl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>copysignl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>j0f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tan<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cos<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>j0l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tanf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cosf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>j1<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tanh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cosh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>j1f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tanhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>coshf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>j1l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tanhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>coshl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>jn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tanl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cosl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>jnf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tgamma<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cpow<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>jnl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tgammaf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cpowf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ldexp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tgammal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cpowl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ldexpf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>trunc<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cproj<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ldexpl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>truncf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cprojf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lgamma<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>truncl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>cprojl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lgamma_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>y0<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>creal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lgammaf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>y0f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>crealf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lgammaf_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>y0l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>creall<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lgammal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>y1<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>csin<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lgammal_r<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>y1f<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>csinf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llrint<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>y1l<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>csinh<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llrintf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>yn<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>csinhf<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llrintl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ynf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>csinhl<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>llround<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>ynl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN68357"
></A
><P
><B
>Table A-7. libm Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>signgam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBNCURSES"
>A.6. libncurses</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
> [X-CURSES]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN68375"
></A
><P
><B
>Table A-8. libncurses Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>addch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvdelch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_refresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>addchnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvderwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_restore<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>addchstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvgetch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>addnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvgetnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_touch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>addstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvgetstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>standend<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attr_get<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvhline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>standout<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attr_off<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>start_color<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attr_on<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinchnstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>subpad<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attr_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinchstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>subwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attroff<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>syncok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attron<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinsch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>termattrs<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attrset<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinsnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>termname<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>baudrate<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinsstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tgetent<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>beep<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvinstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tgetflag<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>bkgd<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvprintw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tgetnum<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>bkgdset<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvscanw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>tgetstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>border<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvvline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tgoto<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>box<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwaddch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tigetflag<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>can_change_color<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwaddchnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tigetnum<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>cbreak<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwaddchstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tigetstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>chgat<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwaddnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>timeout<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>clear<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwaddstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>touchline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>clearok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwchgat<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>touchwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>clrtobot<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwdelch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tparm<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>clrtoeol<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwgetch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>tputs<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>color_content<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwgetnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>typeahead<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>color_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwgetstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>unctrl<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>copywin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwhline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>ungetch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>curs_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>untouchwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>def_prog_mode<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>use_env<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>def_shell_mode<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinchnstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>vidattr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>del_curterm<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinchstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>vidputs<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>delay_output<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>vline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>delch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinsch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>vw_printw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>deleteln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinsnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>vw_scanw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>delscreen<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinsstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>vwprintw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>delwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwinstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>vwscanw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>derwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwprintw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>waddch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>doupdate<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwscanw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>waddchnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>dupwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>mvwvline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>waddchstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>echo<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>napms<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>waddnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>echochar<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>newpad<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>waddstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>endwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>newterm<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattr_get<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>erase<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>newwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattr_off<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>erasechar<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>nl<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattr_on<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>filter<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>nocbreak<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattr_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>flash<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>nodelay<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattroff<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>flushinp<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>noecho<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattron<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getbkgd<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>nonl<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wattrset<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>noqiflush<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wbkgd<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>noraw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wbkgdset<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>notimeout<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wborder<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>getwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>overlay<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wchgat<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>halfdelay<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>overwrite<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wclear<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>has_colors<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>pair_content<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wclrtobot<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>has_ic<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>pechochar<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wclrtoeol<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>has_il<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>pnoutrefresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wcolor_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>hline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>prefresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wcursyncup<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>idcok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>printw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wdelch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>idlok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>putp<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wdeleteln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>immedok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>putwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wechochar<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>inch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>qiflush<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>werase<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>inchnstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>raw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wgetch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>inchstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>redrawwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wgetnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>init_color<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>refresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wgetstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>init_pair<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>reset_prog_mode<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>whline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>initscr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>reset_shell_mode<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>innstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>resetty<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winchnstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>insch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>restartterm<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winchstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>insdelln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>ripoffline<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>winnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>insertln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>savetty<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winsch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>insnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scanw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>winsdelln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>insstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scr_dump<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winsertln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>instr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>scr_init<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winsnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>intrflush<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scr_restore<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winsstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>is_linetouched<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scr_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>winstr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>is_wintouched<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scrl<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wmove<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>isendwin<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scroll<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wnoutrefresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>keyname<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>scrollok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wprintw<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>keypad<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>set_curterm<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wredrawln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>killchar<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>set_term<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wrefresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>leaveok<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>setscrreg<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wscanw<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>longname<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>setupterm<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wscrl<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>meta<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_attr_set<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wsetscrreg<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>move<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_attroff<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wstandend<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddch<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_attron<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wstandout<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddchnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_attrset<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wsyncdown<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddchstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_clear<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wsyncup<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddnstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_color<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wtimeout<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvaddstr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_init<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wtouchln<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvchgat<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>slk_label<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wvline<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>mvcur<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>slk_noutrefresh<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN69022"
></A
><P
><B
>Table A-9. libncurses Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>COLORS<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>acs_map<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>stdscr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>COLOR_PAIRS<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>cur_term<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>ttytype<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>COLS<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>curscr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>LINES<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>newscr<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBNCURSESW"
>A.7. libncursesw</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LIBNCURSESW"
>Libncursesw API</A
> [Libncursesw]</TD
></TR
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.NCURSESW"
>Libncursesw Placeholder</A
> [ncursesw]</TD
></TR
><TR
><TD
><A
HREF="#STD.X.CURSES"
>X/Open Curses, Issue 7</A
> [X-CURSES]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN69065"
></A
><P
><B
>Table A-10. libncursesw Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>add_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvaddnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_init<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>add_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvaddstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_label<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>add_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvaddwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_noutrefresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvchgat<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_refresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvcur<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_restore<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvdelch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvderwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_touch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvget_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_wset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvget_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>standend<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>addwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvgetch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>standout<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>assume_default_colors<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvgetn_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>start_color<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attr_get<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvgetnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>subpad<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attr_off<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvgetstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>subwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attr_on<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvhline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>syncok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attr_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvhline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>term_attrs<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>attroff<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvin_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>termattrs<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attron<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvin_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>termname<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>attrset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvin_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tgetent<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>baudrate<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tgetflag<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>beep<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tgetnum<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>bkgd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tgetstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>bkgdset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tgoto<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>bkgrnd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tigetflag<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>bkgrndset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvins_nwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tigetnum<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>border<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvins_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tigetstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>border_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvins_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>timeout<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>box<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinsch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>touchline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>box_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinsnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>touchwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>can_change_color<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinsstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tparm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>cbreak<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>tputs<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>chgat<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvinwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>typeahead<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>clear<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvprintw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>unctrl<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>clearok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvscanw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>unget_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>clrtobot<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvvline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>ungetch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>clrtoeol<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvvline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>ungetmouse<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>color_content<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwadd_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>untouchwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>color_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwadd_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>use_default_colors<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>copywin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwadd_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>use_env<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>curs_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>use_extended_names<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>curses_version<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vid_attr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
></TR
><TR
><TD
>def_prog_mode<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vid_puts<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>def_shell_mode<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vidattr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>define_key<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vidputs<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>del_curterm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>delay_output<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwaddwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>delch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwchgat<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vw_printw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>deleteln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwdelch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vw_scanw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>delscreen<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwget_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vwprintw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>delwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwget_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>vwscanw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>derwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwgetch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wadd_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>doupdate<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwgetn_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wadd_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>dupwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwgetnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wadd_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>echo<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwgetstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>echo_wchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwhline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>echochar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwhline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>endwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>erase<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwin_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>erasechar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwin_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>erasewchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwin_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>waddwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>filter<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattr_get<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>flash<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattr_off<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>flushinp<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattr_on<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>get_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattr_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>get_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattroff<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getbkgd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwins_nwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattron<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getbkgrnd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwins_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wattrset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getcchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwins_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wbkgd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinsch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wbkgdset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getmouse<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinsnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wbkgrnd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getn_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinsstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wbkgrndset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wborder<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwinwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wborder_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>getwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwprintw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wchgat<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>halfdelay<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwscanw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wclear<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>has_colors<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwvline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wclrtobot<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>has_ic<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>mvwvline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wclrtoeol<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>has_il<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>napms<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wcolor_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>has_key<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>newpad<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wcursyncup<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>has_mouse<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>newterm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wdelch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>hline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>newwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wdeleteln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>hline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>nl<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wecho_wchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>idcok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>nocbreak<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wechochar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>idlok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>nodelay<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>werase<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>immedok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>noecho<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wget_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>in_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>nonl<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wget_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>in_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>noqiflush<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wgetbkgrnd<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>in_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>noraw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wgetch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>inch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>notimeout<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wgetn_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>inchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>overlay<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wgetnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>inchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>overwrite<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wgetstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>init_color<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>pair_content<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>whline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>init_pair<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>pecho_wchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>whline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>initscr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>pechochar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>win_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>innstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>pnoutrefresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>win_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>innwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>prefresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>win_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>ins_nwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>printw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>ins_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>putp<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>ins_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>putwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>insch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>qiflush<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>insdelln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>raw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winnwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>insertln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>redrawwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wins_nwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>insnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>refresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wins_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>insstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>reset_prog_mode<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wins_wstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>instr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>reset_shell_mode<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winsch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>intrflush<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>resetty<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winsdelln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>inwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>resizeterm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winsertln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>is_linetouched<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>restartterm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winsnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>is_wintouched<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>ripoffline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winsstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>isendwin<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>savetty<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>key_name<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scanw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>winwstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>keybound<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scr_dump<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wmouse_trafo<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>keyname<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scr_init<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wmove<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>keyok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scr_restore<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wnoutrefresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>keypad<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>scr_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wprintw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>killchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scrl<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wredrawln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>killwchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scroll<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wrefresh<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>leaveok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>scrollok<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wresize<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>longname<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>set_curterm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wscanw<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mcprint<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>set_term<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wscrl<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>meta<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>setcchar<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wsetscrreg<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mouse_trafo<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>setscrreg<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wstandend<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mouseinterval<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>setupterm<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wstandout<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mousemask<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attr<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wsyncdown<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>move<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attr_off<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wsyncup<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvadd_wch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attr_on<A
HREF="#STD.X.CURSES"
>[X-CURSES]</A
></TD
><TD
>wtimeout<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvadd_wchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attr_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wtouchln<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvadd_wchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attroff<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wunctrl<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvaddch<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attron<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wvline<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvaddchnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_attrset<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>wvline_set<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
></TR
><TR
><TD
>mvaddchstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_clear<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>mvaddnstr<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>slk_color<A
HREF="#STD.LIBNCURSESW"
>[Libncursesw]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="AEN69984"
></A
><P
><B
>Table A-11. libncursesw Data Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>COLORS<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
><TD
>acs_map<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>stdscr<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
></TR
><TR
><TD
>COLOR_PAIRS<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
><TD
>cur_term<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>ttytype<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
></TR
><TR
><TD
>COLS<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
><TD
>curscr<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>LINES<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
><TD
>newscr<A
HREF="#STD.NCURSESW"
>[ncursesw]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBPAM"
>A.8. libpam</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.PAM"
>PAM</A
> [PAM]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70023"
></A
><P
><B
>Table A-12. libpam Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>pam_acct_mgmt(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_get_data(LIBPAM_1.0)<A
HREF="#STD.PAM"
>[PAM]</A
></TD
><TD
>pam_putenv(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_authenticate(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_get_item(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_set_data(LIBPAM_1.0)<A
HREF="#STD.PAM"
>[PAM]</A
></TD
></TR
><TR
><TD
>pam_chauthtok(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_get_user(LIBPAM_1.0)<A
HREF="#STD.PAM"
>[PAM]</A
></TD
><TD
>pam_set_item(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_close_session(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_getenv(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_setcred(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_end(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_getenvlist(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_start(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pam_fail_delay(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_open_session(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pam_strerror(LIBPAM_1.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBPTHREAD"
>A.9. libpthread</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LFS"
>Large File Support</A
> [LFS]</TD
></TR
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV3"
>POSIX 1003.1-2001 (ISO/IEC 9945-2003)</A
> [SUSv3]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> [SUSv4]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70082"
></A
><P
><B
>Table A-13. libpthread Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>__errno_location<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_cond_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_tryrdlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__h_errno_location<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_cond_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_trywrlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__libc_current_sigrtmax<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_cond_signal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_unlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>__libc_current_sigrtmin<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_cond_timedwait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_wrlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_pthread_cleanup_pop<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_cond_wait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>_pthread_cleanup_push<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_condattr_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_getkind_np<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>accept<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_getclock(GLIBC_2.3.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_getpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>close<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_getpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>connect<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_setkind_np<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>fcntl<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_condattr_setclock(GLIBC_2.3.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlockattr_setpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>flockfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_condattr_setpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_self<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fork<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_create<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_setcancelstate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>fsync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_detach<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_setcanceltype<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>ftrylockfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_equal<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_setconcurrency<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>funlockfile<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_exit<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_setschedparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>longjmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_getattr_np<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_setschedprio(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>lseek<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_getconcurrency<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_setspecific<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>lseek64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>pthread_getcpuclockid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_sigmask<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>msync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_getschedparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>nanosleep<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_getspecific<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>open<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_join<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_lock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>open64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>pthread_key_create<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_trylock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pause<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_key_delete<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_spin_unlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pread<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_kill<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_testcancel<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pread64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pthread_mutex_consistent(GLIBC_2.12)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pwrite<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_consistent_np<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>pwrite64<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pthread_attr_getdetachstate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>raise<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getguardsize<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_getprioceiling(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>read<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getinheritsched<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>recv<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getschedparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_lock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>recvfrom<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getschedpolicy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_setprioceiling(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>recvmsg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getscope<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_timedlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_close<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstack<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutex_trylock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstackaddr<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>pthread_mutex_unlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_getvalue<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_getstacksize<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getprioceiling(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_open<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setdetachstate<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getprotocol(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_post<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setguardsize<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_timedwait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setinheritsched<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getrobust(GLIBC_2.12)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_trywait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedparam<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_getrobust_np<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sem_unlink<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setschedpolicy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_gettype<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sem_wait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setscope<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>send<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setstack<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_setprioceiling(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sendmsg<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setstackaddr<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
><TD
>pthread_mutexattr_setprotocol(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sendto<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_attr_setstacksize<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_setpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>sigaction<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_barrier_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_setrobust(GLIBC_2.12)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>siglongjmp<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_barrier_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_setrobust_np<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>sigwait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_barrier_wait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_mutexattr_settype<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>system<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pthread_barrierattr_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_once<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>tcdrain<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_barrierattr_getpshared(GLIBC_2.3.3)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_destroy<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>vfork<A
HREF="#STD.SUSV3"
>[SUSv3]</A
></TD
></TR
><TR
><TD
>pthread_barrierattr_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_init<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>wait<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_barrierattr_setpshared<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_rdlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>waitpid<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>pthread_cancel<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_timedrdlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>write<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>pthread_cond_broadcast<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>pthread_rwlock_timedwrlock<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBRT"
>A.10. librt</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LFS"
>Large File Support</A
> [LFS]</TD
></TR
><TR
><TD
><A
HREF="#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
> [SUSv4]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70472"
></A
><P
><B
>Table A-14. librt Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>aio_cancel<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>aio_write64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>mq_send(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_cancel64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>clock_getcpuclockid<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_setattr(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_error<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>clock_getres<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_timedreceive(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_error64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>clock_gettime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_timedsend(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_fsync<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>clock_nanosleep<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_unlink(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_fsync64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>clock_settime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>shm_open<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_read<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>lio_listio(GLIBC_2.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>shm_unlink<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_read64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>lio_listio64(GLIBC_2.4)<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>timer_create<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_return<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_close(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>timer_delete<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_return64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>mq_getattr(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>timer_getoverrun<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_suspend<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_notify(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>timer_gettime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_suspend64<A
HREF="#STD.LFS"
>[LFS]</A
></TD
><TD
>mq_open(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>timer_settime<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
></TR
><TR
><TD
>aio_write<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>mq_receive(GLIBC_2.3.4)<A
HREF="#STD.SUSV4"
>[SUSv4]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBUTIL"
>A.11. libutil</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70573"
></A
><P
><B
>Table A-15. libutil Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>forkpty<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>login_tty<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>logwtmp<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>login<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>logout<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>openpty<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBZ"
>A.12. libz</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.LSB"
>This Specification</A
> [LSB]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70598"
></A
><P
><B
>Table A-16. libz Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>adler32<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzclose<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflate<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>compress<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzdopen<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateBack(ZLIB_1.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>compress2<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzeof<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateBackEnd(ZLIB_1.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>compressBound(ZLIB_1.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzerror<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateBackInit_(ZLIB_1.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>crc32<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzflush<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateCopy(ZLIB_1.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflate<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzgetc<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateEnd<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateBound(ZLIB_1.2.0)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzgets<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateInit2_<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateCopy<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzopen<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateInit_<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateEnd<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzprintf<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateReset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateInit2_<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzputc<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateSetDictionary<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateInit_<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzputs<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateSync<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateParams<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzread<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>inflateSyncPoint<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflatePrime(ZLIB_1.2.0.8)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzrewind<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>uncompress<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateReset<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzseek<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>zError<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>deflateSetDictionary<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzsetparams<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>zlibVersion<A
HREF="#STD.LSB"
>[LSB]</A
></TD
></TR
><TR
><TD
>get_crc_table<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gztell<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>gzclearerr(ZLIB_1.2.0.2)<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>gzwrite<A
HREF="#STD.LSB"
>[LSB]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBNSPR4"
>A.13. libnspr4</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.NSPR"
>NSPR Reference</A
> [NSPR]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70726"
></A
><P
><B
>Table A-17. libnspr4 Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>PR_Abort<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetErrorTextLength<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NotifyAllCondVar<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Accept<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetLayersIdentity<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NotifyCondVar<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_AtomicAdd<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetOSError<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Now<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_AtomicDecrement<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetSocketOption<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Open<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_AtomicIncrement<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetThreadPrivate<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_OpenTCPSocket<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_AtomicSet<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetThreadScope<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_OpenUDPSocket<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Bind<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetThreadState<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_ParseTimeString<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Calloc<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_GetUniqueIdentity<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_ParseTimeStringToExplodedTime<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Cleanup<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_ImplodeTime<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Poll<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ClearInterrupt<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_ImportTCPSocket<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_PopIOLayer<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Close<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Init<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_ProcessExit<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Connect<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Initialize<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_PushIOLayer<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ConnectContinue<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_InitializeNetAddr<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Read<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ConvertIPv4AddrToIPv6<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Initialized<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Realloc<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_CreateIOLayerStub<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Interrupt<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Recv<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_CreatePipe<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_IntervalNow<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_RecvFrom<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_DestroyCondVar<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_IntervalToMicroseconds<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_SecondsToInterval<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_DestroyLock<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_IntervalToMilliseconds<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Send<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_EnumerateAddrInfo<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_IntervalToSeconds<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_SendTo<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_ExplodeTime<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Listen<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_SetError<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_FormatTime<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_LocalTimeParameters<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_SetErrorText<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_Free<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Lock<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_SetSocketOption<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_FreeAddrInfo<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Malloc<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_SetThreadPrivate<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GMTParameters<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_MicrosecondsToInterval<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Shutdown<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetAddrInfoByName<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_MillisecondsToInterval<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Sleep<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetCanonNameFromAddrInfo<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NetAddrToString<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_StringToNetAddr<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetDefaultIOMethods<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NewCondVar<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_TicksPerSecond<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetDescType<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NewLock<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Unlock<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetError<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NewThreadPrivateIndex<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_WaitCondVar<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
><TR
><TD
>PR_GetErrorText<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_NormalizeTime<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
><TD
>PR_Write<A
HREF="#STD.NSPR"
>[NSPR]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBNSS3"
>A.14. libnss3</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.NSS.SSL"
>Mozilla's NSS SSL Reference</A
> [NSS SSL]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN70947"
></A
><P
><B
>Table A-18. libnss3 Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>CERT_CheckCertValidTimes(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>CERT_VerifyCertNow(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_GetSlotName(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_DestroyCertificate(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>NSS_Init(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_GetTokenName(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_DupCertificate(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>NSS_InitReadWrite(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_IsHW(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_FreeNicknames(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>NSS_NoDB_Init(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_IsPresent(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_GetCertNicknames(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>NSS_Shutdown(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_IsReadOnly(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_GetDefaultCertDB(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_FindCertFromNickname(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_SetPasswordFunc(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>CERT_VerifyCertName(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>PK11_FindKeyByAnyCert(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SECKEY_DestroyPrivateKey(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APP-LIBSSL3"
>A.15. libssl3</A
></H2
><P
></P
><P
>The behavior of the interfaces in this library is specified by the following Standards.<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><A
HREF="#STD.NSS.SSL"
>Mozilla's NSS SSL Reference</A
> [NSS SSL]</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><DIV
CLASS="TABLE"
><A
NAME="AEN71007"
></A
><P
><B
>Table A-19. libssl3 Function Interfaces</B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
>NSS_CmpCertChainWCANames(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ConfigMPServerSIDCache(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_OptionSet(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>NSS_FindCertKEAType(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ConfigSecureServer(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_OptionSetDefault(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>NSS_GetClientAuthData(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ConfigServerSessionIDCache(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_PeerCertificate(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_AuthCertificate(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_DataPending(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ReHandshake(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_AuthCertificateHook(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ForceHandshake(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ResetHandshake(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_BadCertHook(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_GetClientAuthDataHook(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_RevealPinArg(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPolicyGet(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_GetSessionID(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_RevealURL(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPolicySet(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_HandshakeCallback(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_SecurityStatus(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPrefGet(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_ImportFD(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_SetPKCS11PinArg(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPrefGetDefault(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_InheritMPServerSIDCache(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_SetSockPeerID(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPrefSet(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_InvalidateSession(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_SetURL(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
></TR
><TR
><TD
>SSL_CipherPrefSetDefault(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_OptionGet(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
>SSL_ClearSessionCache(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>SSL_OptionGetDefault(NSS_3.2)<A
HREF="#STD.NSS.SSL"
>[NSS SSL]</A
></TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="GFDL"
></A
>Appendix B. GNU Free Documentation License (Informative)</H1
><P
>This specification is published under the terms of the 
GNU Free Documentation License, Version 1.1, March 2000</P
><A
NAME="AEN71103"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (C) 2000  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.</P
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-0"
>B.1. PREAMBLE</A
></H2
><P
>The purpose of this License is to make a manual, textbook,
    or other written document "free" in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it,
    with or without modifying it, either commercially or
    noncommercially.  Secondarily, this License preserves for the
    author and publisher a way to get credit for their work, while not
    being considered responsible for modifications made by
    others.</P
><P
>This License is a kind of "copyleft", which means that
    derivative works of the document must themselves be free in the
    same sense.  It complements the GNU General Public License, which
    is a copyleft license designed for free software.</P
><P
>We have designed this License in order to use it for manuals
    for free software, because free software needs free documentation:
    a free program should come with manuals providing the same
    freedoms that the software does.  But this License is not limited
    to software manuals; it can be used for any textual work,
    regardless of subject matter or whether it is published as a
    printed book.  We recommend this License principally for works
    whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-1"
>B.2. APPLICABILITY AND DEFINITIONS</A
></H2
><P
>This License applies to any manual or other work that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  The "Document",
    below, refers to any such manual or work.  Any member of the
    public is a licensee, and is addressed as "you".</P
><P
>A "Modified Version" of the Document means any work
    containing the Document or a portion of it, either copied
    verbatim, or with modifications and/or translated into another
    language.</P
><P
>A "Secondary Section" is a named appendix or a front-matter
    section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains
    nothing that could fall directly within that overall subject.
    (For example, if the Document is in part a textbook of
    mathematics, a Secondary Section may not explain any mathematics.)
    The relationship could be a matter of historical connection with
    the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding
    them.</P
><P
>The "Invariant Sections" are certain Secondary Sections
    whose titles are designated, as being those of Invariant Sections,
    in the notice that says that the Document is released under this
    License.</P
><P
>The "Cover Texts" are certain short passages of text that
    are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this
    License.</P
><P
>A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification
    is available to the general public, whose contents can be viewed
    and edited directly and straightforwardly with generic text
    editors or (for images composed of pixels) generic paint programs
    or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic
    translation to a variety of formats suitable for input to text
    formatters.  A copy made in an otherwise Transparent file format
    whose markup has been designed to thwart or discourage subsequent
    modification by readers is not Transparent.  A copy that is not
    "Transparent" is called "Opaque".</P
><P
>Examples of suitable formats for Transparent copies include
    plain ASCII without markup, Texinfo input format, LaTeX input
    format, SGML or XML using a publicly available DTD, and
    standard-conforming simple HTML designed for human modification.
    Opaque formats include PostScript, PDF, proprietary formats that
    can be read and edited only by proprietary word processors, SGML
    or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML produced by some word
    processors for output purposes only.</P
><P
>The "Title Page" means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly,
    the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such,
    "Title Page" means the text near the most prominent appearance of
    the work's title, preceding the beginning of the body of the
    text.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-2"
>B.3. VERBATIM COPYING</A
></H2
><P
>You may copy and distribute the Document in any medium,
    either commercially or noncommercially, provided that this
    License, the copyright notices, and the license notice saying this
    License applies to the Document are reproduced in all copies, and
    that you add no other conditions whatsoever to those of this
    License.  You may not use technical measures to obstruct or
    control the reading or further copying of the copies you make or
    distribute.  However, you may accept compensation in exchange for
    copies.  If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</P
><P
>You may also lend copies, under the same conditions stated
    above, and you may publicly display copies.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-3"
>B.4. COPYING IN QUANTITY</A
></H2
><P
>If you publish printed copies of the Document numbering more
    than 100, and the Document's license notice requires Cover Texts,
    you must enclose the copies in covers that carry, clearly and
    legibly, all these Cover Texts: Front-Cover Texts on the front
    cover, and Back-Cover Texts on the back cover.  Both covers must
    also clearly and legibly identify you as the publisher of these
    copies.  The front cover must present the full title with all
    words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes
    limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim
    copying in other respects.</P
><P
>If the required texts for either cover are too voluminous to
    fit legibly, you should put the first ones listed (as many as fit
    reasonably) on the actual cover, and continue the rest onto
    adjacent pages.</P
><P
>If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a
    machine-readable Transparent copy along with each Opaque copy, or
    state in or with each Opaque copy a publicly-accessible
    computer-network location containing a complete Transparent copy
    of the Document, free of added material, which the general
    network-using public has access to download anonymously at no
    charge using public-standard network protocols.  If you use the
    latter option, you must take reasonably prudent steps, when you
    begin distribution of Opaque copies in quantity, to ensure that
    this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you
    distribute an Opaque copy (directly or through your agents or
    retailers) of that edition to the public.</P
><P
>It is requested, but not required, that you contact the
    authors of the Document well before redistributing any large
    number of copies, to give them a chance to provide you with an
    updated version of the Document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-4"
>B.5. MODIFICATIONS</A
></H2
><P
>You may copy and distribute a Modified Version of the
    Document under the conditions of sections 2 and 3 above, provided
    that you release the Modified Version under precisely this
    License, with the Modified Version filling the role of the
    Document, thus licensing distribution and modification of the
    Modified Version to whoever possesses a copy of it.  In addition,
    you must do these things in the Modified Version:</P
><P
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page
      (and on the covers, if any) a title distinct from that of the
      Document, and from those of previous versions (which should, if
      there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if
      the original publisher of that version gives permission.</P
></LI
><LI
><P
>List on the Title Page,
      as authors, one or more persons or entities responsible for
      authorship of the modifications in the Modified Version,
      together with at least five of the principal authors of the
      Document (all of its principal authors, if it has less than
      five).</P
></LI
><LI
><P
>State on the Title page
      the name of the publisher of the Modified Version, as the
      publisher.</P
></LI
><LI
><P
>Preserve all the
      copyright notices of the Document.</P
></LI
><LI
><P
>Add an appropriate
      copyright notice for your modifications adjacent to the other
      copyright notices.</P
></LI
><LI
><P
>Include, immediately
      after the copyright notices, a license notice giving the public
      permission to use the Modified Version under the terms of this
      License, in the form shown in the Addendum below.</P
></LI
><LI
><P
>Preserve in that license
      notice the full lists of Invariant Sections and required Cover
      Texts given in the Document's license notice.</P
></LI
><LI
><P
>Include an unaltered
      copy of this License.</P
></LI
><LI
><P
>Preserve the section
      entitled "History", and its title, and add to it an item stating
      at least the title, year, new authors, and publisher of the
      Modified Version as given on the Title Page.  If there is no
      section entitled "History" in the Document, create one stating
      the title, year, authors, and publisher of the Document as given
      on its Title Page, then add an item describing the Modified
      Version as stated in the previous sentence.</P
></LI
><LI
><P
>Preserve the network
      location, if any, given in the Document for public access to a
      Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was
      based on.  These may be placed in the "History" section.  You
      may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission.</P
></LI
><LI
><P
>In any section entitled
      "Acknowledgements" or "Dedications", preserve the section's
      title, and preserve in the section all the substance and tone of
      each of the contributor acknowledgements and/or dedications
      given therein.</P
></LI
><LI
><P
>Preserve all the
      Invariant Sections of the Document, unaltered in their text and
      in their titles.  Section numbers or the equivalent are not
      considered part of the section titles.</P
></LI
><LI
><P
>Delete any section
      entitled "Endorsements".  Such a section may not be included in
      the Modified Version.</P
></LI
><LI
><P
>Do not retitle any
      existing section as "Endorsements" or to conflict in title with
      any Invariant Section.</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections
    or appendices that qualify as Secondary Sections and contain no
    material copied from the Document, you may at your option
    designate some or all of these sections as invariant.  To do this,
    add their titles to the list of Invariant Sections in the Modified
    Version's license notice.  These titles must be distinct from any
    other section titles.</P
><P
>You may add a section entitled "Endorsements", provided it
    contains nothing but endorsements of your Modified Version by
    various parties--for example, statements of peer review or that
    the text has been approved by an organization as the authoritative
    definition of a standard.</P
><P
>You may add a passage of up to five words as a Front-Cover
    Text, and a passage of up to 25 words as a Back-Cover Text, to the
    end of the list of Cover Texts in the Modified Version.  Only one
    passage of Front-Cover Text and one of Back-Cover Text may be
    added by (or through arrangements made by) any one entity.  If the
    Document already includes a cover text for the same cover,
    previously added by you or by arrangement made by the same entity
    you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous
    publisher that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by
    this License give permission to use their names for publicity for
    or to assert or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-5"
>B.6. COMBINING DOCUMENTS</A
></H2
><P
>You may combine the Document with other documents released
    under this License, under the terms defined in section 4 above for
    modified versions, provided that you include in the combination
    all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your
    combined work in its license notice.</P
><P
>The combined work need only contain one copy of this
    License, and multiple identical Invariant Sections may be replaced
    with a single copy.  If there are multiple Invariant Sections with
    the same name but different contents, make the title of each such
    section unique by adding at the end of it, in parentheses, the
    name of the original author or publisher of that section if known,
    or else a unique number.  Make the same adjustment to the section
    titles in the list of Invariant Sections in the license notice of
    the combined work.</P
><P
>In the combination, you must combine any sections entitled
    "History" in the various original documents, forming one section
    entitled "History"; likewise combine any sections entitled
    "Acknowledgements", and any sections entitled "Dedications".  You
    must delete all sections entitled "Endorsements."</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-6"
>B.7. COLLECTIONS OF DOCUMENTS</A
></H2
><P
>You may make a collection consisting of the Document and
    other documents released under this License, and replace the
    individual copies of this License in the various documents with a
    single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of
    the documents in all other respects.</P
><P
>You may extract a single document from such a collection,
    and distribute it individually under this License, provided you
    insert a copy of this License into the extracted document, and
    follow this License in all other respects regarding verbatim
    copying of that document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-7"
>B.8. AGGREGATION WITH INDEPENDENT WORKS</A
></H2
><P
>A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of
    a storage or distribution medium, does not as a whole count as a
    Modified Version of the Document, provided no compilation
    copyright is claimed for the compilation.  Such a compilation is
    called an "aggregate", and this License does not apply to the
    other self-contained works thus compiled with the Document, on
    account of their being thus compiled, if they are not themselves
    derivative works of the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to
    these copies of the Document, then if the Document is less than
    one quarter of the entire aggregate, the Document's Cover Texts
    may be placed on covers that surround only the Document within the
    aggregate.  Otherwise they must appear on covers around the whole
    aggregate.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-8"
>B.9. TRANSLATION</A
></H2
><P
>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section
    4.  Replacing Invariant Sections with translations requires
    special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition
    to the original versions of these Invariant Sections.  You may
    include a translation of this License provided that you also
    include the original English version of this License.  In case of
    a disagreement between the translation and the original English
    version of this License, the original English version will
    prevail.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-9"
>B.10. TERMINATION</A
></H2
><P
>You may not copy, modify, sublicense, or distribute the
    Document except as expressly provided for under this License.  Any
    other attempt to copy, modify, sublicense or distribute the
    Document is void, and will automatically terminate your rights
    under this License.  However, parties who have received copies, or
    rights, from you under this License will not have their licenses
    terminated so long as such parties remain in full
    compliance.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-10"
>B.11. FUTURE REVISIONS OF THIS LICENSE</A
></H2
><P
>The Free Software Foundation may publish new, revised
    versions of the GNU Free Documentation License from time to time.
    Such new versions will be similar in spirit to the present
    version, but may differ in detail to address new problems or
    concerns.  See <A
HREF="http://www.gnu.org/copyleft/"
TARGET="_top"
>http://www.gnu.org/copyleft/</A
>.</P
><P
>Each version of the License is given a distinguishing
    version number.  If the Document specifies that a particular
    numbered version of this License "or any later version" applies to
    it, you have the option of following the terms and conditions
    either of that specified version or of any later version that has
    been published (not as a draft) by the Free Software Foundation.
    If the Document does not specify a version number of this License,
    you may choose any version ever published (not as a draft) by the
    Free Software Foundation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-11"
>B.12. How to use this License for your documents</A
></H2
><P
>To use this License in a document you have written, include
    a copy of the License in the document and put the following
    copyright and license notices just after the title page:</P
><A
NAME="AEN71193"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</P
></BLOCKQUOTE
><P
>If you have no Invariant Sections, write "with no Invariant
    Sections" instead of saying which ones are invariant.  If you have
    no Front-Cover Texts, write "no Front-Cover Texts" instead of
    "Front-Cover Texts being LIST"; likewise for Back-Cover
    Texts.</P
><P
>If your document contains nontrivial examples of program
    code, we recommend releasing these examples in parallel under your
    choice of free software license, such as the GNU General Public
    License, to permit their use in free software.</P
></DIV
></DIV
></DIV
></BODY
></HTML
>