<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Data Definitions for libc</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Linux Standard Base Core Specification, Generic Part"
HREF="book1.html"><LINK
REL="UP"
TITLE="Base Libraries"
HREF="baselib.html"><LINK
REL="PREVIOUS"
TITLE="Interfaces for libc"
HREF="libc.html"><LINK
REL="NEXT"
TITLE="Interface Definitions for libc"
HREF="libcman.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Standard Base Core Specification, Generic Part</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="libc.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 14. Base Libraries</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="libcman.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBC-DDEFS"
>14.4. Data Definitions for libc</A
></H1
><P
>This section defines global identifiers and their values that are associated
with interfaces contained in libc.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.</P
><P
>This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.</P
><P
>This specification uses the <A
HREF="normativerefs.html#STD.ISOC99"
>ISO C (1999)</A
> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7338"
>14.4.1. argz.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef int error_t;
extern error_t argz_add(char **argz, size_t * argz_len, const char *str);
extern error_t argz_add_sep(char **argz, size_t * argz_len,
			    const char *str, int sep);
extern error_t argz_append(char **argz, size_t * argz_len, const char *buf,
			   size_t buf_len);
extern size_t argz_count(const char *argz, size_t * argz_len);
extern error_t argz_create(char *const argv[], char **argz,
			   size_t * argz_len);
extern error_t argz_create_sep(const char *str, int sep, char **argz,
			       size_t * argz_len);
extern void argz_delete(char **argz, size_t * argz_len, char *entry);
extern void argz_extract(const char *argz, size_t argz_len, char **argv);
extern error_t argz_insert(char **argz_insert, size_t * argz_len,
			   char *before, const char *entry);
extern char argz_next(const char *argz, size_t argz_len,
		      const char *entry);
extern error_t argz_replace(char **argz, size_t * argz_len,
			    const char *str, const char *with,
			    unsigned int *replace_count);
extern void argz_stringify(char *argz, size_t argz_len, int sep);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7342"
>14.4.2. arpa/inet.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern uint32_t htonl(uint32_t);
extern uint16_t htons(uint16_t);
extern in_addr_t inet_addr(const char *__cp);
extern int inet_aton(const char *__cp, struct in_addr *__inp);
extern char *inet_ntoa(struct in_addr __in);
extern const char *inet_ntop(int __af, const void *__cp, char *__buf,
			     socklen_t __len);
extern int inet_pton(int __af, const char *__cp, void *__buf);
extern uint32_t ntohl(uint32_t);
extern uint16_t ntohs(uint16_t);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7346"
>14.4.3. assert.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#ifdef NDEBUG
#define assert(expr) ((void)0)
#else
#define assert(expr)	((void) ((expr) ? 0 : (__assert_fail (#expr, __FILE__, __LINE__, __PRETTY_FUNCTION__), 0)))
#endif

extern void __assert_fail(const char *__assertion, const char *__file,
			  unsigned int __line, const char *__function);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7350"
>14.4.4. cpio.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define C_IXOTH	000001
#define C_IWOTH	000002
#define C_IROTH	000004
#define C_IXGRP	000010
#define C_IWGRP	000020
#define C_IRGRP	000040
#define C_IXUSR	000100
#define C_IWUSR	000200
#define C_IRUSR	000400
#define C_ISVTX	001000
#define C_ISGID	002000
#define C_ISUID	004000
#define C_ISFIFO	010000
#define C_ISREG	0100000
#define C_ISCTG	0110000
#define C_ISLNK	0120000
#define C_ISSOCK	0140000
#define C_ISCHR	020000
#define C_ISDIR	040000
#define C_ISBLK	060000
#define MAGIC	"070707"</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7354"
>14.4.5. ctype.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern const unsigned short **__ctype_b_loc(void);
extern const int32_t **__ctype_tolower_loc(void);
extern const int32_t **__ctype_toupper_loc(void);
extern int _tolower(int);
extern int _toupper(int);
extern int isalnum(int);
extern int isalnum_l(int c, locale_t locale);
extern int isalpha(int);
extern int isalpha_l(int c, locale_t locale);
extern int isascii(int __c);
extern int isblank(int);
extern int isblank_l(int c, locale_t locale);
extern int iscntrl(int);
extern int iscntrl_l(int c, locale_t locale);
extern int isdigit(int);
extern int isdigit_l(int c, locale_t locale);
extern int isgraph(int);
extern int isgraph_l(int c, locale_t locale);
extern int islower(int);
extern int islower_l(int c, locale_t locale);
extern int isprint(int);
extern int isprint_l(int c, locale_t locale);
extern int ispunct(int);
extern int ispunct_l(int c, locale_t locale);
extern int isspace(int);
extern int isspace_l(int c, locale_t locale);
extern int isupper(int);
extern int isupper_l(int c, locale_t locale);
extern int isxdigit(int);
extern int isxdigit_l(int c, locale_t locale);
extern int toascii(int __c);
extern int tolower(int __c);
extern int tolower_l(int c, locale_t locale);
extern int toupper(int __c);
extern int toupper_l(int c, locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7358"
>14.4.6. dirent.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MAXNAMLEN	NAME_MAX

typedef struct __dirstream DIR;

struct dirent {
    long int d_ino;
    off_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
struct dirent64 {
    uint64_t d_ino;
    int64_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
extern int alphasort(const struct dirent **__e1,
		     const struct dirent **__e2);
extern int alphasort64(const struct dirent64 **__e1,
		       const struct dirent64 **__e2);
extern int closedir(DIR * __dirp);
extern int dirfd(DIR * __dirp);
extern DIR *fdopendir(int __fd);
extern DIR *opendir(const char *__name);
extern struct dirent *readdir(DIR * __dirp);
extern struct dirent64 *readdir64(DIR * __dirp);
extern int readdir64_r(DIR * __dirp, struct dirent64 *__entry,
		       struct dirent64 **__result);
extern int readdir_r(DIR * __dirp, struct dirent *__entry,
		     struct dirent **__result);
extern void rewinddir(DIR * __dirp);
extern int scandir(const char *__dir, struct dirent ***__namelist,
		   int (*__selector) (const struct dirent *),
		   int (*__cmp) (const struct dirent * *,
				 const struct dirent * *));
extern int scandir64(const char *__dir, struct dirent64 ***__namelist,
		     int (*__selector) (const struct dirent64 *),
		     int (*__cmp) (const struct dirent64 * *,
				   const struct dirent64 * *));
extern void seekdir(DIR * __dirp, long int __pos);
extern long int telldir(DIR * __dirp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7362"
>14.4.7. elf.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ELFMAG1	'E'
#define ELFMAG3	'F'
#define ELFMAG2	'L'
#define ELF64_R_INFO(sym, type)	((((Elf64_Xword) (sym)) &#60;&#60; 32) + (type))
#define ELF32_ST_INFO(bind,type)	(((bind) &#60;&#60; 4) + ((type) &#38; 0xf))
#define ELF32_R_INFO(sym, type)	(((sym) &#60;&#60; 8) + ((type) &#38; 0xff))
#define ELF32_M_INFO(sym, size)	(((sym) &#60;&#60; 8) + (unsigned char) (size))
#define ELF32_ST_BIND(val)	(((unsigned char) (val)) &#62;&#62; 4)
#define ELF64_R_TYPE(i)	((i) &#38; 0xffffffff)
#define ELF64_R_SYM(i)	((i) &#62;&#62; 32)
#define ELF32_M_SYM(info)	((info) &#62;&#62; 8)
#define ELF32_ST_VISIBILITY(o)	((o) &#38; 0x03)
#define ELF32_M_SIZE(info)	((unsigned char) (info))
#define ELF32_ST_TYPE(val)	((val) &#38; 0xf)
#define ELF32_R_TYPE(val)	((val) &#38; 0xff)
#define ELF32_R_SYM(val)	((val) &#62;&#62; 8)
#define PF_X	(1 &#60;&#60; 0)
#define SHF_WRITE	(1 &#60;&#60; 0)
#define PF_W	(1 &#60;&#60; 1)
#define SHF_ALLOC	(1 &#60;&#60; 1)
#define SHF_TLS	(1 &#60;&#60; 10)
#define PF_R	(1 &#60;&#60; 2)
#define SHF_EXECINSTR	(1 &#60;&#60; 2)
#define SHF_MERGE	(1 &#60;&#60; 4)
#define SHF_STRINGS	(1 &#60;&#60; 5)
#define SHF_INFO_LINK	(1 &#60;&#60; 6)
#define SHF_LINK_ORDER	(1 &#60;&#60; 7)
#define SHF_OS_NONCONFORMING	(1 &#60;&#60; 8)
#define SHF_GROUP	(1 &#60;&#60; 9)
#define EI_NIDENT	(16)
#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))
#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
#define DT_PPC64_GLINK	(DT_LOPROC + 0)
#define DT_PPC_GOT	(DT_LOPROC + 0)
#define DT_PPC64_OPD	(DT_LOPROC + 1)
#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))
#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))
#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)
#define PT_IA_64_UNWIND	(PT_LOPROC + 1)
#define SHT_IA_64_EXT	(SHT_LOPROC + 0)
#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1)
#define DT_NULL	0
#define EI_MAG0	0
#define ELFCLASSNONE	0
#define ELFDATANONE	0
#define ELFOSABI_NONE	0
#define ELFOSABI_SYSV	0
#define ELF_NOTE_OS_LINUX	0
#define EM_NONE	0
#define ET_NONE	0
#define EV_NONE	0
#define PT_NULL	0
#define R_386_NONE	0
#define R_390_NONE	0
#define R_PPC_NONE	0
#define R_X86_64_NONE	0
#define SHN_UNDEF	0
#define SHT_NULL	0
#define STB_LOCAL	0
#define STN_UNDEF	0
#define STT_NOTYPE	0
#define STV_DEFAULT	0
#define SYMINFO_NONE	0
#define R_IA64_NONE	0x00
#define DF_1_NOW	0x00000001
#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
#define DF_P1_LAZYLOAD	0x00000001
#define DTF_1_PARINIT	0x00000001
#define EF_S390_HIGH_GPRS	0x00000001
#define DF_1_GLOBAL	0x00000002
#define DF_P1_GROUPPERM	0x00000002
#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions start with this object */
#define DTF_1_CONFEXP	0x00000002
#define DF_1_GROUP	0x00000004
#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
#define DF_1_NODELETE	0x00000008
#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
#define EF_IA_64_MASKOS	0x0000000f
#define DF_1_LOADFLTR	0x00000010
#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
#define EF_IA_64_ABI64	0x00000010
#define DF_1_INITFIRST	0x00000020
#define DF_1_NOOPEN	0x00000040
#define DF_1_ORIGIN	0x00000080
#define DF_1_DIRECT	0x00000100
#define DF_1_TRANS	0x00000200
#define DF_1_INTERPOSE	0x00000400
#define DF_1_NODEFLIB	0x00000800
#define DF_1_NODUMP	0x00001000
#define DF_1_CONFALT	0x00002000
#define DF_1_ENDFILTEE	0x00004000
#define DF_1_DISPRELDNE	0x00008000
#define SYMINFO_FLG_DIRECT	0x0001
#define DF_1_DISPRELPND	0x00010000
#define SYMINFO_FLG_PASSTHRU	0x0002
#define SYMINFO_FLG_COPY	0x0004
#define SYMINFO_FLG_LAZYLOAD	0x0008
#define EF_CPU32	0x00810000
#define PF_MASKOS	0x0ff00000
#define SHF_MASKOS	0x0ff00000
#define GRP_COMDAT	0x1
#define SHF_IA_64_SHORT	0x10000000
#define SHF_IA_64_NORECOV	0x20000000
#define R_IA64_IMM14	0x21
#define R_IA64_IMM22	0x22
#define R_IA64_IMM64	0x23
#define R_IA64_DIR32MSB	0x24
#define R_IA64_DIR32LSB	0x25
#define R_IA64_DIR64MSB	0x26
#define R_IA64_DIR64LSB	0x27
#define R_IA64_GPREL22	0x2a
#define R_IA64_GPREL64I	0x2b
#define R_IA64_GPREL32MSB	0x2c
#define R_IA64_GPREL32LSB	0x2d
#define R_IA64_GPREL64MSB	0x2e
#define R_IA64_GPREL64LSB	0x2f
#define R_IA64_LTOFF22	0x32
#define R_IA64_LTOFF64I	0x33
#define R_IA64_PLTOFF22	0x3a
#define R_IA64_PLTOFF64I	0x3b
#define R_IA64_PLTOFF64MSB	0x3e
#define R_IA64_PLTOFF64LSB	0x3f
#define R_IA64_FPTR64I	0x43
#define R_IA64_FPTR32MSB	0x44
#define R_IA64_FPTR32LSB	0x45
#define R_IA64_FPTR64MSB	0x46
#define R_IA64_FPTR64LSB	0x47
#define R_IA64_PCREL60B	0x48
#define R_IA64_PCREL21B	0x49
#define R_IA64_PCREL21M	0x4a
#define R_IA64_PCREL21F	0x4b
#define R_IA64_PCREL32MSB	0x4c
#define R_IA64_PCREL32LSB	0x4d
#define R_IA64_PCREL64MSB	0x4e
#define R_IA64_PCREL64LSB	0x4f
#define R_IA64_LTOFF_FPTR22	0x52
#define R_IA64_LTOFF_FPTR64I	0x53
#define R_IA64_LTOFF_FPTR32MSB	0x54
#define R_IA64_LTOFF_FPTR32LSB	0x55
#define R_IA64_LTOFF_FPTR64MSB	0x56
#define R_IA64_LTOFF_FPTR64LSB	0x57
#define R_IA64_SEGREL32MSB	0x5c
#define R_IA64_SEGREL32LSB	0x5d
#define R_IA64_SEGREL64MSB	0x5e
#define R_IA64_SEGREL64LSB	0x5f
#define PT_LOOS	0x60000000
#define SHT_LOOS	0x60000000
#define DT_LOOS	0x6000000d
#define R_IA64_SECREL32MSB	0x64
#define PT_GNU_EH_FRAME	0x6474e550
#define PT_GNU_STACK	0x6474e551
#define PT_GNU_RELRO	0x6474e552
#define R_IA64_SECREL32LSB	0x65
#define R_IA64_SECREL64MSB	0x66
#define R_IA64_SECREL64LSB	0x67
#define R_IA64_REL32MSB	0x6c
#define R_IA64_REL32LSB	0x6d
#define R_IA64_REL64MSB	0x6e
#define R_IA64_REL64LSB	0x6f
#define DT_HIOS	0x6ffff000
#define DT_VALRNGLO	0x6ffffd00
#define DT_GNU_PRELINKED	0x6ffffdf5
#define DT_GNU_CONFLICTSZ	0x6ffffdf6
#define DT_GNU_LIBLISTSZ	0x6ffffdf7
#define DT_CHECKSUM	0x6ffffdf8
#define DT_PLTPADSZ	0x6ffffdf9
#define DT_MOVEENT	0x6ffffdfa
#define DT_MOVESZ	0x6ffffdfb
#define DT_FEATURE_1	0x6ffffdfc
#define DT_POSFLAG_1	0x6ffffdfd
#define DT_SYMINSZ	0x6ffffdfe
#define DT_SYMINENT	0x6ffffdff
#define DT_VALRNGHI	0x6ffffdff
#define DT_ADDRRNGLO	0x6ffffe00
#define DT_GNU_HASH	0x6ffffef5
#define DT_TLSDESC_PLT	0x6ffffef6
#define DT_TLSDESC_GOT	0x6ffffef7
#define DT_GNU_CONFLICT	0x6ffffef8
#define DT_GNU_LIBLIST	0x6ffffef9
#define DT_CONFIG	0x6ffffefa
#define DT_DEPAUDIT	0x6ffffefb
#define DT_AUDIT	0x6ffffefc
#define DT_PLTPAD	0x6ffffefd
#define DT_MOVETAB	0x6ffffefe
#define DT_ADDRRNGHI	0x6ffffeff
#define DT_SYMINFO	0x6ffffeff
#define DT_VERSYM	0x6ffffff0
#define SHT_GNU_ATTRIBUTES	0x6ffffff5
#define SHT_GNU_HASH	0x6ffffff6
#define SHT_GNU_LIBLIST	0x6ffffff7
#define SHT_CHECKSUM	0x6ffffff8
#define DT_RELACOUNT	0x6ffffff9
#define DT_RELCOUNT	0x6ffffffa
#define DT_FLAGS_1	0x6ffffffb
#define DT_VERDEF	0x6ffffffc
#define DT_VERDEFNUM	0x6ffffffd
#define SHT_GNU_verdef	0x6ffffffd
#define DT_VERNEED	0x6ffffffe
#define SHT_GNU_verneed	0x6ffffffe
#define DT_VERNEEDNUM	0x6fffffff
#define PT_HIOS	0x6fffffff
#define SHT_GNU_versym	0x6fffffff
#define SHT_HIOS	0x6fffffff
#define DT_LOPROC	0x70000000
#define PT_LOPROC	0x70000000
#define SHT_LOPROC	0x70000000
#define R_IA64_LTV32MSB	0x74
#define R_IA64_LTV32LSB	0x75
#define R_IA64_LTV64MSB	0x76
#define R_IA64_LTV64LSB	0x77
#define R_IA64_PCREL21BI	0x79
#define R_IA64_PCREL22	0x7a
#define R_IA64_PCREL64I	0x7b
#define ELFMAG0	0x7f
#define DT_AUXILIARY	0x7ffffffd
#define DT_FILTER	0x7fffffff
#define DT_HIPROC	0x7fffffff
#define PT_HIPROC	0x7fffffff
#define SHT_HIPROC	0x7fffffff
#define R_IA64_IPLTMSB	0x80
#define PF_IA_64_NORECOV	0x80000000
#define SHT_LOUSER	0x80000000
#define R_IA64_IPLTLSB	0x81
#define R_IA64_COPY	0x84
#define R_IA64_SUB	0x85
#define R_IA64_LTOFF22X	0x86
#define R_IA64_LDXMOV	0x87
#define SHT_HIUSER	0x8fffffff
#define R_IA64_TPREL14	0x91
#define R_IA64_TPREL22	0x92
#define R_IA64_TPREL64I	0x93
#define R_IA64_TPREL64MSB	0x96
#define R_IA64_TPREL64LSB	0x97
#define R_IA64_LTOFF_TPREL22	0x9a
#define R_IA64_DTPMOD64MSB	0xa6
#define R_IA64_DTPMOD64LSB	0xa7
#define R_IA64_LTOFF_DTPMOD22	0xaa
#define R_IA64_DTPREL14	0xb1
#define R_IA64_DTPREL22	0xb2
#define R_IA64_DTPREL64I	0xb3
#define R_IA64_DTPREL32MSB	0xb4
#define R_IA64_DTPREL32LSB	0xb5
#define R_IA64_DTPREL64MSB	0xb6
#define R_IA64_DTPREL64LSB	0xb7
#define R_IA64_LTOFF_DTPREL22	0xba
#define PF_MASKPROC	0xf0000000
#define SHF_MASKPROC	0xf0000000
#define ET_LOOS	0xfe00
#define ET_HIOS	0xfeff
#define ET_LOPROC	0xff00
#define SHN_LOPROC	0xff00
#define SHN_LORESERVE	0xff00
#define SYMINFO_BT_LOWRESERVE	0xff00
#define EF_IA_64_ARCH	0xff000000
#define SHN_HIPROC	0xff1f
#define SHN_LOOS	0xff20
#define SHN_HIOS	0xff3f
#define SHN_ABS	0xfff1
#define SHN_COMMON	0xfff2
#define SYMINFO_BT_PARENT	0xfffe
#define ET_HIPROC	0xffff
#define PN_XNUM	0xffff
#define SHN_HIRESERVE	0xffff
#define SHN_XINDEX	0xffff
#define SYMINFO_BT_SELF	0xffff
#define DT_IA_64_NUM	1
#define DT_NEEDED	1
#define DT_PPC_NUM	1
#define EI_MAG1	1
#define ELFCLASS32	1
#define ELFDATA2LSB	1
#define ELF_NOTE_OS_GNU	1
#define ET_REL	1
#define EV_CURRENT	1
#define NT_GNU_ABI_TAG	1
#define PT_LOAD	1
#define R_386_32	1
#define R_390_8	1
#define R_PPC_ADDR32	1
#define R_X86_64_64	1
#define SHT_PROGBITS	1
#define STB_GLOBAL	1
#define STT_OBJECT	1
#define STV_INTERNAL	1
#define SYMINFO_CURRENT	1
#define DT_STRSZ	10
#define R_386_GOTPC	10
#define R_390_GLOB_DAT	10
#define R_PPC_REL24	10
#define R_X86_64_32	10
#define SHT_SHLIB	10
#define STB_LOOS	10
#define STT_GNU_IFUNC	10
#define STT_LOOS	10
#define R_PPC64_TPREL16_HIGHESTA	100
#define R_PPC64_DTPREL16_DS	101
#define R_PPC64_DTPREL16_LO_DS	102
#define R_PPC64_DTPREL16_HIGHER	103
#define R_PPC64_DTPREL16_HIGHERA	104
#define R_PPC64_DTPREL16_HIGHEST	105
#define R_PPC64_DTPREL16_HIGHESTA	106
#define DT_ADDRNUM	11
#define DT_SYMENT	11
#define R_386_32PLT	11
#define R_390_JMP_SLOT	11
#define R_PPC_REL14	11
#define R_X86_64_32S	11
#define SHT_DYNSYM	11
#define DT_INIT	12
#define DT_VALNUM	12
#define R_390_RELATIVE	12
#define R_PPC_REL14_BRTAKEN	12
#define R_X86_64_16	12
#define STB_HIOS	12
#define STT_HIOS	12
#define DT_FINI	13
#define R_390_GOTOFF32	13
#define R_PPC_REL14_BRNTAKEN	13
#define R_X86_64_PC16	13
#define STB_LOPROC	13
#define STT_LOPROC	13
#define DT_SONAME	14
#define R_386_TLS_TPOFF	14
#define R_390_GOTPC	14
#define R_PPC_GOT16	14
#define R_X86_64_8	14
#define SHT_INIT_ARRAY	14
#define DT_RPATH	15
#define R_386_TLS_IE	15
#define R_390_GOT16	15
#define R_PPC_GOT16_LO	15
#define R_X86_64_PC8	15
#define SHT_FINI_ARRAY	15
#define STB_HIPROC	15
#define STT_HIPROC	15
#define DT_SYMBOLIC	16
#define DT_VERSIONTAGNUM	16
#define R_386_TLS_GOTIE	16
#define R_390_PC16	16
#define R_PPC_GOT16_HI	16
#define R_X86_64_DTPMOD64	16
#define SHT_PREINIT_ARRAY	16
#define DT_REL	17
#define R_386_TLS_LE	17
#define R_390_PC16DBL	17
#define R_PPC_GOT16_HA	17
#define R_X86_64_DTPOFF64	17
#define SHT_GROUP	17
#define DT_RELSZ	18
#define R_386_TLS_GD	18
#define R_390_PLT16DBL	18
#define R_PPC_PLTREL24	18
#define R_X86_64_TPOFF64	18
#define SHT_SYMTAB_SHNDX	18
#define DT_RELENT	19
#define R_386_TLS_LDM	19
#define R_390_PC32DBL	19
#define R_PPC_COPY	19
#define R_X86_64_TLSGD	19
#define DT_PLTRELSZ	2
#define EI_MAG2	2
#define ELFCLASS64	2
#define ELFDATA2MSB	2
#define ELF_NOTE_OS_SOLARIS2	2
#define ET_EXEC	2
#define EV_NUM	2
#define PT_DYNAMIC	2
#define R_386_PC32	2
#define R_390_12	2
#define R_PPC_ADDR24	2
#define R_X86_64_PC32	2
#define SHT_SYMTAB	2
#define STB_WEAK	2
#define STT_FUNC	2
#define STV_HIDDEN	2
#define SYMINFO_NUM	2
#define DT_PLTREL	20
#define EM_PPC	20
#define R_386_16	20
#define R_390_PLT32DBL	20
#define R_PPC_GLOB_DAT	20
#define R_X86_64_TLSLD	20
#define DT_DEBUG	21
#define EM_PPC64	21
#define R_386_PC16	21
#define R_390_GOTPCDBL	21
#define R_PPC_JMP_SLOT	21
#define R_X86_64_DTPOFF32	21
#define DT_TEXTREL	22
#define EM_S390	22
#define R_386_8	22
#define R_390_64	22
#define R_PPC_RELATIVE	22
#define R_X86_64_GOTTPOFF	22
#define DT_JMPREL	23
#define R_386_PC8	23
#define R_390_PC64	23
#define R_PPC_LOCAL24PC	23
#define R_X86_64_TPOFF32	23
#define DT_BIND_NOW	24
#define R_386_TLS_GD_32	24
#define R_390_GOT64	24
#define R_PPC_UADDR32	24
#define R_X86_64_PC64	24
#define R_PPC64_JMP_IREL	247
#define R_PPC64_IRELATIVE	248
#define R_PPC_IRELATIVE	248
#define R_PPC64_REL16	249
#define R_PPC_REL16	249
#define DT_INIT_ARRAY	25
#define R_386_TLS_GD_PUSH	25
#define R_390_PLT64	25
#define R_PPC_UADDR16	25
#define R_X86_64_GOTOFF64	25
#define R_PPC64_REL16_LO	250
#define R_PPC_REL16_LO	250
#define R_PPC64_REL16_HI	251
#define R_PPC_REL16_HI	251
#define R_PPC64_REL16_HA	252
#define R_PPC_REL16_HA	252
#define R_PPC_TOC16	255
#define DT_FINI_ARRAY	26
#define R_386_TLS_GD_CALL	26
#define R_390_GOTENT	26
#define R_PPC_REL32	26
#define R_X86_64_GOTPC32	26
#define DT_INIT_ARRAYSZ	27
#define R_386_TLS_GD_POP	27
#define R_390_GOTOFF16	27
#define R_PPC_PLT32	27
#define R_X86_64_GOT64	27
#define DT_FINI_ARRAYSZ	28
#define R_386_TLS_LDM_32	28
#define R_390_GOTOFF64	28
#define R_PPC_PLTREL32	28
#define R_X86_64_GOTPCREL64	28
#define DT_RUNPATH	29
#define R_386_TLS_LDM_PUSH	29
#define R_390_GOTPLT12	29
#define R_PPC_PLT16_LO	29
#define R_X86_64_GOTPC64	29
#define DT_EXTRANUM	3
#define DT_PLTGOT	3
#define DT_PPC64_NUM	3
#define EI_MAG3	3
#define ELFCLASSNUM	3
#define ELFDATANUM	3
#define ELFOSABI_LINUX	3
#define ELF_NOTE_OS_FREEBSD	3
#define EM_386	3
#define ET_DYN	3
#define PT_INTERP	3
#define R_386_GOT32	3
#define R_390_16	3
#define R_PPC_ADDR16	3
#define R_X86_64_GOT32	3
#define SHT_STRTAB	3
#define STB_NUM	3
#define STT_SECTION	3
#define STV_PROTECTED	3
#define DT_FLAGS	30
#define R_386_TLS_LDM_CALL	30
#define R_390_GOTPLT16	30
#define R_PPC_PLT16_HI	30
#define R_X86_64_GOTPLT64	30
#define R_386_TLS_LDM_POP	31
#define R_390_GOTPLT32	31
#define R_PPC_PLT16_HA	31
#define R_X86_64_PLTOFF64	31
#define DT_ENCODING	32
#define DT_PREINIT_ARRAY	32
#define R_386_TLS_LDO_32	32
#define R_390_GOTPLT64	32
#define R_PPC_SDAREL16	32
#define R_X86_64_SIZE32	32
#define DT_PREINIT_ARRAYSZ	33
#define R_386_TLS_IE_32	33
#define R_390_GOTPLTENT	33
#define R_PPC_SECTOFF	33
#define R_X86_64_SIZE64	33
#define DT_NUM	34
#define R_386_TLS_LE_32	34
#define R_390_PLTOFF16	34
#define R_PPC_SECTOFF_LO	34
#define R_X86_64_GOTPC32_TLSDESC	34
#define R_386_TLS_DTPMOD32	35
#define R_390_PLTOFF32	35
#define R_PPC_SECTOFF_HI	35
#define R_X86_64_TLSDESC_CALL	35
#define R_386_TLS_DTPOFF32	36
#define R_390_PLTOFF64	36
#define R_PPC_SECTOFF_HA	36
#define R_X86_64_TLSDESC	36
#define R_386_TLS_TPOFF32	37
#define R_390_TLS_LOAD	37
#define R_PPC64_ADDR30	37
#define R_X86_64_IRELATIVE	37
#define R_390_TLS_GDCALL	38
#define R_PPC64_ADDR64	38
#define R_X86_64_NUM	38
#define R_386_TLS_GOTDESC	39
#define R_390_TLS_LDCALL	39
#define R_PPC64_ADDR16_HIGHER	39
#define DT_HASH	4
#define EI_CLASS	4
#define ET_CORE	4
#define PT_NOTE	4
#define R_386_PLT32	4
#define R_390_32	4
#define R_PPC_ADDR16_LO	4
#define R_X86_64_PLT32	4
#define SELFMAG	4
#define SHT_RELA	4
#define STT_FILE	4
#define EM_ARM	40
#define R_386_TLS_DESC_CALL	40
#define R_390_TLS_GD32	40
#define R_PPC64_ADDR16_HIGHERA	40
#define R_386_TLS_DESC	41
#define R_390_TLS_GD64	41
#define R_PPC64_ADDR16_HIGHEST	41
#define R_386_IRELATIVE	42
#define R_390_TLS_GOTIE12	42
#define R_PPC64_ADDR16_HIGHESTA	42
#define R_386_NUM	43
#define R_390_TLS_GOTIE32	43
#define R_PPC64_UADDR64	43
#define R_390_TLS_GOTIE64	44
#define R_PPC64_REL64	44
#define R_390_TLS_LDM32	45
#define R_PPC64_PLT64	45
#define R_390_TLS_LDM64	46
#define R_PPC64_PLTREL64	46
#define R_390_TLS_IE32	47
#define R_PPC64_TOC16	47
#define R_390_TLS_IE64	48
#define R_PPC64_TOC16_LO	48
#define R_390_TLS_IEENT	49
#define R_PPC64_TOC16_HI	49
#define DT_STRTAB	5
#define EI_DATA	5
#define ET_NUM	5
#define PT_SHLIB	5
#define R_386_COPY	5
#define R_390_PC32	5
#define R_PPC_ADDR16_HI	5
#define R_X86_64_COPY	5
#define SHT_HASH	5
#define STT_COMMON	5
#define EM_IA_64	50
#define R_390_TLS_LE32	50
#define R_PPC64_TOC16_HA	50
#define R_390_TLS_LE64	51
#define R_PPC64_TOC	51
#define R_390_TLS_LDO32	52
#define R_PPC64_PLTGOT16	52
#define R_390_TLS_LDO64	53
#define R_PPC64_PLTGOT16_LO	53
#define R_390_TLS_DTPMOD	54
#define R_PPC64_PLTGOT16_HI	54
#define R_390_TLS_DTPOFF	55
#define R_PPC64_PLTGOT16_HA	55
#define R_390_TLS_TPOFF	56
#define R_PPC64_ADDR16_DS	56
#define R_390_20	57
#define R_PPC64_ADDR16_LO_DS	57
#define R_390_GOT20	58
#define R_PPC64_GOT16_DS	58
#define R_390_GOTPLT20	59
#define R_PPC64_GOT16_LO_DS	59
#define DT_SYMTAB	6
#define EI_VERSION	6
#define PT_PHDR	6
#define R_386_GLOB_DAT	6
#define R_390_GOT12	6
#define R_PPC_ADDR16_HA	6
#define R_X86_64_GLOB_DAT	6
#define SHT_DYNAMIC	6
#define STT_TLS	6
#define R_390_TLS_GOTIE20	60
#define R_PPC64_PLT16_LO_DS	60
#define R_390_NUM	61
#define R_PPC64_SECTOFF_DS	61
#define EM_X86_64	62
#define R_PPC64_SECTOFF_LO_DS	62
#define R_PPC64_TOC16_DS	63
#define R_PPC64_TOC16_LO_DS	64
#define R_PPC64_PLTGOT16_DS	65
#define R_PPC64_PLTGOT16_LO_DS	66
#define R_PPC64_TLS	67
#define R_PPC_TLS	67
#define R_PPC64_DTPMOD64	68
#define R_PPC_DTPMOD32	68
#define R_PPC64_TPREL16	69
#define R_PPC_TPREL16	69
#define DT_RELA	7
#define EI_OSABI	7
#define PT_TLS	7
#define R_386_JMP_SLOT	7
#define R_390_GOT32	7
#define R_PPC_ADDR14	7
#define R_X86_64_JUMP_SLOT	7
#define SHT_NOTE	7
#define STT_NUM	7
#define R_PPC64_TPREL16_LO	70
#define R_PPC_TPREL16_LO	70
#define R_PPC64_TPREL16_HI	71
#define R_PPC_TPREL16_HI	71
#define R_PPC64_TPREL16_HA	72
#define R_PPC_TPREL16_HA	72
#define R_PPC64_TPREL64	73
#define R_PPC_TPREL32	73
#define R_PPC64_DTPREL16	74
#define R_PPC_DTPREL16	74
#define R_PPC64_DTPREL16_LO	75
#define R_PPC_DTPREL16_LO	75
#define R_PPC64_DTPREL16_HI	76
#define R_PPC_DTPREL16_HI	76
#define R_PPC64_DTPREL16_HA	77
#define R_PPC_DTPREL16_HA	77
#define R_PPC64_DTPREL64	78
#define R_PPC_DTPREL32	78
#define R_PPC64_GOT_TLSGD16	79
#define R_PPC_GOT_TLSGD16	79
#define DT_RELASZ	8
#define EI_ABIVERSION	8
#define PT_NUM	8
#define R_386_RELATIVE	8
#define R_390_PLT32	8
#define R_PPC_ADDR14_BRTAKEN	8
#define R_X86_64_RELATIVE	8
#define SHT_NOBITS	8
#define R_PPC64_GOT_TLSGD16_LO	80
#define R_PPC_GOT_TLSGD16_LO	80
#define R_PPC64_GOT_TLSGD16_HI	81
#define R_PPC_GOT_TLSGD16_HI	81
#define R_PPC64_GOT_TLSGD16_HA	82
#define R_PPC_GOT_TLSGD16_HA	82
#define R_PPC64_GOT_TLSLD16	83
#define R_PPC_GOT_TLSLD16	83
#define R_PPC64_GOT_TLSLD16_LO	84
#define R_PPC_GOT_TLSLD16_LO	84
#define R_PPC64_GOT_TLSLD16_HI	85
#define R_PPC_GOT_TLSLD16_HI	85
#define R_PPC64_GOT_TLSLD16_HA	86
#define R_PPC_GOT_TLSLD16_HA	86
#define R_PPC64_GOT_TPREL16_DS	87
#define R_PPC_GOT_TPREL16	87
#define R_PPC64_GOT_TPREL16_LO_DS	88
#define R_PPC_GOT_TPREL16_LO	88
#define R_PPC64_GOT_TPREL16_HI	89
#define R_PPC_GOT_TPREL16_HI	89
#define DT_RELAENT	9
#define EI_PAD	9
#define R_386_GOTOFF	9
#define R_390_COPY	9
#define R_PPC_ADDR14_BRNTAKEN	9
#define R_X86_64_GOTPCREL	9
#define SHT_REL	9
#define R_PPC64_GOT_TPREL16_HA	90
#define R_PPC_GOT_TPREL16_HA	90
#define R_PPC64_GOT_DTPREL16_DS	91
#define R_PPC_GOT_DTPREL16	91
#define R_PPC64_GOT_DTPREL16_LO_DS	92
#define R_PPC_GOT_DTPREL16_LO	92
#define R_PPC64_GOT_DTPREL16_HI	93
#define R_PPC_GOT_DTPREL16_HI	93
#define R_PPC64_GOT_DTPREL16_HA	94
#define R_PPC_GOT_DTPREL16_HA	94
#define R_PPC64_TPREL16_DS	95
#define R_PPC64_TPREL16_LO_DS	96
#define R_PPC64_TPREL16_HIGHER	97
#define R_PPC64_TPREL16_HIGHERA	98
#define R_PPC64_TPREL16_HIGHEST	99
#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
#define ELF64_ST_BIND(val)	ELF32_ST_BIND (val)
#define ELF64_ST_INFO(bind,type)	ELF32_ST_INFO ((bind), (type))
#define ELF64_ST_TYPE(val)	ELF32_ST_TYPE (val)
#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY(o)
#define ELF_NOTE_GNU	"GNU"
#define ELF_NOTE_ABI	NT_GNU_ABI_TAG
#define R_PPC64_ADDR14	R_PPC_ADDR14
#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
#define R_PPC64_ADDR16	R_PPC_ADDR16
#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA
#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI
#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO
#define R_PPC64_ADDR24	R_PPC_ADDR24
#define R_PPC64_ADDR32	R_PPC_ADDR32
#define R_PPC64_COPY	R_PPC_COPY
#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
#define R_PPC64_GOT16	R_PPC_GOT16
#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
#define R_PPC64_NONE	R_PPC_NONE
#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
#define R_PPC64_PLT32	R_PPC_PLT32
#define R_PPC64_PLTREL32	R_PPC_PLTREL32
#define R_PPC64_REL14	R_PPC_REL14
#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
#define R_PPC64_REL24	R_PPC_REL24
#define R_PPC64_REL32	R_PPC_REL32
#define R_PPC64_RELATIVE	R_PPC_RELATIVE
#define R_PPC64_SECTOFF	R_PPC_SECTOFF
#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
#define R_PPC64_UADDR16	R_PPC_UADDR16
#define R_PPC64_UADDR32	R_PPC_UADDR32
#define ELFMAG	"\177ELF"

typedef uint32_t Elf32_Addr;
typedef uint64_t Elf64_Addr;
typedef uint32_t Elf32_Word;
typedef uint32_t Elf64_Word;
typedef int32_t Elf32_Sword;
typedef int32_t Elf64_Sword;
typedef uint64_t Elf32_Xword;
typedef uint64_t Elf64_Xword;
typedef int64_t Elf32_Sxword;
typedef int64_t Elf64_Sxword;
typedef uint32_t Elf32_Off;
typedef uint64_t Elf64_Off;
typedef struct {
    Elf32_Word p_type;		/* Segment type */
    Elf32_Off p_offset;		/* Segment file offset */
    Elf32_Addr p_vaddr;		/* Segment virtual address */
    Elf32_Addr p_paddr;		/* Segment physical address */
    Elf32_Word p_filesz;	/* Segment size in file */
    Elf32_Word p_memsz;		/* Segment size in memory */
    Elf32_Word p_flags;		/* Segment flags */
    Elf32_Word p_align;		/* Segment alignment */
} Elf32_Phdr;
typedef struct {
    Elf64_Word p_type;		/* Segment type */
    Elf64_Word p_flags;		/* Segment flags */
    Elf64_Off p_offset;		/* Segment file offset */
    Elf64_Addr p_vaddr;		/* Segment virtual address */
    Elf64_Addr p_paddr;		/* Segment physical address */
    Elf64_Xword p_filesz;	/* Segment size in file */
    Elf64_Xword p_memsz;	/* Segment size in memory */
    Elf64_Xword p_align;	/* Segment alignment */
} Elf64_Phdr;
typedef uint16_t Elf32_Half;
typedef uint16_t Elf64_Half;
typedef uint16_t Elf32_Section;
typedef uint16_t Elf64_Section;
typedef struct {
    Elf32_Word n_namesz;
    Elf32_Word n_descsz;
    Elf32_Word n_type;
} Elf32_Nhdr;
typedef struct {
    Elf64_Word n_namesz;
    Elf64_Word n_descsz;
    Elf64_Word n_type;
} Elf64_Nhdr;
typedef struct {
    Elf64_Word st_name;
    unsigned char st_info;
    unsigned char st_other;
    Elf64_Section st_shndx;
    Elf64_Addr st_value;
    Elf64_Xword st_size;
} Elf64_Sym;
typedef struct {
    Elf32_Word st_name;
    Elf32_Addr st_value;
    Elf32_Word st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf32_Section st_shndx;
} Elf32_Sym;
typedef struct {
    Elf64_Addr r_offset;
    Elf64_Xword r_info;
} Elf64_Rel;
typedef struct {
    Elf32_Addr r_offset;
    Elf32_Word r_info;
} Elf32_Rel;
typedef struct {
    Elf64_Addr r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
} Elf64_Rela;
typedef struct {
    Elf32_Addr r_offset;
    Elf32_Word r_info;
    Elf32_Sword r_addend;
} Elf32_Rela;
typedef struct {
    Elf32_Half vd_version;
    Elf32_Half vd_flags;
    Elf32_Half vd_ndx;
    Elf32_Half vd_cnt;
    Elf32_Word vd_hash;
    Elf32_Word vd_aux;
    Elf32_Word vd_next;
} Elf32_Verdef;
typedef struct {
    Elf64_Half vd_version;
    Elf64_Half vd_flags;
    Elf64_Half vd_ndx;
    Elf64_Half vd_cnt;
    Elf64_Word vd_hash;
    Elf64_Word vd_aux;
    Elf64_Word vd_next;
} Elf64_Verdef;
typedef struct {
    Elf64_Word vda_name;
    Elf64_Word vda_next;
} Elf64_Verdaux;
typedef struct {
    Elf32_Word vda_name;
    Elf32_Word vda_next;
} Elf32_Verdaux;
typedef struct {
    Elf32_Half vn_version;
    Elf32_Half vn_cnt;
    Elf32_Word vn_file;
    Elf32_Word vn_aux;
    Elf32_Word vn_next;
} Elf32_Verneed;
typedef struct {
    Elf64_Half vn_version;
    Elf64_Half vn_cnt;
    Elf64_Word vn_file;
    Elf64_Word vn_aux;
    Elf64_Word vn_next;
} Elf64_Verneed;
typedef struct {
    Elf32_Word vna_hash;
    Elf32_Half vna_flags;
    Elf32_Half vna_other;
    Elf32_Word vna_name;
    Elf32_Word vna_next;
} Elf32_Vernaux;
typedef struct {
    Elf64_Word vna_hash;
    Elf64_Half vna_flags;
    Elf64_Half vna_other;
    Elf64_Word vna_name;
    Elf64_Word vna_next;
} Elf64_Vernaux;
typedef struct {
    unsigned char e_ident[EI_NIDENT];
    Elf64_Half e_type;
    Elf64_Half e_machine;
    Elf64_Word e_version;
    Elf64_Addr e_entry;
    Elf64_Off e_phoff;
    Elf64_Off e_shoff;
    Elf64_Word e_flags;
    Elf64_Half e_ehsize;
    Elf64_Half e_phentsize;
    Elf64_Half e_phnum;
    Elf64_Half e_shentsize;
    Elf64_Half e_shnum;
    Elf64_Half e_shstrndx;
} Elf64_Ehdr;
typedef struct {
    unsigned char e_ident[EI_NIDENT];
    Elf32_Half e_type;
    Elf32_Half e_machine;
    Elf32_Word e_version;
    Elf32_Addr e_entry;
    Elf32_Off e_phoff;
    Elf32_Off e_shoff;
    Elf32_Word e_flags;
    Elf32_Half e_ehsize;
    Elf32_Half e_phentsize;
    Elf32_Half e_phnum;
    Elf32_Half e_shentsize;
    Elf32_Half e_shnum;
    Elf32_Half e_shstrndx;
} Elf32_Ehdr;
typedef struct {
    Elf32_Word sh_name;
    Elf32_Word sh_type;
    Elf32_Word sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off sh_offset;
    Elf32_Word sh_size;
    Elf32_Word sh_link;
    Elf32_Word sh_info;
    Elf32_Word sh_addralign;
    Elf32_Word sh_entsize;
} Elf32_Shdr;
typedef struct {
    Elf64_Word sh_name;
    Elf64_Word sh_type;
    Elf64_Xword sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off sh_offset;
    Elf64_Xword sh_size;
    Elf64_Word sh_link;
    Elf64_Word sh_info;
    Elf64_Xword sh_addralign;
    Elf64_Xword sh_entsize;
} Elf64_Shdr;
typedef struct {
    Elf32_Sword d_tag;
    union {
	Elf32_Word d_val;
	Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
typedef struct {
    Elf64_Sxword d_tag;
    union {
	Elf64_Xword d_val;
	Elf64_Addr d_ptr;
    } d_un;
} Elf64_Dyn;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7366"
>14.4.8. endian.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __LITTLE_ENDIAN	1234
#define __BIG_ENDIAN	4321
#define BIG_ENDIAN	__BIG_ENDIAN
#define BYTE_ORDER	__BYTE_ORDER
#define LITTLE_ENDIAN	__LITTLE_ENDIAN</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7370"
>14.4.9. envz.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern error_t envz_add(char **envz, size_t * envz_len, const char *name,
			const char *value);
extern char envz_entry(const char *envz, size_t envz_len,
		       const char *name);
extern char envz_get(const char *envz, size_t envz_len, const char *name);
extern error_t envz_merge(char **envz, size_t * envz_len,
			  const char *envz2, size_t envz2_len,
			  int override);
extern void envz_remove(char **envz, size_t * envz_len, const char *name);
extern void envz_strip(char **envz, size_t * envz_len);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7374"
>14.4.10. err.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void err(int eval, const char *fmt, ...);
extern void errx(int eval, const char *fmt, ...);
extern void verrx(int eval, const char *fmt, va_list args);
extern void warn(const char *fmt, ...);
extern void warnx(const char *fmt, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7378"
>14.4.11. errno.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define errno	(*__errno_location())

#define EPERM	1		/* Operation not permitted */
#define ECHILD	10		/* No child processes */
#define ENETDOWN	100	/* Network is down */
#define ENETUNREACH	101	/* Network is unreachable */
#define ENETRESET	102	/* Network dropped connection because of reset */
#define ECONNABORTED	103	/* Software caused connection abort */
#define ECONNRESET	104	/* Connection reset by peer */
#define ENOBUFS	105		/* No buffer space available */
#define EISCONN	106		/* Transport endpoint is already connected */
#define ENOTCONN	107	/* Transport endpoint is not connected */
#define ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
#define ETOOMANYREFS	109	/* Too many references: cannot splice */
#define EAGAIN	11		/* Try again */
#define ETIMEDOUT	110	/* Connection timed out */
#define ECONNREFUSED	111	/* Connection refused */
#define EHOSTDOWN	112	/* Host is down */
#define EHOSTUNREACH	113	/* No route to host */
#define EALREADY	114	/* Operation already in progress */
#define EINPROGRESS	115	/* Operation now in progress */
#define ESTALE	116		/* Stale NFS file handle */
#define EUCLEAN	117		/* Structure needs cleaning */
#define ENOTNAM	118		/* Not a XENIX named type file */
#define ENAVAIL	119		/* No XENIX semaphores available */
#define ENOMEM	12		/* Out of memory */
#define EISNAM	120		/* Is a named type file */
#define EREMOTEIO	121	/* Remote I/O error */
#define EDQUOT	122		/* Quota exceeded */
#define ENOMEDIUM	123	/* No medium found */
#define EMEDIUMTYPE	124	/* Wrong medium type */
#define ECANCELED	125	/* Operation Canceled */
#define EACCES	13		/* Permission denied */
#define EOWNERDEAD	130	/* Owner died */
#define ENOTRECOVERABLE	131	/* State not recoverable */
#define ERFKILL	132		/* Operation not possible due to RF-kill */
#define EFAULT	14		/* Bad address */
#define ENOTBLK	15		/* Block device required */
#define EBUSY	16		/* Device or resource busy */
#define EEXIST	17		/* File exists */
#define EXDEV	18		/* Cross-device link */
#define ENODEV	19		/* No such device */
#define ENOENT	2		/* No such file or directory */
#define ENOTDIR	20		/* Not a directory */
#define EISDIR	21		/* Is a directory */
#define EINVAL	22		/* Invalid argument */
#define ENFILE	23		/* File table overflow */
#define EMFILE	24		/* Too many open files */
#define ENOTTY	25		/* Not a typewriter */
#define ETXTBSY	26		/* Text file busy */
#define EFBIG	27		/* File too large */
#define ENOSPC	28		/* No space left on device */
#define ESPIPE	29		/* Illegal seek */
#define ESRCH	3		/* No such process */
#define EROFS	30		/* Read-only file system */
#define EMLINK	31		/* Too many links */
#define EPIPE	32		/* Broken pipe */
#define EDOM	33		/* Math argument out of domain of func */
#define ERANGE	34		/* Math result not representable */
#define EDEADLK	35		/* Resource deadlock would occur */
#define ENAMETOOLONG	36	/* File name too long */
#define ENOLCK	37		/* No record locks available */
#define ENOSYS	38		/* Function not implemented */
#define ENOTEMPTY	39	/* Directory not empty */
#define EINTR	4		/* Interrupted system call */
#define ELOOP	40		/* Too many symbolic links encountered */
#define ENOMSG	42		/* No message of desired type */
#define EIDRM	43		/* Identifier removed */
#define ECHRNG	44		/* Channel number out of range */
#define EL2NSYNC	45	/* Level 2 not synchronized */
#define EL3HLT	46		/* Level 3 halted */
#define EL3RST	47		/* Level 3 reset */
#define ELNRNG	48		/* Link number out of range */
#define EUNATCH	49		/* Protocol driver not attached */
#define EIO	5		/* I/O error */
#define ENOANO	55		/* No anode */
#define EBADRQC	56		/* Invalid request code */
#define EBADSLT	57		/* Invalid slot */
#define EBFONT	59		/* Bad font file format */
#define ENXIO	6		/* No such device or address */
#define ENOSTR	60		/* Device not a stream */
#define ENODATA	61		/* No data available */
#define ETIME	62		/* Timer expired */
#define ENOSR	63		/* Out of streams resources */
#define ENONET	64		/* Machine is not on the network */
#define ENOPKG	65		/* Package not installed */
#define EREMOTE	66		/* Object is remote */
#define ENOLINK	67		/* Link has been severed */
#define EADV	68		/* Advertise error */
#define ESRMNT	69		/* Srmount error */
#define E2BIG	7		/* Argument list too long */
#define ECOMM	70		/* Communication error on send */
#define EPROTO	71		/* Protocol error */
#define EMULTIHOP	72	/* Multihop attempted */
#define EDOTDOT	73		/* RFS specific error */
#define EBADMSG	74		/* Not a data message */
#define EOVERFLOW	75	/* Value too large for defined data type */
#define ENOTUNIQ	76	/* Name not unique on network */
#define EBADFD	77		/* File descriptor in bad state */
#define EREMCHG	78		/* Remote address changed */
#define ELIBACC	79		/* Can not access a needed shared library */
#define ENOEXEC	8		/* Exec format error */
#define ELIBBAD	80		/* Accessing a corrupted shared library */
#define ELIBSCN	81		/* .lib section in a.out corrupted */
#define ELIBMAX	82		/* Attempting to link in too many shared libraries */
#define ELIBEXEC	83	/* Cannot exec a shared library directly */
#define EILSEQ	84		/* Illegal byte sequence */
#define ERESTART	85	/* Interrupted system call should be restarted */
#define ESTRPIPE	86	/* Streams pipe error */
#define EUSERS	87		/* Too many users */
#define ENOTSOCK	88	/* Socket operation on non-socket */
#define EDESTADDRREQ	89	/* Destination address required */
#define EBADF	9		/* Bad file number */
#define EMSGSIZE	90	/* Message too long */
#define EPROTOTYPE	91	/* Protocol wrong type for socket */
#define ENOPROTOOPT	92	/* Protocol not available */
#define EPROTONOSUPPORT	93	/* Protocol not supported */
#define ESOCKTNOSUPPORT	94	/* Socket type not supported */
#define EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
#define EPFNOSUPPORT	96	/* Protocol family not supported */
#define EAFNOSUPPORT	97	/* Address family not supported by protocol */
#define EADDRINUSE	98	/* Address already in use */
#define EADDRNOTAVAIL	99	/* Cannot assign requested address */
#define EWOULDBLOCK	EAGAIN	/* Operation would block */
#define ENOTSUP	EOPNOTSUPP

extern int *__errno_location(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7382"
>14.4.12. error.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void error(int status, int errnum, const char *format, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7386"
>14.4.13. execinfo.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int backtrace(void **__array, int __size);
extern char **backtrace_symbols(void *const *__array, int __size);
extern void backtrace_symbols_fd(void *const *__array, int __size,
				 int __fd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7390"
>14.4.14. fcntl.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define AT_FDCWD	-100	/* Use the current working directory to determine the target of relative file paths. */
#define POSIX_FADV_NORMAL	0
#define O_RDONLY	00
#define O_ACCMODE	0003
#define O_WRONLY	01
#define O_CREAT	0100
#define O_TRUNC	01000
#define O_DSYNC	010000
#define O_RDWR	02
#define O_EXCL	0200
#define O_APPEND	02000
#define O_ASYNC	020000
#define O_CLOEXEC	02000000	/* The FD_CLOEXEC flag associated with the new descriptor shall be set to close the file descriptor upon execution of an exec family function. */
#define O_NOCTTY	0400
#define O_NDELAY	04000
#define O_NONBLOCK	04000
#define O_SYNC	04010000
#define AT_SYMLINK_NOFOLLOW	0x100	/* Do not follow symbolic links. */
#define AT_EMPTY_PATH	0x1000	/* Allow empty relative pathname. */
#define AT_EACCESS	0x200	/* Check access using effective user and group ID. */
#define AT_REMOVEDIR	0x200	/* Remove directory instead of file. */
#define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic link. */
#define AT_NO_AUTOMOUNT	0x800	/* Suppress terminal automount traversal. */
#define FD_CLOEXEC	1
#define POSIX_FADV_RANDOM	1
#define F_DUPFD_CLOEXEC	1030	/* Duplicate file descriptor with the close-on-exec flag FD_CLOEXEC set. */
#define POSIX_FADV_SEQUENTIAL	2
#define POSIX_FADV_WILLNEED	3
#define O_RSYNC	O_SYNC

struct flock {
    short l_type;
    short l_whence;
    off_t l_start;
    off_t l_len;
    pid_t l_pid;
};
struct flock64 {
    short l_type;
    short l_whence;
    loff_t l_start;
    loff_t l_len;
    pid_t l_pid;
};

#define AT_FDCWD	-100
#define AT_SYMLINK_NOFOLLOW	0x100
#define AT_EACCESS	0x200
#define AT_REMOVEDIR	0x200
#define AT_SYMLINK_FOLLOW	0x400

#define F_DUPFD	0
#define F_RDLCK	0
#ifndef SEEK_SET
#define SEEK_SET	0
#endif
#define F_GETFD	1
#define F_WRLCK	1
#ifndef SEEK_CUR
#define SEEK_CUR	1
#endif
#define F_SETSIG	10
#define F_GETSIG	11
#define F_SETFD	2
#define F_UNLCK	2
#ifndef SEEK_END
#define SEEK_END	2
#endif
#define F_GETFL	3
#define F_SETFL	4
#define F_GETLK	5
#define F_SETLK	6
#define F_SETLKW	7
#define F_SETOWN	8
#define F_GETOWN	9

extern int creat(const char *__file, mode_t __mode);
extern int creat64(const char *__file, mode_t __mode);
extern int fcntl(int __fd, int __cmd, ...);
extern int open(const char *__file, int __oflag, ...);
extern int open64(const char *__file, int __oflag, ...);
extern int openat(int __fd, const char *__file, int __oflag, ...);
extern int openat64(int __fd, const char *__file, int __oflag, ...);
extern int posix_fadvise(int __fd, off_t __offset, off_t __len,
			 int __advise);
extern int posix_fadvise64(int __fd, off64_t __offset, off64_t __len,
			   int __advise);
extern int posix_fallocate(int __fd, off_t __offset, off_t __len);
extern int posix_fallocate64(int __fd, off64_t __offset, off64_t __len);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7394"
>14.4.15. fmtmsg.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MM_HARD	1		/* Source of the condition is hardware. */
#define MM_NRECOV	128	/* Non-recoverable error. */
#define MM_UTIL	16		/* Condition detected by utility. */
#define MM_SOFT	2		/* Source of the condition is software. */
#define MM_PRINT	256	/* Display message in standard error. */
#define MM_OPSYS	32	/* Condition detected by operating system. */
#define MM_FIRM	4		/* Source of the condition is firmware. */
#define MM_CONSOLE	512	/* Display message on system console. */
#define MM_RECOVER	64	/* Recoverable error. */
#define MM_APPL	8		/* Condition detected by application. */

#define MM_NOSEV	0	/* No severity level provided for the message. */
#define MM_HALT	1		/* Error causing application to halt. */
#define MM_ERROR	2	/* Application has encountered a non-fatal fault. */
#define MM_WARNING	3	/* Application has detected unusual non-error condition. */
#define MM_INFO	4		/* Informative message. */

#define MM_NULLACT	((char *) 0)
#define MM_NULLLBL	((char *) 0)
#define MM_NULLTAG	((char *) 0)
#define MM_NULLTXT	((char *) 0)
#define MM_NULLMC	((long int) 0)
#define MM_NULLSEV	0

#define MM_NOTOK	-1	/* The function failed completely. */
#define MM_OK	0		/* The function succeeded. */
#define MM_NOMSG	1	/* The function was unable to generate a message on standard error, but otherwise succeeded. */
#define MM_NOCON	4	/* The function was unable to generate a console message, but otherwise succeeded. */

extern int fmtmsg(long int __classification, const char *__label,
		  int __severity, const char *__text, const char *__action,
		  const char *__tag);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7398"
>14.4.16. fnmatch.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FNM_CASEFOLD	(1&#60;&#60;4)
#define FNM_FILE_NAME	FNM_PATHNAME

#define FNM_PATHNAME	(1&#60;&#60;0)
#define FNM_NOESCAPE	(1&#60;&#60;1)
#define FNM_PERIOD	(1&#60;&#60;2)
#define FNM_NOMATCH	1

extern int fnmatch(const char *__pattern, const char *__name, int __flags);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7402"
>14.4.17. ftw.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FTW_D	FTW_D
#define FTW_DNR	FTW_DNR
#define FTW_DP	FTW_DP
#define FTW_F	FTW_F
#define FTW_NS	FTW_NS
#define FTW_SL	FTW_SL
#define FTW_SLN	FTW_SLN

enum {
    FTW_F,
    FTW_D,
    FTW_DNR,
    FTW_NS,
    FTW_SL,
    FTW_DP,
    FTW_SLN
};

enum {
    FTW_PHYS = 1,
    FTW_MOUNT = 2,
    FTW_CHDIR = 4,
    FTW_DEPTH = 8
};

struct FTW {
    int base;
    int level;
};

typedef int (*__ftw_func_t) (const char *__filename,
			     const struct stat * __status, int __flag);
typedef int (*__ftw64_func_t) (const char *__filename,
			       const struct stat64 * __status, int __flag);
typedef int (*__nftw_func_t) (const char *__filename,
			      const struct stat * __status, int __flag,
			      struct FTW * __info);
typedef int (*__nftw64_func_t) (const char *__filename,
				const struct stat64 * __status, int __flag,
				struct FTW * __info);
extern int ftw(const char *__dir, __ftw_func_t __func, int __descriptors);
extern int ftw64(const char *__dir, __ftw64_func_t __func,
		 int __descriptors);
extern int nftw(const char *__dir, __nftw_func_t __func, int __descriptors,
		int __flag);
extern int nftw64(const char *__dir, __nftw64_func_t __func,
		  int __descriptors, int __flag);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7406"
>14.4.18. getopt.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define no_argument	0
#define required_argument	1
#define optional_argument	2

struct option {
    const char *name;
    int has_arg;
    int *flag;
    int val;
};
extern int getopt_long(int ___argc, char *const ___argv[],
		       const char *__shortopts,
		       const struct option *__longopts, int *__longind);
extern int getopt_long_only(int ___argc, char *const ___argv[],
			    const char *__shortopts,
			    const struct option *__longopts,
			    int *__longind);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7410"
>14.4.19. glob.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define GLOB_ERR	(1&#60;&#60;0)
#define GLOB_MARK	(1&#60;&#60;1)
#define GLOB_BRACE	(1&#60;&#60;10)
#define GLOB_NOMAGIC	(1&#60;&#60;11)
#define GLOB_TILDE	(1&#60;&#60;12)
#define GLOB_ONLYDIR	(1&#60;&#60;13)
#define GLOB_TILDE_CHECK	(1&#60;&#60;14)
#define GLOB_NOSORT	(1&#60;&#60;2)
#define GLOB_DOOFFS	(1&#60;&#60;3)
#define GLOB_NOCHECK	(1&#60;&#60;4)
#define GLOB_APPEND	(1&#60;&#60;5)
#define GLOB_NOESCAPE	(1&#60;&#60;6)
#define GLOB_PERIOD	(1&#60;&#60;7)
#define GLOB_MAGCHAR	(1&#60;&#60;8)
#define GLOB_ALTDIRFUNC	(1&#60;&#60;9)

#define GLOB_NOSPACE	1
#define GLOB_ABORTED	2
#define GLOB_NOMATCH	3
#define GLOB_NOSYS	4

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob_t;

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent64 *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob64_t;
extern int glob(const char *__pattern, int __flags,
		int (*__errfunc) (const char *, int), glob_t * __pglob);
extern int glob64(const char *__pattern, int __flags,
		  int (*__errfunc) (const char *, int),
		  glob64_t * __pglob);
extern void globfree(glob_t * __pglob);
extern void globfree64(glob64_t * __pglob);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7414"
>14.4.20. gnu/libc-version.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern const char *gnu_get_libc_release(void);
extern const char *gnu_get_libc_version(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7418"
>14.4.21. grp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct group {
    char *gr_name;
    char *gr_passwd;
    gid_t gr_gid;
    char **gr_mem;
};

extern void endgrent(void);
extern struct group *getgrent(void);
extern int getgrent_r(struct group *__resultbuf, char *__buffer,
		      size_t __buflen, struct group **__result);
extern struct group *getgrgid(gid_t __gid);
extern int getgrgid_r(gid_t __gid, struct group *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct group **__result);
extern struct group *getgrnam(const char *__name);
extern int getgrnam_r(const char *__name, struct group *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct group **__result);
extern int getgrouplist(const char *__user, gid_t __group,
			gid_t * __groups, int *__ngroups);
extern int initgroups(const char *__user, gid_t __group);
extern void setgrent(void);
extern int setgroups(size_t __n, const gid_t * __groups);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7422"
>14.4.22. iconv.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef void *iconv_t;
extern size_t iconv(iconv_t __cd, char **__inbuf, size_t * __inbytesleft,
		    char **__outbuf, size_t * __outbytesleft);
extern int iconv_close(iconv_t __cd);
extern iconv_t iconv_open(const char *__tocode, const char *__fromcode);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7426"
>14.4.23. ifaddrs.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ifa_broadaddr	ifa_ifu.ifu_broadaddr
#define ifa_dstaddr	ifa_ifu.ifu_dstaddr

struct ifaddrs {
    struct ifaddrs *ifa_next;
    char *ifa_name;
    unsigned int ifa_flags;
    struct sockaddr *ifa_addr;
    struct sockaddr *ifa_netmask;
    union {
	struct sockaddr *ifu_broadaddr;
	struct sockaddr *ifu_dstaddr;
    } ifa_ifu;
    void *ifa_data;
};
extern void freeifaddrs(struct ifaddrs *);
extern int getifaddrs(struct ifaddrs **);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7430"
>14.4.24. inttypes.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#if !defined __cplusplus || defined __STDC_FORMAT_MACROS
#define PRId16	"d"
#define PRId32	"d"
#define PRId8	"d"
#define PRIdFAST8	"d"
#define PRIdLEAST16	"d"
#define PRIdLEAST32	"d"
#define PRIdLEAST8	"d"
#define SCNd32	"d"
#define SCNdLEAST32	"d"
#define SCNd16	"hd"
#define SCNdLEAST16	"hd"
#define SCNd8	"hhd"
#define SCNdFAST8	"hhd"
#define SCNdLEAST8	"hhd"
#define SCNi8	"hhi"
#define SCNiFAST8	"hhi"
#define SCNiLEAST8	"hhi"
#define SCNo8	"hho"
#define SCNoFAST8	"hho"
#define SCNoLEAST8	"hho"
#define SCNu8	"hhu"
#define SCNuFAST8	"hhu"
#define SCNuLEAST8	"hhu"
#define SCNx8	"hhx"
#define SCNxFAST8	"hhx"
#define SCNxLEAST8	"hhx"
#define SCNi16	"hi"
#define SCNiLEAST16	"hi"
#define SCNo16	"ho"
#define SCNoLEAST16	"ho"
#define SCNu16	"hu"
#define SCNuLEAST16	"hu"
#define SCNx16	"hx"
#define SCNxLEAST16	"hx"
#define PRIi16	"i"
#define PRIi32	"i"
#define PRIi8	"i"
#define PRIiFAST8	"i"
#define PRIiLEAST16	"i"
#define PRIiLEAST32	"i"
#define PRIiLEAST8	"i"
#define SCNi32	"i"
#define SCNiLEAST32	"i"
#define PRIo16	"o"
#define PRIo32	"o"
#define PRIo8	"o"
#define PRIoFAST8	"o"
#define PRIoLEAST16	"o"
#define PRIoLEAST32	"o"
#define PRIoLEAST8	"o"
#define SCNo32	"o"
#define SCNoLEAST32	"o"
#define PRIu16	"u"
#define PRIu32	"u"
#define PRIu8	"u"
#define PRIuFAST8	"u"
#define PRIuLEAST16	"u"
#define PRIuLEAST32	"u"
#define PRIuLEAST8	"u"
#define SCNu32	"u"
#define SCNuLEAST32	"u"
#define PRIX16	"X"
#define PRIX32	"X"
#define PRIX8	"X"
#define PRIXFAST8	"X"
#define PRIXLEAST16	"X"
#define PRIXLEAST32	"X"
#define PRIXLEAST8	"X"
#define PRIx16	"x"
#define PRIx32	"x"
#define PRIx8	"x"
#define PRIxFAST8	"x"
#define PRIxLEAST16	"x"
#define PRIxLEAST32	"x"
#define PRIxLEAST8	"x"
#define SCNx32	"x"
#define SCNxLEAST32	"x"
#define PRId64	__PRI64_PREFIX"d"
#define PRIdFAST64	__PRI64_PREFIX"d"
#define PRIdLEAST64	__PRI64_PREFIX"d"
#define PRIdMAX	__PRI64_PREFIX"d"
#define SCNd64	__PRI64_PREFIX"d"
#define SCNdFAST64	__PRI64_PREFIX"d"
#define SCNdLEAST64	__PRI64_PREFIX"d"
#define SCNdMAX	__PRI64_PREFIX"d"
#define PRIi64	__PRI64_PREFIX"i"
#define PRIiFAST64	__PRI64_PREFIX"i"
#define PRIiLEAST64	__PRI64_PREFIX"i"
#define PRIiMAX	__PRI64_PREFIX"i"
#define SCNi64	__PRI64_PREFIX"i"
#define SCNiFAST64	__PRI64_PREFIX"i"
#define SCNiLEAST64	__PRI64_PREFIX"i"
#define SCNiMAX	__PRI64_PREFIX"i"
#define PRIo64	__PRI64_PREFIX"o"
#define PRIoFAST64	__PRI64_PREFIX"o"
#define PRIoLEAST64	__PRI64_PREFIX"o"
#define PRIoMAX	__PRI64_PREFIX"o"
#define SCNo64	__PRI64_PREFIX"o"
#define SCNoFAST64	__PRI64_PREFIX"o"
#define SCNoLEAST64	__PRI64_PREFIX"o"
#define SCNoMAX	__PRI64_PREFIX"o"
#define PRIu64	__PRI64_PREFIX"u"
#define PRIuFAST64	__PRI64_PREFIX"u"
#define PRIuLEAST64	__PRI64_PREFIX"u"
#define PRIuMAX	__PRI64_PREFIX"u"
#define SCNu64	__PRI64_PREFIX"u"
#define SCNuFAST64	__PRI64_PREFIX"u"
#define SCNuLEAST64	__PRI64_PREFIX"u"
#define SCNuMAX	__PRI64_PREFIX"u"
#define PRIX64	__PRI64_PREFIX"X"
#define PRIXFAST64	__PRI64_PREFIX"X"
#define PRIXLEAST64	__PRI64_PREFIX"X"
#define PRIXMAX	__PRI64_PREFIX"X"
#define PRIx64	__PRI64_PREFIX"x"
#define PRIxFAST64	__PRI64_PREFIX"x"
#define PRIxLEAST64	__PRI64_PREFIX"x"
#define PRIxMAX	__PRI64_PREFIX"x"
#define SCNx64	__PRI64_PREFIX"x"
#define SCNxFAST64	__PRI64_PREFIX"x"
#define SCNxLEAST64	__PRI64_PREFIX"x"
#define SCNxMAX	__PRI64_PREFIX"x"
#define PRIdFAST16	__PRIPTR_PREFIX"d"
#define PRIdFAST32	__PRIPTR_PREFIX"d"
#define PRIdPTR	__PRIPTR_PREFIX"d"
#define SCNdFAST16	__PRIPTR_PREFIX"d"
#define SCNdFAST32	__PRIPTR_PREFIX"d"
#define SCNdPTR	__PRIPTR_PREFIX"d"
#define PRIiFAST16	__PRIPTR_PREFIX"i"
#define PRIiFAST32	__PRIPTR_PREFIX"i"
#define PRIiPTR	__PRIPTR_PREFIX"i"
#define SCNiFAST16	__PRIPTR_PREFIX"i"
#define SCNiFAST32	__PRIPTR_PREFIX"i"
#define SCNiPTR	__PRIPTR_PREFIX"i"
#define PRIoFAST16	__PRIPTR_PREFIX"o"
#define PRIoFAST32	__PRIPTR_PREFIX"o"
#define PRIoPTR	__PRIPTR_PREFIX"o"
#define SCNoFAST16	__PRIPTR_PREFIX"o"
#define SCNoFAST32	__PRIPTR_PREFIX"o"
#define SCNoPTR	__PRIPTR_PREFIX"o"
#define PRIuFAST16	__PRIPTR_PREFIX"u"
#define PRIuFAST32	__PRIPTR_PREFIX"u"
#define PRIuPTR	__PRIPTR_PREFIX"u"
#define SCNuFAST16	__PRIPTR_PREFIX"u"
#define SCNuFAST32	__PRIPTR_PREFIX"u"
#define SCNuPTR	__PRIPTR_PREFIX"u"
#define PRIXFAST16	__PRIPTR_PREFIX"X"
#define PRIXFAST32	__PRIPTR_PREFIX"X"
#define PRIXPTR	__PRIPTR_PREFIX"X"
#define PRIxFAST16	__PRIPTR_PREFIX"x"
#define PRIxFAST32	__PRIPTR_PREFIX"x"
#define PRIxPTR	__PRIPTR_PREFIX"x"
#define SCNxFAST16	__PRIPTR_PREFIX"x"
#define SCNxFAST32	__PRIPTR_PREFIX"x"
#define SCNxPTR	__PRIPTR_PREFIX"x"
#endif

#define __PDP_ENDIAN	3412
#define PDP_ENDIAN	__PDP_ENDIAN

extern intmax_t imaxabs(intmax_t __n);
extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom);
extern intmax_t strtoimax(const char *__nptr, char **__endptr, int __base);
extern uintmax_t strtoumax(const char *__nptr, char **__endptr,
			   int __base);
extern intmax_t wcstoimax(const wchar_t * __nptr, wchar_t * *__endptr,
			  int __base);
extern uintmax_t wcstoumax(const wchar_t * __nptr, wchar_t * *__endptr,
			   int __base);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7434"
>14.4.25. langinfo.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ABDAY_1	0x20000		/* Sun. */
#define ABDAY_2	0x20001
#define ABDAY_3	0x20002
#define ABDAY_4	0x20003
#define ABDAY_5	0x20004
#define ABDAY_6	0x20005
#define ABDAY_7	0x20006

#define DAY_1	0x20007
#define DAY_2	0x20008
#define DAY_3	0x20009
#define DAY_4	0x2000A
#define DAY_5	0x2000B
#define DAY_6	0x2000C
#define DAY_7	0x2000D

#define ABMON_1	0x2000E
#define ABMON_2	0x2000F
#define ABMON_3	0x20010
#define ABMON_4	0x20011
#define ABMON_5	0x20012
#define ABMON_6	0x20013
#define ABMON_7	0x20014
#define ABMON_8	0x20015
#define ABMON_9	0x20016
#define ABMON_10	0x20017
#define ABMON_11	0x20018
#define ABMON_12	0x20019

#define MON_1	0x2001A
#define MON_2	0x2001B
#define MON_3	0x2001C
#define MON_4	0x2001D
#define MON_5	0x2001E
#define MON_6	0x2001F
#define MON_7	0x20020
#define MON_8	0x20021
#define MON_9	0x20022
#define MON_10	0x20023
#define MON_11	0x20024
#define MON_12	0x20025

#define AM_STR	0x20026
#define PM_STR	0x20027

#define D_T_FMT	0x20028
#define D_FMT	0x20029
#define T_FMT	0x2002A
#define T_FMT_AMPM	0x2002B

#define ERA	0x2002C
#define ERA_D_FMT	0x2002E
#define ALT_DIGITS	0x2002F
#define ERA_D_T_FMT	0x20030
#define ERA_T_FMT	0x20031

#define CODESET	14

#define CRNCYSTR	0x4000F

#define RADIXCHAR	0x10000
#define THOUSEP	0x10001
#define YESEXPR	0x50000
#define NOEXPR	0x50001
#define YESSTR	0x50002
#define NOSTR	0x50003

extern char *nl_langinfo(nl_item __item);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7438"
>14.4.26. libgen.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define basename __xpg_basename

extern char *__xpg_basename(char *__path);
extern char *dirname(char *__path);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7442"
>14.4.27. libintl.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern char *bind_textdomain_codeset(const char *__domainname,
				     const char *__codeset);
extern char *bindtextdomain(const char *__domainname,
			    const char *__dirname);
extern char *dcgettext(const char *__domainname, const char *__msgid,
		       int __category);
extern char *dcngettext(const char *__domainname, const char *__msgid1,
			const char *__msgid2, unsigned long int __n,
			int __category);
extern char *dgettext(const char *__domainname, const char *__msgid);
extern char *dngettext(const char *__domainname, const char *__msgid1,
		       const char *__msgid2, unsigned long int __n);
extern char *gettext(const char *__msgid);
extern char *ngettext(const char *__msgid1, const char *__msgid2,
		      unsigned long int __n);
extern char *textdomain(const char *__domainname);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7446"
>14.4.28. limits.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LLONG_MIN	(-LLONG_MAX-1LL)
#define _POSIX_AIO_MAX	1
#define _POSIX_QLIMIT	1
#define _POSIX2_BC_STRING_MAX	1000
#define IOV_MAX	1024
#define _POSIX2_CHARCLASS_NAME_MAX	14
#define _POSIX_NAME_MAX	14
#define _POSIX_UIO_MAXIOV	16
#define ULLONG_MAX	18446744073709551615ULL
#define _POSIX2_COLL_WEIGHTS_MAX	2
#define _POSIX_AIO_LISTIO_MAX	2
#define _POSIX_OPEN_MAX	20
#define _POSIX_CLOCKRES_MIN	20000000
#define CHARCLASS_NAME_MAX	2048
#define LINE_MAX	2048
#define _POSIX2_BC_DIM_MAX	2048
#define _POSIX2_LINE_MAX	2048
#define _POSIX_CHILD_MAX	25
#define COLL_WEIGHTS_MAX	255
#define NAME_MAX	255
#define _POSIX2_RE_DUP_MAX	255
#define _POSIX_HOST_NAME_MAX	255
#define _POSIX_MAX_CANON	255
#define _POSIX_MAX_INPUT	255
#define _POSIX_RE_DUP_MAX	255
#define _POSIX_SYMLINK_MAX	255
#define _POSIX_PATH_MAX	256
#define _POSIX_SEM_NSEMS_MAX	256
#define NGROUPS_MAX	32
#define WORD_BIT	32
#define _POSIX2_EXPR_NEST_MAX	32
#define _POSIX_DELAYTIMER_MAX	32
#define _POSIX_MQ_PRIO_MAX	32
#define _POSIX_SIGQUEUE_MAX	32
#define _POSIX_TIMER_MAX	32
#define _POSIX_SEM_VALUE_MAX	32767
#define _POSIX_SSIZE_MAX	32767
#define PATH_MAX	4096
#define _POSIX_ARG_MAX	4096
#define _POSIX_PIPE_BUF	512
#define _POSIX_TZNAME_MAX	6
#define _POSIX_LINK_MAX	8
#define _POSIX_MQ_OPEN_MAX	8
#define _POSIX_NGROUPS_MAX	8
#define _POSIX_RTSIG_MAX	8
#define _POSIX_STREAM_MAX	8
#define _POSIX_SYMLOOP_MAX	8
#define _POSIX_LOGIN_NAME_MAX	9
#define _POSIX_TTY_NAME_MAX	9
#define LLONG_MAX	9223372036854775807LL
#define _POSIX2_BC_BASE_MAX	99
#define _POSIX2_BC_SCALE_MAX	99
#define NL_MSGMAX	INT_MAX
#define NL_SETMAX	INT_MAX
#define NL_TEXTMAX	INT_MAX
#define SSIZE_MAX	LONG_MAX	/* Maximum value of an object of type ssize_t */
#define BC_BASE_MAX	_POSIX2_BC_BASE_MAX
#define BC_DIM_MAX	_POSIX2_BC_DIM_MAX
#define BC_SCALE_MAX	_POSIX2_BC_SCALE_MAX
#define BC_STRING_MAX	_POSIX2_BC_STRING_MAX
#define EXPR_NEST_MAX	_POSIX2_EXPR_NEST_MAX
#define NL_LANGMAX	_POSIX2_LINE_MAX
#define NL_ARGMAX	_POSIX_ARG_MAX
#define _POSIX_FD_SETSIZE	_POSIX_OPEN_MAX
#define _POSIX_HIWAT	_POSIX_PIPE_BUF

#define MB_LEN_MAX	16

#define SCHAR_MIN	(-128)
#define SCHAR_MAX	127
#define UCHAR_MAX	255
#define CHAR_BIT	8

#define SHRT_MIN	(-32768)
#define SHRT_MAX	32767
#define USHRT_MAX	65535

#define INT_MIN	(-INT_MAX-1)
#define INT_MAX	2147483647
#define UINT_MAX	4294967295U

#define LONG_MIN	(-LONG_MAX-1L)

#define PTHREAD_KEYS_MAX	1024
#define PTHREAD_THREADS_MAX	16384
#define PTHREAD_DESTRUCTOR_ITERATIONS	4</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7450"
>14.4.29. link.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int
dl_iterate_phdr(int (*callback) (struct dl_phdr_info *, size_t, void *),
		void *data);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7454"
>14.4.30. locale.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};

#define LC_GLOBAL_LOCALE	((locale_t) -1L)
#define LC_CTYPE	0
#define LC_NUMERIC	1
#define LC_TELEPHONE	10
#define LC_MEASUREMENT	11
#define LC_IDENTIFICATION	12
#define LC_TIME	2
#define LC_COLLATE	3
#define LC_MONETARY	4
#define LC_MESSAGES	5
#define LC_ALL	6
#define LC_PAPER	7
#define LC_NAME	8
#define LC_ADDRESS	9

struct __locale_struct {
    struct locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;

typedef struct __locale_struct *locale_t;

#define LC_ADDRESS_MASK	(1 &#60;&#60; LC_ADDRESS)
#define LC_COLLATE_MASK	(1 &#60;&#60; LC_COLLATE)
#define LC_IDENTIFICATION_MASK	(1 &#60;&#60; LC_IDENTIFICATION)
#define LC_MEASUREMENT_MASK	(1 &#60;&#60; LC_MEASUREMENT)
#define LC_MESSAGES_MASK	(1 &#60;&#60; LC_MESSAGES)
#define LC_MONETARY_MASK	(1 &#60;&#60; LC_MONETARY)
#define LC_NAME_MASK	(1 &#60;&#60; LC_NAME)
#define LC_NUMERIC_MASK	(1 &#60;&#60; LC_NUMERIC)
#define LC_PAPER_MASK	(1 &#60;&#60; LC_PAPER)
#define LC_TELEPHONE_MASK	(1 &#60;&#60; LC_TELEPHONE)
#define LC_TIME_MASK	(1 &#60;&#60; LC_TIME)
#define LC_CTYPE_MASK	(1&#60;&#60;LC_CTYPE)
#define LC_ALL_MASK	\
        (LC_CTYPE_MASK| LC_NUMERIC_MASK| LC_TIME_MASK| LC_COLLATE_MASK| LC_MONETARY_MASK|\
         LC_MESSAGES_MASK| LC_PAPER_MASK| LC_NAME_MASK| LC_ADDRESS_MASK| LC_TELEPHONE_MASK|\
         LC_MEASUREMENT_MASK| LC_IDENTIFICATION_MASK)

extern locale_t duplocale(locale_t __dataset);
extern void freelocale(locale_t __dataset);
extern struct lconv *localeconv(void);
extern locale_t newlocale(int __category_mask, const char *__locale,
			  locale_t __base);
extern char *setlocale(int __category, const char *__locale);
extern locale_t uselocale(locale_t __dataset);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7458"
>14.4.31. lsb/time.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct timeval {
    time_t tv_sec;
    suseconds_t tv_usec;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7462"
>14.4.32. lsb/types.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;/*
 * This header is architecture dependent
 * Please refer to the specific architecture specification for details
 */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7466"
>14.4.33. lsb/wchar.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef unsigned int wint_t;
typedef struct {
    int count;
    wint_t value;
} __mbstate_t;

typedef __mbstate_t mbstate_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7470"
>14.4.34. monetary.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t strfmon(char *__s, size_t __maxsize, const char *__format,
		       ...);
extern ssize_t strfmon_l(char *s, size_t maxsize, locale_t locale,
			 const char *format, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7474"
>14.4.35. net/if.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IF_NAMESIZE	16

#define IFF_UP	0x01		/* Interface is up. */
#define IFF_BROADCAST	0x02	/* Broadcast address valid. */
#define IFF_DEBUG	0x04	/* Turn on debugging. */
#define IFF_LOOPBACK	0x08	/* Is a loopback net. */
#define IFF_POINTOPOINT	0x10	/* Interface is point-to-point link. */
#define IFF_PROMISC	0x100	/* Receive all packets. */
#define IFF_MULTICAST	0x1000	/* Supports multicast. */
#define IFF_NOTRAILERS	0x20	/* Avoid use of trailers. */
#define IFF_RUNNING	0x40	/* Resources allocated. */
#define IFF_NOARP	0x80	/* No address resolution protocol. */

struct if_nameindex {
    unsigned int if_index;	/* 1, 2, ... */
    char *if_name;		/* null terminated name: */
};

struct ifaddr {
    struct sockaddr ifa_addr;	/* Address of interface. */
    union {
	struct sockaddr ifu_broadaddr;
	struct sockaddr ifu_dstaddr;
    } ifa_ifu;
    void *ifa_ifp;
    void *ifa_next;
};

#define ifr_name	ifr_ifrn.ifrn_name	/* interface name */
#define ifr_addr	ifr_ifru.ifru_addr	/* address */
#define ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
#define ifr_data	ifr_ifru.ifru_data	/* for use by interface */
#define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk */
#define ifr_flags	ifr_ifru.ifru_flags	/* flags */
#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* interface name */
#define ifr_bandwidth	ifr_ifru.ifru_ivalue	/* link bandwidth */
#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index */
#define ifr_metric	ifr_ifru.ifru_ivalue	/* metric */
#define ifr_qlen	ifr_ifru.ifru_ivalue	/* queue length */
#define ifr_mtu	ifr_ifru.ifru_mtu	/* mtu */
#define ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
#define ifr_slave	ifr_ifru.ifru_slave	/* slave device */
#define IFNAMSIZ	IF_NAMESIZE

struct ifreq {
    union {
	char ifrn_name[IFNAMSIZ];
    } ifr_ifrn;
    union {
	struct sockaddr ifru_addr;
	struct sockaddr ifru_dstaddr;
	struct sockaddr ifru_broadaddr;
	struct sockaddr ifru_netmask;
	struct sockaddr ifru_hwaddr;
	short ifru_flags;
	int ifru_ivalue;
	int ifru_mtu;
	char ifru_slave[IFNAMSIZ];
	char ifru_newname[IFNAMSIZ];
	caddr_t ifru_data;
	struct ifmap ifru_map;
    } ifr_ifru;
};

#define ifc_buf	ifc_ifcu.ifcu_buf	/* Buffer address. */
#define ifc_req	ifc_ifcu.ifcu_req	/* Array of structures. */

struct ifconf {
    int ifc_len;
    union {
	caddr_t ifcu_buf;
	struct ifreq *ifcu_req;
    } ifc_ifcu;
};
extern void if_freenameindex(struct if_nameindex *__ptr);
extern char *if_indextoname(unsigned int __ifindex, char *__ifname);
extern struct if_nameindex *if_nameindex(void);
extern unsigned int if_nametoindex(const char *__ifname);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7478"
>14.4.36. netdb.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define h_errno	(*__h_errno_location ())
#define NETDB_INTERNAL	-1	/* See errno. */
#define NETDB_SUCCESS	0	/* No problem. */
#define HOST_NOT_FOUND	1	/* Authoritative Answer Host not found. */
#define IPPORT_RESERVED	1024
#define NI_MAXHOST	1025
#define TRY_AGAIN	2	/* Non-Authoritative Host not found, or SERVERFAIL. */
#define NO_RECOVERY	3	/* Non recoverable errors, FORMERR, REFUSED, NOTIMP. */
#define NI_MAXSERV	32
#define NO_DATA	4		/* Valid name, no data record of requested type. */
#define h_addr	h_addr_list[0]
#define NO_ADDRESS	NO_DATA	/* No address, look for MX record. */

struct servent {
    char *s_name;
    char **s_aliases;
    int s_port;
    char *s_proto;
};
struct hostent {
    char *h_name;
    char **h_aliases;
    int h_addrtype;
    int h_length;
    char **h_addr_list;
};
struct protoent {
    char *p_name;
    char **p_aliases;
    int p_proto;
};
struct netent {
    char *n_name;
    char **n_aliases;
    int n_addrtype;
    unsigned int n_net;
};

#define AI_PASSIVE	0x0001	/* Socket address is intended for `bind' */
#define AI_CANONNAME	0x0002	/* Request for canonical name */
#define AI_NUMERICHOST	0x0004	/* Don't use name resolution */
#define AI_V4MAPPED	0x0008	/* IPv4 mapped addresses are acceptable. */
#define AI_ALL	0x0010		/* Return IPv4 mapped and IPv6 addresses. */
#define AI_ADDRCONFIG	0x0020	/* Use configuration of this host to choose returned address type.. */
#define AI_NUMERICSERV	0x0400	/* Don't use name resolution */

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
};

#define NI_NUMERICHOST	1
#define NI_DGRAM	16
#define NI_NUMERICSERV	2
#define NI_NOFQDN	4
#define NI_NAMEREQD	8

#define EAI_BADFLAGS	-1	/* Invalid value for `ai_flags' field. */
#define EAI_MEMORY	-10	/* Memory allocation failure. */
#define EAI_SYSTEM	-11	/* System error returned in `errno'. */
#define EAI_NONAME	-2	/* NAME or SERVICE is unknown. */
#define EAI_AGAIN	-3	/* Temporary failure in name resolution. */
#define EAI_FAIL	-4	/* Non-recoverable failure in name res. */
#define EAI_NODATA	-5	/* No address associated with NAME. */
#define EAI_FAMILY	-6	/* `ai_family' not supported. */
#define EAI_SOCKTYPE	-7	/* `ai_family' not supported. */
#define EAI_SERVICE	-8	/* SERVICE not supported for `ai_socktype'. */
#define EAI_ADDRFAMILY	-9	/* Address family for NAME not supported. */

extern int *__h_errno_location(void);
extern void endprotoent(void);
extern void endservent(void);
extern void freeaddrinfo(struct addrinfo *__ai);
extern const char *gai_strerror(int __ecode);
extern int getaddrinfo(const char *__name, const char *__service,
		       const struct addrinfo *__req,
		       struct addrinfo **__pai);
extern struct hostent *gethostbyaddr(const void *__addr, socklen_t __len,
				     int __type);
extern int gethostbyaddr_r(const void *__addr, socklen_t __len, int __type,
			   struct hostent *__result_buf, char *__buf,
			   size_t __buflen, struct hostent **__result,
			   int *__h_errnop);
extern struct hostent *gethostbyname(const char *__name);
extern struct hostent *gethostbyname2(const char *__name, int __af);
extern int gethostbyname2_r(const char *__name, int __af,
			    struct hostent *__result_buf, char *__buf,
			    size_t __buflen, struct hostent **__result,
			    int *__h_errnop);
extern int gethostbyname_r(const char *__name,
			   struct hostent *__result_buf, char *__buf,
			   size_t __buflen, struct hostent **__result,
			   int *__h_errnop);
extern struct protoent *getprotobyname(const char *__name);
extern int getprotobyname_r(const char *__name,
			    struct protoent *__result_buf, char *__buf,
			    size_t __buflen, struct protoent **__result);
extern struct protoent *getprotobynumber(int __proto);
extern int getprotobynumber_r(int __proto, struct protoent *__result_buf,
			      char *__buf, size_t __buflen,
			      struct protoent **__result);
extern struct protoent *getprotoent(void);
extern int getprotoent_r(struct protoent *__result_buf, char *__buf,
			 size_t __buflen, struct protoent **__result);
extern struct servent *getservbyname(const char *__name,
				     const char *__proto);
extern int getservbyname_r(const char *__name, const char *__proto,
			   struct servent *__result_buf, char *__buf,
			   size_t __buflen, struct servent **__result);
extern struct servent *getservbyport(int __port, const char *__proto);
extern int getservbyport_r(int __port, const char *__proto,
			   struct servent *__result_buf, char *__buf,
			   size_t __buflen, struct servent **__result);
extern struct servent *getservent(void);
extern int getservent_r(struct servent *__result_buf, char *__buf,
			size_t __buflen, struct servent **__result);
extern void setprotoent(int __stay_open);
extern void setservent(int __stay_open);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7482"
>14.4.37. netinet/icmp6.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ICMP6_FILTER_WILLBLOCK(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) &#38; (1 &#60;&#60; ((type) &#38; 31))) != 0)
#define ICMP6_FILTER_WILLPASS(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) &#38; (1 &#60;&#60; ((type) &#38; 31))) == 0)
#define ICMP6_FILTER_SETPASS(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) &#38;= ~(1 &#60;&#60; ((type) &#38; 31))))
#define ICMP6_FILTER_SETBLOCK(type,filterp)	((((filterp)-&#62;icmp6_filt[(type) &#62;&#62; 5]) |= (1 &#60;&#60; ((type) &#38; 31))))
#define ICMP6_DST_UNREACH_NOROUTE	0
#define ICMP6_PARAMPROB_HEADER	0
#define ICMP6_TIME_EXCEED_TRANSIT	0
#define ICMP6_RR_FLAGS_PREVDONE	0x08
#define ICMP6_RR_FLAGS_SPECSITE	0x10
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO	0x10
#define ICMP6_RR_FLAGS_FORCEAPPLY	0x20
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK	0x20
#define ND_OPT_PI_FLAG_RADDR	0x20
#define ND_RA_FLAG_HOME_AGENT	0x20
#define ICMP6_RR_FLAGS_REQRESULT	0x40
#define ND_OPT_PI_FLAG_AUTO	0x40
#define ND_RA_FLAG_OTHER	0x40
#define ICMP6_INFOMSG_MASK	0x80
#define ICMP6_RR_FLAGS_TEST	0x80
#define ND_OPT_PI_FLAG_ONLINK	0x80
#define ND_RA_FLAG_MANAGED	0x80
#define ICMP6_DST_UNREACH	1
#define ICMP6_DST_UNREACH_ADMIN	1
#define ICMP6_FILTER	1
#define ICMP6_FILTER_BLOCK	1
#define ICMP6_PARAMPROB_NEXTHEADER	1
#define ICMP6_TIME_EXCEED_REASSEMBLY	1
#define ND_OPT_SOURCE_LINKADDR	1
#define RPM_PCO_ADD	1
#define ICMP6_ECHO_REQUEST	128
#define ICMP6_ECHO_REPLY	129
#define MLD_LISTENER_QUERY	130
#define MLD_LISTENER_REPORT	131
#define MLD_LISTENER_REDUCTION	132
#define ND_ROUTER_SOLICIT	133
#define ND_ROUTER_ADVERT	134
#define ND_NEIGHBOR_SOLICIT	135
#define ND_NEIGHBOR_ADVERT	136
#define ND_REDIRECT	137
#define ICMP6_ROUTER_RENUMBERING	138
#define ICMP6_DST_UNREACH_BEYONDSCOPE	2
#define ICMP6_FILTER_PASS	2
#define ICMP6_PACKET_TOO_BIG	2
#define ICMP6_PARAMPROB_OPTION	2
#define ND_OPT_TARGET_LINKADDR	2
#define RPM_PCO_CHANGE	2
#define ICMP6_DST_UNREACH_ADDR	3
#define ICMP6_FILTER_BLOCKOTHERS	3
#define ICMP6_TIME_EXCEEDED	3
#define ND_OPT_PREFIX_INFORMATION	3
#define RPM_PCO_SETGLOBAL	3
#define ICMP6_DST_UNREACH_NOPORT	4
#define ICMP6_FILTER_PASSONLY	4
#define ICMP6_PARAM_PROB	4
#define ND_OPT_REDIRECTED_HEADER	4
#define ND_OPT_MTU	5
#define ND_OPT_RTR_ADV_INTERVAL	7
#define ND_OPT_HOME_AGENT_INFO	8
#define icmp6_id	icmp6_data16[0]
#define icmp6_maxdelay	icmp6_data16[0]
#define icmp6_seq	icmp6_data16[1]
#define icmp6_mtu	icmp6_data32[0]
#define icmp6_pptr	icmp6_data32[0]
#define icmp6_data16	icmp6_dataun.icmp6_un_data16
#define icmp6_data32	icmp6_dataun.icmp6_un_data32
#define icmp6_data8	icmp6_dataun.icmp6_un_data8
#define ICMP6_FILTER_SETPASSALL(filterp)	memset (filterp, 0, sizeof (struct icmp6_filter));
#define ICMP6_FILTER_SETBLOCKALL(filterp)	memset (filterp, 0xFF, sizeof (struct icmp6_filter));
#define mld_cksum	mld_icmp6_hdr.icmp6_cksum
#define mld_code	mld_icmp6_hdr.icmp6_code
#define mld_maxdelay	mld_icmp6_hdr.icmp6_data16[0]
#define mld_reserved	mld_icmp6_hdr.icmp6_data16[1]
#define mld_type	mld_icmp6_hdr.icmp6_type
#define nd_na_cksum	nd_na_hdr.icmp6_cksum
#define nd_na_code	nd_na_hdr.icmp6_code
#define nd_na_flags_reserved	nd_na_hdr.icmp6_data32[0]
#define nd_na_type	nd_na_hdr.icmp6_type
#define nd_ns_cksum	nd_ns_hdr.icmp6_cksum
#define nd_ns_code	nd_ns_hdr.icmp6_code
#define nd_ns_reserved	nd_ns_hdr.icmp6_data32[0]
#define nd_ns_type	nd_ns_hdr.icmp6_type
#define nd_ra_cksum	nd_ra_hdr.icmp6_cksum
#define nd_ra_code	nd_ra_hdr.icmp6_code
#define nd_ra_router_lifetime	nd_ra_hdr.icmp6_data16[1]
#define nd_ra_curhoplimit	nd_ra_hdr.icmp6_data8[0]
#define nd_ra_flags_reserved	nd_ra_hdr.icmp6_data8[1]
#define nd_ra_type	nd_ra_hdr.icmp6_type
#define nd_rd_cksum	nd_rd_hdr.icmp6_cksum
#define nd_rd_code	nd_rd_hdr.icmp6_code
#define nd_rd_reserved	nd_rd_hdr.icmp6_data32[0]
#define nd_rd_type	nd_rd_hdr.icmp6_type
#define nd_rs_cksum	nd_rs_hdr.icmp6_cksum
#define nd_rs_code	nd_rs_hdr.icmp6_code
#define nd_rs_reserved	nd_rs_hdr.icmp6_data32[0]
#define nd_rs_type	nd_rs_hdr.icmp6_type
#define rr_cksum	rr_hdr.icmp6_cksum
#define rr_code	rr_hdr.icmp6_code
#define rr_seqnum	rr_hdr.icmp6_data32[0]
#define rr_type	rr_hdr.icmp6_type

struct icmp6_filter {
    uint32_t icmp6_filt[8];
};
struct icmp6_hdr {
    uint8_t icmp6_type;
    uint8_t icmp6_code;
    uint16_t icmp6_cksum;
    union {
	uint32_t icmp6_un_data32[1];
	uint16_t icmp6_un_data16[2];
	uint8_t icmp6_un_data8[4];
    } icmp6_dataun;
};
struct nd_router_solicit {
    struct icmp6_hdr nd_rs_hdr;
};
struct nd_router_advert {
    struct icmp6_hdr nd_ra_hdr;
    uint32_t nd_ra_reachable;
    uint32_t nd_ra_retransmit;
};
struct nd_neighbor_solicit {
    struct icmp6_hdr nd_ns_hdr;
    struct in6_addr nd_ns_target;
};
struct nd_neighbor_advert {
    struct icmp6_hdr nd_na_hdr;
    struct in6_addr nd_na_target;
};
struct nd_redirect {
    struct icmp6_hdr nd_rd_hdr;
    struct in6_addr nd_rd_target;
    struct in6_addr nd_rd_dst;
};
struct nd_opt_hdr {
    uint8_t nd_opt_type;
    uint8_t nd_opt_len;
};
struct nd_opt_prefix_info {
    uint8_t nd_opt_pi_type;
    uint8_t nd_opt_pi_len;
    uint8_t nd_opt_pi_prefix_len;
    uint8_t nd_opt_pi_flags_reserved;
    uint32_t nd_opt_pi_valid_time;
    uint32_t nd_opt_pi_preferred_time;
    uint32_t nd_opt_pi_reserved2;
    struct in6_addr nd_opt_pi_prefix;
};
struct nd_opt_rd_hdr {
    uint8_t nd_opt_rh_type;
    uint8_t nd_opt_rh_len;
    uint16_t nd_opt_rh_reserved1;
    uint32_t nd_opt_rh_reserved2;
};
struct nd_opt_mtu {
    uint8_t nd_opt_mtu_type;
    uint8_t nd_opt_mtu_len;
    uint16_t nd_opt_mtu_reserved;
    uint32_t nd_opt_mtu_mtu;
};
struct mld_hdr {
    struct icmp6_hdr mld_icmp6_hdr;
    struct in6_addr mld_addr;
};
struct icmp6_router_renum {
    struct icmp6_hdr rr_hdr;
    uint8_t rr_segnum;
    uint8_t rr_flags;
    uint16_t rr_maxdelay;
    uint32_t rr_reserved;
};
struct rr_pco_match {
    uint8_t rpm_code;
    uint8_t rpm_len;
    uint8_t rpm_ordinal;
    uint8_t rpm_matchlen;
    uint8_t rpm_minlen;
    uint8_t rpm_maxlen;
    uint16_t rpm_reserved;
    struct in6_addr rpm_prefix;
};
struct rr_pco_use {
    uint8_t rpu_uselen;
    uint8_t rpu_keeplen;
    uint8_t rpu_ramask;
    uint8_t rpu_raflags;
    uint32_t rpu_vltime;
    uint32_t rpu_pltime;
    uint32_t rpu_flags;
    struct in6_addr rpu_prefix;
};
struct rr_result {
    uint16_t rrr_flags;
    uint8_t rrr_ordinal;
    uint8_t rrr_matchedlen;
    uint32_t rrr_ifid;
    struct in6_addr rrr_prefix;
};
struct nd_opt_adv_interval {
    uint8_t nd_opt_adv_interval_type;
    uint8_t nd_opt_adv_interval_len;
    uint16_t nd_opt_adv_interval_reserved;
    uint32_t nd_opt_adv_interval_ival;
};
struct nd_opt_home_agent_info {
    uint8_t nd_opt_home_agent_info_type;
    uint8_t nd_opt_home_agent_info_len;
    uint16_t nd_opt_home_agent_info_reserved;
    int16_t nd_opt_home_agent_info_preference;
    uint16_t nd_opt_home_agent_info_lifetime;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7486"
>14.4.38. netinet/igmp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IGMP_MEMBERSHIP_QUERY	0x11
#define IGMP_V1_MEMBERSHIP_REPORT	0x12
#define IGMP_DVMRP	0x13
#define IGMP_PIM	0x14
#define IGMP_TRACE	0x15
#define IGMP_V2_MEMBERSHIP_REPORT	0x16
#define IGMP_V2_LEAVE_GROUP	0x17
#define IGMP_MTRACE_RESP	0x1e
#define IGMP_MTRACE	0x1f
#define IGMP_DELAYING_MEMBER	1
#define IGMP_v1_ROUTER	1
#define IGMP_MAX_HOST_REPORT_DELAY	10
#define IGMP_TIMER_SCALE	10
#define IGMP_IDLE_MEMBER	2
#define IGMP_v2_ROUTER	2
#define IGMP_LAZY_MEMBER	3
#define IGMP_SLEEPING_MEMBER	4
#define IGMP_AWAKENING_MEMBER	5
#define IGMP_MINLEN	8
#define IGMP_HOST_MEMBERSHIP_QUERY	IGMP_MEMBERSHIP_QUERY
#define IGMP_HOST_MEMBERSHIP_REPORT	IGMP_V1_MEMBERSHIP_REPORT
#define IGMP_HOST_LEAVE_MESSAGE	IGMP_V2_LEAVE_GROUP
#define IGMP_HOST_NEW_MEMBERSHIP_REPORT	IGMP_V2_MEMBERSHIP_REPORT

struct igmp {
    u_int8_t igmp_type;
    u_int8_t igmp_code;
    u_int16_t igmp_cksum;
    struct in_addr igmp_group;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7490"
>14.4.39. netinet/in.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPPROTO_IP	0
#define IPPROTO_ICMP	1
#define IPPROTO_UDP	17
#define IPPROTO_IGMP	2
#define IPPROTO_RAW	255
#define IPPROTO_IPV6	41
#define IPPROTO_ICMPV6	58
#define IPPROTO_TCP	6

typedef uint16_t in_port_t;

struct in_addr {
    uint32_t s_addr;
};
typedef uint32_t in_addr_t;

#define INADDR_NONE	((in_addr_t) 0xffffffff)
#define INADDR_BROADCAST	(0xffffffff)
#define INADDR_ANY	0
#define INADDR_LOOPBACK	0x7f000001	/* 127.0.0.1 */

#define s6_addr16	in6_u.u6_addr16
#define s6_addr32	in6_u.u6_addr32
#define s6_addr	in6_u.u6_addr8

struct in6_addr {
    union {
	uint8_t u6_addr8[16];
	uint16_t u6_addr16[8];
	uint32_t u6_addr32[4];
    } in6_u;
};

#define IN6ADDR_ANY_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
#define IN6ADDR_LOOPBACK_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

#define IN_MULTICAST(a)	((((in_addr_t)(a))&#38;0xf0000000)==0xe0000000)
#define INET_ADDRSTRLEN	16

struct sockaddr_in {
    sa_family_t sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    unsigned char sin_zero[8];
};

#define IN6_IS_ADDR_LINKLOCAL(a)	((((const uint32_t *) (a))[0] &#38; htonl (0xffc00000)) == htonl (0xfe800000))
#define IN6_IS_ADDR_SITELOCAL(a)	((((const uint32_t *) (a))[0] &#38; htonl (0xffc00000)) == htonl (0xfec00000))
#define IN6_ARE_ADDR_EQUAL(a,b)	((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0]) &#38;&#38; (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1]) &#38;&#38; (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2]) &#38;&#38; (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))
#define IN6_IS_ADDR_V4COMPAT(a)	((((const uint32_t *) (a))[0] == 0) &#38;&#38; (((const uint32_t *) (a))[1] == 0) &#38;&#38; (((const uint32_t *) (a))[2] == 0) &#38;&#38; (ntohl (((const uint32_t *) (a))[3]) &#62; 1))
#define IN6_IS_ADDR_V4MAPPED(a)	((((const uint32_t *) (a))[0] == 0) &#38;&#38; (((const uint32_t *) (a))[1] == 0) &#38;&#38; (((const uint32_t *) (a))[2] == htonl (0xffff)))
#define IN6_IS_ADDR_UNSPECIFIED(a)	(((const uint32_t *) (a))[0] == 0 &#38;&#38; ((const uint32_t *) (a))[1] == 0 &#38;&#38; ((const uint32_t *) (a))[2] == 0 &#38;&#38; ((const uint32_t *) (a))[3] == 0)
#define IN6_IS_ADDR_LOOPBACK(a)	(((const uint32_t *) (a))[0] == 0 &#38;&#38; ((const uint32_t *) (a))[1] == 0 &#38;&#38; ((const uint32_t *) (a))[2] == 0 &#38;&#38; ((const uint32_t *) (a))[3] == htonl (1))
#define IN6_IS_ADDR_MULTICAST(a)	(((const uint8_t *) (a))[0] == 0xff)
#define IN6_IS_ADDR_MC_NODELOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x1))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x2))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x5))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0x8))
#define IN6_IS_ADDR_MC_GLOBAL(a)	(IN6_IS_ADDR_MULTICAST(a) &#38;&#38; ((((const uint8_t *) (a))[1] &#38; 0xf) == 0xe))
#define INET6_ADDRSTRLEN	46

struct sockaddr_in6 {
    unsigned short sin6_family;	/* AF_INET6 */
    uint16_t sin6_port;		/* Transport layer port # */
    uint32_t sin6_flowinfo;	/* IPv6 flow information */
    struct in6_addr sin6_addr;	/* IPv6 address */
    uint32_t sin6_scope_id;	/* scope id (new in RFC2553) */
};

#define SOL_IP	0
#define IP_TOS	1		/* IP type of service and precedence */
#define IPV6_UNICAST_HOPS	16
#define IPV6_MULTICAST_IF	17
#define IPV6_MULTICAST_HOPS	18
#define IPV6_MULTICAST_LOOP	19
#define IP_TTL	2		/* IP time to live */
#define IPV6_JOIN_GROUP	20
#define IPV6_LEAVE_GROUP	21
#define IPV6_V6ONLY	26
#define IP_MULTICAST_IF	32	/* set/get IP multicast i/f */
#define IP_MULTICAST_TTL	33	/* set/get IP multicast ttl */
#define IP_MULTICAST_LOOP	34	/* set/get IP multicast loopback */
#define IP_ADD_MEMBERSHIP	35	/* add an IP group membership */
#define IP_DROP_MEMBERSHIP	36	/* drop an IP group membership */
#define IP_OPTIONS	4	/* IP per-packet options */
#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP

struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;	/* IPv6 multicast address of group */
    int ipv6mr_interface;	/* local IPv6 address of interface */
};
struct ip_mreq {
    struct in_addr imr_multiaddr;	/* IP multicast address of group */
    struct in_addr imr_interface;	/* local IP address of interface */
};
extern int bindresvport(int, struct sockaddr_in *);
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7494"
>14.4.40. netinet/in_systm.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef u_int16_t n_short;
typedef u_int32_t n_long;
typedef u_int32_t n_time;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7498"
>14.4.41. netinet/ip.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPOPT_CLASS(o)	((o) &#38; IPOPT_CLASS_MASK)
#define IPOPT_COPIED(o)	((o) &#38; IPOPT_COPY)
#define IPOPT_NUMBER(o)	((o) &#38; IPOPT_NUMBER_MASK)
#define IPOPT_EOL	0
#define IPOPT_OPTVAL	0
#define IPOPT_TS_TSONLY	0
#define IPOPT_CONTROL	0x00
#define IPOPT_SECUR_UNCLASS	0x0000
#define IPOPT_NUMBER_MASK	0x1f
#define IP_OFFMASK	0x1fff
#define IPOPT_RESERVED1	0x20
#define IP_MF	0x2000
#define IPOPT_DEBMEAS	0x40
#define IP_DF	0x4000
#define IPOPT_CLASS_MASK	0x60
#define IPOPT_RESERVED2	0x60
#define IPOPT_SECUR_TOPSECRET	0x6bc5
#define IPOPT_SECUR_EFTO	0x789a
#define IPOPT_COPY	0x80
#define IP_RF	0x8000
#define IPOPT_SECUR_RESTR	0xaf13
#define IPOPT_SECUR_MMMM	0xbc4d
#define IPOPT_SECUR_SECRET	0xd788
#define IPOPT_SECUR_CONFID	0xf135
#define IPOPT_NOP	1
#define IPOPT_OLEN	1
#define IPOPT_TS_TSANDADDR	1
#define IPTTLDEC	1
#define IPOPT_SECURITY	130
#define IPOPT_LSRR	131
#define IPOPT_SATID	136
#define IPOPT_SSRR	137
#define IPOPT_RA	148
#define IPOPT_OFFSET	2
#define MAXTTL	255
#define IPOPT_TS_PRESPEC	3
#define IPOPT_MINOFF	4
#define IPVERSION	4
#define MAX_IPOPTLEN	40
#define IP_MSS	576
#define IPFRAGTTL	60
#define IPDEFTTL	64
#define IP_MAXPACKET	65535
#define IPOPT_TS	68
#define IPOPT_RR	7
#define IPOPT_MEASUREMENT	IPOPT_DEBMEAS
#define IPOPT_END	IPOPT_EOL
#define IPOPT_NOOP	IPOPT_NOP
#define IPOPT_SID	IPOPT_SATID
#define IPOPT_SEC	IPOPT_SECURITY
#define IPOPT_TIMESTAMP	IPOPT_TS

#define IPTOS_TOS(tos)	((tos) &#38; IPTOS_TOS_MASK)
#define IPTOS_LOWCOST	0x02
#define IPTOS_RELIABILITY	0x04
#define IPTOS_THROUGHPUT	0x08
#define IPTOS_LOWDELAY	0x10
#define IPTOS_TOS_MASK	0x1e
#define IPTOS_MINCOST	IPTOS_LOWCOST

#define IPTOS_PREC(tos)	((tos) &#38; IPTOS_PREC_MASK)
#define IPTOS_PREC_MASK	0xe0</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7502"
>14.4.42. netinet/ip6.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IP6OPT_TYPE(o)	((o) &#38; 0xc0)
#define IP6OPT_PAD1	0
#define IP6OPT_TYPE_SKIP	0x00
#define IP6OPT_TUNNEL_LIMIT	0x04
#define IP6OPT_ROUTER_ALERT	0x05
#define IP6OPT_TYPE_MUTABLE	0x20
#define IP6OPT_TYPE_DISCARD	0x40
#define IP6OPT_TYPE_FORCEICMP	0x80
#define IP6OPT_TYPE_ICMP	0xc0
#define IP6OPT_JUMBO	0xc2
#define IP6OPT_NSAP_ADDR	0xc3
#define IP6OPT_PADN	1
#define IP6OPT_JUMBO_LEN	6
#define ip6_flow	ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_hlim	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_nxt	ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_plen	ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_vfc	ip6_ctlun.ip6_un2_vfc

struct ip6_hdrctl {
    uint32_t ip6_un1_flow;
    uint16_t ip6_un1_plen;
    uint8_t ip6_un1_nxt;
    uint8_t ip6_un1_hlim;
};
struct ip6_hdr {
    struct in6_addr ip6_src;
    struct in6_addr ip6_dst;
};
struct ip6_ext {
    uint8_t ip6e_nxt;
    uint8_t ip6e_len;
};
struct ip6_hbh {
    uint8_t ip6h_nxt;
    uint8_t ip6h_len;
};
struct ip6_dest {
    uint8_t ip6d_nxt;
    uint8_t ip6d_len;
};
struct ip6_rthdr {
    uint8_t ip6r_nxt;
    uint8_t ip6r_len;
    uint8_t ip6r_type;
    uint8_t ip6r_segleft;
};
struct ip6_frag {
    uint8_t ip6f_nxt;
    uint8_t ip6f_reserved;
    uint16_t ip6f_offlg;
    uint32_t ip6f_ident;
};
struct ip6_opt {
    uint8_t ip6o_type;
    uint8_t ip6o_len;
};
struct ip6_opt_jumbo {
    uint8_t ip6oj_type;
    uint8_t ip6oj_len;
    uint8_t ip6oj_jumbo_len[4];
};
struct ip6_opt_nsap {
    uint8_t ip6on_type;
    uint8_t ip6on_len;
    uint8_t ip6on_src_nsap_len;
    uint8_t ip6on_dst_nsap_len;
};
struct ip6_opt_tunnel {
    uint8_t ip6ot_type;
    uint8_t ip6ot_len;
    uint8_t ip6ot_encap_limit;
};
struct ip6_opt_router {
    uint8_t ip6or_type;
    uint8_t ip6or_len;
    uint8_t ip6or_value[2];
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7506"
>14.4.43. netinet/ip_icmp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ICMP_INFOTYPE(type)	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || (type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || (type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || (type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || (type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
#define ICMP_ADVLEN(p)	(8 + ((p)-&#62;icmp_ip.ip_hl &#60;&#60; 2) + 8)
#define ICMP_TSLEN	(8 + 3 * sizeof (n_time))
#define ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)
#define ICMP_ECHOREPLY	0
#define ICMP_EXC_TTL	0
#define ICMP_NET_UNREACH	0
#define ICMP_REDIRECT_NET	0
#define ICMP_REDIR_NET	0
#define ICMP_TIMXCEED_INTRANS	0
#define ICMP_UNREACH_NET	0
#define ICMP_EXC_FRAGTIME	1
#define ICMP_HOST_UNREACH	1
#define ICMP_PARAMPROB_OPTABSENT	1
#define ICMP_REDIRECT_HOST	1
#define ICMP_REDIR_HOST	1
#define ICMP_TIMXCEED_REASS	1
#define ICMP_UNREACH_HOST	1
#define ICMP_HOST_ANO	10
#define ICMP_ROUTERSOLICIT	10
#define ICMP_UNREACH_HOST_PROHIB	10
#define ICMP_NET_UNR_TOS	11
#define ICMP_TIME_EXCEEDED	11
#define ICMP_TIMXCEED	11
#define ICMP_UNREACH_TOSNET	11
#define ICMP_HOST_UNR_TOS	12
#define ICMP_MASKLEN	12
#define ICMP_PARAMETERPROB	12
#define ICMP_PARAMPROB	12
#define ICMP_UNREACH_TOSHOST	12
#define ICMP_PKT_FILTERED	13
#define ICMP_TIMESTAMP	13
#define ICMP_TSTAMP	13
#define ICMP_UNREACH_FILTER_PROHIB	13
#define ICMP_PREC_VIOLATION	14
#define ICMP_TIMESTAMPREPLY	14
#define ICMP_TSTAMPREPLY	14
#define ICMP_UNREACH_HOST_PRECEDENCE	14
#define ICMP_INFO_REQUEST	15
#define ICMP_IREQ	15
#define ICMP_PREC_CUTOFF	15
#define ICMP_UNREACH_PRECEDENCE_CUTOFF	15
#define NR_ICMP_UNREACH	15
#define ICMP_INFO_REPLY	16
#define ICMP_IREQREPLY	16
#define ICMP_ADDRESS	17
#define ICMP_MASKREQ	17
#define ICMP_ADDRESSREPLY	18
#define ICMP_MASKREPLY	18
#define ICMP_MAXTYPE	18
#define NR_ICMP_TYPES	18
#define ICMP_PROT_UNREACH	2
#define ICMP_REDIRECT_TOSNET	2
#define ICMP_REDIR_NETTOS	2
#define ICMP_UNREACH_PROTOCOL	2
#define ICMP_DEST_UNREACH	3
#define ICMP_PORT_UNREACH	3
#define ICMP_REDIRECT_TOSHOST	3
#define ICMP_REDIR_HOSTTOS	3
#define ICMP_UNREACH	3
#define ICMP_UNREACH_PORT	3
#define ICMP_FRAG_NEEDED	4
#define ICMP_SOURCEQUENCH	4
#define ICMP_SOURCE_QUENCH	4
#define ICMP_UNREACH_NEEDFRAG	4
#define ICMP_REDIRECT	5
#define ICMP_SR_FAILED	5
#define ICMP_UNREACH_SRCFAIL	5
#define ICMP_NET_UNKNOWN	6
#define ICMP_UNREACH_NET_UNKNOWN	6
#define ICMP_HOST_UNKNOWN	7
#define ICMP_UNREACH_HOST_UNKNOWN	7
#define ICMP_ECHO	8
#define ICMP_HOST_ISOLATED	8
#define ICMP_MINLEN	8
#define ICMP_UNREACH_ISOLATED	8
#define ICMP_NET_ANO	9
#define ICMP_ROUTERADVERT	9
#define ICMP_UNREACH_NET_PROHIB	9
#define icmp_data	icmp_dun.id_data
#define icmp_ip	icmp_dun.id_ip.idi_ip
#define icmp_mask	icmp_dun.id_mask
#define icmp_radv	icmp_dun.id_radv
#define icmp_otime	icmp_dun.id_ts.its_otime
#define icmp_rtime	icmp_dun.id_ts.its_rtime
#define icmp_ttime	icmp_dun.id_ts.its_ttime
#define icmp_gwaddr	icmp_hun.ih_gwaddr
#define icmp_id	icmp_hun.ih_idseq.icd_id
#define icmp_seq	icmp_hun.ih_idseq.icd_seq
#define icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
#define icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
#define icmp_pptr	icmp_hun.ih_pptr
#define icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
#define icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
#define icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
#define icmp_void	icmp_hun.ih_void

struct icmphdr {
    u_int8_t type;
    u_int8_t code;
    u_int16_t checksum;
    union {
	struct {
	    u_int16_t id;
	    u_int16_t sequence;
	} echo;
	u_int32_t gateway;
	struct {
	    u_int16_t __unused;
	    u_int16_t mtu;
	} frag;
    } un;
};
struct icmp_ra_addr {
    u_int32_t ira_addr;
    u_int32_t ira_preference;
};
struct ih_idseq {
    u_int16_t icd_id;
    u_int16_t icd_seq;
};
struct ih_pmtu {
    u_int16_t ipm_void;
    u_int16_t ipm_nextmtu;
};
struct ih_rtradv {
    u_int8_t irt_num_addrs;
    u_int8_t irt_wpa;
    u_int16_t irt_lifetime;
};
struct icmp {
    u_int8_t icmp_type;
    u_int8_t icmp_code;
    u_int16_t icmp_cksum;
    union {
	u_int16_t ih_pptr;
	struct in_addr ih_gwaddr;
	struct ih_idseq ih_idseq;
	u_int32_t ih_void;
	struct ih_pmtu ih_pmtu;
	struct ih_rtradv ih_rtradv;
    } icmp_hun;
    union {
	struct {
	    u_int32_t its_otime;
	    u_int32_t its_rtime;
	    u_int32_t its_ttime;
	} id_ts;
	struct {
	    struct ip idi_ip;
	} id_ip;
	struct icmp_ra_addr id_radv;
	u_int32_t id_mask;
	u_int8_t id_data[1];
    } icmp_dun;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7510"
>14.4.44. netinet/tcp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2)
#define TCPOPT_TSTAMP_HDR	(TCPOPT_NOP&#60;&#60;24|TCPOPT_NOP&#60;&#60;16|TCPOPT_TIMESTAMP&#60;&#60;8|TCPOLEN_TIMESTAMP)
#define TCPOPT_EOL	0
#define TCPI_OPT_TIMESTAMPS	1
#define TCPOPT_NOP	1
#define TCP_NODELAY	1
#define TCPOLEN_TIMESTAMP	10
#define TCP_WINDOW_CLAMP	10
#define TCP_INFO	11
#define TCP_QUICKACK	12
#define TCP_CONGESTION	13
#define TCP_MAX_WINSHIFT	14
#define TCPI_OPT_SACK	2
#define TCPOLEN_SACK_PERMITTED	2
#define TCPOPT_MAXSEG	2
#define TCP_MAXSEG	2
#define TCPOLEN_WINDOW	3
#define TCPOPT_WINDOW	3
#define TCP_CORK	3
#define TCPI_OPT_WSCALE	4
#define TCPOLEN_MAXSEG	4
#define TCPOPT_SACK_PERMITTED	4
#define TCP_KEEPIDLE	4
#define TCPOPT_SACK	5
#define TCP_KEEPINTVL	5
#define TCP_MSS	512
#define SOL_TCP	6
#define TCP_KEEPCNT	6
#define TCP_MAXWIN	65535
#define TCP_SYNCNT	7
#define TCPI_OPT_ECN	8
#define TCPOPT_TIMESTAMP	8
#define TCP_LINGER2	8
#define TCP_DEFER_ACCEPT	9

enum tcp_ca_state {
    TCP_CA_Open,
    TCP_CA_Disorder,
    TCP_CA_CWR,
    TCP_CA_Recovery,
    TCP_CA_Loss
};
struct tcp_info {
    uint8_t tcpi_state;
    uint8_t tcpi_ca_state;
    uint8_t tcpi_retransmits;
    uint8_t tcpi_probes;
    uint8_t tcpi_backoff;
    uint8_t tcpi_options;
    uint8_t tcpi_snd_wscale:4;
    uint8_t tcpi_rcv_wscale:4;
    uint32_t tcpi_rto;
    uint32_t tcpi_ato;
    uint32_t tcpi_snd_mss;
    uint32_t tcpi_rcv_mss;
    uint32_t tcpi_unacked;
    uint32_t tcpi_sacked;
    uint32_t tcpi_lost;
    uint32_t tcpi_retrans;
    uint32_t tcpi_fackets;
    uint32_t tcpi_last_data_sent;
    uint32_t tcpi_last_ack_sent;
    uint32_t tcpi_last_data_recv;
    uint32_t tcpi_last_ack_recv;
    uint32_t tcpi_pmtu;
    uint32_t tcpi_rcv_ssthresh;
    uint32_t tcpi_rtt;
    uint32_t tcpi_rttvar;
    uint32_t tcpi_snd_ssthresh;
    uint32_t tcpi_snd_cwnd;
    uint32_t tcpi_advmss;
    uint32_t tcpi_reordering;
};
enum {
    TCP_ESTABLISHED = 1,
    TCP_SYN_SENT = 2,
    TCP_SYN_RECV = 3,
    TCP_FIN_WAIT1 = 4,
    TCP_FIN_WAIT2 = 5,
    TCP_TIME_WAIT = 6,
    TCP_CLOSE = 7,
    TCP_CLOSE_WAIT = 8,
    TCP_LAST_ACK = 9,
    TCP_LISTEN = 10,
    TCP_CLOSING = 11
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7514"
>14.4.45. netinet/udp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SOL_UDP	17

struct udphdr {
    u_int16_t source;
    u_int16_t dest;
    u_int16_t len;
    u_int16_t check;
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7518"
>14.4.46. nl_types.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NL_CAT_LOCALE	1
#define NL_SETD	1

typedef void *nl_catd;

typedef int nl_item;
extern int catclose(nl_catd __catalog);
extern char *catgets(nl_catd __catalog, int __set, int __number,
		     const char *__string);
extern nl_catd catopen(const char *__cat_name, int __flag);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7522"
>14.4.47. poll.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int poll(struct pollfd *__fds, nfds_t __nfds, int __timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7526"
>14.4.48. pwd.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct passwd {
    char *pw_name;
    char *pw_passwd;
    uid_t pw_uid;
    gid_t pw_gid;
    char *pw_gecos;
    char *pw_dir;
    char *pw_shell;
};
extern void endpwent(void);
extern struct passwd *getpwent(void);
extern int getpwent_r(struct passwd *__resultbuf, char *__buffer,
		      size_t __buflen, struct passwd **__result);
extern struct passwd *getpwnam(const char *__name);
extern int getpwnam_r(const char *__name, struct passwd *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct passwd **__result);
extern struct passwd *getpwuid(uid_t __uid);
extern int getpwuid_r(uid_t __uid, struct passwd *__resultbuf,
		      char *__buffer, size_t __buflen,
		      struct passwd **__result);
extern void setpwent(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7530"
>14.4.49. regex.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RE_DUP_MAX	(0x7fff)

typedef unsigned long int reg_syntax_t;

typedef struct re_pattern_buffer {
    unsigned char *buffer;
    unsigned long int allocated;
    unsigned long int used;
    reg_syntax_t syntax;
    char *fastmap;
    char *translate;
    size_t re_nsub;
    unsigned int can_be_null:1;
    unsigned int regs_allocated:2;
    unsigned int fastmap_accurate:1;
    unsigned int no_sub:1;
    unsigned int not_bol:1;
    unsigned int not_eol:1;
    unsigned int newline_anchor:1;
} regex_t;
typedef int regoff_t;
typedef struct {
    regoff_t rm_so;
    regoff_t rm_eo;
} regmatch_t;

#define REG_ICASE	(REG_EXTENDED&#60;&#60;1)
#define REG_NEWLINE	(REG_ICASE&#60;&#60;1)
#define REG_NOSUB	(REG_NEWLINE&#60;&#60;1)
#define REG_EXTENDED	1

#define REG_NOTEOL	(1&#60;&#60;1)
#define REG_NOTBOL	1

typedef enum {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} reg_errcode_t;
extern int regcomp(regex_t * __preg, const char *__pattern, int __cflags);
extern size_t regerror(int __errcode, const regex_t * __preg,
		       char *__errbuf, size_t __errbuf_size);
extern int regexec(const regex_t * __preg, const char *__string,
		   size_t __nmatch, regmatch_t __pmatch[], int __eflags);
extern void regfree(regex_t * __preg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7534"
>14.4.50. rpc/auth.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define auth_destroy(auth)	((*((auth)-&#62;ah_ops-&#62;ah_destroy))(auth))

enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,		/* bogus credentials (seal broken) */
    AUTH_REJECTEDCRED = 2,	/* client should begin new session */
    AUTH_BADVERF = 3,		/* bogus verifier (seal broken) */
    AUTH_REJECTEDVERF = 4,	/* verifier expired or was replayed */
    AUTH_TOOWEAK = 5,		/* Rpc calls return an enum clnt_stat. */
    AUTH_INVALIDRESP = 6,	/* bogus response verifier */
    AUTH_FAILED = 7		/* some unknown reason */
};

union des_block {
    struct {
	u_int32_t high;
	u_int32_t low;
    } key;
    char c[8];
};

struct opaque_auth {
    enum_t oa_flavor;		/* flavor of auth */
    caddr_t oa_base;		/* address of more auth stuff */
    u_int oa_length;		/* not to exceed MAX_AUTH_BYTES */
};

typedef struct AUTH {
    struct opaque_auth ah_cred;
    struct opaque_auth ah_verf;
    union des_block ah_key;
    struct auth_ops *ah_ops;
    caddr_t ah_private;
} AUTH;

struct auth_ops {
    void (*ah_nextverf) (struct AUTH *);
    int (*ah_marshal) (struct AUTH *, XDR *);	/* nextverf &#38; serialize */
    int (*ah_validate) (struct AUTH *, struct opaque_auth *);	/* validate verifier */
    int (*ah_refresh) (struct AUTH *);	/* refresh credentials */
    void (*ah_destroy) (struct AUTH *);	/* Rpc calls return an enum clnt_stat. */
};
extern struct AUTH *authnone_create(void);
extern int key_decryptsession(char *, union des_block *);
extern bool_t xdr_opaque_auth(XDR *, struct opaque_auth *);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7538"
>14.4.51. rpc/clnt.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define clnt_control(cl,rq,in)	((*(cl)-&#62;cl_ops-&#62;cl_control)(cl,rq,in))
#define clnt_abort(rh)	((*(rh)-&#62;cl_ops-&#62;cl_abort)(rh))
#define clnt_destroy(rh)	((*(rh)-&#62;cl_ops-&#62;cl_destroy)(rh))
#define clnt_freeres(rh,xres,resp)	((*(rh)-&#62;cl_ops-&#62;cl_freeres)(rh,xres,resp))
#define clnt_geterr(rh,errp)	((*(rh)-&#62;cl_ops-&#62;cl_geterr)(rh, errp))
#define NULLPROC	((u_long)0)	/* By convention, procedure 0 takes null arguments and returns */
#define CLSET_TIMEOUT	1	/* set timeout (timeval) */
#define CLGET_XID	10	/* Get xid */
#define CLSET_XID	11	/* Set xid */
#define CLGET_VERS	12	/* Get version number */
#define CLSET_VERS	13	/* Set version number */
#define CLGET_PROG	14	/* Get program number */
#define CLSET_PROG	15	/* Set program number */
#define CLGET_TIMEOUT	2	/* get timeout (timeval) */
#define CLGET_SERVER_ADDR	3	/* get server's address (sockaddr) */
#define CLSET_RETRY_TIMEOUT	4	/* set retry timeout (timeval) */
#define CLGET_RETRY_TIMEOUT	5	/* get retry timeout (timeval) */
#define CLGET_FD	6	/* get connections file descriptor */
#define CLGET_SVC_ADDR	7	/* get server's address (netbuf) */
#define CLSET_FD_CLOSE	8	/* close fd while clnt_destroy */
#define CLSET_FD_NCLOSE	9	/* Do not close fd while clnt_destroy */
#define clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)-&#62;cl_ops-&#62;cl_call)(rh, proc, xargs, argsp, xres, resp, secs))

enum clnt_stat {
    RPC_SUCCESS = 0,		/* call succeeded */
    RPC_CANTENCODEARGS = 1,	/* can't encode arguments */
    RPC_CANTDECODERES = 2,	/* can't decode results */
    RPC_CANTSEND = 3,		/* failure in sending call */
    RPC_CANTRECV = 4,		/* failure in receiving result */
    RPC_TIMEDOUT = 5,		/* call timed out */
    RPC_VERSMISMATCH = 6,	/* rpc versions not compatible */
    RPC_AUTHERROR = 7,		/* authentication error */
    RPC_PROGUNAVAIL = 8,	/* program not available */
    RPC_PROGVERSMISMATCH = 9,	/* program version mismatched */
    RPC_PROCUNAVAIL = 10,	/* procedure unavailable */
    RPC_CANTDECODEARGS = 11,	/* decode arguments error */
    RPC_SYSTEMERROR = 12,	/* generic "other problem" */
    RPC_NOBROADCAST = 21,	/* Broadcasting not supported */
    RPC_UNKNOWNHOST = 13,	/* unknown host name */
    RPC_UNKNOWNPROTO = 17,	/* unknown protocol */
    RPC_UNKNOWNADDR = 19,	/* Remote address unknown */
    RPC_RPCBFAILURE = 14,	/* portmapper failed in its call */
    RPC_PROGNOTREGISTERED = 15,	/* remote program is not registered */
    RPC_N2AXLATEFAILURE = 22,	/* Name to addr translation failed */
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
};
struct rpc_err {
    enum clnt_stat re_status;
    union {
	int RE_errno;
	enum auth_stat RE_why;
	struct {
	    u_long low;
	    u_long high;
	} RE_vers;
	struct {
	    long int s1;
	    long int s2;
	} RE_lb;
    } ru;
};

typedef struct CLIENT {
    struct AUTH *cl_auth;
    struct clnt_ops *cl_ops;
    caddr_t cl_private;
} CLIENT;

struct clnt_ops {
    enum clnt_stat (*cl_call) (struct CLIENT *, u_long, xdrproc_t, caddr_t,
			       xdrproc_t, caddr_t, struct timeval);
    void (*cl_abort) (void);
    void (*cl_geterr) (struct CLIENT *, struct rpc_err *);
     bool_t(*cl_freeres) (struct CLIENT *, xdrproc_t, caddr_t);
    void (*cl_destroy) (struct CLIENT *);
     bool_t(*cl_control) (struct CLIENT *, int, char *);
};
extern int callrpc(const char *__host, const u_long __prognum,
		   const u_long __versnum, const u_long __procnum,
		   const xdrproc_t __inproc, const char *__in,
		   const xdrproc_t __outproc, char *__out);
extern struct CLIENT *clnt_create(const char *__host, const u_long __prog,
				  const u_long __vers, const char *__prot);
extern void clnt_pcreateerror(const char *__msg);
extern void clnt_perrno(enum clnt_stat __num);
extern void clnt_perror(struct CLIENT *__clnt, const char *__msg);
extern char *clnt_spcreateerror(const char *__msg);
extern char *clnt_sperrno(enum clnt_stat __num);
extern char *clnt_sperror(struct CLIENT *__clnt, const char *__msg);
extern struct CLIENT *clntraw_create(u_long __prog, u_long __vers);
extern struct CLIENT *clnttcp_create(struct sockaddr_in *__raddr,
				     u_long __prog, u_long __version,
				     int *__sockp, u_int __sendsz,
				     u_int __recvsz);
extern struct CLIENT *clntudp_bufcreate(struct sockaddr_in *__raddr,
					u_long __program, u_long __version,
					struct timeval __wait_resend,
					int *__sockp, u_int __sendsz,
					u_int __recvsz);
extern struct CLIENT *clntudp_create(struct sockaddr_in *__raddr,
				     u_long __program, u_long __version,
				     struct timeval __wait_resend,
				     int *__sockp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7542"
>14.4.52. rpc/pmap_clnt.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern u_short pmap_getport(struct sockaddr_in *__address,
			    const u_long __program, const u_long __version,
			    u_int __protocol);
extern bool_t pmap_set(const u_long __program, const u_long __vers,
		       int __protocol, u_short __port);
extern bool_t pmap_unset(u_long __program, u_long __vers);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7546"
>14.4.53. rpc/rpc_msg.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum msg_type {
    CALL = 0,
    REPLY = 1
};
enum reply_stat {
    MSG_ACCEPTED = 0,
    MSG_DENIED = 1
};
enum accept_stat {
    SUCCESS = 0,
    PROG_UNAVAIL = 1,
    PROG_MISMATCH = 2,
    PROC_UNAVAIL = 3,
    GARBAGE_ARGS = 4,
    SYSTEM_ERR = 5
};
enum reject_stat {
    RPC_MISMATCH = 0,
    AUTH_ERROR = 1
};

#define ar_results	ru.AR_results
#define ar_vers	ru.AR_versions

struct accepted_reply {
    struct opaque_auth ar_verf;
    enum accept_stat ar_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} AR_versions;
	struct {
	    caddr_t where;
	    xdrproc_t proc;
	} AR_results;
    } ru;
};

#define rj_vers	ru.RJ_versions
#define rj_why	ru.RJ_why

struct rejected_reply {
    enum reject_stat rj_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} RJ_versions;
	enum auth_stat RJ_why;	/* why authentication did not work */
    } ru;
};

#define rp_acpt	ru.RP_ar
#define rp_rjct	ru.RP_dr

struct reply_body {
    enum reply_stat rp_stat;
    union {
	struct accepted_reply RP_ar;
	struct rejected_reply RP_dr;
    } ru;
};

struct call_body {
    unsigned long int cb_rpcvers;	/* must be equal to two */
    unsigned long int cb_prog;
    unsigned long int cb_vers;
    unsigned long int cb_proc;
    struct opaque_auth cb_cred;
    struct opaque_auth cb_verf;	/* protocol specific - provided by client */
};

#define rm_call	ru.RM_cmb
#define rm_reply	ru.RM_rmb
#define acpted_rply	ru.RM_rmb.ru.RP_ar
#define rjcted_rply	ru.RM_rmb.ru.RP_dr

struct rpc_msg {
    unsigned long int rm_xid;
    enum msg_type rm_direction;
    union {
	struct call_body RM_cmb;
	struct reply_body RM_rmb;
    } ru;
};
extern bool_t xdr_accepted_reply(XDR *, struct accepted_reply *);
extern bool_t xdr_callhdr(XDR * __xdrs, struct rpc_msg *__cmsg);
extern bool_t xdr_callmsg(XDR * __xdrs, struct rpc_msg *__cmsg);
extern bool_t xdr_rejected_reply(XDR *, struct rejected_reply *);
extern bool_t xdr_replymsg(XDR * __xdrs, struct rpc_msg *__rmsg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7550"
>14.4.54. rpc/svc.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define svc_getcaller(x)	(&#38;(x)-&#62;xp_raddr)
#define svc_destroy(xprt)	(*(xprt)-&#62;xp_ops-&#62;xp_destroy)(xprt)
#define svc_recv(xprt,msg)	(*(xprt)-&#62;xp_ops-&#62;xp_recv)((xprt), (msg))
#define svc_reply(xprt,msg)	(*(xprt)-&#62;xp_ops-&#62;xp_reply) ((xprt), (msg))
#define svc_stat(xprt)	(*(xprt)-&#62;xp_ops-&#62;xp_stat)(xprt)
#define RPC_ANYSOCK	-1
#define svc_freeargs(xprt,xargs, argsp)	\
	(*(xprt)-&#62;xp_ops-&#62;xp_freeargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt,xargs, argsp)	\
	(*(xprt)-&#62;xp_ops-&#62;xp_getargs)((xprt), (xargs), (argsp))

enum xprt_stat {
    XPRT_DIED,
    XPRT_MOREREQS,
    XPRT_IDLE
};

typedef struct SVCXPRT {
    int xp_sock;
    u_short xp_port;
    struct xp_ops *xp_ops;
    int xp_addrlen;
    struct sockaddr_in xp_raddr;
    struct opaque_auth xp_verf;
    caddr_t xp_p1;
    caddr_t xp_p2;
    char xp_pad[256];
} SVCXPRT;

struct svc_req {
    rpcprog_t rq_prog;
    rpcvers_t rq_vers;
    rpcproc_t rq_proc;
    struct opaque_auth rq_cred;
    caddr_t rq_clntcred;
    SVCXPRT *rq_xprt;
};

typedef void (*__dispatch_fn_t) (struct svc_req *, SVCXPRT *);

struct xp_ops {
    bool_t(*xp_recv) (SVCXPRT * __xprt, struct rpc_msg * __msg);
    enum xprt_stat (*xp_stat) (SVCXPRT * __xprt);
     bool_t(*xp_getargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			  caddr_t args_ptr);
     bool_t(*xp_reply) (SVCXPRT * __xprt, struct rpc_msg * __msg);
     bool_t(*xp_freeargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			   caddr_t args_ptr);
    void (*xp_destroy) (SVCXPRT * __xprt);
};
extern void svc_getreqset(fd_set * __readfds);
extern bool_t svc_register(SVCXPRT * __xprt, rpcprog_t __prog,
			   rpcvers_t __vers, __dispatch_fn_t __dispatch,
			   rpcprot_t __protocol);
extern void svc_run(void);
extern bool_t svc_sendreply(SVCXPRT * xprt, xdrproc_t __xdr_results,
			    caddr_t __xdr_location);
extern void svcerr_auth(SVCXPRT * __xprt, enum auth_stat __why);
extern void svcerr_decode(SVCXPRT * __xprt);
extern void svcerr_noproc(SVCXPRT * __xprt);
extern void svcerr_noprog(SVCXPRT * __xprt);
extern void svcerr_progvers(SVCXPRT * __xprt, rpcvers_t __low_vers,
			    rpcvers_t __high_vers);
extern void svcerr_systemerr(SVCXPRT * __xprt);
extern void svcerr_weakauth(SVCXPRT * __xprt);
extern SVCXPRT *svcfd_create(int, unsigned int, unsigned int);
extern SVCXPRT *svcraw_create(void);
extern SVCXPRT *svctcp_create(int __sock, u_int __sendsize,
			      u_int __recvsize);
extern SVCXPRT *svcudp_create(int __sock);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7554"
>14.4.55. rpc/types.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef int bool_t;
typedef int enum_t;
typedef unsigned long int rpcprog_t;
typedef unsigned long int rpcvers_t;
typedef unsigned long int rpcproc_t;
typedef unsigned long int rpcprot_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7558"
>14.4.56. rpc/xdr.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define XDR_DESTROY(xdrs)	 \
   do { if ((xdrs)-&#62;x_ops-&#62;x_destroy) (*(xdrs)-&#62;x_ops-&#62;x_destroy)(xdrs); \
      } while (0)
#define xdr_destroy(xdrs)	 \
   do { if ((xdrs)-&#62;x_ops-&#62;x_destroy) (*(xdrs)-&#62;x_ops-&#62;x_destroy)(xdrs); \
      } while (0)
#define XDR_GETBYTES(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_getbytes)(xdrs, addr, len)
#define XDR_GETINT32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_getint32)(xdrs, int32p)
#define xdr_getint32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_getint32)(xdrs, int32p)
#define XDR_GETLONG(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_getlong)(xdrs, longp)
#define XDR_GETPOS(xdrs)	(*(xdrs)-&#62;x_ops-&#62;x_getpostn)(xdrs)
#define xdr_getpos(xdrs)	(*(xdrs)-&#62;x_ops-&#62;x_getpostn)(xdrs)
#define XDR_INLINE(xdrs,len)	(*(xdrs)-&#62;x_ops-&#62;x_inline)(xdrs, len)
#define xdr_inline(xdrs,len)	(*(xdrs)-&#62;x_ops-&#62;x_inline)(xdrs, len)
#define XDR_PUTBYTES(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs,addr,len)	(*(xdrs)-&#62;x_ops-&#62;x_putbytes)(xdrs, addr, len)
#define XDR_PUTINT32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_putint32)(xdrs, int32p)
#define xdr_putint32(xdrs,int32p)	(*(xdrs)-&#62;x_ops-&#62;x_putint32)(xdrs, int32p)
#define XDR_PUTLONG(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs,longp)	(*(xdrs)-&#62;x_ops-&#62;x_putlong)(xdrs, longp)
#define XDR_SETPOS(xdrs,pos)	(*(xdrs)-&#62;x_ops-&#62;x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs,pos)	(*(xdrs)-&#62;x_ops-&#62;x_setpostn)(xdrs, pos)

enum xdr_op {
    XDR_ENCODE,
    XDR_DECODE,
    XDR_FREE
};
typedef struct XDR {
    enum xdr_op x_op;
    struct xdr_ops *x_ops;
    caddr_t x_public;
    caddr_t x_private;
    caddr_t x_base;
    int x_handy;
} XDR;

struct xdr_ops {
    bool_t(*x_getlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_putlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_getbytes) (XDR * __xdrs, caddr_t __addr, u_int __len);
    bool_t(*x_putbytes) (XDR * __xdrs, char *__addr, u_int __len);
    u_int(*x_getpostn) (XDR * __xdrs);
    bool_t(*x_setpostn) (XDR * __xdrs, u_int __pos);
    int32_t *(*x_inline) (XDR * __xdrs, int __len);
    void (*x_destroy) (XDR * __xdrs);
     bool_t(*x_getint32) (XDR * __xdrs, int32_t * __ip);
     bool_t(*x_putint32) (XDR * __xdrs, int32_t * __ip);
};

typedef bool_t(*xdrproc_t) (XDR *, void *, ...);

struct xdr_discrim {
    int value;
    xdrproc_t proc;
};
extern bool_t xdr_array(XDR * _xdrs, caddr_t * __addrp, u_int * __sizep,
			u_int __maxsize, u_int __elsize,
			xdrproc_t __elproc);
extern bool_t xdr_bool(XDR * __xdrs, bool_t * __bp);
extern bool_t xdr_bytes(XDR * __xdrs, char **__cpp, u_int * __sizep,
			u_int __maxsize);
extern bool_t xdr_char(XDR * __xdrs, char *__cp);
extern bool_t xdr_double(XDR * __xdrs, double *__dp);
extern bool_t xdr_enum(XDR * __xdrs, enum_t * __ep);
extern bool_t xdr_float(XDR * __xdrs, float *__fp);
extern void xdr_free(xdrproc_t __proc, char *__objp);
extern bool_t xdr_int(XDR * __xdrs, int *__ip);
extern bool_t xdr_long(XDR * __xdrs, long int *__lp);
extern bool_t xdr_opaque(XDR * __xdrs, caddr_t __cp, u_int __cnt);
extern bool_t xdr_pointer(XDR * __xdrs, char **__objpp, u_int __obj_size,
			  xdrproc_t __xdr_obj);
extern bool_t xdr_reference(XDR * __xdrs, caddr_t * __xpp, u_int __size,
			    xdrproc_t __proc);
extern bool_t xdr_short(XDR * __xdrs, short *__sp);
extern bool_t xdr_string(XDR * __xdrs, char **__cpp, u_int __maxsize);
extern bool_t xdr_u_char(XDR * __xdrs, u_char * __cp);
extern bool_t xdr_u_int(XDR * __xdrs, u_int * __up);
extern bool_t xdr_u_long(XDR * __xdrs, u_long * __ulp);
extern bool_t xdr_u_short(XDR * __xdrs, u_short * __usp);
extern bool_t xdr_union(XDR * __xdrs, enum_t * __dscmp, char *__unp,
			const struct xdr_discrim *__choices,
			xdrproc_t dfault);
extern bool_t xdr_vector(XDR * __xdrs, char *__basep, u_int __nelem,
			 u_int __elemsize, xdrproc_t __xdr_elem);
extern bool_t xdr_void(void);
extern bool_t xdr_wrapstring(XDR * __xdrs, char **__cpp);
extern void xdrmem_create(XDR * __xdrs, caddr_t __addr, u_int __size,
			  enum xdr_op __xop);
extern void xdrrec_create(XDR * __xdrs, u_int __sendsize, u_int __recvsize,
			  caddr_t __tcp_handle, int (*__readit) (char *,
								 char *,
								 int),
			  int (*__writeit) (char *, char *, int));
extern bool_t xdrrec_endofrecord(XDR * __xdrs, bool_t __sendnow);
extern bool_t xdrrec_eof(XDR * __xdrs);
extern bool_t xdrrec_skiprecord(XDR * __xdrs);
extern void xdrstdio_create(XDR * __xdrs, FILE * __file,
			    enum xdr_op __xop);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7562"
>14.4.57. sched.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define __CPU_ALLOC_SIZE(count)	((((count) + __NCPUBITS - 1) / __NCPUBITS) * 8)
#define __CPUELT(cpu)	((cpu) / __NCPUBITS)
#define __CPUMASK(cpu)	((__cpu_mask) 1 &#60;&#60; ((cpu) % __NCPUBITS))
#define __NCPUBITS	(8 * sizeof (__cpu_mask))
#define SCHED_OTHER	0
#define SCHED_FIFO	1
#define __CPU_SETSIZE	1024
#define SCHED_RR	2
#define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) 	\
  (__extension__\
   ({ cpu_set_t *__dest = (destset); \
     cpu_set_t *__arr1 = (srcset1); \
     cpu_set_t *__arr2 = (srcset2); \
     size_t __imax = (setsize) / sizeof (__cpu_mask); \
     size_t __i; \
     for (__i = 0; __i &#60; __imax; ++__i)\
       __dest-&#62;__bits[__i] = __arr1-&#62;__bits[__i] op __arr2-&#62;__bits[__i]; \
 __dest; }))
#define __CPU_SET_S(cpu, setsize, cpusetp)	\
  (__extension__\
   ({ size_t __cpu = (cpu); \
     __cpu &#60; 8 * (setsize) \
     ? ((cpusetp)-&#62;__bits[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))
#define __CPU_ISSET_S(cpu, setsize, cpusetp)	\
  (__extension__\
   ({ size_t __cpu = (cpu); \
     __cpu &#60; 8 * (setsize)\
     ? (((cpusetp)-&#62;__bits[__CPUELT (__cpu)] &#38; __CPUMASK (__cpu))) != 0 \
 : 0; }))
#define __CPU_CLR_S(cpu, setsize, cpusetp)	\
  (__extension__\
   ({ size_t __cpu = (cpu); \
     __cpu &#60; 8 * (setsize)\
     ? ((cpusetp)-&#62;__bits[__CPUELT (__cpu)] &#38;= ~__CPUMASK (__cpu)) : 0; }))
#define __CPU_ZERO_S(setsize, cpusetp)	\
  do {\
    size_t __i; \
    size_t __imax = (setsize) / sizeof (__cpu_mask); \
    cpu_set_t *__arr = (cpusetp); \
    for (__i = 0; __i &#60; __imax; ++__i)\
       __arr-&#62;__bits[__i] = 0; \
  } while (0)
#define CPU_ALLOC_SIZE(count)	__CPU_ALLOC_SIZE (count)
#define CPU_CLR(cpu, cpusetp)	__CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_ISSET(cpu, cpusetp)	__CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_AND_S(setsize, destset, srcset1, srcset2)	__CPU_OP_S (setsize, destset, srcset1, srcset2, &#38;)
#define CPU_XOR_S(setsize, destset, srcset1, srcset2)	__CPU_OP_S (setsize, destset, srcset1, srcset2, ^)
#define CPU_OR_S(setsize, destset, srcset1, srcset2)	__CPU_OP_S (setsize, destset, srcset1, srcset2, |)
#define CPU_AND(destset, srcset1, srcset2)	__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &#38;)
#define CPU_XOR(destset, srcset1, srcset2)	__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)
#define CPU_OR(destset, srcset1, srcset2)	__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)
#define CPU_SETSIZE	__CPU_SETSIZE
#define CPU_SET(cpu, cpusetp)	__CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_ZERO(cpusetp)	__CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)

struct sched_param {
    int sched_priority;
};
typedef unsigned long int __cpu_mask;
typedef struct {
    __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
} cpu_set_t;
extern int sched_get_priority_max(int __algorithm);
extern int sched_get_priority_min(int __algorithm);
extern int sched_getaffinity(pid_t __pid, size_t __cpusetsize,
			     cpu_set_t * __cpuset);
extern int sched_getparam(pid_t __pid, struct sched_param *__param);
extern int sched_getscheduler(pid_t __pid);
extern int sched_rr_get_interval(pid_t __pid, struct timespec *__t);
extern int sched_setaffinity(pid_t __pid, size_t __cpusetsize,
			     const cpu_set_t * __cpuset);
extern int sched_setparam(pid_t __pid, const struct sched_param *__param);
extern int sched_setscheduler(pid_t __pid, int __policy,
			      const struct sched_param *__param);
extern int sched_yield(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7566"
>14.4.58. search.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;typedef struct entry {
    char *key;
    void *data;
} ENTRY;
typedef enum {
    FIND,
    ENTER
} ACTION;
struct _ENTRY;
typedef enum {
    preorder,
    postorder,
    endorder,
    leaf
} VISIT;
struct hsearch_data {
    struct _ENTRY *table;
    unsigned int size;
    unsigned int filled;
};

typedef void (*__action_fn_t) (const void *__nodep, VISIT __value,
			       int __level);
extern int hcreate(size_t __nel);
extern int hcreate_r(size_t __nel, struct hsearch_data *__htab);
extern void hdestroy(void);
extern void hdestroy_r(struct hsearch_data *__htab);
extern ENTRY *hsearch(ENTRY __item, ACTION __action);
extern int hsearch_r(ENTRY __item, ACTION __action, ENTRY * *__retval,
		     struct hsearch_data *__htab);
extern void insque(void *__elem, void *__prev);
extern void *lfind(const void *__key, const void *__base, size_t * __nmemb,
		   size_t __size, __compar_fn_t __compar);
extern void *lsearch(const void *__key, void *__base, size_t * __nmemb,
		     size_t __size, __compar_fn_t __compar);
extern void remque(void *__elem);
extern void *tdelete(const void *__key, void **__rootp,
		     __compar_fn_t __compar);
extern void *tfind(const void *__key, void *const *__rootp,
		   __compar_fn_t __compar);
extern void *tsearch(const void *__key, void **__rootp,
		     __compar_fn_t __compar);
extern void twalk(const void *__root, __action_fn_t __action);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7570"
>14.4.59. setjmp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define setjmp(env)	_setjmp(env)
#define sigsetjmp(a,b)	__sigsetjmp(a,b)

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    sigset_t __saved_mask;
};

typedef struct __jmp_buf_tag jmp_buf[1];
typedef jmp_buf sigjmp_buf;
extern int __sigsetjmp(jmp_buf __env, int __savemask);
extern void _longjmp(jmp_buf __env, int __val);
extern int _setjmp(jmp_buf __env);
extern void longjmp(jmp_buf __env, int __val);
extern void siglongjmp(sigjmp_buf __env, int __val);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7574"
>14.4.60. signal.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define sigpause __xpg_sigpause

#define _SIGSET_NWORDS	(1024/(8*sizeof(unsigned long)))
#define SIGRTMAX	(__libc_current_sigrtmax ())
#define SIGRTMIN	(__libc_current_sigrtmin ())
#define NSIG	65
#define SIG_BLOCK	0	/* Block signals. */
#define SIG_UNBLOCK	1	/* Unblock signals. */
#define SIG_SETMASK	2	/* Set the set of blocked signals. */

typedef int sig_atomic_t;

typedef void (*sighandler_t) (int);

#define SIG_HOLD	((sighandler_t) 2)	/* Request that signal be held. */
#define SIG_DFL	((sighandler_t)0)	/* Request for default signal handling. */
#define SIG_IGN	((sighandler_t)1)	/* Request that signal be ignored. */
#define SIG_ERR	((sighandler_t)-1)	/* Return value from signal() in case of error. */

#define SIGHUP	1		/* Hangup. */
#define SIGINT	2		/* Terminal interrupt signal. */
#define SIGQUIT	3		/* Terminal quit signal. */
#define SIGILL	4		/* Illegal instruction. */
#define SIGTRAP	5		/* Trace/breakpoint trap. */
#define SIGABRT	6		/* Process abort signal. */
#define SIGIOT	6		/* IOT trap */
#define SIGBUS	7		/* Access to an undefined portion of a memory object. */
#define SIGFPE	8		/* Erroneous arithmetic operation. */
#define SIGKILL	9		/* Kill (cannot be caught or ignored). */
#define SIGUSR1	10		/* User-defined signal 1. */
#define SIGSEGV	11		/* Invalid memory reference. */
#define SIGUSR2	12		/* User-defined signal 2. */
#define SIGPIPE	13		/* Write  on a pipe with no one to read it. */
#define SIGALRM	14		/* Alarm clock. */
#define SIGTERM	15		/* Termination signal. */
#define SIGSTKFLT	16	/* Stack fault. */
#define SIGCHLD	17		/* Child process terminated, stopped, or continued. */
#define SIGCLD	SIGCHLD		/* Same as SIGCHLD */
#define SIGCONT	18		/* Continue executing, if stopped. */
#define SIGSTOP	19		/* Stop executing (cannot be caught or ignored). */
#define SIGTSTP	20		/* Terminal stop signal. */
#define SIGTTIN	21		/* Background process attempting read. */
#define SIGTTOU	22		/* Background process attempting write. */
#define SIGURG	23		/* High bandwidth data is available at a socket. */
#define SIGXCPU	24		/* CPU time limit exceeded. */
#define SIGXFSZ	25		/* File size limit exceeded. */
#define SIGVTALRM	26	/* Virtual timer expired. */
#define SIGPROF	27		/* Profiling timer expired. */
#define SIGWINCH	28	/* Window size change. */
#define SIGIO	29		/* I/O now possible. */
#define SIGPOLL	SIGIO		/* Pollable event. */
#define SIGPWR	30		/* Power failure restart */
#define SIGSYS	31		/* Bad system call. */
#define SIGUNUSED	31

#define SV_ONSTACK	(1&#60;&#60;0)	/* Take the signal on the signal stack. */
#define SV_INTERRUPT	(1&#60;&#60;1)	/* Do not restart system calls. */
#define SV_RESETHAND	(1&#60;&#60;2)	/* Reset handler to SIG_DFL on receipt. */

typedef union sigval {
    int sival_int;
    void *sival_ptr;
} sigval_t;

#define SIGEV_SIGNAL	0	/* Notify via signal. */
#define SIGEV_NONE	1	/* Other notification: meaningless. */
#define SIGEV_THREAD	2	/* Deliver via thread creation. */
#define SIGEV_MAX_SIZE	64

typedef struct sigevent {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;
    union {
	int _pad[SIGEV_PAD_SIZE];
	struct {
	    void (*_function) (sigval_t);
	    void *_attribute;
	} _sigev_thread;
    } _sigev_un;
} sigevent_t;

#define SI_MAX_SIZE	128
#define si_pid	_sifields._kill._pid
#define si_uid	_sifields._kill._uid
#define si_value	_sifields._rt._sigval
#define si_int	_sifields._rt._sigval.sival_int
#define si_ptr	_sifields._rt._sigval.sival_ptr
#define si_status	_sifields._sigchld._status
#define si_stime	_sifields._sigchld._stime
#define si_utime	_sifields._sigchld._utime
#define si_addr	_sifields._sigfault._addr
#define si_band	_sifields._sigpoll._band
#define si_fd	_sifields._sigpoll._fd
#define si_timer1	_sifields._timer._timer1
#define si_timer2	_sifields._timer._timer2
#define sigev_notify_attributes	_sigev_un._sigev_thread._attribute
#define sigev_notify_function	_sigev_un._sigev_thread._function

typedef struct siginfo {
    int si_signo;		/* Signal number. */
    int si_errno;
    int si_code;		/* Signal code. */
    union {
	int _pad[SI_PAD_SIZE];
	struct {
	    pid_t _pid;
	    uid_t _uid;
	} _kill;
	struct {
	    unsigned int _timer1;
	    unsigned int _timer2;
	} _timer;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    sigval_t _sigval;
	} _rt;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    int _status;
	    clock_t _utime;
	    clock_t _stime;
	} _sigchld;
	struct {
	    void *_addr;
	} _sigfault;
	struct {
	    int _band;
	    int _fd;
	} _sigpoll;
    } _sifields;
} siginfo_t;

#define SI_QUEUE	-1	/* Sent by sigqueue. */
#define SI_TIMER	-2	/* Sent by timer expiration. */
#define SI_MESGQ	-3	/* Sent by real time mesq state change. */
#define SI_ASYNCIO	-4	/* Sent by AIO completion. */
#define SI_SIGIO	-5	/* Sent by queued SIGIO. */
#define SI_TKILL	-6	/* Sent by tkill. */
#define SI_ASYNCNL	-60	/* Sent by asynch name lookup completion. */
#define SI_USER	0		/* Sent by kill, sigsend, raise. */
#define SI_KERNEL	0x80	/* Sent by kernel. */

#define ILL_ILLOPC	1	/* Illegal opcode. */
#define ILL_ILLOPN	2	/* Illegal operand. */
#define ILL_ILLADR	3	/* Illegal addressing mode. */
#define ILL_ILLTRP	4	/* Illegal trap. */
#define ILL_PRVOPC	5	/* Privileged opcode. */
#define ILL_PRVREG	6	/* Privileged register. */
#define ILL_COPROC	7	/* Coprocessor error. */
#define ILL_BADSTK	8	/* Internal stack error. */

#define FPE_INTDIV	1	/* Integer divide by zero. */
#define FPE_INTOVF	2	/* Integer overflow. */
#define FPE_FLTDIV	3	/*  Floating-point divide by zero. */
#define FPE_FLTOVF	4	/* Floating-point overflow. */
#define FPE_FLTUND	5	/*  Floating-point underflow. */
#define FPE_FLTRES	6	/*  Floating-point inexact result. */
#define FPE_FLTINV	7	/* Invalid floating-point operation. */
#define FPE_FLTSUB	8	/* Subscript out of range. */

#define SEGV_MAPERR	1	/* Address not mapped to object. */
#define SEGV_ACCERR	2	/*  Invalid permissions for mapped object. */

#define BUS_ADRALN	1	/*  Invalid address alignment. */
#define BUS_ADRERR	2	/*  Nonexistent physical address. */
#define BUS_OBJERR	3	/*  Object-specific hardware error. */

#define TRAP_BRKPT	1	/*  Process breakpoint. */
#define TRAP_TRACE	2	/*  Process trace trap. */

#define CLD_EXITED	1	/* Child has exited. */
#define CLD_KILLED	2	/* Child has terminated abnormally and did not create a core fi */
#define CLD_DUMPED	3	/* Child has terminated abnormally and created a core file. */
#define CLD_TRAPPED	4	/*  Traced child has trapped. */
#define CLD_STOPPED	5	/* Child has stopped. */
#define CLD_CONTINUED	6	/* Stopped child has continued. */

#define POLL_IN	1		/*  Data input available. */
#define POLL_OUT	2	/*  Output buffers available. */
#define POLL_MSG	3	/*  Input message available. */
#define POLL_ERR	4	/*  I/O error. */
#define POLL_PRI	5	/* High priority input available. */
#define POLL_HUP	6	/*  Device disconnected. */

typedef struct {
    unsigned long int sig[_SIGSET_NWORDS];
} sigset_t;

#define SA_INTERRUPT	0x20000000
#define sa_handler	__sigaction_handler._sa_handler
#define sa_sigaction	__sigaction_handler._sa_sigaction
#define SA_ONSTACK	0x08000000	/* Use signal stack by using `sa_restorer`. */
#define SA_RESETHAND	0x80000000	/* Reset to SIG_DFL on entry to handler. */
#define SA_NOCLDSTOP	0x00000001	/* Don't send SIGCHLD when children stop. */
#define SA_SIGINFO	0x00000004	/* Invoke signal-catching function with three arguments instead of one. */
#define SA_NODEFER	0x40000000	/* Don't automatically block the signal when its handler is being executed. */
#define SA_RESTART	0x10000000	/* Restart syscall on signal return. */
#define SA_NOCLDWAIT	0x00000002	/* Don't create zombie on child death. */
#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND

typedef struct sigaltstack {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
} stack_t;

#define SS_ONSTACK	1
#define SS_DISABLE	2

extern int __libc_current_sigrtmax(void);
extern int __libc_current_sigrtmin(void);
extern sighandler_t __sysv_signal(int __sig, sighandler_t __handler);
extern int __xpg_sigpause(int);
extern char *const _sys_siglist[];
extern sighandler_t bsd_signal(int __sig, sighandler_t __handler);
extern int kill(pid_t __pid, int __sig);
extern int killpg(pid_t __pgrp, int __sig);
extern void psiginfo(const siginfo_t * pinfo, const char *message);
extern void psignal(int __sig, const char *__s);
extern int pthread_kill(pthread_t, int);
extern int pthread_sigmask(int, const sigset_t *, sigset_t *);
extern int raise(int __sig);
extern int sigaction(int __sig, const struct sigaction *__act,
		     struct sigaction *__oact);
extern int sigaddset(sigset_t * __set, int __signo);
extern int sigaltstack(const struct sigaltstack *__ss,
		       struct sigaltstack *__oss);
extern int sigandset(sigset_t * __set, const sigset_t * __left,
		     const sigset_t * __right);
extern int sigdelset(sigset_t * __set, int __signo);
extern int sigemptyset(sigset_t * __set);
extern int sigfillset(sigset_t * __set);
extern int sighold(int __sig);
extern int sigignore(int __sig);
extern int siginterrupt(int __sig, int __interrupt);
extern int sigisemptyset(const sigset_t * __set);
extern int sigismember(const sigset_t * __set, int __signo);
extern sighandler_t signal(int __sig, sighandler_t __handler);
extern int sigorset(sigset_t * __set, const sigset_t * __left,
		    const sigset_t * __right);
extern int sigpending(sigset_t * __set);
extern int sigprocmask(int __how, const sigset_t * __set,
		       sigset_t * __oset);
extern int sigqueue(pid_t __pid, int __sig, const union sigval __val);
extern int sigrelse(int __sig);
extern int sigreturn(struct sigcontext *__scp);
extern sighandler_t sigset(int __sig, sighandler_t __disp);
extern int sigsuspend(const sigset_t * __set);
extern int sigtimedwait(const sigset_t * __set, siginfo_t * __info,
			const struct timespec *__timeout);
extern int sigwait(const sigset_t * __set, int *__sig);
extern int sigwaitinfo(const sigset_t * __set, siginfo_t * __info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7578"
>14.4.61. spawn.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define POSIX_SPAWN_RESETIDS	0x01
#define POSIX_SPAWN_SETPGROUP	0x02
#define POSIX_SPAWN_SETSIGDEF	0x04
#define POSIX_SPAWN_SETSIGMASK	0x08
#define POSIX_SPAWN_SETSCHEDPARAM	0x10
#define POSIX_SPAWN_SETSCHEDULER	0x20

typedef struct {
    int __allocated;
    int __used;
    struct __spawn_action *__actions;
    int __pad[16];
} posix_spawn_file_actions_t;
typedef struct {
    short __flags;
    pid_t __pgrp;
    sigset_t __sd;
    sigset_t __ss;
    struct sched_param __sp;
    int __policy;
    int __pad[16];
} posix_spawnattr_t;
extern int posix_spawn(pid_t * __pid, const char *__path,
		       const posix_spawn_file_actions_t * __file_actions,
		       const posix_spawnattr_t * __attrp,
		       char *const argv[], char *const envp[]);
extern int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *
					     __file_actions, int __fd);
extern int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *
					    __file_actions, int __fd,
					    int __newfd);
extern int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *
					    __file_actions, int __fd,
					    const char *__path,
					    int __oflag, mode_t __mode);
extern int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *
					    __file_actions);
extern int posix_spawn_file_actions_init(posix_spawn_file_actions_t *
					 __file_actions);
extern int posix_spawnattr_destroy(posix_spawnattr_t * __attr);
extern int posix_spawnattr_getflags(const posix_spawnattr_t * __attr,
				    short int *__flags);
extern int posix_spawnattr_getpgroup(const posix_spawnattr_t * __attr,
				     pid_t * __pgroup);
extern int posix_spawnattr_getschedparam(const posix_spawnattr_t * __attr,
					 struct sched_param *__schedparam);
extern int posix_spawnattr_getschedpolicy(const posix_spawnattr_t * __attr,
					  int *__schedpolicy);
extern int posix_spawnattr_getsigdefault(const posix_spawnattr_t * __attr,
					 sigset_t * __sigdefault);
extern int posix_spawnattr_getsigmask(const posix_spawnattr_t * __attr,
				      sigset_t * __sigmask);
extern int posix_spawnattr_init(posix_spawnattr_t * __attr);
extern int posix_spawnattr_setflags(posix_spawnattr_t * _attr,
				    short int __flags);
extern int posix_spawnattr_setpgroup(posix_spawnattr_t * __attr,
				     pid_t __pgroup);
extern int posix_spawnattr_setschedparam(posix_spawnattr_t * __attr,
					 const struct sched_param
					 *__schedparam);
extern int posix_spawnattr_setschedpolicy(posix_spawnattr_t * __attr,
					  int __schedpolicy);
extern int posix_spawnattr_setsigdefault(posix_spawnattr_t * __attr,
					 const sigset_t * __sigdefault);
extern int posix_spawnattr_setsigmask(posix_spawnattr_t * __attr,
				      const sigset_t * __sigmask);
extern int posix_spawnp(pid_t * __pid, const char *__file,
			const posix_spawn_file_actions_t * __file_actions,
			const posix_spawnattr_t * __attrp,
			char *const argv[], char *const envp[]);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7582"
>14.4.62. stddef.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#if !defined(__GNUC__)
#define __builtin_offsetof (TYPE, MEMBER)	((size_t)&#38;((TYPE*)0)-&#62;MEMBER)
#endif
#ifndef NULL
#  ifdef __cplusplus
#    define NULL        (0L)
#  else
#    define NULL        ((void*) 0)
#  endif
#endif
#define offsetof(TYPE,MEMBER)	__builtin_offsetof (TYPE, MEMBER)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7586"
>14.4.63. stdint.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define INT16_C(c)	c
#define INT32_C(c)	c
#define INT8_C(c)	c
#define UINT16_C(c)	c
#define UINT8_C(c)	c
#define UINT32_C(c)	c ## U

#define INT8_MIN	(-128)
#define INT_FAST8_MIN	(-128)
#define INT_LEAST8_MIN	(-128)
#define INT32_MIN	(-2147483647-1)
#define INT_LEAST32_MIN	(-2147483647-1)
#define SIG_ATOMIC_MIN	(-2147483647-1)
#define INT16_MIN	(-32767-1)
#define INT_LEAST16_MIN	(-32767-1)
#define INT64_MIN	(-__INT64_C(9223372036854775807)-1)
#define INTMAX_MIN	(-__INT64_C(9223372036854775807)-1)
#define INT_FAST64_MIN	(-__INT64_C(9223372036854775807)-1)
#define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
#define WINT_MIN	(0u)
#define INT8_MAX	(127)
#define INT_FAST8_MAX	(127)
#define INT_LEAST8_MAX	(127)
#define INT32_MAX	(2147483647)
#define INT_LEAST32_MAX	(2147483647)
#define SIG_ATOMIC_MAX	(2147483647)
#define UINT8_MAX	(255)
#define UINT_FAST8_MAX	(255)
#define UINT_LEAST8_MAX	(255)
#define INT16_MAX	(32767)
#define INT_LEAST16_MAX	(32767)
#define UINT32_MAX	(4294967295U)
#define UINT_LEAST32_MAX	(4294967295U)
#define WINT_MAX	(4294967295u)
#define UINT16_MAX	(65535)
#define UINT_LEAST16_MAX	(65535)
#define INT64_MAX	(__INT64_C(9223372036854775807))
#define INTMAX_MAX	(__INT64_C(9223372036854775807))
#define INT_FAST64_MAX	(__INT64_C(9223372036854775807))
#define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))
#define UINT64_MAX	(__UINT64_C(18446744073709551615))
#define UINTMAX_MAX	(__UINT64_C(18446744073709551615))
#define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))
#define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7590"
>14.4.64. stdio.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EOF	(-1)
#define P_tmpdir	"/tmp"
#ifndef SEEK_SET
#define SEEK_SET	0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR	1
#endif
#define FOPEN_MAX	16
#ifndef SEEK_END
#define SEEK_END	2
#endif
#define L_tmpnam	20
#define TMP_MAX	238328
#define FILENAME_MAX	4096
#define BUFSIZ	8192
#define L_ctermid	9
#define L_cuserid	9

typedef struct {
    off_t __pos;
    mbstate_t __state;
} fpos_t;
typedef struct {
    off64_t __pos;
    mbstate_t __state;
} fpos64_t;

typedef struct _IO_FILE FILE;

#define _IOFBF	0
#define _IOLBF	1
#define _IONBF	2

extern char *__fgets_chk(char *, size_t, int, FILE *);
extern char *__fgets_unlocked_chk(char *, size_t, int, FILE *);
extern size_t __fpending(FILE *);
extern int __fprintf_chk(FILE *, int, const char *, ...);
extern int __printf_chk(int, const char *, ...);
extern int __snprintf_chk(char *, size_t, int, size_t, const char *, ...);
extern int __sprintf_chk(char *, int, size_t, const char *, ...);
extern int __vfprintf_chk(FILE *, int, const char *, va_list);
extern int __vprintf_chk(int, const char *, va_list);
extern int __vsnprintf_chk(char *, size_t, int, size_t, const char *,
			   va_list);
extern int __vsprintf_chk(char *, int, size_t, const char *, va_list);
extern char *const _sys_errlist[];
extern int asprintf(char **__ptr, const char *__fmt, ...);
extern void clearerr(FILE * __stream);
extern void clearerr_unlocked(FILE * __stream);
extern int dprintf(int __fd, const char *__fmt, ...);
extern int fclose(FILE * __stream);
extern FILE *fdopen(int __fd, const char *__modes);
extern int feof(FILE * __stream);
extern int feof_unlocked(FILE * __stream);
extern int ferror(FILE * __stream);
extern int ferror_unlocked(FILE * __stream);
extern int fflush(FILE * __stream);
extern int fflush_unlocked(FILE * __stream);
extern int fgetc(FILE * __stream);
extern int fgetc_unlocked(FILE * __stream);
extern int fgetpos(FILE * __stream, fpos_t * __pos);
extern int fgetpos64(FILE * __stream, fpos64_t * __pos);
extern char *fgets(char *__s, int __n, FILE * __stream);
extern char *fgets_unlocked(char *__s, int __n, FILE * __stream);
extern int fileno(FILE * __stream);
extern int fileno_unlocked(FILE * __stream);
extern void flockfile(FILE * __stream);
extern FILE *fmemopen(void *__s, size_t __len, const char *__modes);
extern FILE *fopen(const char *__filename, const char *__modes);
extern FILE *fopen64(const char *__filename, const char *__modes);
extern int fprintf(FILE * __stream, const char *__format, ...);
extern int fputc(int __c, FILE * __stream);
extern int fputc_unlocked(int __c, FILE * __stream);
extern int fputs(const char *__s, FILE * __stream);
extern int fputs_unlocked(const char *__s, FILE * __stream);
extern size_t fread(void *__ptr, size_t __size, size_t __n,
		    FILE * __stream);
extern size_t fread_unlocked(void *__ptr, size_t __size, size_t __n,
			     FILE * __stream);
extern FILE *freopen(const char *__filename, const char *__modes,
		     FILE * __stream);
extern FILE *freopen64(const char *__filename, const char *__modes,
		       FILE * __stream);
extern int fscanf(FILE * __stream, const char *__format, ...);
extern int fseek(FILE * __stream, long int __off, int __whence);
extern int fseeko(FILE * __stream, off_t __off, int __whence);
extern int fseeko64(FILE * __stream, loff_t __off, int __whence);
extern int fsetpos(FILE * __stream, const fpos_t * __pos);
extern int fsetpos64(FILE * __stream, const fpos64_t * __pos);
extern long int ftell(FILE * __stream);
extern off_t ftello(FILE * __stream);
extern loff_t ftello64(FILE * __stream);
extern int ftrylockfile(FILE * __stream);
extern void funlockfile(FILE * __stream);
extern size_t fwrite(const void *__ptr, size_t __size, size_t __n,
		     FILE * __s);
extern size_t fwrite_unlocked(const void *__ptr, size_t __size, size_t __n,
			      FILE * __stream);
extern int getc(FILE * __stream);
extern int getc_unlocked(FILE * __stream);
extern int getchar(void);
extern int getchar_unlocked(void);
extern ssize_t getdelim(char **__lineptr, size_t * __n, int __delimiter,
			FILE * __stream);
extern ssize_t getline(char **__lineptr, size_t * __n, FILE * __stream);
extern int getw(FILE * __stream);
extern FILE *open_memstream(char **__bufloc, size_t * __sizeloc);
extern int pclose(FILE * __stream);
extern void perror(const char *__s);
extern FILE *popen(const char *__command, const char *__modes);
extern int printf(const char *__format, ...);
extern int putc(int __c, FILE * __stream);
extern int putc_unlocked(int __c, FILE * __stream);
extern int putchar(int __c);
extern int putchar_unlocked(int __c);
extern int puts(const char *__s);
extern int putw(int __w, FILE * __stream);
extern int remove(const char *__filename);
extern int rename(const char *__old, const char *__new);
extern int renameat(int __oldfd, const char *__old, int __newfd,
		    const char *__new);
extern void rewind(FILE * __stream);
extern int scanf(const char *__format, ...);
extern void setbuf(FILE * __stream, char *__buf);
extern void setbuffer(FILE * __stream, char *__buf, size_t __size);
extern int setvbuf(FILE * __stream, char *__buf, int __modes, size_t __n);
extern int snprintf(char *__s, size_t __maxlen, const char *__format, ...);
extern int sprintf(char *__s, const char *__format, ...);
extern int sscanf(const char *__s, const char *__format, ...);
extern FILE *stderr;
extern FILE *stdin;
extern FILE *stdout;
extern char *tempnam(const char *__dir, const char *__pfx);
extern FILE *tmpfile(void);
extern FILE *tmpfile64(void);
extern char *tmpnam(char *__s);
extern int ungetc(int __c, FILE * __stream);
extern int vasprintf(char **__ptr, const char *__f, va_list __arg);
extern int vdprintf(int __fd, const char *__fmt, va_list __arg);
extern int vfprintf(FILE * __s, const char *__format, va_list __arg);
extern int vfscanf(FILE * __s, const char *__format, va_list __arg);
extern int vprintf(const char *__format, va_list __arg);
extern int vscanf(const char *__format, va_list __arg);
extern int vsnprintf(char *__s, size_t __maxlen, const char *__format,
		     va_list __arg);
extern int vsprintf(char *__s, const char *__format, va_list __arg);
extern int vsscanf(const char *__s, const char *__format, va_list __arg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7594"
>14.4.65. stdlib.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MB_CUR_MAX	(__ctype_get_mb_cur_max())
#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
#define RAND_MAX	2147483647

struct drand48_data {
    unsigned short __x[3];
    unsigned short __old_x[3];
    unsigned short __c;
    unsigned short __init;
    unsigned long long int __a;
};
typedef int (*__compar_fn_t) (const void *, const void *);
struct random_data {
    int32_t *fptr;		/* Front pointer. */
    int32_t *rptr;		/* Rear pointer. */
    int32_t *state;		/* Array of state values. */
    int rand_type;		/* Type of random number generator. */
    int rand_deg;		/* Degree of random number generator. */
    int rand_sep;		/* Distance between front and rear. */
    int32_t *end_ptr;		/* Pointer behind state table. */
};

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;
extern void _Exit(int __status);
extern size_t __ctype_get_mb_cur_max(void);
extern size_t __mbstowcs_chk(wchar_t *, const char *, size_t, size_t);
extern char *__realpath_chk(const char *, char *, size_t);
extern double __strtod_internal(const char *, char **, int);
extern float __strtof_internal(const char *, char **, int);
extern long int __strtol_internal(const char *, char **, int, int);
extern long double __strtold_internal(const char *, char **, int);
extern long long int __strtoll_internal(const char *, char **, int, int);
extern unsigned long int __strtoul_internal(const char *, char **, int,
					    int);
extern unsigned long long int __strtoull_internal(const char *, char **,
						  int, int);
extern size_t __wcstombs_chk(char *, const wchar_t *, size_t, size_t);
extern int __wctomb_chk(char *, wchar_t, size_t);
extern long int a64l(const char *__s);
extern void abort(void);
extern int abs(int __x);
extern int atexit(void (*__func) (void));
extern double atof(const char *__nptr);
extern int atoi(const char *__nptr);
extern long int atol(const char *__nptr);
extern long long int atoll(const char *__nptr);
extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
		     size_t __size, __compar_fn_t __compar);
extern void *calloc(size_t __nmemb, size_t __size);
extern div_t div(int __numer, int __denom);
extern double drand48(void);
extern int drand48_r(struct drand48_data *__buffer, double *__result);
extern char *ecvt(double __value, int __ndigit, int *__decpt, int *__sign);
extern char **environ;
extern double erand48(unsigned short __xsubi[3]);
extern int erand48_r(unsigned short __xsubi[3],
		     struct drand48_data *__buffer, double *__result);
extern void exit(int __status);
extern char *fcvt(double __value, int __ndigit, int *__decpt, int *__sign);
extern void free(void *__ptr);
extern char *gcvt(double __value, int __ndigit, char *__buf);
extern char *getenv(const char *__name);
extern int getloadavg(double __loadavg[], int __nelem);
extern int getsubopt(char **__optionp, char *const *__tokens,
		     char **__valuep);
extern int grantpt(int __fd);
extern char *initstate(unsigned int __seed, char *__statebuf,
		       size_t __statelen);
extern int initstate_r(unsigned int __seed, char *__statebuf,
		       size_t __statelen, struct random_data *__buf);
extern long int jrand48(unsigned short __xsubi[3]);
extern int jrand48_r(unsigned short __xsubi[3],
		     struct drand48_data *__buffer, long int *__result);
extern char *l64a(long int __n);
extern long int labs(long int __x);
extern void lcong48(unsigned short __param[7]);
extern int lcong48_r(unsigned short __param[7],
		     struct drand48_data *__buffer);
extern ldiv_t ldiv(long int __numer, long int __denom);
extern long long int llabs(long long int __x);
extern lldiv_t lldiv(long long int __numer, long long int __denom);
extern long int lrand48(void);
extern int lrand48_r(struct drand48_data *__buffer, long int *__result);
extern void *malloc(size_t __size);
extern int mblen(const char *__s, size_t __n);
extern size_t mbstowcs(wchar_t * __pwcs, const char *__s, size_t __n);
extern int mbtowc(wchar_t * __pwc, const char *__s, size_t __n);
extern char *mkdtemp(char *__template);
extern int mkstemp(char *__template);
extern int mkstemp64(char *__template);
extern char *mktemp(char *__template);
extern long int mrand48(void);
extern int mrand48_r(struct drand48_data *__buffer, long int *__result);
extern long int nrand48(unsigned short __xsubi[3]);
extern int nrand48_r(unsigned short __xsubi[3],
		     struct drand48_data *__buffer, long int *__result);
extern int posix_memalign(void **__memptr, size_t __alignment,
			  size_t __size);
extern int posix_openpt(int __oflag);
extern char *ptsname(int __fd);
extern int putenv(char *__string);
extern void qsort(void *__base, size_t __nmemb, size_t __size,
		  const __compar_fn_t __compar);
extern int rand(void);
extern int rand_r(unsigned int *__seed);
extern long int random(void);
extern int random_r(struct random_data *__buf, int32_t * __result);
extern void *realloc(void *__ptr, size_t __size);
extern char *realpath(const char *__name, char *__resolved);
extern unsigned short *seed48(unsigned short __seed16v[3]);
extern int seed48_r(unsigned short __seed16v[3],
		    struct drand48_data *__buffer);
extern int setenv(const char *__name, const char *__value, int __replace);
extern char *setstate(char *__statebuf);
extern int setstate_r(char *__statebuf, struct random_data *__buf);
extern void srand(unsigned int __seed);
extern void srand48(long int __seedval);
extern int srand48_r(long int __seedval, struct drand48_data *__buffer);
extern void srandom(unsigned int __seed);
extern int srandom_r(unsigned int __seed, struct random_data *__buf);
extern double strtod(const char *__nptr, char **__endptr);
extern float strtof(const char *__nptr, char **__endptr);
extern long int strtol(const char *__nptr, char **__endptr, int __base);
extern long double strtold(const char *__nptr, char **__endptr);
extern long long int strtoll(const char *__nptr, char **__endptr,
			     int __base);
extern long long int strtoq(const char *__nptr, char **__endptr,
			    int __base);
extern unsigned long int strtoul(const char *__nptr, char **__endptr,
				 int __base);
extern unsigned long long int strtoull(const char *__nptr, char **__endptr,
				       int __base);
extern unsigned long long int strtouq(const char *__nptr, char **__endptr,
				      int __base);
extern int system(const char *__command);
extern int unlockpt(int __fd);
extern int unsetenv(const char *__name);
extern size_t wcstombs(char *__s, const wchar_t * __pwcs, size_t __n);
extern int wctomb(char *__s, wchar_t __wchar);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7598"
>14.4.66. string.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define strerror_r __xpg_strerror_r

#define bzero(s,n)	memset(s,0,n)

extern void *__memcpy_chk(void *, const void *, size_t, size_t);
extern void *__memmove_chk(void *, const void *, size_t, size_t);
extern void *__mempcpy(void *__dest, const void *__src, size_t __n);
extern void *__mempcpy_chk(void *, const void *, size_t, size_t);
extern void *__memset_chk(void *, int, size_t, size_t);
extern char *__stpcpy(char *__dest, const char *__src);
extern char *__stpcpy_chk(char *, const char *, size_t);
extern char *__stpncpy_chk(char *, const char *, size_t, size_t);
extern char *__strcat_chk(char *, const char *, size_t);
extern char *__strcpy_chk(char *, const char *, size_t);
extern char *__strncat_chk(char *, const char *, size_t, size_t);
extern char *__strncpy_chk(char *, const char *, size_t, size_t);
extern char *__strtok_r(char *__s, const char *__delim, char **__save_ptr);
extern int __xpg_strerror_r(int, char *, size_t);
extern void *memccpy(void *__dest, const void *__src, int __c, size_t __n);
extern void *memchr(const void *__s, int __c, size_t __n);
extern int memcmp(const void *__s1, const void *__s2, size_t __n);
extern void *memcpy(void *__dest, const void *__src, size_t __n);
extern void *memmem(const void *__haystack, size_t __haystacklen,
		    const void *__needle, size_t __needlelen);
extern void *memmove(void *__dest, const void *__src, size_t __n);
extern void *memrchr(const void *__s, int __c, size_t __n);
extern void *memset(void *__s, int __c, size_t __n);
extern char *stpcpy(char *__dest, const char *__src);
extern char *stpncpy(char *__dest, const char *__src, size_t __n);
extern char *strcasestr(const char *__haystack, const char *__needle);
extern char *strcat(char *__dest, const char *__src);
extern char *strchr(const char *__s, int __c);
extern int strcmp(const char *__s1, const char *__s2);
extern int strcoll(const char *__s1, const char *__s2);
extern int strcoll_l(const char *s1, const char *s2, locale_t locale);
extern char *strcpy(char *__dest, const char *__src);
extern size_t strcspn(const char *__s, const char *__reject);
extern char *strdup(const char *__s);
extern char *strerror(int __errnum);
extern char *strerror_l(int errnum, locale_t locale);
extern size_t strlen(const char *__s);
extern char *strncat(char *__dest, const char *__src, size_t __n);
extern int strncmp(const char *__s1, const char *__s2, size_t __n);
extern char *strncpy(char *__dest, const char *__src, size_t __n);
extern char *strndup(const char *__string, size_t __n);
extern size_t strnlen(const char *__string, size_t __maxlen);
extern char *strpbrk(const char *__s, const char *__accept);
extern char *strrchr(const char *__s, int __c);
extern char *strsep(char **__stringp, const char *__delim);
extern char *strsignal(int __sig);
extern size_t strspn(const char *__s, const char *__accept);
extern char *strstr(const char *__haystack, const char *__needle);
extern char *strtok(char *__s, const char *__delim);
extern char *strtok_r(char *__s, const char *__delim, char **__save_ptr);
extern size_t strxfrm(char *__dest, const char *__src, size_t __n);
extern size_t strxfrm_l(char *s1, const char *s2, size_t n,
			locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7602"
>14.4.67. strings.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int bcmp(const void *__s1, const void *__s2, size_t __n);
extern void bcopy(const void *__src, void *__dest, size_t __n);
extern void bzero(void *__s, size_t __n);
extern int ffs(int __i);
extern char *index(const char *__s, int __c);
extern char *rindex(const char *__s, int __c);
extern int strcasecmp(const char *__s1, const char *__s2);
extern int strcasecmp_l(const char *s1, const char *s2, locale_t locale);
extern int strncasecmp(const char *__s1, const char *__s2, size_t __n);
extern int strncasecmp_l(const char *s1, const char *s2, size_t n,
			 locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7606"
>14.4.68. sys/epoll.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EPOLL_CTL_ADD	1	/* Add a file decriptor to the interface. */
#define EPOLL_CTL_DEL	2	/* Remove a file decriptor from the interface. */
#define EPOLL_CTL_MOD	3	/* Change file decriptor epoll_event structure. */
#define EPOLLIN	1
#define EPOLLPRI	2
#define EPOLLOUT	4
#define EPOLLERR	8
#define EPOLLHUP	16
#define EPOLLRDHUP	0x2000
#define EPOLLONESHOT	(1 &#60;&#60; 30)
#define EPOLLET	(1 &#60;&#60; 31)

typedef union epoll_data {
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;

struct epoll_event {
    uint32_t events;
    epoll_data_t data;
};
extern int epoll_create(int __size);
extern int epoll_ctl(int __epfd, int __op, int __fd,
		     struct epoll_event *__event);
extern int epoll_wait(int __epfd, struct epoll_event *__events,
		      int __maxevents, int __timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7610"
>14.4.69. sys/file.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LOCK_SH	1
#define LOCK_EX	2
#define LOCK_NB	4
#define LOCK_UN	8

extern int flock(int __fd, int __operation);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7614"
>14.4.70. sys/inotify.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IN_ACCESS	0x00000001
#define IN_MODIFY	0x00000002
#define IN_ATTRIB	0x00000004
#define IN_CLOSE_WRITE	0x00000008
#define IN_CLOSE_NOWRITE	0x00000010
#define IN_OPEN	0x00000020
#define IN_MOVED_FROM	0x00000040
#define IN_MOVED_TO	0x00000080
#define IN_CREATE	0x00000100
#define IN_DELETE	0x00000200
#define IN_DELETE_SELF	0x00000400
#define IN_MOVE_SELF	0x00000800
#define IN_UNMOUNT	0x00002000
#define IN_Q_OVERFLOW	0x00004000
#define IN_IGNORED	0x00008000
#define IN_ISDIR	0x40000000
#define IN_ONESHOT	0x80000000
#define IN_CLOSE	(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
#define IN_MOVE	(IN_MOVED_FROM | IN_MOVED_TO)
#define IN_ALL_EVENTS	 \
   (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
  IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_CREATE | \
 IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF)

struct inotify_event {
    int wd;
    uint32_t mask;
    uint32_t cookie;
    uint32_t len;
    char name[];
};
extern int inotify_add_watch(int __fd, const char *__name,
			     uint32_t __mask);
extern int inotify_init(void);
extern int inotify_rm_watch(int __fd, int __wd);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7618"
>14.4.71. sys/ioctl.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define _IOC(dir,type,nr,size)	(((dir) &#60;&#60; _IOC_DIRSHIFT) | ((type) &#60;&#60; _IOC_TYPESHIFT) | ((nr) &#60;&#60; _IOC_NRSHIFT) | ((size) &#60;&#60; _IOC_SIZESHIFT))
#define _IOC_DIR(nr)	(((nr) &#62;&#62; _IOC_DIRSHIFT) &#38; _IOC_DIRMASK)
#define _IOC_NR(nr)	(((nr) &#62;&#62; _IOC_NRSHIFT) &#38; _IOC_NRMASK)
#define _IOC_SIZE(nr)	(((nr) &#62;&#62; _IOC_SIZESHIFT) &#38; _IOC_SIZEMASK)
#define _IOC_TYPE(nr)	(((nr) &#62;&#62; _IOC_TYPESHIFT) &#38; _IOC_TYPEMASK)
#define _IOC_DIRMASK	((1 &#60;&#60; _IOC_DIRBITS)-1)
#define _IOC_NRMASK	((1 &#60;&#60; _IOC_NRBITS)-1)
#define _IOC_SIZEMASK	((1 &#60;&#60; _IOC_SIZEBITS)-1)
#define _IOC_TYPEMASK	((1 &#60;&#60; _IOC_TYPEBITS)-1)
#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) &#60;&#60; _IOC_DIRSHIFT)
#define _IOC_TYPECHECK(t)	(sizeof(t))
#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
#define IOC_OUT	(_IOC_READ &#60;&#60; _IOC_DIRSHIFT)
#define IOCSIZE_MASK	(_IOC_SIZEMASK &#60;&#60; _IOC_SIZESHIFT)
#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
#define IOC_IN	(_IOC_WRITE &#60;&#60; _IOC_DIRSHIFT)
#define _IOC_NRSHIFT	0
#define _IOC_NONE	0U
#define _IOC_SIZEBITS	14
#define _IOC_WRITE	1U
#define _IOC_DIRBITS	2
#define _IOC_READ	2U
#define _IOC_NRBITS	8
#define _IOC_TYPEBITS	8
#define _IO(type,nr)	_IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))

struct winsize {
    unsigned short ws_row;	/* Rows, in characters. */
    unsigned short ws_col;	/* Columns, in characters. */
    unsigned short ws_xpixel;	/* Horizontal pixels. */
    unsigned short ws_ypixel;	/* Vertical pixels. */
};
extern int ioctl(int __fd, unsigned long int __request, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7622"
>14.4.72. sys/ipc.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define IPC_PRIVATE	((key_t)0)
#define IPC_RMID	0
#define IPC_CREAT	00001000
#define IPC_EXCL	00002000
#define IPC_NOWAIT	00004000
#define IPC_SET	1
#define IPC_STAT	2

extern key_t ftok(const char *__pathname, int __proj_id);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7626"
>14.4.73. sys/mman.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MAP_FAILED	((void*)-1)
#define POSIX_MADV_NORMAL	0
#define PROT_NONE	0x0
#define MAP_SHARED	0x01
#define MAP_PRIVATE	0x02
#define PROT_READ	0x1
#define MAP_FIXED	0x10
#define PROT_WRITE	0x2
#define MAP_ANONYMOUS	0x20
#define PROT_EXEC	0x4
#define MREMAP_MAYMOVE	1
#define MS_ASYNC	1
#define POSIX_MADV_RANDOM	1
#define MREMAP_FIXED	2
#define MS_INVALIDATE	2
#define POSIX_MADV_SEQUENTIAL	2
#define POSIX_MADV_WILLNEED	3
#define MS_SYNC	4
#define POSIX_MADV_DONTNEED	4
#define MAP_ANON	MAP_ANONYMOUS

extern int mlock(const void *__addr, size_t __len);
extern int mlockall(int __flags);
extern void *mmap(void *__addr, size_t __len, int __prot, int __flags,
		  int __fd, off_t __offset);
extern void *mmap64(void *__addr, size_t __len, int __prot, int __flags,
		    int __fd, off64_t __offset);
extern int mprotect(void *__addr, size_t __len, int __prot);
extern void *mremap(void *__addr, size_t __old_len, size_t __new_len,
		    int __flags, ...);
extern int msync(void *__addr, size_t __len, int __flags);
extern int munlock(const void *__addr, size_t __len);
extern int munlockall(void);
extern int munmap(void *__addr, size_t __len);
extern int posix_madvise(void *__addr, size_t __len, int __advice);
extern int shm_open(const char *__name, int __oflag, mode_t __mode);
extern int shm_unlink(const char *__name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7630"
>14.4.74. sys/msg.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define MSG_NOERROR	010000

extern int msgctl(int __msqid, int __cmd, struct msqid_ds *__buf);
extern int msgget(key_t __key, int __msgflg);
extern ssize_t msgrcv(int __msqid, void *__msgp, size_t __msgsz,
		      long int __msgtyp, int __msgflg);
extern int msgsnd(int __msqid, const void *__msgp, size_t __msgsz,
		  int __msgflg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7634"
>14.4.75. sys/param.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NOFILE	256
#define MAXPATHLEN	4096</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7638"
>14.4.76. sys/poll.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define POLLIN	0x0001		/* There is data to read */
#define POLLPRI	0x0002		/* There is urgent data to read */
#define POLLOUT	0x0004		/* Writing now will not block */
#define POLLERR	0x0008		/* Error condition */
#define POLLHUP	0x0010		/* Hung up */
#define POLLNVAL	0x0020	/* Invalid request: fd not open */
#define POLLRDNORM	0x0040	/* Normal data may be read */
#define POLLRDBAND	0x0080	/* Priority data may be read */
#define POLLWRNORM	0x0100	/* Writing now will not block */
#define POLLWRBAND	0x0200	/* Priority data may be written */

struct pollfd {
    int fd;			/* File descriptor to poll. */
    short events;		/* Types of events poller cares about. */
    short revents;		/* Types of events that actually occurred. */
};
typedef unsigned long int nfds_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7642"
>14.4.77. sys/ptrace.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum __ptrace_setoptions {
    PTRACE_O_TRACESYSGOOD = 0x00000001,
    PTRACE_O_TRACEFORK = 0x00000002,
    PTRACE_O_TRACEVFORK = 0x00000004,
    PTRACE_O_TRACECLONE = 0x00000008,
    PTRACE_O_TRACEEXEC = 0x00000010,
    PTRACE_O_TRACEVFORKDONE = 0x00000020,
    PTRACE_O_TRACEEXIT = 0x00000040,
    PTRACE_O_MASK = 0x0000007f
};
enum __ptrace_eventcodes {
    PTRACE_EVENT_FORK = 1,
    PTRACE_EVENT_VFORK = 2,
    PTRACE_EVENT_CLONE = 3,
    PTRACE_EVENT_EXEC = 4,
    PTRACE_EVENT_VFORK_DONE = 5,
    PTRACE_EVENT_EXIT = 6
};
extern long int ptrace(enum __ptrace_request, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7646"
>14.4.78. sys/resource.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define RUSAGE_CHILDREN	(-1)
#define RLIM_INFINITY	(~0UL)
#define RLIM_SAVED_CUR	-1
#define RLIM_SAVED_MAX	-1
#define RLIMIT_CPU	0
#define RUSAGE_SELF	0
#define RLIMIT_FSIZE	1
#define RLIMIT_LOCKS	10
#define RLIMIT_SIGPENDING	11
#define RLIMIT_MSGQUEUE	12
#define RLIMIT_NICE	13
#define RLIMIT_RTPRIO	14
#define RLIMIT_RTTIME	15
#define RLIM_NLIMITS	16
#define RLIMIT_DATA	2
#define RLIMIT_STACK	3
#define RLIMIT_CORE	4
#define RLIMIT_RSS	5
#define RLIMIT_NPROC	6
#define RLIMIT_NOFILE	7
#define RLIMIT_MEMLOCK	8
#define RLIMIT_AS	9

typedef unsigned long int rlim_t;
typedef unsigned long long int rlim64_t;
typedef int __rlimit_resource_t;

struct rlimit {
    rlim_t rlim_cur;		/* The current (soft) limit. */
    rlim_t rlim_max;		/* The hard limit. */
};
struct rlimit64 {
    rlim64_t rlim_cur;		/* The current (soft) limit. */
    rlim64_t rlim_max;		/* The hard limit. */
};

struct rusage {
    struct timeval ru_utime;	/* Total amount of user time used. */
    struct timeval ru_stime;	/* Total amount of system time used. */
    long int ru_maxrss;		/* Maximum resident set size (in kilobytes). */
    long int ru_ixrss;		/* Amount of sharing of text segment memory        with other p */
    long int ru_idrss;		/* Amount of data segment memory used (kilobyte-seconds). */
    long int ru_isrss;		/* Amount of stack memory used (kilobyte-seconds). */
    long int ru_minflt;		/* Number of soft page faults (i.e. those serviced by reclaimin */
    long int ru_majflt;		/* Number of hard page faults (i.e. those that required I/O). */
    long int ru_nswap;		/* Number of times a process was swapped out of physical memory */
    long int ru_inblock;	/* Number of input operations via the file system.  Note: This */
    long int ru_oublock;	/* Number of output operations via the file system. */
    long int ru_msgsnd;		/* Number of IPC messages sent. */
    long int ru_msgrcv;		/* Number of IPC messages received. */
    long int ru_nsignals;	/* Number of signals delivered. */
    long int ru_nvcsw;		/* Number of voluntary context switches, i.e. because the proce */
    long int ru_nivcsw;		/* Number of involuntary context switches, i.e. a higher priori */
};

enum __priority_which {
    PRIO_PROCESS = 0,		/* WHO is a process ID. */
    PRIO_PGRP = 1,		/* WHO is a process group ID. */
    PRIO_USER = 2		/* WHO is a user ID. */
};

#define PRIO_PGRP	PRIO_PGRP
#define PRIO_PROCESS	PRIO_PROCESS
#define PRIO_USER	PRIO_USER

typedef enum __priority_which __priority_which_t;
extern int getpriority(__priority_which_t __which, id_t __who);
extern int getrlimit(__rlimit_resource_t __resource,
		     struct rlimit *__rlimits);
extern int getrlimit64(__rlimit_resource_t __resource,
		       struct rlimit64 *__rlimits);
extern int getrusage(int __who, struct rusage *__usage);
extern int setpriority(__priority_which_t __which, id_t __who, int __prio);
extern int setrlimit(__rlimit_resource_t __resource,
		     const struct rlimit *__rlimits);
extern int setrlimit64(__rlimit_resource_t __resource,
		       const struct rlimit64 *__rlimits);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7650"
>14.4.79. sys/select.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define FD_ISSET(d,set)	(((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]&#38;(1L&#60;&#60;((d)%(8*sizeof(long)))))!=0)
#define FD_CLR(d,set)	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]&#38;=~(1L&#60;&#60;((d)%(8*sizeof(long)))))
#define FD_SET(d,set)	((set)-&#62;fds_bits[((d)/(8*sizeof(long)))]|=(1L&#60;&#60;((d)%(8*sizeof(long)))))
#define NFDBITS	(8 * sizeof (long))
#define FD_SETSIZE	1024
#define FD_ZERO(fdsetp)	bzero(fdsetp, sizeof(*(fdsetp)))

typedef struct {
    unsigned long int fds_bits[FD_SETSIZE / NFDBITS];
} fd_set;
extern int pselect(int __nfds, fd_set * __readfds, fd_set * __writefds,
		   fd_set * __exceptfds, const struct timespec *__timeout,
		   const sigset_t * __sigmask);
extern int select(int __nfds, fd_set * __readfds, fd_set * __writefds,
		  fd_set * __exceptfds, struct timeval *__timeout);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7654"
>14.4.80. sys/sem.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SEM_UNDO	0x1000
#define GETPID	11
#define GETVAL	12
#define GETALL	13
#define GETNCNT	14
#define GETZCNT	15
#define SETVAL	16
#define SETALL	17

struct sembuf {
    short sem_num;
    short sem_op;
    short sem_flg;
};
extern int semctl(int __semid, int __semnum, int __cmd, ...);
extern int semget(key_t __key, int __nsems, int __semflg);
extern int semop(int __semid, struct sembuf *__sops, size_t __nsops);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7658"
>14.4.81. sys/sendfile.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t sendfile(int __out_fd, int __in_fd, off_t * __offset,
			size_t __count);
extern ssize_t sendfile64(int __out_fd, int __in_fd, off64_t * __offset,
			  size_t __count);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7662"
>14.4.82. sys/shm.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SHM_RDONLY	010000
#define SHM_W	0200
#define SHM_RND	020000
#define SHM_R	0400
#define SHM_REMAP	040000
#define SHM_LOCK	11
#define SHM_UNLOCK	12

extern int __getpagesize(void);
extern void *shmat(int __shmid, const void *__shmaddr, int __shmflg);
extern int shmctl(int __shmid, int __cmd, struct shmid_ds *__buf);
extern int shmdt(const void *__shmaddr);
extern int shmget(key_t __key, size_t __size, int __shmflg);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7666"
>14.4.83. sys/socket.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CMSG_FIRSTHDR(msg)	((size_t) (msg)-&#62;msg_controllen &#62;= sizeof(struct cmsghdr) ? (struct cmsghdr *)(msg)-&#62;msg_control : (struct cmsghdr *) NULL)
#define CMSG_LEN(len)	(CMSG_ALIGN(sizeof(struct cmsghdr))+(len))
#define SCM_RIGHTS	0x01
#define SOL_SOCKET	1
#define SOMAXCONN	128
#define SOL_RAW	255
#define CMSG_ALIGN(len)	\
	(((len)+sizeof(size_t)-1)&#38;(size_t)~(sizeof(size_t)-1))
#define CMSG_DATA(cmsg)	\
	((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr)))
#define CMSG_SPACE(len)	\
	(CMSG_ALIGN(sizeof(struct cmsghdr))+CMSG_ALIGN(len))
#define CMSG_NXTHDR(mhdr,cmsg)	\
        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \
         (((u_char *)(cmsg) + CMSG_ALIGN((cmsg)-&#62;cmsg_len) \
                            + CMSG_ALIGN(sizeof(struct cmsghdr)) &#62; \
           (u_char *)((mhdr)-&#62;msg_control) + (mhdr)-&#62;msg_controllen) ? \
          (struct cmsghdr *)NULL : \
          (struct cmsghdr *)((u_char *)(cmsg) + CMSG_ALIGN((cmsg)-&#62;cmsg_len))))

struct linger {
    int l_onoff;
    int l_linger;
};
struct cmsghdr {
    size_t cmsg_len;
    int cmsg_level;
    int cmsg_type;
};
struct iovec {
    void *iov_base;
    size_t iov_len;
};

typedef unsigned short sa_family_t;
typedef unsigned int socklen_t;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};
struct sockaddr_storage {
    sa_family_t ss_family;
    __ss_aligntype __ss_align;
    char __ss_padding[(128 - (2 * sizeof(__ss_aligntype)))];
};

struct msghdr {
    void *msg_name;
    int msg_namelen;
    struct iovec *msg_iov;
    size_t msg_iovlen;
    void *msg_control;
    size_t msg_controllen;
    unsigned int msg_flags;
};

#define AF_UNSPEC	0
#define AF_UNIX	1
#define AF_INET6	10
#define AF_INET	2

#define PF_INET	AF_INET
#define PF_INET6	AF_INET6
#define PF_UNIX	AF_UNIX
#define PF_UNSPEC	AF_UNSPEC

#define SOCK_STREAM	1
#define SOCK_PACKET	10
#define SOCK_DGRAM	2
#define SOCK_RAW	3
#define SOCK_RDM	4
#define SOCK_SEQPACKET	5

#define SO_DEBUG	1
#define SO_OOBINLINE	10
#define SO_NO_CHECK	11
#define SO_PRIORITY	12
#define SO_LINGER	13
#define SO_BSDCOMPAT	14
#define SO_REUSEADDR	2
#define SO_TYPE	3
#define SO_ACCEPTCONN	30
#define SO_ERROR	4
#define SO_DONTROUTE	5
#define SO_BROADCAST	6
#define SO_SNDBUF	7
#define SO_RCVBUF	8
#define SO_KEEPALIVE	9

#define SIOCGIFNAME	0x8910
#define SIOCGIFCONF	0x8912
#define SIOCGIFFLAGS	0x8913
#define SIOCGIFADDR	0x8915
#define SIOCGIFDSTADDR	0x8917
#define SIOCGIFBRDADDR	0x8919
#define SIOCGIFNETMASK	0x891b
#define SIOCGIFMTU	0x8921
#define SIOCGIFHWADDR	0x8927

#define SHUT_RD	0
#define SHUT_WR	1
#define SHUT_RDWR	2

#define MSG_WAITALL	0x100
#define MSG_TRUNC	0x20
#define MSG_NOSIGNAL	0x4000
#define MSG_EOR	0x80
#define MSG_OOB	1
#define MSG_PEEK	2
#define MSG_DONTROUTE	4
#define MSG_CTRUNC	8

extern ssize_t __recv_chk(int, void *, size_t, size_t, int);
extern ssize_t __recvfrom_chk(int, void *, size_t, size_t, int,
			      struct sockaddr *, socklen_t *);
extern int accept(int __fd, struct sockaddr *__addr,
		  socklen_t * __addr_len);
extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len);
extern int connect(int __fd, const struct sockaddr *__addr,
		   socklen_t __len);
extern int getnameinfo(const struct sockaddr *__sa, socklen_t __salen,
		       char *__host, socklen_t __hostlen, char *__serv,
		       socklen_t __servlen, unsigned int __flags);
extern int getpeername(int __fd, struct sockaddr *__addr,
		       socklen_t * __len);
extern int getsockname(int __fd, struct sockaddr *__addr,
		       socklen_t * __len);
extern int getsockopt(int __fd, int __level, int __optname, void *__optval,
		      socklen_t * __optlen);
extern int listen(int __fd, int __n);
extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags);
extern ssize_t recvfrom(int __fd, void *__buf, size_t __n, int __flags,
			struct sockaddr *__addr, socklen_t * __addr_len);
extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags);
extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags);
extern ssize_t sendmsg(int __fd, const struct msghdr *__message,
		       int __flags);
extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags,
		      const struct sockaddr *__addr, socklen_t __addr_len);
extern int setsockopt(int __fd, int __level, int __optname,
		      const void *__optval, socklen_t __optlen);
extern int shutdown(int __fd, int __how);
extern int sockatmark(int __fd);
extern int socket(int __domain, int __type, int __protocol);
extern int socketpair(int __domain, int __type, int __protocol,
		      int __fds[2]);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7670"
>14.4.84. sys/stat.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define S_ISBLK(m)	(((m)&#38;S_IFMT)==S_IFBLK)
#define S_ISCHR(m)	(((m)&#38;S_IFMT)==S_IFCHR)
#define S_ISDIR(m)	(((m)&#38;S_IFMT)==S_IFDIR)
#define S_ISFIFO(m)	(((m)&#38;S_IFMT)==S_IFIFO)
#define S_ISLNK(m)	(((m)&#38;S_IFMT)==S_IFLNK)
#define S_ISREG(m)	(((m)&#38;S_IFMT)==S_IFREG)
#define S_ISSOCK(m)	(((m)&#38;S_IFMT)==S_IFSOCK)
#define UTIME_NOW	((1l &#60;&#60; 30) - 1l)
#define UTIME_OMIT	((1l &#60;&#60; 30) - 2l)
#define S_TYPEISMQ(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_TYPEISSEM(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_TYPEISSHM(buf)	((buf)-&#62;st_mode - (buf)-&#62;st_mode)
#define S_IRWXU	(S_IREAD|S_IWRITE|S_IEXEC)
#define S_IROTH	(S_IRGRP&#62;&#62;3)
#define S_IRGRP	(S_IRUSR&#62;&#62;3)
#define S_IRWXO	(S_IRWXG&#62;&#62;3)
#define S_IRWXG	(S_IRWXU&#62;&#62;3)
#define S_IWOTH	(S_IWGRP&#62;&#62;3)
#define S_IWGRP	(S_IWUSR&#62;&#62;3)
#define S_IXOTH	(S_IXGRP&#62;&#62;3)
#define S_IXGRP	(S_IXUSR&#62;&#62;3)
#define S_ISVTX	01000
#define S_IXUSR	0x0040
#define S_IWUSR	0x0080
#define S_IRUSR	0x0100
#define S_ISGID	0x0400
#define S_ISUID	0x0800
#define S_IFIFO	0x1000
#define S_IFCHR	0x2000
#define S_IFDIR	0x4000
#define S_IFBLK	0x6000
#define S_IFREG	0x8000
#define S_IFLNK	0xa000
#define S_IFSOCK	0xc000
#define S_IFMT	0xf000
#define st_atime	st_atim.tv_sec
#define st_ctime	st_ctim.tv_sec
#define st_mtime	st_mtim.tv_sec
#define S_IREAD	S_IRUSR
#define S_IWRITE	S_IWUSR
#define S_IEXEC	S_IXUSR

extern int __fxstat(int __ver, int __fildes, struct stat *__stat_buf);
extern int __fxstat64(int __ver, int __fildes, struct stat64 *__stat_buf);
extern int __fxstatat(int __ver, int __fildes, const char *__filename,
		      struct stat *__stat_buf, int __flag);
extern int __fxstatat64(int __ver, int __fildes, const char *__filename,
			struct stat64 *__stat_buf, int __flag);
extern int __lxstat(int __ver, const char *__filename,
		    struct stat *__stat_buf);
extern int __lxstat64(int __ver, const char *__filename,
		      struct stat64 *__stat_buf);
extern int __xmknod(int __ver, const char *__path, mode_t __mode,
		    dev_t * __dev);
extern int __xmknodat(int __ver, int __fd, const char *__path,
		      mode_t __mode, dev_t * __dev);
extern int __xstat(int __ver, const char *__filename,
		   struct stat *__stat_buf);
extern int __xstat64(int __ver, const char *__filename,
		     struct stat64 *__stat_buf);
extern int chmod(const char *__file, mode_t __mode);
extern int fchmod(int __fd, mode_t __mode);
extern int fchmodat(int __fd, const char *__file, mode_t mode, int __flag);
extern int fstat(int __fd, struct stat *__buf);
extern int fstat64(int __fd, struct stat64 *__buf);
extern int fstatat(int __fd, const char *__file, struct stat *__buf,
		   int __flag);
extern int fstatat64(int __fd, const char *__file, struct stat64 *__buf,
		     int __flag);
extern int futimens(int fd, const struct timespec times[2]);
extern int lstat(const char *__file, struct stat *__buf);
extern int lstat64(const char *__file, struct stat64 *__buf);
extern int mkdir(const char *__path, mode_t __mode);
extern int mkdirat(int __fd, const char *__path, mode_t __mode);
extern int mkfifo(const char *__path, mode_t __mode);
extern int mkfifoat(int __fd, const char *__path, mode_t __mode);
extern int mknod(const char *__path, mode_t __mode, dev_t __dev);
extern int mknodat(int __fd, const char *__path, mode_t __mode,
		   dev_t __dev);
extern int stat(const char *__file, struct stat *__buf);
extern int stat64(const char *__file, struct stat64 *__buf);
extern mode_t umask(mode_t __mask);
extern int utimensat(int fd, const char *path,
		     const struct timespec times[2], int flags);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7674"
>14.4.85. sys/statfs.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define NFS_SUPER_MAGIC	0x6969

extern int fstatfs(int __fildes, struct statfs *__buf);
extern int fstatfs64(int __fildes, struct statfs64 *__buf);
extern int statfs(const char *__file, struct statfs *__buf);
extern int statfs64(const char *__file, struct statfs64 *__buf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7678"
>14.4.86. sys/statvfs.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int fstatvfs(int __fildes, struct statvfs *__buf);
extern int fstatvfs64(int __fildes, struct statvfs64 *__buf);
extern int statvfs(const char *__file, struct statvfs *__buf);
extern int statvfs64(const char *__file, struct statvfs64 *__buf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7682"
>14.4.87. sys/sysinfo.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct sysinfo {
    long int uptime;		/* Seconds since boot */
    unsigned long int loads[3];	/* 1, 5, and 15 minute load averages */
    unsigned long int totalram;	/* Total usable main memory size */
    unsigned long int freeram;	/* Available memory size */
    unsigned long int sharedram;	/* Amount of shared memory */
    unsigned long int bufferram;	/* Memory used by buffers */
    unsigned long int totalswap;	/* Total swap space size */
    unsigned long int freeswap;	/* Swap space still available */
    unsigned short procs;	/* Number of current processes */
    unsigned short pad;		/* Padding for m68k */
    unsigned long int totalhigh;	/* Total high memory size */
    unsigned long int freehigh;	/* Available high memory size */
    unsigned int mem_unit;	/* Memory unit size in bytes */
    char _f[20 - 2 * sizeof(long) - sizeof(int)];	/* Padding for libc5 */
};
extern int sysinfo(struct sysinfo *info);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7686"
>14.4.88. sys/time.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define ITIMER_REAL	0
#define ITIMER_VIRTUAL	1
#define ITIMER_PROF	2

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef int __itimer_which_t;

struct itimerval {
    struct timeval it_interval;
    struct timeval it_value;
};
extern int adjtime(const struct timeval *__delta,
		   struct timeval *__olddelta);
extern int futimes(int fd, const struct timeval tv[2]);
extern int getitimer(__itimer_which_t __which, struct itimerval *__value);
extern int gettimeofday(struct timeval *__tv, struct timezone *__tz);
extern int lutimes(const char *filename, const struct timeval tv[2]);
extern int setitimer(__itimer_which_t __which,
		     const struct itimerval *__new,
		     struct itimerval *__old);
extern int utimes(const char *__file, const struct timeval *__tvp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7690"
>14.4.89. sys/timeb.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct timeb {
    time_t time;		/* Seconds since epoch, as from time. */
    unsigned short millitm;	/* Additional milliseconds. */
    short timezone;		/* Minutes west of GMT. */
    short dstflag;		/* Nonzero if Daylight Savings Time used. */
};
extern int ftime(struct timeb *__timebuf);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7694"
>14.4.90. sys/times.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct tms {
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
};
extern clock_t times(struct tms *__buffer);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7698"
>14.4.91. sys/types.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	1
#endif

typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long int u_int64_t;
typedef unsigned int uid_t;
typedef int pid_t;
typedef long int off_t;
typedef long long int off64_t;
typedef int key_t;
typedef long int suseconds_t;
typedef unsigned int u_int;
typedef struct {
    int __val[2];
} fsid_t;
typedef unsigned int useconds_t;
typedef long int blksize_t;
typedef long int fd_mask;
typedef void *timer_t;
typedef int clockid_t;

typedef unsigned int id_t;

typedef unsigned long long int ino64_t;
typedef long long int loff_t;
typedef long int blkcnt_t;
typedef unsigned long int fsblkcnt_t;
typedef unsigned long int fsfilcnt_t;
typedef long long int blkcnt64_t;
typedef unsigned long long int fsblkcnt64_t;
typedef unsigned long long int fsfilcnt64_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned long int u_long;

typedef unsigned long int ino_t;
typedef unsigned int gid_t;
typedef unsigned long long int dev_t;
typedef unsigned int mode_t;
typedef unsigned long int nlink_t;
typedef char *caddr_t;

typedef long int clock_t;
typedef long int time_t;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7702"
>14.4.92. sys/uio.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern ssize_t readv(int __fd, const struct iovec *__iovec, int __count);
extern ssize_t writev(int __fd, const struct iovec *__iovec, int __count);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7706"
>14.4.93. sys/un.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct sockaddr_un {
    sa_family_t sun_family;	/* AF_UNIX */
    char sun_path[108];
};</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7710"
>14.4.94. sys/utsname.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define SYS_NMLN	65

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};
extern int uname(struct utsname *__name);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7714"
>14.4.95. sys/wait.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define WIFSIGNALED(status)	(!WIFSTOPPED(status) &#38;&#38; !WIFEXITED(status))
#define WIFSTOPPED(status)	(((status) &#38; 0xff) == 0x7f)
#define WEXITSTATUS(status)	(((status) &#38; 0xff00) &#62;&#62; 8)
#define WTERMSIG(status)	((status) &#38; 0x7f)
#define WCOREDUMP(status)	((status) &#38; 0x80)
#define WIFEXITED(status)	(WTERMSIG(status) == 0)
#define WNOHANG	0x00000001
#define WUNTRACED	0x00000002
#define WCOREFLAG	0x80
#define WSTOPSIG(status)	WEXITSTATUS(status)

typedef enum {
    P_ALL,
    P_PID,
    P_PGID
} idtype_t;
extern pid_t wait(int *__stat_loc);
extern pid_t wait4(pid_t __pid, int *__stat_loc, int __options,
		   struct rusage *__usage);
extern int waitid(idtype_t __idtype, id_t __id, siginfo_t * __infop,
		  int __options);
extern pid_t waitpid(pid_t __pid, int *__stat_loc, int __options);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7718"
>14.4.96. sysexits.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define EX_OK	0		/* successful termination  */
#define EX_USAGE	64	/* command line usage error  */
#define EX__BASE	64	/* base value for error messages  */
#define EX_DATAERR	65	/* data format error  */
#define EX_NOINPUT	66	/* cannot open input  */
#define EX_NOUSER	67	/* addressee unknown  */
#define EX_NOHOST	68	/* host name unknown  */
#define EX_UNAVAILABLE	69	/* service unavailable  */
#define EX_SOFTWARE	70	/* internal software error  */
#define EX_OSERR	71	/* system error (e.g., cannot fork)  */
#define EX_OSFILE	72	/* critical OS file missing  */
#define EX_CANTCREAT	73	/* cannot create (user) output file  */
#define EX_IOERR	74	/* input/output error  */
#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry  */
#define EX_PROTOCOL	76	/* remote error in protocol  */
#define EX_NOPERM	77	/* permission denied  */
#define EX_CONFIG	78	/* configuration error  */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7722"
>14.4.97. syslog.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define LOG_MAKEPRI(fac, pri)	(((fac) &#60;&#60; 3) | (pri))
#define LOG_PRI(p)	((p) &#38; LOG_PRIMASK)	/* extract priority */
#define LOG_EMERG	0	/* system is unusable */
#define LOG_PRIMASK	0x07	/* mask to extract priority part */
#define LOG_ALERT	1	/* action must be taken immediately */
#define LOG_CRIT	2	/* critical conditions */
#define LOG_ERR	3		/* error conditions */
#define LOG_WARNING	4	/* warning conditions */
#define LOG_NOTICE	5	/* normal but significant condition */
#define LOG_INFO	6	/* informational */
#define LOG_DEBUG	7	/* debug-level messages */

#define LOG_FAC(p)	(((p) &#38; LOG_FACMASK) &#62;&#62; 3)	/* facility of pri */
#define LOG_KERN	(0&#60;&#60;3)	/* kernel messages */
#define LOG_AUTHPRIV	(10&#60;&#60;3)	/* security/authorization messages (private) */
#define LOG_FTP	(11&#60;&#60;3)		/* ftp daemon */
#define LOG_USER	(1&#60;&#60;3)	/* random user-level messages */
#define LOG_MAIL	(2&#60;&#60;3)	/* mail system */
#define LOG_DAEMON	(3&#60;&#60;3)	/* system daemons */
#define LOG_AUTH	(4&#60;&#60;3)	/* security/authorization messages */
#define LOG_SYSLOG	(5&#60;&#60;3)	/* messages generated internally by syslogd */
#define LOG_LPR	(6&#60;&#60;3)		/* line printer subsystem */
#define LOG_NEWS	(7&#60;&#60;3)	/* network news subsystem */
#define LOG_UUCP	(8&#60;&#60;3)	/* UUCP subsystem */
#define LOG_CRON	(9&#60;&#60;3)	/* clock daemon */
#define LOG_FACMASK	0x03f8	/* mask to extract facility part */

#define LOG_LOCAL0	(16&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL1	(17&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL2	(18&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL3	(19&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL4	(20&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL5	(21&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL6	(22&#60;&#60;3)	/* reserved for local use */
#define LOG_LOCAL7	(23&#60;&#60;3)	/* reserved for local use */

#define LOG_UPTO(pri)	((1 &#60;&#60; ((pri)+1)) - 1)	/* all priorities through pri */
#define LOG_MASK(pri)	(1 &#60;&#60; (pri))	/* mask for one priority */

#define LOG_PID	0x01		/* log the pid with each message */
#define LOG_CONS	0x02	/* log on the console if errors in sending */
#define LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
#define LOG_NDELAY	0x08	/* don't delay open */
#define LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
#define LOG_PERROR	0x20	/* log to stderr as well */

extern void __syslog_chk(int, int, const char *, ...);
extern void __vsyslog_chk(int, int, const char *, va_list);
extern void closelog(void);
extern void openlog(const char *__ident, int __option, int __facility);
extern int setlogmask(int __mask);
extern void syslog(int __pri, const char *__fmt, ...);
extern void vsyslog(int __pri, const char *__fmt, va_list __ap);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7726"
>14.4.98. tar.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define REGTYPE	'0'
#define LNKTYPE	'1'
#define SYMTYPE	'2'
#define CHRTYPE	'3'
#define BLKTYPE	'4'
#define DIRTYPE	'5'
#define FIFOTYPE	'6'
#define CONTTYPE	'7'
#define AREGTYPE	'\0'
#define TVERSION	"00"
#define TOEXEC	00001
#define TOWRITE	00002
#define TOREAD	00004
#define TGEXEC	00010
#define TGWRITE	00020
#define TGREAD	00040
#define TUEXEC	00100
#define TUWRITE	00200
#define TUREAD	00400
#define TSVTX	01000
#define TSGID	02000
#define TSUID	04000
#define TVERSLEN	2
#define TMAGLEN	6
#define TMAGIC	"ustar"</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7730"
>14.4.99. termios.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define TCIFLUSH	0
#define TCOOFF	0
#define TCSANOW	0
#define BS0	0000000
#define CR0	0000000
#define FF0	0000000
#define NL0	0000000
#define TAB0	0000000
#define VT0	0000000
#define OPOST	0000001
#define OCRNL	0000010
#define ONOCR	0000020
#define ONLRET	0000040
#define OFILL	0000100
#define OFDEL	0000200
#define NL1	0000400
#define TCOFLUSH	1
#define TCOON	1
#define TCSADRAIN	1
#define TCIOFF	2
#define TCIOFLUSH	2
#define TCSAFLUSH	2
#define TCION	3

typedef unsigned int speed_t;
typedef unsigned char cc_t;
typedef unsigned int tcflag_t;

#define NCCS	32

struct termios {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;		/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
};

#define VINTR	0
#define VQUIT	1
#define VLNEXT	15
#define VERASE	2
#define VKILL	3
#define VEOF	4

#define IGNBRK	0000001
#define BRKINT	0000002
#define IGNPAR	0000004
#define PARMRK	0000010
#define INPCK	0000020
#define ISTRIP	0000040
#define INLCR	0000100
#define IGNCR	0000200
#define ICRNL	0000400
#define IXANY	0004000
#define IMAXBEL	0020000

#define CS5	0000000

#define ECHO	0000010

#define B0	0000000
#define B50	0000001
#define B75	0000002
#define B110	0000003
#define B134	0000004
#define B150	0000005
#define B200	0000006
#define B300	0000007
#define B600	0000010
#define B1200	0000011
#define B1800	0000012
#define B2400	0000013
#define B4800	0000014
#define B9600	0000015
#define B19200	0000016
#define B38400	0000017

extern speed_t cfgetispeed(const struct termios *__termios_p);
extern speed_t cfgetospeed(const struct termios *__termios_p);
extern void cfmakeraw(struct termios *__termios_p);
extern int cfsetispeed(struct termios *__termios_p, speed_t __speed);
extern int cfsetospeed(struct termios *__termios_p, speed_t __speed);
extern int cfsetspeed(struct termios *__termios_p, speed_t __speed);
extern int tcdrain(int __fd);
extern int tcflow(int __fd, int __action);
extern int tcflush(int __fd, int __queue_selector);
extern int tcgetattr(int __fd, struct termios *__termios_p);
extern pid_t tcgetsid(int __fd);
extern int tcsendbreak(int __fd, int __duration);
extern int tcsetattr(int __fd, int __optional_actions,
		     const struct termios *__termios_p);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7734"
>14.4.100. time.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define CLK_TCK	((clock_t)sysconf(2))
#define timerclear(tvp)	((tvp)-&#62;tv_sec = (tvp)-&#62;tv_usec = 0)
#define timerisset(tvp)	((tvp)-&#62;tv_sec || (tvp)-&#62;tv_usec)
#define CLOCK_REALTIME	0
#define CLOCK_MONOTONIC	1
#define TIMER_ABSTIME	1
#define CLOCKS_PER_SEC	1000000l
#define CLOCK_PROCESS_CPUTIME_ID	2
#define CLOCK_THREAD_CPUTIME_ID	3
#define timeradd(a,b,result)	\
  do { \
    (result)-&#62;tv_sec = (a)-&#62;tv_sec + (b)-&#62;tv_sec; \
    (result)-&#62;tv_usec = (a)-&#62;tv_usec + (b)-&#62;tv_usec; \
    if ((result)-&#62;tv_usec &#62;= 1000000) \
      { \
        ++(result)-&#62;tv_sec; \
        (result)-&#62;tv_usec -= 1000000; \
      } \
  } while (0)
#define timersub(a,b,result)	\
  do { \
    (result)-&#62;tv_sec = (a)-&#62;tv_sec - (b)-&#62;tv_sec; \
    (result)-&#62;tv_usec = (a)-&#62;tv_usec - (b)-&#62;tv_usec; \
    if ((result)-&#62;tv_usec &#60; 0) { \
      --(result)-&#62;tv_sec; \
      (result)-&#62;tv_usec += 1000000; \
    } \
  } while (0)
#define timercmp(a,b,CMP)	\
 (((a)-&#62;tv_sec == (b)-&#62;tv_sec) ? \
  ((a)-&#62;tv_usec CMP (b)-&#62;tv_usec) : \
  ((a)-&#62;tv_sec CMP (b)-&#62;tv_sec))

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    char *tm_zone;
};

struct timespec {
    time_t tv_sec;
    long int tv_nsec;
};

struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
extern int __daylight;
extern long int __timezone;
extern char *__tzname[];
extern char *asctime(const struct tm *__tp);
extern char *asctime_r(const struct tm *__tp, char *__buf);
extern clock_t clock(void);
extern int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id);
extern int clock_getres(clockid_t __clock_id, struct timespec *__res);
extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp);
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
			   const struct timespec *__req,
			   struct timespec *__rem);
extern int clock_settime(clockid_t __clock_id,
			 const struct timespec *__tp);
extern char *ctime(const time_t * __timer);
extern char *ctime_r(const time_t * __timer, char *__buf);
extern int daylight;
extern double difftime(time_t __time1, time_t __time0);
extern struct tm *getdate(const char *__string);
extern int getdate_err;
extern struct tm *gmtime(const time_t * __timer);
extern struct tm *gmtime_r(const time_t * __timer, struct tm *__tp);
extern struct tm *localtime(const time_t * __timer);
extern struct tm *localtime_r(const time_t * __timer, struct tm *__tp);
extern time_t mktime(struct tm *__tp);
extern int nanosleep(const struct timespec *__requested_time,
		     struct timespec *__remaining);
extern int stime(const time_t * __when);
extern size_t strftime(char *__s, size_t __maxsize, const char *__format,
		       const struct tm *__tp);
extern size_t strftime_l(char *s, size_t maxsize, const char *format,
			 const struct tm *timeptr, locale_t locale);
extern char *strptime(const char *__s, const char *__fmt, struct tm *__tp);
extern time_t time(time_t * __timer);
extern int timer_create(clockid_t __clock_id, struct sigevent *__evp,
			timer_t * __timerid);
extern int timer_delete(timer_t __timerid);
extern int timer_getoverrun(timer_t __timerid);
extern int timer_gettime(timer_t __timerid, struct itimerspec *__value);
extern int timer_settime(timer_t __timerid, int __flags,
			 const struct itimerspec *__value,
			 struct itimerspec *__ovalue);
extern long int timezone;
extern char *tzname[];
extern void tzset(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7738"
>14.4.101. ucontext.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int getcontext(ucontext_t * __ucp);
extern void makecontext(ucontext_t * __ucp, void (*__func) (void),
			int __argc, ...);
extern int setcontext(const struct ucontext *__ucp);
extern int swapcontext(ucontext_t * __oucp, const struct ucontext *__ucp);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7742"
>14.4.102. ulimit.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UL_GETFSIZE	1
#define UL_SETFSIZE	2

extern long int ulimit(int __cmd, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7746"
>14.4.103. unistd.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#ifndef SEEK_SET
#define SEEK_SET	0
#endif
#define STDIN_FILENO	0
#ifndef SEEK_CUR
#define SEEK_CUR	1
#endif
#define STDOUT_FILENO	1
#ifndef SEEK_END
#define SEEK_END	2
#endif
#define STDERR_FILENO	2

#define F_OK	0
#define X_OK	1
#define W_OK	2
#define R_OK	4

#define _POSIX_VDISABLE	'\0'
#define _POSIX_ASYNC_IO	0
#define _POSIX_CHOWN_RESTRICTED	1
#define _POSIX_JOB_CONTROL	1
#define _POSIX_NO_TRUNC	1
#define _POSIX_SHELL	1
#define _POSIX2_CHAR_TERM	200809L
#define _POSIX2_C_BIND	200809L
#define _POSIX2_LOCALEDEF	200809L
#define _POSIX2_VERSION	200809L
#define _POSIX_ADVISORY_INFO	200809L
#define _POSIX_BARRIERS	200809L
#define _POSIX_CLOCK_SELECTION	200809L
#define _POSIX_FSYNC	200809L
#define _POSIX_IPV6	200809L
#define _POSIX_MAPPED_FILES	200809L
#define _POSIX_MEMLOCK	200809L
#define _POSIX_MEMLOCK_RANGE	200809L
#define _POSIX_MEMORY_PROTECTION	200809L
#define _POSIX_MESSAGE_PASSING	200809L
#define _POSIX_PRIORITIZED_IO	200809L
#define _POSIX_PRIORITY_SCHEDULING	200809L
#define _POSIX_RAW_SOCKETS	200809L
#define _POSIX_READER_WRITER_LOCKS	200809L
#define _POSIX_REALTIME_SIGNALS	200809L
#define _POSIX_SEMAPHORES	200809L
#define _POSIX_SHARED_MEMORY_OBJECTS	200809L
#define _POSIX_SPAWN	200809L
#define _POSIX_SPIN_LOCKS	200809L
#define _POSIX_SYNCHRONIZED_IO	200809L
#define _POSIX_THREADS	200809L
#define _POSIX_THREAD_ATTR_STACKADDR	200809L
#define _POSIX_THREAD_ATTR_STACKSIZE	200809L
#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
#define _POSIX_THREAD_PRIO_INHERIT	200809L
#define _POSIX_THREAD_PRIO_PROTECT	200809L
#define _POSIX_THREAD_PROCESS_SHARED	200809L
#define _POSIX_THREAD_ROBUST_PRIO_INHERIT	200809L
#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
#define _POSIX_TIMEOUTS	200809L
#define _POSIX_TIMERS	200809L
#define _POSIX_VERSION	200809L

#define _PC_LINK_MAX	0
#define _PC_MAX_CANON	1
#define _PC_ASYNC_IO	10
#define _PC_PRIO_IO	11
#define _PC_FILESIZEBITS	13
#define _PC_REC_INCR_XFER_SIZE	14
#define _PC_REC_MIN_XFER_SIZE	16
#define _PC_REC_XFER_ALIGN	17
#define _PC_ALLOC_SIZE_MIN	18
#define _PC_MAX_INPUT	2
#define _PC_2_SYMLINKS	20
#define _PC_NAME_MAX	3
#define _PC_PATH_MAX	4
#define _PC_PIPE_BUF	5
#define _PC_CHOWN_RESTRICTED	6
#define _PC_NO_TRUNC	7
#define _PC_VDISABLE	8
#define _PC_SYNC_IO	9

#define _SC_ARG_MAX	0
#define _SC_CHILD_MAX	1
#define _SC_PRIORITY_SCHEDULING	10
#define _SC_XOPEN_XPG4	100
#define _SC_CHAR_BIT	101
#define _SC_CHAR_MAX	102
#define _SC_CHAR_MIN	103
#define _SC_INT_MAX	104
#define _SC_INT_MIN	105
#define _SC_LONG_BIT	106
#define _SC_WORD_BIT	107
#define _SC_MB_LEN_MAX	108
#define _SC_NZERO	109
#define _SC_TIMERS	11
#define _SC_SSIZE_MAX	110
#define _SC_SCHAR_MAX	111
#define _SC_SCHAR_MIN	112
#define _SC_SHRT_MAX	113
#define _SC_SHRT_MIN	114
#define _SC_UCHAR_MAX	115
#define _SC_UINT_MAX	116
#define _SC_ULONG_MAX	117
#define _SC_USHRT_MAX	118
#define _SC_NL_ARGMAX	119
#define _SC_ASYNCHRONOUS_IO	12
#define _SC_NL_LANGMAX	120
#define _SC_NL_MSGMAX	121
#define _SC_NL_NMAX	122
#define _SC_NL_SETMAX	123
#define _SC_NL_TEXTMAX	124
#define _SC_XBS5_ILP32_OFF32	125
#define _SC_XBS5_ILP32_OFFBIG	126
#define _SC_XBS5_LP64_OFF64	127
#define _SC_XBS5_LPBIG_OFFBIG	128
#define _SC_XOPEN_LEGACY	129
#define _SC_PRIORITIZED_IO	13
#define _SC_XOPEN_REALTIME	130
#define _SC_XOPEN_REALTIME_THREADS	131
#define _SC_ADVISORY_INFO	132
#define _SC_BARRIERS	133
#define _SC_BASE	134
#define _SC_C_LANG_SUPPORT	135
#define _SC_C_LANG_SUPPORT_R	136
#define _SC_CLOCK_SELECTION	137
#define _SC_CPUTIME	138
#define _SC_THREAD_CPUTIME	139
#define _SC_SYNCHRONIZED_IO	14
#define _SC_DEVICE_IO	140
#define _SC_DEVICE_SPECIFIC	141
#define _SC_DEVICE_SPECIFIC_R	142
#define _SC_FD_MGMT	143
#define _SC_FIFO	144
#define _SC_PIPE	145
#define _SC_FILE_ATTRIBUTES	146
#define _SC_FILE_LOCKING	147
#define _SC_FILE_SYSTEM	148
#define _SC_MONOTONIC_CLOCK	149
#define _SC_FSYNC	15
#define _SC_MULTI_PROCESS	150
#define _SC_SINGLE_PROCESS	151
#define _SC_NETWORKING	152
#define _SC_READER_WRITER_LOCKS	153
#define _SC_SPIN_LOCKS	154
#define _SC_REGEXP	155
#define _SC_REGEX_VERSION	156
#define _SC_SHELL	157
#define _SC_SIGNALS	158
#define _SC_SPAWN	159
#define _SC_MAPPED_FILES	16
#define _SC_SPORADIC_SERVER	160
#define _SC_THREAD_SPORADIC_SERVER	161
#define _SC_SYSTEM_DATABASE	162
#define _SC_SYSTEM_DATABASE_R	163
#define _SC_TIMEOUTS	164
#define _SC_TYPED_MEMORY_OBJECTS	165
#define _SC_USER_GROUPS	166
#define _SC_USER_GROUPS_R	167
#define _SC_2_PBS	168
#define _SC_2_PBS_ACCOUNTING	169
#define _SC_MEMLOCK	17
#define _SC_2_PBS_LOCATE	170
#define _SC_2_PBS_MESSAGE	171
#define _SC_2_PBS_TRACK	172
#define _SC_SYMLOOP_MAX	173
#define _SC_STREAMS	174
#define _SC_2_PBS_CHECKPOINT	175
#define _SC_V6_ILP32_OFF32	176
#define _SC_V6_ILP32_OFFBIG	177
#define _SC_V6_LP64_OFF64	178
#define _SC_V6_LPBIG_OFFBIG	179
#define _SC_MEMLOCK_RANGE	18
#define _SC_HOST_NAME_MAX	180
#define _SC_TRACE	181
#define _SC_TRACE_EVENT_FILTER	182
#define _SC_TRACE_INHERIT	183
#define _SC_TRACE_LOG	184
#define _SC_LEVEL1_ICACHE_SIZE	185
#define _SC_LEVEL1_ICACHE_ASSOC	186
#define _SC_LEVEL1_ICACHE_LINESIZE	187
#define _SC_LEVEL1_DCACHE_SIZE	188
#define _SC_LEVEL1_DCACHE_ASSOC	189
#define _SC_MEMORY_PROTECTION	19
#define _SC_LEVEL1_DCACHE_LINESIZE	190
#define _SC_LEVEL2_CACHE_SIZE	191
#define _SC_LEVEL2_CACHE_ASSOC	192
#define _SC_LEVEL2_CACHE_LINESIZE	193
#define _SC_LEVEL3_CACHE_SIZE	194
#define _SC_LEVEL3_CACHE_ASSOC	195
#define _SC_LEVEL3_CACHE_LINESIZE	196
#define _SC_LEVEL4_CACHE_SIZE	197
#define _SC_LEVEL4_CACHE_ASSOC	198
#define _SC_LEVEL4_CACHE_LINESIZE	199
#define _SC_CLK_TCK	2
#define _SC_MESSAGE_PASSING	20
#define _SC_SEMAPHORES	21
#define _SC_SHARED_MEMORY_OBJECTS	22
#define _SC_AIO_LISTIO_MAX	23
#define _SC_IPV6	235
#define _SC_RAW_SOCKETS	236
#define _SC_V7_ILP32_OFF32	237
#define _SC_V7_ILP32_OFFBIG	238
#define _SC_V7_LP64_OFF64	239
#define _SC_AIO_MAX	24
#define _SC_V7_LPBIG_OFFBIG	240
#define _SC_SS_REPL_MAX	241
#define _SC_TRACE_EVENT_NAME_MAX	242
#define _SC_TRACE_NAME_MAX	243
#define _SC_TRACE_SYS_MAX	244
#define _SC_TRACE_USER_EVENT_MAX	245
#define _SC_XOPEN_STREAMS	246
#define _SC_THREAD_ROBUST_PRIO_INHERIT	247
#define _SC_THREAD_ROBUST_PRIO_PROTECT	248
#define _SC_AIO_PRIO_DELTA_MAX	25
#define _SC_DELAYTIMER_MAX	26
#define _SC_MQ_OPEN_MAX	27
#define _SC_MQ_PRIO_MAX	28
#define _SC_VERSION	29
#define _SC_NGROUPS_MAX	3
#define _SC_PAGESIZE	30
#define _SC_PAGE_SIZE	30
#define _SC_RTSIG_MAX	31
#define _SC_SEM_NSEMS_MAX	32
#define _SC_SEM_VALUE_MAX	33
#define _SC_SIGQUEUE_MAX	34
#define _SC_TIMER_MAX	35
#define _SC_BC_BASE_MAX	36
#define _SC_BC_DIM_MAX	37
#define _SC_BC_SCALE_MAX	38
#define _SC_BC_STRING_MAX	39
#define _SC_OPEN_MAX	4
#define _SC_COLL_WEIGHTS_MAX	40
#define _SC_EQUIV_CLASS_MAX	41
#define _SC_EXPR_NEST_MAX	42
#define _SC_LINE_MAX	43
#define _SC_RE_DUP_MAX	44
#define _SC_CHARCLASS_NAME_MAX	45
#define _SC_2_VERSION	46
#define _SC_2_C_BIND	47
#define _SC_2_C_DEV	48
#define _SC_2_FORT_DEV	49
#define _SC_STREAM_MAX	5
#define _SC_2_FORT_RUN	50
#define _SC_2_SW_DEV	51
#define _SC_2_LOCALEDEF	52
#define _SC_PII	53
#define _SC_PII_XTI	54
#define _SC_PII_SOCKET	55
#define _SC_PII_INTERNET	56
#define _SC_PII_OSI	57
#define _SC_POLL	58
#define _SC_SELECT	59
#define _SC_TZNAME_MAX	6
#define _SC_IOV_MAX	60
#define _SC_UIO_MAXIOV	60
#define _SC_PII_INTERNET_STREAM	61
#define _SC_PII_INTERNET_DGRAM	62
#define _SC_PII_OSI_COTS	63
#define _SC_PII_OSI_CLTS	64
#define _SC_PII_OSI_M	65
#define _SC_T_IOV_MAX	66
#define _SC_THREADS	67
#define _SC_THREAD_SAFE_FUNCTIONS	68
#define _SC_GETGR_R_SIZE_MAX	69
#define _SC_JOB_CONTROL	7
#define _SC_GETPW_R_SIZE_MAX	70
#define _SC_LOGIN_NAME_MAX	71
#define _SC_TTY_NAME_MAX	72
#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
#define _SC_THREAD_KEYS_MAX	74
#define _SC_THREAD_STACK_MIN	75
#define _SC_THREAD_THREADS_MAX	76
#define _SC_THREAD_ATTR_STACKADDR	77
#define _SC_THREAD_ATTR_STACKSIZE	78
#define _SC_THREAD_PRIORITY_SCHEDULING	79
#define _SC_SAVED_IDS	8
#define _SC_THREAD_PRIO_INHERIT	80
#define _SC_THREAD_PRIO_PROTECT	81
#define _SC_THREAD_PROCESS_SHARED	82
#define _SC_NPROCESSORS_CONF	83
#define _SC_NPROCESSORS_ONLN	84
#define _SC_PHYS_PAGES	85
#define _SC_AVPHYS_PAGES	86
#define _SC_ATEXIT_MAX	87
#define _SC_PASS_MAX	88
#define _SC_XOPEN_VERSION	89
#define _SC_REALTIME_SIGNALS	9
#define _SC_XOPEN_XCU_VERSION	90
#define _SC_XOPEN_UNIX	91
#define _SC_XOPEN_CRYPT	92
#define _SC_XOPEN_ENH_I18N	93
#define _SC_XOPEN_SHM	94
#define _SC_2_CHAR_TERM	95
#define _SC_2_C_VERSION	96
#define _SC_2_UPE	97
#define _SC_XOPEN_XPG2	98
#define _SC_XOPEN_XPG3	99

#define _CS_PATH	0
#define _POSIX_REGEXP	1
#define _CS_XBS5_ILP32_OFF32_CFLAGS	1100
#define _CS_XBS5_ILP32_OFF32_LDFLAGS	1101
#define _CS_XBS5_ILP32_OFF32_LIBS	1102
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS	1103
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS	1104
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS	1105
#define _CS_XBS5_ILP32_OFFBIG_LIBS	1106
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS	1107
#define _CS_XBS5_LP64_OFF64_CFLAGS	1108
#define _CS_XBS5_LP64_OFF64_LDFLAGS	1109
#define _CS_XBS5_LP64_OFF64_LIBS	1110
#define _CS_XBS5_LP64_OFF64_LINTFLAGS	1111
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS	1112
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS	1113
#define _CS_XBS5_LPBIG_OFFBIG_LIBS	1114
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS	1115
#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS	1116
#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS	1117
#define _CS_POSIX_V6_ILP32_OFF32_LIBS	1118
#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS	1119
#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS	1120
#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS	1121
#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS	1122
#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS	1123
#define _CS_POSIX_V6_LP64_OFF64_CFLAGS	1124
#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS	1125
#define _CS_POSIX_V6_LP64_OFF64_LIBS	1126
#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS	1127
#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS	1128
#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS	1129
#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS	1130
#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS	1131
#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS	1132
#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS	1133
#define _CS_POSIX_V7_ILP32_OFF32_LIBS	1134
#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS	1135
#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS	1136
#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS	1137
#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS	1138
#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS	1139
#define _CS_POSIX_V7_LP64_OFF64_CFLAGS	1140
#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS	1141
#define _CS_POSIX_V7_LP64_OFF64_LIBS	1142
#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS	1143
#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS	1144
#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS	1145
#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS	1146
#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS	1147
#define _CS_V6_ENV	1148
#define _CS_V7_ENV	1149

#define _XOPEN_XPG4	1
#define _XOPEN_VERSION	700

#define F_ULOCK	0
#define F_LOCK	1
#define F_TLOCK	2
#define F_TEST	3

extern size_t __confstr_chk(int, char *, size_t, size_t);
extern char **__environ;
extern char *__getcwd_chk(char *, size_t, size_t);
extern int __getgroups_chk(int, gid_t *, size_t);
extern int __gethostname_chk(char *, size_t, size_t);
extern int __getlogin_r_chk(char *, size_t, size_t);
extern pid_t __getpgid(pid_t __pid);
extern ssize_t __pread64_chk(int, void *, size_t, off64_t, size_t);
extern ssize_t __pread_chk(int, void *, size_t, off_t, size_t);
extern ssize_t __read_chk(int, void *, size_t, size_t);
extern ssize_t __readlink_chk(const char *, char *, size_t, size_t);
extern int __ttyname_r_chk(int, char *, size_t, size_t);
extern char **_environ;
extern void _exit(int __status);
extern int access(const char *__name, int __type);
extern int acct(const char *__name);
extern unsigned int alarm(unsigned int __seconds);
extern int brk(void *__addr);
extern int chdir(const char *__path);
extern int chown(const char *__file, uid_t __owner, gid_t __group);
extern int chroot(const char *__path);
extern int close(int __fd);
extern size_t confstr(int __name, char *__buf, size_t __len);
extern char *crypt(const char *__key, const char *__salt);
extern char *ctermid(char *__s);
extern char *cuserid(char *__s);
extern int daemon(int __nochdir, int __noclose);
extern int dup(int __fd);
extern int dup2(int __fd, int __fd2);
extern void encrypt(char *__block, int __edflag);
extern int execl(const char *__path, const char *__arg, ...);
extern int execle(const char *__path, const char *__arg, ...);
extern int execlp(const char *__file, const char *__arg, ...);
extern int execv(const char *__path, char *const __argv[]);
extern int execve(const char *__path, char *const __argv[],
		  char *const __envp[]);
extern int execvp(const char *__file, char *const __argv[]);
extern int faccessat(int __fd, const char *__file, int __type, int __flag);
extern int fchdir(int __fd);
extern int fchown(int __fd, uid_t __owner, gid_t __group);
extern int fchownat(int __fd, const char *__file, uid_t __owner,
		    gid_t __group, int __flag);
extern int fdatasync(int __fildes);
extern int fexecve(int __fd, char *const __argv[], char *const __envp[]);
extern pid_t fork(void);
extern long int fpathconf(int __fd, int __name);
extern int fsync(int __fd);
extern int ftruncate(int __fd, off_t __length);
extern int ftruncate64(int __fd, off64_t __length);
extern char *getcwd(char *__buf, size_t __size);
extern int getdomainname(char *__name, size_t __len);
extern int getdtablesize(void);
extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern int getgroups(int __size, gid_t __list[]);
extern long int gethostid(void);
extern int gethostname(char *__name, size_t __len);
extern char *getlogin(void);
extern int getlogin_r(char *__name, size_t __name_len);
extern int getopt(int ___argc, char *const ___argv[],
		  const char *__shortopts);
extern int getpagesize(void);
extern pid_t getpgid(pid_t __pid);
extern pid_t getpgrp(void);
extern pid_t getpid(void);
extern pid_t getppid(void);
extern pid_t getsid(pid_t __pid);
extern uid_t getuid(void);
extern char *getwd(char *__buf);
extern int isatty(int __fd);
extern int lchown(const char *__file, uid_t __owner, gid_t __group);
extern int link(const char *__from, const char *__to);
extern int linkat(int __fromfd, const char *__from, int __tofd,
		  const char *__to, int __flags);
extern int lockf(int __fd, int __cmd, off_t __len);
extern int lockf64(int __fd, int __cmd, off64_t __len);
extern off_t lseek(int __fd, off_t __offset, int __whence);
extern loff_t lseek64(int __fd, loff_t __offset, int __whence);
extern int nice(int __inc);
extern char *optarg;
extern int opterr;
extern int optind;
extern int optopt;
extern long int pathconf(const char *__path, int __name);
extern int pause(void);
extern int pipe(int __pipedes[2]);
extern ssize_t pread(int __fd, void *__buf, size_t __nbytes,
		     off_t __offset);
extern ssize_t pread64(int __fd, void *__buf, size_t __nbytes,
		       off64_t __offset);
extern ssize_t pwrite(int __fd, const void *__buf, size_t __n,
		      off_t __offset);
extern ssize_t pwrite64(int __fd, const void *__buf, size_t __n,
			off64_t __offset);
extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
extern ssize_t readlink(const char *__path, char *__buf, size_t __len);
extern ssize_t readlinkat(int __fd, const char *__path, char *__buf,
			  size_t __len);
extern int rmdir(const char *__path);
extern void *sbrk(intptr_t __delta);
extern int setegid(gid_t __gid);
extern int seteuid(uid_t __uid);
extern int setgid(gid_t __gid);
extern int sethostname(const char *__name, size_t __len);
extern void setkey(const char *__key);
extern int setpgid(pid_t __pid, pid_t __pgid);
extern int setpgrp(void);
extern int setregid(gid_t __rgid, gid_t __egid);
extern int setreuid(uid_t __ruid, uid_t __euid);
extern pid_t setsid(void);
extern int setuid(uid_t __uid);
extern unsigned int sleep(unsigned int __seconds);
extern void swab(const void *__from, void *__to, ssize_t __n);
extern int symlink(const char *__from, const char *__to);
extern int symlinkat(const char *__from, int __tofd, const char *__to);
extern void sync(void);
extern long int sysconf(int __name);
extern pid_t tcgetpgrp(int __fd);
extern int tcsetpgrp(int __fd, pid_t __pgrp_id);
extern int truncate(const char *__file, off_t __length);
extern int truncate64(const char *__file, off64_t __length);
extern char *ttyname(int __fd);
extern int ttyname_r(int __fd, char *__buf, size_t __buflen);
extern unsigned int ualarm(useconds_t __value, useconds_t __interval);
extern int unlink(const char *__name);
extern int unlinkat(int __fd, const char *__name, int __flag);
extern int usleep(useconds_t __useconds);
extern pid_t vfork(void);
extern ssize_t write(int __fd, const void *__buf, size_t __n);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7750"
>14.4.104. utime.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;struct utimbuf {
    time_t actime;
    time_t modtime;
};
extern int utime(const char *__file, const struct utimbuf *__file_times);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7754"
>14.4.105. utmp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define UT_HOSTSIZE	256
#define UT_LINESIZE	32
#define UT_NAMESIZE	32
#define ut_addr	ut_addr_v6[0]
#define ut_time	ut_tv.tv_sec
#define ut_name	ut_user		/* Backwards compatability */

struct exit_status {
    short e_termination;	/* Process termination status. */
    short e_exit;		/* Process exit status. */
};

#define EMPTY	0		/* No valid user accounting information. */
#define RUN_LVL	1		/* The system's runlevel. */
#define BOOT_TIME	2	/* Time of system boot. */
#define NEW_TIME	3	/* Time after system clock changed. */
#define OLD_TIME	4	/* Time when system clock changed. */
#define INIT_PROCESS	5	/* Process spawned by the init process. */
#define LOGIN_PROCESS	6	/* Session leader of a logged in user. */
#define USER_PROCESS	7	/* Normal process. */
#define DEAD_PROCESS	8	/* Terminated process. */
#define ACCOUNTING	9

extern void endutent(void);
extern struct utmp *getutent(void);
extern int getutent_r(struct utmp *__buffer, struct utmp **__result);
extern void login(const struct utmp *__entry);
extern int login_tty(int __fd);
extern int logout(const char *__ut_line);
extern void logwtmp(const char *__ut_line, const char *__ut_name,
		    const char *__ut_host);
extern void setutent(void);
extern int utmpname(const char *__file);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7758"
>14.4.106. utmpx.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern void endutxent(void);
extern struct utmpx *getutxent(void);
extern struct utmpx *getutxid(const struct utmpx *__id);
extern struct utmpx *getutxline(const struct utmpx *__line);
extern struct utmpx *pututxline(const struct utmpx *__utmpx);
extern void setutxent(void);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7762"
>14.4.107. wchar.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;#define WEOF	(0xffffffffu)
#define WCHAR_MAX	0x7FFFFFFF
#define WCHAR_MIN	0x80000000

typedef unsigned long int wctype_t;
typedef const int32_t *wctrans_t;

extern wchar_t *__fgetws_chk(wchar_t *, size_t, int, FILE *);
extern wchar_t *__fgetws_unlocked_chk(wchar_t *, size_t, int, FILE *);
extern int __fwprintf_chk(FILE *, int, const wchar_t *, ...);
extern size_t __mbsnrtowcs_chk(wchar_t *, const char **, size_t, size_t,
			       mbstate_t *, size_t);
extern size_t __mbsrtowcs_chk(wchar_t *, const char **, size_t,
			      mbstate_t *, size_t);
extern int __swprintf_chk(wchar_t *, size_t, int, size_t, const wchar_t *,
			  ...);
extern int __vfwprintf_chk(FILE *, int, const wchar_t *, va_list);
extern int __vswprintf_chk(wchar_t *, size_t, int, size_t, const wchar_t *,
			   va_list);
extern int __vwprintf_chk(int, const wchar_t *, va_list);
extern wchar_t *__wcpcpy_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcpncpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern size_t __wcrtomb_chk(char *, wchar_t, mbstate_t *, size_t);
extern wchar_t *__wcscat_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcscpy_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcsncat_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wcsncpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern size_t __wcsnrtombs_chk(char *, const wchar_t * *, size_t, size_t,
			       mbstate_t *, size_t);
extern size_t __wcsrtombs_chk(char *, const wchar_t * *, size_t,
			      mbstate_t *, size_t);
extern double __wcstod_internal(const wchar_t *, wchar_t * *, int);
extern float __wcstof_internal(const wchar_t *, wchar_t * *, int);
extern long int __wcstol_internal(const wchar_t *, wchar_t * *, int, int);
extern long double __wcstold_internal(const wchar_t *, wchar_t * *, int);
extern unsigned long int __wcstoul_internal(const wchar_t *, wchar_t * *,
					    int, int);
extern wchar_t *__wmemcpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmemmove_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmempcpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmemset_chk(wchar_t *, wchar_t, size_t, size_t);
extern int __wprintf_chk(int, const wchar_t *, ...);
extern wint_t btowc(int __c);
extern wint_t fgetwc(FILE * __stream);
extern wint_t fgetwc_unlocked(FILE * __stream);
extern wchar_t *fgetws(wchar_t * __ws, int __n, FILE * __stream);
extern wchar_t *fgetws_unlocked(wchar_t * __ws, int __n, FILE * __stream);
extern wint_t fputwc(wchar_t __wc, FILE * __stream);
extern wint_t fputwc_unlocked(wchar_t __wc, FILE * __stream);
extern int fputws(const wchar_t * __ws, FILE * __stream);
extern int fputws_unlocked(const wchar_t * __ws, FILE * __stream);
extern int fwide(FILE * __fp, int __mode);
extern int fwprintf(FILE * __stream, const wchar_t * __format, ...);
extern int fwscanf(FILE * __stream, const wchar_t * __format, ...);
extern wint_t getwc(FILE * __stream);
extern wint_t getwc_unlocked(FILE * __stream);
extern wint_t getwchar(void);
extern wint_t getwchar_unlocked(void);
extern size_t mbrlen(const char *__s, size_t __n, mbstate_t * __ps);
extern size_t mbrtowc(wchar_t * __pwc, const char *__s, size_t __n,
		      mbstate_t * __p);
extern int mbsinit(const mbstate_t * __ps);
extern size_t mbsnrtowcs(wchar_t * __dst, const char **__src, size_t __nmc,
			 size_t __len, mbstate_t * __ps);
extern size_t mbsrtowcs(wchar_t * __dst, const char **__src, size_t __len,
			mbstate_t * __ps);
extern FILE *open_wmemstream(wchar_t * *__bufloc, size_t * __sizeloc);
extern wint_t putwc(wchar_t __wc, FILE * __stream);
extern wint_t putwc_unlocked(wchar_t __wc, FILE * __stream);
extern wint_t putwchar(wchar_t __wc);
extern wint_t putwchar_unlocked(wchar_t __wc);
extern int swprintf(wchar_t * __s, size_t __n, const wchar_t * __format,
		    ...);
extern int swscanf(const wchar_t * __s, const wchar_t * __format, ...);
extern wint_t ungetwc(wint_t __wc, FILE * __stream);
extern int vfwprintf(FILE * __s, const wchar_t * __format, va_list __arg);
extern int vfwscanf(FILE * __s, const wchar_t * __format, va_list __arg);
extern int vswprintf(wchar_t * __s, size_t __n, const wchar_t * __format,
		     va_list __arg);
extern int vswscanf(const wchar_t * __s, const wchar_t * __format,
		    va_list __arg);
extern int vwprintf(const wchar_t * __format, va_list __arg);
extern int vwscanf(const wchar_t * __format, va_list __arg);
extern wchar_t *wcpcpy(wchar_t * __dest, const wchar_t * __src);
extern wchar_t *wcpncpy(wchar_t * __dest, const wchar_t * __src,
			size_t __n);
extern size_t wcrtomb(char *__s, wchar_t __wc, mbstate_t * __ps);
extern int wcscasecmp(const wchar_t * __s1, const wchar_t * __s2);
extern int wcscasecmp_l(const wchar_t * ws1, const wchar_t * ws2,
			locale_t locale);
extern wchar_t *wcscat(wchar_t * __dest, const wchar_t * __src);
extern wchar_t *wcschr(const wchar_t * __wcs, wchar_t __wc);
extern int wcscmp(const wchar_t * __s1, const wchar_t * __s2);
extern int wcscoll(const wchar_t * __s1, const wchar_t * __s2);
extern int wcscoll_l(const wchar_t * ws1, const wchar_t * ws2,
		     locale_t locale);
extern wchar_t *wcscpy(wchar_t * __dest, const wchar_t * __src);
extern size_t wcscspn(const wchar_t * __wcs, const wchar_t * __reject);
extern wchar_t *wcsdup(const wchar_t * __s);
extern size_t wcsftime(wchar_t * __s, size_t __maxsize,
		       const wchar_t * __format, const struct tm *__tp);
extern size_t wcslen(const wchar_t * __s);
extern int wcsncasecmp(const wchar_t * __s1, const wchar_t * __s2,
		       size_t __n);
extern int wcsncasecmp_l(const wchar_t * ws1, const wchar_t * ws2,
			 size_t n, locale_t locale);
extern wchar_t *wcsncat(wchar_t * __dest, const wchar_t * __src,
			size_t __n);
extern int wcsncmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wcsncpy(wchar_t * __dest, const wchar_t * __src,
			size_t __n);
extern size_t wcsnlen(const wchar_t * __s, size_t __maxlen);
extern size_t wcsnrtombs(char *__dst, const wchar_t * *__src, size_t __nwc,
			 size_t __len, mbstate_t * __ps);
extern wchar_t *wcspbrk(const wchar_t * __wcs, const wchar_t * __accept);
extern wchar_t *wcsrchr(const wchar_t * __wcs, wchar_t __wc);
extern size_t wcsrtombs(char *__dst, const wchar_t * *__src, size_t __len,
			mbstate_t * __ps);
extern size_t wcsspn(const wchar_t * __wcs, const wchar_t * __accept);
extern wchar_t *wcsstr(const wchar_t * __haystack,
		       const wchar_t * __needle);
extern double wcstod(const wchar_t * __nptr, wchar_t * *__endptr);
extern float wcstof(const wchar_t * __nptr, wchar_t * *__endptr);
extern wchar_t *wcstok(wchar_t * __s, const wchar_t * __delim,
		       wchar_t * *__ptr);
extern long int wcstol(const wchar_t * __nptr, wchar_t * *__endptr,
		       int __base);
extern long double wcstold(const wchar_t * __nptr, wchar_t * *__endptr);
extern long long int wcstoll(const wchar_t * __nptr, wchar_t * *__endptr,
			     int __base);
extern long long int wcstoq(const wchar_t * __nptr, wchar_t * *__endptr,
			    int __base);
extern unsigned long int wcstoul(const wchar_t * __nptr,
				 wchar_t * *__endptr, int __base);
extern unsigned long long int wcstoull(const wchar_t * __nptr,
				       wchar_t * *__endptr, int __base);
extern unsigned long long int wcstouq(const wchar_t * __nptr,
				      wchar_t * *__endptr, int __base);
extern wchar_t *wcswcs(const wchar_t * __haystack,
		       const wchar_t * __needle);
extern int wcswidth(const wchar_t * __s, size_t __n);
extern size_t wcsxfrm(wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern size_t wcsxfrm_l(const wchar_t * ws1, const wchar_t * ws2, size_t n,
			locale_t locale);
extern int wctob(wint_t __c);
extern int wcwidth(wchar_t __c);
extern wchar_t *wmemchr(const wchar_t * __s, wchar_t __c, size_t __n);
extern int wmemcmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wmemcpy(wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wmemmove(wchar_t * __s1, const wchar_t * __s2, size_t __n);
extern wchar_t *wmemset(wchar_t * __s, wchar_t __c, size_t __n);
extern int wprintf(const wchar_t * __format, ...);
extern int wscanf(const wchar_t * __format, ...);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7766"
>14.4.108. wctype.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;extern int iswalnum(wint_t __wc);
extern int iswalnum_l(wint_t wc, locale_t locale);
extern int iswalpha(wint_t __wc);
extern int iswalpha_l(wint_t wc, locale_t locale);
extern int iswblank(wint_t __wc);
extern int iswblank_l(wint_t wc, locale_t locale);
extern int iswcntrl(wint_t __wc);
extern int iswcntrl_l(wint_t wc, locale_t locale);
extern int iswctype(wint_t __wc, wctype_t __desc);
extern int iswctype_l(wint_t wc, locale_t locale);
extern int iswdigit(wint_t __wc);
extern int iswdigit_l(wint_t wc, locale_t locale);
extern int iswgraph(wint_t __wc);
extern int iswgraph_l(wint_t wc, locale_t locale);
extern int iswlower(wint_t __wc);
extern int iswlower_l(wint_t wc, locale_t locale);
extern int iswprint(wint_t __wc);
extern int iswprint_l(wint_t wc, locale_t locale);
extern int iswpunct(wint_t __wc);
extern int iswpunct_l(wint_t wc, locale_t locale);
extern int iswspace(wint_t __wc);
extern int iswspace_l(wint_t wc, locale_t locale);
extern int iswupper(wint_t __wc);
extern int iswupper_l(wint_t wc, locale_t locale);
extern int iswxdigit(wint_t __wc);
extern int iswxdigit_l(wint_t wc, locale_t locale);
extern wint_t towctrans(wint_t __wc, wctrans_t __desc);
extern wint_t towctrans_l(wint_t wc, wctrans_t desc, locale_t locale);
extern wint_t towlower(wint_t __wc);
extern wint_t towlower_l(wint_t wc, locale_t locale);
extern wint_t towupper(wint_t __wc);
extern wint_t towupper_l(wint_t wc, locale_t locale);
extern wctrans_t wctrans(const char *__property);
extern size_t wctrans_l(const char *charclass, locale_t locale);
extern wctype_t wctype(const char *__property);
extern size_t wctype_l(const char *property, locale_t locale);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN7770"
>14.4.109. wordexp.h</A
></H2
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;enum {
    WRDE_DOOFFS = 1,
    WRDE_APPEND = 2,
    WRDE_NOCMD = 4,
    WRDE_REUSE = 8,
    WRDE_SHOWERR = 16,
    WRDE_UNDEF = 32
};

typedef struct {
    size_t we_wordc;
    char **we_wordv;
    size_t we_offs;
} wordexp_t;

enum {
    WRDE_NOSYS = -1,
    WRDE_NOSPACE = 1,
    WRDE_BADCHAR = 2,
    WRDE_BADVAL = 3,
    WRDE_CMDSUB = 4,
    WRDE_SYNTAX = 5
};
extern int wordexp(const char *__words, wordexp_t * __pwordexp,
		   int __flags);
extern void wordfree(wordexp_t * __wordexp);</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libc.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libcman.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Interfaces for libc</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="baselib.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Interface Definitions for libc</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>