<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>getrlimit, setrlimit</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Linux Standard Base Core Specification, Generic Part"
HREF="book1.html"><LINK
REL="UP"
TITLE="Interface Definitions for libc"
HREF="libcman.html"><LINK
REL="PREVIOUS"
TITLE="getpwent_r"
HREF="baselib-getpwent-r-1.html"><LINK
REL="NEXT"
TITLE="getservbyname_r"
HREF="baselib-getservbyname-r.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux Standard Base Core Specification, Generic Part</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="baselib-getpwent-r-1.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="baselib-getservbyname-r.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="BASELIB-GETRLIMIT-1"
></A
>getrlimit, setrlimit</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN15940"
></A
><H2
>Name</H2
>getrlimit, setrlimit&nbsp;--&nbsp;get resource consumption limits</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN15947"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN15948"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;sys/resource.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>getrlimit</TT
></CODE
>(__rlimit_resource_t
<TT
CLASS="PARAMETER"
><I
>__resource</I
></TT
>, struct rlimit *
<TT
CLASS="PARAMETER"
><I
>__rlimits</I
></TT
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int
<TT
CLASS="FUNCTION"
>setrlimit</TT
></CODE
>(__rlimit_resource_t
<TT
CLASS="PARAMETER"
><I
>__resource</I
></TT
>, const struct rlimit *
<TT
CLASS="PARAMETER"
><I
>__rlimits</I
></TT
>);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN15964"
></A
><H2
>Description</H2
><P
><TT
CLASS="FUNCTION"
>getrlimit()</TT
> and <TT
CLASS="FUNCTION"
>setrlimit()</TT
>
are as specified in <A
HREF="normativerefs.html#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>, 
but with differences as listed below. </P
><DIV
CLASS="REFSECT2"
><A
NAME="EXTRA.RESOURCES"
></A
><H3
>Extra Resources</H3
><P
>These additional resources extend the list in <A
HREF="normativerefs.html#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15975"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_NPROC</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The maximum number of processes (or, more precisely on Linux,
threads) that can be created for the real user ID of the calling
process. Upon encountering this limit, <TT
CLASS="FUNCTION"
>fork()</TT
>
shall fail with the error <SPAN
CLASS="ERRORCODE"
>EAGAIN</SPAN
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15981"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_MEMLOCK</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The maximum number of bytes of memory that may be
locked into RAM.  In effect this limit is rounded down to the
nearest multiple of the system page size. This limit affects
<TT
CLASS="FUNCTION"
>mlock()</TT
> and <TT
CLASS="FUNCTION"
>mlockall()</TT
>, the
<TT
CLASS="FUNCTION"
>mmap()</TT
> <CODE
CLASS="CONSTANT"
>MAP_LOCKED</CODE
> operation and
the <TT
CLASS="FUNCTION"
>shmctl()</TT
> <CODE
CLASS="CONSTANT"
>SHM_LOCK</CODE
> operation.
The <TT
CLASS="FUNCTION"
>shmctl()</TT
> <CODE
CLASS="CONSTANT"
>SHM_LOCK</CODE
> locks are
accounted for separately from the per-process memory locks established
by <TT
CLASS="FUNCTION"
>mlock()</TT
>, <TT
CLASS="FUNCTION"
>mlockall()</TT
>, and
<TT
CLASS="FUNCTION"
>mmap()</TT
> <CODE
CLASS="CONSTANT"
>MAP_LOCKED</CODE
>. In the former
case, the limit sets a maximum on the total bytes in shared memory
segments (see <TT
CLASS="FUNCTION"
>shmget()</TT
>) that may be locked by the
real user ID of the calling process.  A process can lock bytes up to
this limit in each of these two categories.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN15998"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_LOCKS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> A limit on the combined number of <TT
CLASS="FUNCTION"
>flock()</TT
> locks 
and <TT
CLASS="FUNCTION"
>fcntl()</TT
> leases that this process may establish.
This limit is obsolete and should not be used; support depends heavily
on the version of the operating system kernel. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16004"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_RSS</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Specifies the
limit (in pages) of the process's resident set. This limit
is obsolete and should not be used; support depends heavily
on the version of the operating system kernel. It affects
only calls to <TT
CLASS="FUNCTION"
>madvise()</TT
> specifying
<CODE
CLASS="CONSTANT"
>MADV_WILLNEED</CODE
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16010"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_SIGPENDING</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies the limit on the number of signals that may be queued
for the real user ID of the calling process.  Both standard and
real-time signals are counted for the purpose of checking this
limit.  However, the limit is enforced only for <TT
CLASS="FUNCTION"
>sigqueue()</TT
>;
it is always possible to use <TT
CLASS="FUNCTION"
>kill()</TT
> to queue one 
instance of any of the signals that are not already queued to the process.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16016"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_MSGQUEUE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies the limit on the number of bytes that can be allocated for
POSIX message queues for the real user ID of the calling process. This
limit is enforced for <TT
CLASS="FUNCTION"
>mq_open()</TT
>.   Each message queue
that the user creates counts (until it is removed) against this limit
according to the formula:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
	  attr.mq_maxmsg * attr.mq_msgsize</PRE
></TD
></TR
></TABLE
><P
>where attr is the mq_attr structure specified as the fourth argument
to mq_open(3).</P
><P
>The first addend in the formula, which includes sizeof(struct msg_msg *)
(4 bytes on Linux/i386), ensures that the user cannot create an unlimited
number of zero-length messages (such messages nevertheless each
consume some system memory for bookkeeping overhead).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16024"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_NICE</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies a ceiling to which the process's nice value can be
raised using <TT
CLASS="FUNCTION"
>setpriority()</TT
> or <TT
CLASS="FUNCTION"
>nice()</TT
>.  
The actual ceiling for
the nice value is calculated as 20 minus the value of 
<CODE
CLASS="VARNAME"
>rlim_cur</CODE
>. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16031"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_RTPRIO</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies a ceiling on the real-time priority that may be set
for this process using sched_setscheduler(2) and sched_setparam(2).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16035"
></A
><SPAN
STYLE="white-space: nowrap"
>RLIMIT_RTTIME</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 
Specifies a limit (in microseconds) on the amount of CPU time that a
process scheduled under a real-time scheduling policy may consume without
making a blocking system call. For the purpose of this limit, each time
a process makes a blocking system call, the count of its consumed CPU
time is reset to zero.  The CPU time count is not reset if the process
continues trying to use the CPU but is preempted, its time slice expires,
or it calls <TT
CLASS="FUNCTION"
>sched_yield()</TT
>.</P
><P
>Upon reaching the soft limit, the process is sent a
<CODE
CLASS="CONSTANT"
>SIGXCPU</CODE
> signal. If the process catches or
ignores this signal and continues consuming CPU time, then
<CODE
CLASS="CONSTANT"
>SIGXCPU</CODE
> will be generated once each second until
the hard limit is reached, at which point the process is sent a
<CODE
CLASS="CONSTANT"
>SIGKILL</CODE
> signal.</P
><P
>The intended use of this limit is to stop a runaway real-time
process from locking up the system.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="EXTRA.ERRORS"
></A
><H3
>Extra Errors</H3
><P
>These additional error codes extend the list in <A
HREF="normativerefs.html#STD.SUSV4"
>POSIX 1003.1-2008 (ISO/IEC 9945-2009)</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="1"
CELLPADDING="1"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN16050"
></A
><SPAN
STYLE="white-space: nowrap"
>EFAULT</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A pointer argument points to a location outside  the  accessible
address space.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="baselib-getpwent-r-1.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="baselib-getservbyname-r.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>getpwent_r</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libcman.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>getservbyname_r</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>